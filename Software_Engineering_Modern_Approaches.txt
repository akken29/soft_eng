SOFTWARE
ENGINEERING
Modern Approaches

Second Edition

Eric J. Braude

Boston University, Metropolitan College

Michael E. Bernstein
Boston University, Metropolitan College

For information about this book, contact,
Waveland Press, Inc.
4180 IL Route 83, Suite 101
Long Grove, IL 60047-9580
(847) 634-0081
info@waveland.com
www.waveland.com

Copyright © 2011 by Eric]. Braude and Michael E. Bernstein
Reissued 2016 by Waveland Press, Inc.
10-digit ISBN 1-4786-3230-5
13-digit ISBN 978-1-4786-3230-6

All rights reseroed. No part of this book may he reproduced, stored in a retrieval system, or transmitted
in any form or by any means without permission in writing from the publisher.
Printed in the United States of America
7

6

5

4

3

2

For Judy (Eric 1. Braude)
To Bambi, Garrett and Reid,
for all their love and support (Michael E. Bernstein)

Brief Contents

Pre face
xiv
Acknowledgments

xvii

Part I

Introduction to Software
Engineering

1 The Go al s and Terminolo gy o f So ftw are Engineeri ng
2 Introduction to Qu al ity and Metrics i n So ftw are
Engi neeri ng 2 1

Part II

Software Process

3 So ftw are Process 3 2
4 Agi le So ftw are Processes 6 3
5 Qu al ity i n the So ftw are Process 80
6 So ftw are Configur ation M an agement

Part III

Project Management

7 Principles o f So ftw are Project M an agement I 140
8 Principles o f So ftw are Project M an agement I I 16 8
9 Qu ali ty and Metrics in Project M an agement 2 13

Part IV

Requirement Analysis

10 Pri nciples o f Re quirements An alysis 2 3 0
1 1 An alyzing High - Level Re quireme nts 24 5
12 An alyzing Det ailed Re quirements 27 8
13 Qu al i ty and Metrics in Re quirements An alysis 3 3 1
14 Form al and Emerging Methods in Re quirements An alysis
(Online ch apter) 34 9

Part V

Software Design

15 Principles o f So ftw are Design 3 50
16 The U n i fied Modeling L angu age 3 6 1
17 So ftw are Design P atterns 3 8 3
18 So ftw are Archi tecture 4 3 8
19 Det ailed Design 476
20 Design Qu ali ty and Metrics 50 8
2 1 Adv anced and Emerging Methods in So ftw are Design
(Online ch apter) 5 3 8

Part VI

Implementation

22 Pri nciples o f Implemen t ation 53 9
2 3 Qu al ity and Metrics in Implemen t ation
24 Re factori ng 60 1

Part VII

Testing and
Maintenance

Gloss ary 7 59
Index 767

2 5 Introduction to So ftw are Testing 62 1
26 U n it Testing 6 3 0
2 7 Module and Integr atio n Testing 666
2 8 Testi ng at the System Level 6 94
2 9 So ftw are M ainte n ance 730

120

5 84

Contents

Preface

xiv

xiv
xiv
xv

The Issue of Scale
This Edition Compared with the First . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
How I nstructors Can Use This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Ackn owledgments

PART I

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

xvii

.

Introduction to Software Engineering

. . . . . . . . . . . . . . . . . . . . . . . .
What is Software Engineering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Why Software Engineering Is Critical : Software Disasters . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . .
. . . .
.
Why Software Fails or Succeeds
Software Engineeri ng Act iv ities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Software Engineeri ng Principles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Ethics i n Software Engineering .
.
.
.
. .
. .
Case Studies
. . . . .. . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . .
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

t The Goals and Terminology of Software Engineering

1. 1
t. 2
1 .3
1. 4
1. 5
1. 6
1. 7
1. 8
1. 9

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

2 Introduction to Quality and Metrics in Software Engineering......................

2. 1
2. 2
2.3
2.4
2.5
2.6
2.7

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

PART II

22
23
25
27
28
30
31
31

Software Process

.
. . . . . . . .
.
. . . . .
.
. .
. . .
The Activities of Software Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . .
. . . .
Software Process Models . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Case Study : Student Team Gui dance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3 Software Process ....

3. 1
3.2
3.3

2
3
4
5
10
12
14
19
19
20
21

.

. .
. . . .
. .
The Meaning of Software Quality . . . . .
Defects in Software . . . . . . . . . . . . . . .
.
.
. .
.
Veri fication and Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Planning for Quality . . . . . . . . . . . .
. .
. .
. . .
.
Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Summary . . . . . . . . . . . . . . . . . .
. . .
.
.
.
.
Exercises . . . .
. .
.
. .
.
.
.
. . . . . . .
. . .
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.

I

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

32

33
37
55

vi

CONTENTS

3.4
3.5

Summ ary . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exercises
Bibliogr aphy

59
60
62

. . . . . . ...
. . . . . . . . . . ... . . . . . . . . . . . . . . . . . . . . . . . .
Agile Histo ry and Agi le M ani festo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Agi le Principles . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . .
Agile Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
Agi le Processes . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . .
Integr ating Agile with Non -Agi le Processes . . . . . . . . . . . . . . . . . . . . . . . . .
Summ ary . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . .
Exercises . . . . . . . . . . . .
Bibliogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

63

4 Agile Software Processes

4. 1
4.2
4.3
4.4
4. 5
4.6
4.7

.

.

.

.

.

.

. . . .
Principles of M an aging Qu ali ty . . . .
. . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . .
M an aging Qu al i ty in Agile Processes . . . . . . . . . . . .
. . . . . . . . . . . .
. . . . . . .
Qu al ity Pl anning . . . . .
. . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . .
Inspections . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
QA Reviews and Aud its . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
De fect M an agement . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
. . .
. . .
Process Improvement and Process Metrics . . . . . . . . . . . .
. . . . . . .. . . .
.
Org aniz ation- Level Qu al ity and the CMMI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C ase Study: So ftw are Qu al ity Assur ance Pl an for Encounter
. . . . . . . . . . . . . . . . .
Summ ary . . . . . . . . . .
. . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bibliogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5 Quality in the Software Process .

5. 1
5.2
5.3
5.4
5.5
5.6
5.7
5. 8
5.9
5 . 10
5 . 11

.

.

.

.

.

.

.

.

.

.

.

.

.

.

6 Software Configuration Management

6. I
6.2
6.3
6.4
6.5
6.6
6.7
6. 8
6.9

PART III

7.5

80

81
82
83
87
92
93
96
tOO

10 3
118
118
119
1 20

So ftw are Configur ation M an agement Go als
SCM Activities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Configur ation M an agement Pl ans . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . .
Con figur ation M an agement Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C ase Study : Encounter Video Game . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
C ase Study: Eclipse . . . . . . .
Student Te am Guid ance : Configur ation M an agement . . . . . . . . . . . . . . . . . . . . . . . . .
Summ ary . . . . . . . . . . . . . .
. . . . . . . .
. . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . .
Exercises . . .
B ibliogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.

.

.

.

12 1
12 1
128
12 8
129
13 4
13 6
13 7
13 8
139

Project Management

7 Principles of Software Project Management I: Organization, Tools, and Risk Management

7. I
7.2
7.3
7.4

64
65
66
68
74
77
78
79

. . . . . . . .
Softw are Project Org aniz ation . . . . . . . . . . . . . . . . . . . . . . .
Te am Size . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Geogr aphic ally Distributed Development . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
The Te am So ftw are Process
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
So ftw are Project Tools and Tec hniques . . .

1 40

142
144
146
15 1
15 3

CONTENTS

7.6
7.7
7. 8
7. 9

. . . .. . . . . . .. . . . . . . 1 5 9
Risk M an agement . . . . . . . . . . . . . . . . .
Student Te am Gu id ance : Org aniz ing the Softw are Proj ect s' M an agement . . . . . . . . . . .
162
Summ ary . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 65
Exerc ises . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . .. . . . . ... . . . . . ...
166
1 67
Bibl iogr aphy . . . . . . . . . . . ... . . . . . . .. . . . . . . . . .. . . . . . . . . . . . . . .... . . .
.

. . ... .
Cost Est im at ion . . . . . . . . . . . . . . . .. . . . . . . . . .. .. . . . . . . .. . . . . . . . . . . . . . .
Scheduling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . .
The Softw are Project M an agement Pl an . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C ase Study: Encounter Proj ect M an agement Pl an . . . . . . . . . . . . . . . . . . . . . . . . .
C ase Study: Project M an agement in Eclipse . . . . . . . . . .. . . . . . . . . . . . . . . . . .
C ase Study : Project M an agement for Open Office . . . . . . . . . . . . . .. . . . . . . . . . . . .
C ase Study: Student Te am Guid ance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Summ ary . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exerc ises . . . . . . . . . . . .. . . . . . . . . . . .. . . . . . . . . . . . . . . . . .. . . . . . . .. . . . . .
Bibl iogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1 68

9 Quality and Metrics in Project Management .................................. .
Cul t iv at ing and Pl anning Intern al Qu al ity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.1
Project Metr ic s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9. 2
Us ing Metrics for Improvement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9. 3
9.4
Softw are Verific at ion and V al id ation Pl an . . . . . .. . . . . . . . . . . .. . . . . . . . . . . . .
C ase Study : Softw are Ver ific ation and V alid at ion Pl an for Encounter . . . . . . . . . . . . . .
9. 5
9 .6
Summ ary . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . .
9 .7
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B ib liogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . .. . . . . . . .. . . . . . .

213
214
215
21 9
2 23
2 25
228
228
22 9

8 Principles of Software Project Management II: Estimation, Scheduling, and Planning

8. 1
8. 2
8. 3
8. 4
8.5
8. 6
8. 7
8. 8
8. 9

.

.

.

.

.

.

PART IV

16 9
1 82
1 85
1 87
1 96
205
20 8
210
21 1
21 2

Requirement Analysis

1 0 Principles of Requirements Analysis

230

1 0. 1 The V alue of Re qu irements An alysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 0 .2 Sources of Re qu irements . .. . . . . . . ... . . . . . . . . .. . . . . . . . . . . . . . . . .. . . .
1 0. 3 High-level vs. Detailed Re qu irements . . . . . . . . . . . . . .. . . . . . . . . . . .. . . . . . . . . . . .
1 0. 4 Types of Re qu irements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 0. 5 Nonfunct ion al Re qu irements . . . . .. . . . . . . . . . . . . . .
.. ...... . ... .... . .. .
1 0 .6 Document ing Re qu irements . . . . . . . .
. . . . . .. . . . . . . . . . . . . . . .. . . . . . .
1 0. 7 Tr ace ab i l ity . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . .
1 0. 8 Ag ile Methods and Re qu irements . . . . . . . . . . . . . . .
. ... . .. . . . . . . .. ..
1 0 . 9 Upd at ing the Proj ect to Reflect Re qu irements An alysis . . . . . . . . . . . . . . . ... . .. .
10. 10 Summ ary . . . . .. .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 0. 1 1 Exerc ises . . .. . . . . .... . . . . .. . .. . . . . . .... . . . . . .. . . . . . . ... . . . . .
Bibliogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

23 1
23 1
23 2
233
233
23 8
23 9
23 9
24 1
243
244
244

. . . .. . . . . . . . . . . . ..... . . ... .. . .. .. . . . . . ..
Ex amples of Customer W ants . . . . . . . . . . . . . . . .. . . . . . . . . . . .. . . . . . . . . . .
St akehol der V is ion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
The I nterv iew and Document at ion Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

24 5

.

.

.

.

1 1 Analyzing High-Level Requirements.

1 1.1
1 1.2
1 1. 3

.

.

246
247
24 8

vii

viii

CONTENTS

1 1. 4 Writing an Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 1. 5 Describing M ai n Functions and Use C ases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 1. 6 Agile Methods for High - Level Re quirements . .
. .
.
1 1 .7 Speci fying User Inter faces : High Level .
. .
.
.
. . . . . . .
1 1. 8 Security Re quirements
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 1. 9 Using Di agr ams for High -Level Re quirement . . . . . . .
. . . .
.
11. 1 0 C ase Study : High - Level So ftw are Re quirements Specific ation
(SRS ) for the Encounter Video G ame . . .
. . . .
. .
.
. . .
1 1. 1 1 C ase Study: High - Level Re quirements for Ecl i pse . . . . . . . . . . . .
. . .
11. 12 Eclipse Pl at form Subproject (First o f three) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 1. 1 3 C ase Study : High - Level Re quirements for Open O ffice . . . . . . . . . . . . . . . . . . . . .
11. 1 4 Summ ary . . . . . . . . . . . . . . . . . . . .
.
. . .
. .
.
.
1 1. 15 Exercises . . .
. .
. . . . .
.
. .
.
.
. .
Bibli ogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

12 Analyzing Detailed Requirements
.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

264
26 8
26 9
273
2 75
2 75
2 76
278

12.1 The Me aning o f Det ailed Re quirements . .
. .
.
..
. . .
. .
.
. . .
12. 2 Org anizing Det ailed Re quirements . . . . . . . . . . . .
1 2 . 3 User Inter faces: Det ai l ed Re quirements . . .
.
. .
12. 4 Det ailed Security Re quirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 2 . 5 Error Conditions .
.
.
.
.
.
12. 6 Tr ace abil ity o f Det ailed Re quirements . . .
. . . . . . . . . . .
.
.
.
12. 7 Using Det ailed Re quirements to M an age Projects . . . . . . . . . . . . . . . . . .
1 2. 8 Prioritizing Re quirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12. 9 Associ ating Re quirements with Tests . . . . . . . . . . . . . . . . .
.
. . . . . . .
1 2 . 1 0 Agile Methods for Det ailed Re quirements . .
.
.
.
.
12 . 11 Using Tool s and the Web for Re quirements An alysis . . . . . . . . . . . . . . . . . . . . . .
1 2. 1 2 The E ffects on Proj ects o f the Det ailed Re quirements Process . . . . . . . . . . . . . .
12.13 Student Project Guide : Re quirements for the Encounter C ase Study . . . . . . . . . . . . .
1 2 . 1 4 C ase Study: Det ai led Re quirements for the Encounter Video G ame . . . . . . . . . . . . . .
1 2.1 5 Summ ary . . . .
. .
. . . ..
.
1 2. 1 6 Exercises
Bibliogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.

24 9
24 9
25 2
254
25 8
260

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

33 1

I 3 Quality and Metrics in Requirements Analysis .................. ............. .

1 3.1 Qu al ity o f Re quirements for Agile Projects . . . . . . . . . . . . . . . .
. . .
. . .
1 3. 2 Accessibil i ty o f Re quirements
. . . . . ... .
1 3. 3 Comprehensiveness o f Re quirements . . . . . . . . . . .
. .
. . .
. .
1 3. 4 Underst and ability o f Re quirements
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . .
.
. . . . .
. .
1 3 . 5 Un ambiguity o f Re quirements
1 3.6 Consistency o f Re quirements
. . .
. . .
. .
.
1 3. 7 Prioritiz ation o f Re quirements
. . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . .
1 3. 8 Security and High -Level Re quirements .
.
.
. . .
.
.
. .
1 3. 9 Sel f-Completeness o f Re quirements . . . . . . . . . . . . . .
.
. . . .
1 3 . 10 Test ability o f Re quirements . . . . .
. . . . . . . . . .
1 3 . 1 1 Tr ace ability o f Re quirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 3 . 1 2 Metrics fo r Re qui rements An alysis
.
.
. .
. .
.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

27 9
2 80
2 91
2 96
2 96
2 97
3 00
301
30 2
303
305
30 8
30 9
315
328
329
3 30

.

33 2
33 2
333
335
335
336
337
33 8
33 9
3 40
342
3 43

CONTENTS

344
34 7
34 8

13 . 13 I nspecting Det ailed Re quirements
13.14 Summ ary . . . . . . .
13 . 15 Exercises . . .
t 4 Formal and Emerging Methods in Requirements Analysis: An Introduction

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ..
Prov able Re quirements Method
I n troduction to Form al Methods
M athem atic al Prel im i n aries
The Z-Spec ific at ion L angu age
The B L angu age System
Tr ade -o ffs for Us ing a B - l ike system
Summ ary
Exercises
B ib liogr aphy

(Online Chapter)

14 . 1
14. 2
14.3
14.4
14 . 5
14 . 6
14.7
14 . 8

PART V

. . ..... . . .. .

349

Software Design

. . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
The Go als of Softw are Des ign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Integr ating Design Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.. . . . ... . . .. .... .. ..
. . . . . . .. .
Fr ameworks . . . . . . . . . . . . . .
IEEE S t and ards for Express ing Des igns . . . . ... . . . . . . . . .. . . .. . ... ..... . ... .
Summ ary . . . . . . . . . . . . . . . . . . . . . . . . .
. . .. . .. . ... . .. . . ..... . ..
Exercises . .

350

. .... .. . . . . . . .. . . . . . . . . . . . . . . . . . . . ... . . .. . .
16.1 Cl asses i n U M L . . . . ... . . .. . .. . . . . . .
. . . . . .. . . . . . . . . .. . . . . . . .... .
16. 2 Cl ass Rel ationsh ips in UML . . . . . . . . . . . . . . .. . .. . . . . . . . .. . . . . . . . . . . . . .
. . . . . . .. . . .... . . .. . . ... . . . . . .... ... . .. . .
16.3 Mult iplicity . . . . . . . . .
16 . 4 Inher it ance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16 . 5 Se quence D i agr ams . . . . . . . . . . . . . . . .. . . . . . . . .
. . . . . . . . . . . . . . . . . .
16. 6 St ate D i agr ams . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . .
16 . 7 Act iv ity D i agr ams . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.8 D at a Flow Models . . . . . .
. . . . . . . . . . . . . . . . . . ....... . . . ..
16. 9 A Design Ex ample w ith UML
16. 10 Summ ary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16. 11 Exercises . .
. . . . . . . . . . . . . . . . .. . . . . . .. . . . . . . . . . . ... . ... .
B ibl iogr aphy . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . ... . . ............ .. .

36 1
36 2
36 2
364
364
36 8
3 72
3 74
3 76
3 77
3 80
3 81
3 82

. . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17. 1 Ex amples o f a Recurring Design Purpose . . . . . . . . . . . . . . .
.. . . . . . . . . . . . . . .
17.2 An I ntroduct ion to Design P atterns . . . . . . .. . . . . . . . ... .. . ... . ..
17.3 Summ ary o f Des ign P atterns by Type: Cre at ion al ,
. . .... . . . . . . ... . ..... . . . . .. .. . . .. . .. .
Structur al , and Beh avior al
17.4 Ch ar acteristics o f Des ign P atterns: V iewpoints, Roles, and Level s . . . . . . . . . . . . . . . .
. ... . ...... . ...... . . .. . . . "
17. 5 Selected C re ation al Design P atte rns .
17. 6 Selected Structur al Design P atte rns
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. .

38 3

t 5 Principles of Software Design

15.1
15. 2
15 . 3
15.4
15. 5
15 . 6

.

.

t 6 The Unified Modeling Language

.

.

.

.

.

.

.

.

.

1 7 Software Design Patterns

.

.

.

.

.

.

.

.

35 1
354
35 7
359
359
360

3 84
3 86
390
396
400
40 8

ix

x

CONTENTS

17. 7 Selected Beh avior al Design P atterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17. 8 Design P attern Forms : Deleg ation and Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17.9 Summ ary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17. 10 Exercises . . .
Bibliogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4 17
43 1
435
436
43 7

. . ... .. .. . . .. . .. .... . .. . . . .. . . .. .. .. .. . . . .
18 . 1 A C ategoriz ation of Architectures . . . . . . . . .
.. . . . . . .. . . . . . . . . . . . . .
18. 2 Softw are Architecture Altern atives and Their Cl ass Models . . . . . . . . . . . . . . . . . . .
18. 3 Tr ading O f f Architecture Altern atives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.4 Tools for Architectures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18 . 5 IEEE St and ards for Expressing Designs . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 8 . 6 Effects of Architecture Selection on the Project Pl an . . . . . . . . . . . . . . . . . . . .
18 . 7 C ase Study : Prep aring to Design Encounter (Student Project Guide continued) . . . . . .
1 8 . 8 C ase Study: Softw are Design Document for the Role-Playing Video Game Fr amework .
1 8 . 9 C ase Study: Softw are Design Document for Encounter ( U ses the Fr amework)
.
18. 10 C ase Study: Architecture of Ecl i pse . . . . . . . . . . . . . . . . . . . . . .
18. 1 1 C ase Study : OpenO ffice Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18. 12 Summ ary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1 8 . 13 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bibliogr aphy . . . . . . . . . . .
. . . . . . . ... . . . . . .
. . . . . . . . . ... . . . . ... .

4 38

. . . . . . . . . . . . . . . . . . . . . . ... . . . . . . . . . . . . . . . . . . . . . . . . .
19. 1 Rel ating Use C ases, Architecture, and Det ailed Design . . . . . . . . .. . . . . . . . . . . . .
19 . 2 A Typic al Ro ad M ap for the "Det ailed Design" Process
. . . . . . . . . . . . . . . . . . . . . .
19 . 3 Object-Oriented Design Principles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19. 4 Design ing ag ainst Interf aces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19. 5 Specifying Cl asses , Functions, and Algorithms . . . . . . . . . . . . . . . . . . . .. . . . .
19. 6 Reusing Components . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . .
19 . 7 Se quence and D at a Flow Di agr ams for Det ailed Design
. . . . . . .. . . . . . . .. . . . .
19. 8 Det ailed Design and Agile Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19 . 9 Design i n the Uni fied Development Process . . . . . . .
. . . .. . . . . . . . . . . . . .
19 . 10 IEEE St and ard 890 for Det ailed Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19 . 11 Upd ating a Project with Det ailed Design
. .. . . . . .
. . . .. . . . . . .. . . . .
19.12 C ase Study : Det ailed Design of Encounter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19 . 13 C ase Study: Det ailed Design of Eclipse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19. 14 Summ ary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19. 15 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bibliogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

476

. . .. .. . . . .. . . . . .... .. . . . .... . .. . . .
20. 1 Degree of Underst and ability ,Cohesion, and Coupling . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
20. 2 Degree of Sufficiency as a Qu ali ty Go al . . . . . .
20. 3 Degree of Robustness as a Qu ali ty Go al . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.4 Degree of Flexibility as a Design Qu ality Go al . . . . . . . . . . . . . . . . . .
20.5 Degree of Reus ability as a Design Qu al ity Go al . . . . . . . . . . . . . . . . . . . . . . . . .
20.6 Degree of Time E fficiency as a Design Qu ali ty Me asure . . . . . . . . . . . . . . . . . . . .

508

.

.

.

t 8 Software Architecture

.

.

.

.

.

.

.

1 9 Detailed Design .

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

20 Design Quality and Metrics

.

.

.

.

.

.

.

.

.

.

439
439
453
454
455
455
45 7
460
46 2
466
46 8
4 73
4 74
4 75

4 77
4 78
4 79
4 81
4 82
4 85
4 86
490
490
49 1
49 1
494
503
505
505
50 7

5 10
5 10
5 11
5 12
5 13
5 17

CONTENTS

20.7 Degree o f Sp ace E ffic ie ncy as a Des ig n Qu al ity Me asure . . . . . . . . . . . . . . . . . . . . . .
20. 8 Degree of Rel iab il ity as a Des ig n Qu al ity Me asure . . . . . . . . . . . . . . . . . . . . . . . . . .
20.9 Degree o f Security as a Des ig n Qu al ity Me asure . . . . . . . . . . . . . . . . . . . . . .
20. 10 Assessi ng Qu al ity i n Architecture Selectio n . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . .
20. 1 1 Assessi ng the Qu ality o f Det ailed Desig ns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . ... . . .. . . . .. . .. .. . . .. .. .
20. 12 Summ ary . . . . . . . . .... . . . . . . . . . . .
20. 13 Exerc is es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B ibliogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.

.

2 1 Advanced and Emerging Methods in Software Design (Online Chapter)

2 1. I
2 1. 2
2 1. 3
2 1. 4
2 1. 5
2 1. 6
2 1. 7

PART VI

5 19
52 1
5 23
5 25
53 1
536
536
537

538

Desig n ing in a Distributed E nv iro nme nt
I ntroductio n to Aspect-Ori e nted Progr ammi ng
Desig n i ng for Secur ity with UM Lsec
Model-Drive n Architectures
The Form al Des ig n Process i n B
Summ ary
Exerc ises
Bibl iogr aphy

Implementation

. .......
. . ............. . ............. . .. ....
2 2. 1 Ag ile and No n-Ag ile Appro aches to Impleme nt atio n . . . . . . . . . . . . . . . . . . . . . . . .
2 2. 2 Choosi ng a Progr ammi ng L angu age . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 2 . 3 I de nti fyi ng Cl asses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 2 . 4 Defi n ing Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 2 . 5 Impleme nt atio n Pr actices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 2 . 6 De fe ns ive Progr amm ing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 2 . 7 Codi ng St and ards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 2. 8 Comme nts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 2 . 9 Tools and E nviro nme nts for Progr amm ing . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . .
2 2 . 10 C ase Study : E ncou nter Impleme nt at io n . . . . .. . . . . . . . . ... . . . . . . . . . . . . . . . . .
2 2. 1 1 C ase Study : Ecli pse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 2. 12 C ase Study : Ope n O ffice . . . . . . . . . . .
.. .. .. . . . .. . .. . . . . . . ... . . .. . .
2 2 . 13 Stude nt Te am Cu id ance for Impleme nt atio n . . . . . . . . .
.. . .. . . . ..... . .
2 2 . 14 Summ ary . . . . .
. . . . . . . . . . . . . . . . . . . . .. . . . . . . . . ... . .. . . ... . .. . ..
2 2 . 15 Code List ings Re ferred to i n th is Ch apter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 2 . 16 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B ib l iogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

539

.. . . . . . . . . . . . . . . .
.. .... . .......
2 3. 1 Qu al ity o f Impleme nt atio n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 3 . 2 Code I nspect io ns and Rel ated Qu ality Procedures . . . . . . . . . . . . . . . . . . . . . . .
2 3. 3 Summ ary
. . . . . . . . . . . . . . .. . . . . . .... .. ..... . . . .. .. .... . . . . .
2 3 . 4 Exercises

584

22 Principles of Implementation

.

.

.

.

.

.

.

.

.

23 Quality and Metrics in Implementation

.

.

.

540
540
540
54 1
544
54 8
55 2
554
555
556
559
559
565
566
566
58 1
5 83

5 85
597
599
59 9

xi

xii

CONTENTS

. . . . . .
. . ......... ... . .
. . ... . . . ... ... .. ....
B i g Re factorings . . . . . . . . .. . . . . . . . . .... . . . . . ..
. . .. . . .. ... . . . .
Composing Methods . . . .
...... ..... ....... . .. .. . . . ... ... . . .. .. ..
Moving Features between Ob jects . . . . . . . . . . . . . ... . . . . . . .. . . . . . . . . . .. . .
. ..... ... . . . ...
Organizing Data . .. .. . . . . .
. ..........
Genera lization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I n troducing Modules . .
. .. ... . .. . .. ..... .. ....... .. . ...... ....
. ...... .. .. . .
Re factori ng in Projects . ............ .... ... ... ...
Summary .. . . . . . . . . . . . .. . .. . .... . . . . .. ..... . . .. .. . .. ... .. .. . . ..
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bibliography .. ..... . ..... .. . .. . . . ... . .. . .. . . . . . . ... . . . .. ....

24 Refactoring

2 4 .1
24.2
24.3
2 4 .4
2 4 .5
24.6
2 4 .7
24.8
2 4 .9

PART VII

60 1
604
60 6
60 8
609
612
616
617
6 19
619
620

Testing and Maintenance

. .... ........ . .. .........................
2 5 . 1 Testing Early and O ften ; and the Agile Connection . . . . . . . . . . .. . . . . . . . . . . . . .
2 5 .2 Retesting : Regression Testing . . . . . . . . .. . .
. .. .... ..... .... ...
2 5 .3 B lack Box and White Box Testing . . . . . . ... .. . . . . . . . . . . . . . . . . . . . . . . .. .
2 5 .4 Unit Testing vs. Post -U n i t Testing . . . . . . . . .. . . .. . . . .. . . . .. .
2 5 .5 Testing Ob ject-Oriented Implementations . . . .. . . . . . . . . . . . . . . . . . .. . .. . . . . .
.. . .......
.. .. ... . ...... .
2 5 .6 Documenting Tests
25 .7 Test Planning . . . . . . . . . . . . . ..
.... ... ............ .. .. ..
2 5 . 8 Testing Test Suites by Faul t Injection
........ . ....... . .. . .... .
2 5 .9 Summary . . . . . . . . . . . . . . . . .
.. . .. ...... .. .. .. .... .. ....
25 .10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . .

62 1

2 6 Unit Testing . . . . .............. . . . . . .. . . . . .... . . . . ........... . . ....

630

25 Introduction to Software Testing .

.

.

.

.

2 6.1
2 6. 2
2 6.3
2 6.4
2 6.5
2 6.6
2 6.7

62 2
62 2
62 3
624
625
62 6
62 6
62 8
62 8
629

The Sources o f U n i ts for U n i t Testing . . . .
. . .. . .. . . . . . . ... . .
. .. . . . . . . . . . ... .. . .. . ... . .. . .. . . . . . . . . . . . .
U n i t Test Methods
. . . . .. ..
. .. . . . . . . . . . . . . . . . . . . .. . .. .
Testing Methods
Test -Driven Development . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Case Study: Encounter Video Game . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .. ... . . . . ... . . . . . . . . .
Summary . .
Exercises . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bibliography . . . . . . . . . . . .. . . .. . . . . .. .
.. . . . . . . . . . . . .. . .

63 1
63 1
64 2
64 7
65 2
662
663
665

. . ... ..
............... . ... .
. .. . . . .
2 7.1 Stubs and Drivers . . . .. . .. . . .. . . .. . . . . . . . . . . . .. . . . . . . . .
. . .. . ..
2 7. 2 Testing a Class . . . . . . . . .. . . . . . . . . . . . . . . . . . .. . . . . . . . .. . .. . . . . . . . .
2 7. 3 Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 7. 4 Daily Bui lds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 7. 5 Inter face Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . .
2 7. 6 Module Integration . . . . . . . . . .
. . . . . . ... . .. .. . . . . .
2 7.7 Case Study: Class Test for Encounter . . . .
2 7.8 Case Study: Encounter Integration Plan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . .. . . . . .
. . . . . . . ... . . . . . . . . . . . . . . .
2 7. 9 Summary . .
2 7.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

666

.

.

.

27 Module and Integration Testing

.

.

.

.

.

.

.

.

.

.

66 7
66 8
6 72
6 79
680
68 2
683
68 8
69 2
69 2
69 3

CONTENTS

28 Testing at the System Level. ....................... ......... ............ ..

694

2 8 . 1 Function al Test ing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 8 . 2 Non function al Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . .
2 8 . 3 Testi ng with Lightweight Re quirements . . . . . . . . . . . ... . .... . ... . .. . . ... . . .
2 8 . 4 Test ing Shortly Be fore Rele ase . . ... . .... . . . . . . . . . . .. . . . . . . . ... . . .. . . . .
2 8 . 5 C ase Study : Encounter So ftw are Test Document ation . . . . .... . . . ...... . .. . . .
2 8 . 6 C ase Study : Ecl ipse . . . .. . . . . . . . . . . ... . . . . . .. . . . .... . . . . . . . .. . . . . . .
2 8 . 7 C ase Study : OpenO ffice . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . .
2 8 . 8 Summ ary .. . . . . . . . . ... . . . . ... . . ..... . . . ...
. . . .. . ... . . . .. . . . . . .
2 8 . 9 Exercises . ... . . . . . . . . . . . . . . . . . . . . . ... . . . .. . . . . ... . . ... . . . . . . .. . . .
Bibliogr aphy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

696
69 8
70 8
713
7 14
72 3
726
72 8
72 8
729

. .............................. . ................
Types o f So ftw are M ai n ten ance . . . . . . . . . . . . . . . . . . . . .... . . . . . . . . . . . . . . . .
Issues o f So ftw are M ainten ance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
M ainten ance Process . . . . . .. . . . . . . . . .... . . . . . . . . . . ... . . .. . . ... . . .. .
IEEE M ai n ten ance S t and ards . . . . . . ... . . . .... . . . .. . . ..... . .. . . . .. . . . .. .
So ftw are Evolution . ... . . . .... . . . . . . . . .... . . . .... . .... . . . . . . ...
M ainten ance Metrics . . . . . ...... . .. . . ..... . . . . . .. . .... . ... . . ... . . ..
C ase Study . . .... . .... . . . .. . . . . . . . . . . .. . . . . . . . . . . ... . . .. . .... . . ..
Summ ary . . . . .... . . .. . . . .... . . . . ..
. . . . . . ... . . .. . . . .. . . . .
Exercises . . . . . . .. . . . . . . . . . ... . . . ... . . . . ... . . . .. . . .... . . .. . .. . . . .
Bibl io gr aphy . . . . . . . . . . . . . .... . . . . . . . . . . . .. . . . .. . . . . .. . .. . . . . .. . . .

730

.

.

.

29 Software Maintenance.

29. 1
29. 2
29.3
29.4
29.5
29.6
29.7
29. 8
29.9

.

.

Glossary
Index

.

.

.

............................. . ............................

... .

.

.

.

.

.. . .. . .. . .... .

.

.

.

.

.

.

.. . . .

.

.

. . .. . ... .

.

......... .

.

....

73 1
73 4
73 6
74 1
749
75 1
754
756
75 7
75 8
759
767

xiii

Preface

Much o f the modern world runs on so ftw are. As a result, so ftw are engi neers are entrusted with signific ant
responsibi lity. Although it is a biomedic al engi neer, for ex amp le, who designs he alth monitoring systems, it is
a so ftw are engi neer who cre ates its actu al control functions. A m arketing pro fession al develops w ays to re ach
customers online but it is a so ftw are engineer who m akes the system a re ality.
Tod ay's so ftw are engi neer must be able to p articip ate i n more th an one kind o fso ftw are process, work in
agile te ams, de al with customers, express re quirements cle arly, cre ate modul ar designs, utilize leg acy and
open source projects, monitor qu al ity, incorpor ate security, and apply m any types o f tests.
THE ISSUE OF SCALE

A so ftw are applic ation consists o f tens, hundreds, even thous ands o f cl asses. This is very di fferent from
m an aging three or four o f them, and results i n the dr agon o f comp lexity suggested by this book's cover. As
al so suggested there, however, this dr agon c an be subdued. Indeed, to de al with numerous and complex
c lasses, so ftw are engineers h ave at their dispos al a wide v ariety o f too ls and techni ques. These r ange from the
w ater fal l process to agile methodologies, from high ly integr ated tool suites to re factoring and loosely coupled
tool sets . Underlying this v ariety is continuing rese arch into rel i able appro aches, and an acknowledgment o f
the fact th at one size does not fit all projects.
THIS EDITION COMPARED WITH THE F IRST

The first edition o f this book emph asized the object -oriented appro ach, which h as subse quently
become widespre ad. It w as also designed to help student te ams c ar ry out h ands -on term projects through
theory, ex amp le s , c ase studies, and pr actic al steps. Object-orient ation and h ands -on continue to be m ajor fe atures
o f this edition. However, we h ave widened the scope o f the first edition, especi ally by including extensive
cover age o f agile methods and re factoring, together with deeper cover age o f qu ality and so ftw are design.
Re aders o f the first edition m ade extensive use o f the complete video g ame c ase study -an ex ample th at
they could fo llow " from soup to nuts" but which w as signific antly more comprehensive th an a toy. This edition
ret ains and upd ates th at c ase study, but it adds the explor ation o f asimpler ex ample on one h and ( aDVD rent al
store) and l arge, re al , open source c ase studies on the other. In p articul ar, to provide students a fee ling fo r the
scope and complexity o f re al-world app lic ation s, thi s boo k le ads them through se le cted re quireme nt s, de si gn,
implement ation, and m ainten ance o f the Ecli pse and OpenO fflc e open source projects . The size, complexity ,
and tr ansp arency o f these projects provide students a wi ndow into so ftw are engi neering on a re alistic sc ale .
Every book on so ftw are engineeri ng faces a di lem ma: h o w t o reconcile the org aniz ation o f the topics
with the org aniz ation o f actu al so ftw are project phases. An org aniz atio n o f ch apters into process/project
m an agement/re quirements an alysis/design limp lement ation/test/m ainten ance is str aightforw ard but is li able
to be misinterpreted as pro moting the w ater fall deve lopment process at the expe nse others . Our appro ach h as
been to use this org aniz ation in the seven p arts o f the book but to demonstr ate throughout th at e ach ph ase

PREFACE

typic ally belongs to a cycle r ather th an to a single w aterf al l se quence. I n p articul ar , our appro ach integr ates
agile methodologies consistently.
This edition also i n troduces somewh at adv anced i nfluenti al i de as , i nc ludi ng mode l - driven archi ­
tectures and aspect -oriented progr amming. Now ad ays, form al methods are m an d ated by government
agencies for the h i ghest l eve ls o f security, and thi s book aims to educ ate re aders i n their possibilities. Due
to print sp ace l i m i t ations, some of this m ateri al is to be found in the online extension of this book.
I n summ ary , speci fic fe atures of this edition comp ared with the first are as fol 1ows :
•

A sh arpening and st and ardi z ation of the m ateri al from the first edition

•

A strong agile thre ad throughout, includi ng a ch apter on agil ity alone and one devoted to ref actoring.

•

A sep ar ate ch apter on qu ality in six of the book's seven p arts

•

Re al -world c ase studies , t aken from the Eclipse and OpenOffice open source pro je cts

•

Gre atly exp anded cover age of softw are design and design p atterns

•

New ch apters on adv anced , i nfluenti al softw are engineering i de as

•

An org aniz ation of m any of the book 's seven p arts as follows :
•

Principles

•

Det ails

•

Qu ality

•

Adv anced Methods

HOW I NSTRUCTO RS CAN USE THIS BOOK

This book h as been designed to accommod ate multiple appro aches to the le arning and te aching of softw are
engineering. Most instructors te ach the fun d ament als of softw are process, pro ject m an agemen t , re quirements
an alysis, deSign , testing , implement ation, and m ai nten ance . Beyond this common ground , however ,
i nstructors employ a wide v ariety of styles and emph ases. The following are m ajor appro aches , together
with the se quence of ch apters th at support e ach of them .
A.

Process emphasis, concentr ating on how applic ations are developed
All of P arts I through IV ; and Ch apters 15 , 2 2 , and 25 (the rem ai n i ng principles and introduction
ch apters)

B.

Design emphasis, which te aches softw are engineering prim arily as a design activity
Principles and introduction : Ch apters 1, 3 , 7, and 10 ; all of P art V ; and Ch apters 2 2 and 25 (principles
and introduction)

C.

Programming and agile emphasis, which emph asizes softw are engineering as a code-oriented activity th at
s atisfies re quiremen ts , emph asizing agile appro aches
Principles and i ntroduction : Ch apters 1,3 ,7, 10, and 15 ; all of P art V I; and Ch apters 25 and 26

D
.

Two-semester course, which en ables the instructor to cover most topics and assign a subst anti al h ands-on
pro je ct

XV

xvi

PREFACE

Di.

All o f the chapters in the book, either in se quence from beginning to end

or
D2.

I n two passes as follows:
( i ) Pri nciples and i ntroduction chapters in the first semester : Chapters 1, 3 , 7, 15, 2 2 , and 2 5
( i i ) The remaining chapters in the second semester

E.

Emphasis on a hands-on projects and case studies, which relies mostly on an active team or individual project as
the vehicle for learning theory and principles
Principles and introduction chapters: Chapters 1, 3 , 7, 15, 2 2 , 25, and 26, and all case study sections i n
the remaining chapters

F.

G.

Theory and principles emphasis, concen trating on what one can learn about so ftware engineeri ng and its
underpin nings
Principles and introduction chapters : Chapters 1, 2, 3 , 7, 15 , 2 2 , and 2 5 , followed , as time allows, by
Chapters 14 and 2 1 (emergi ng topics)
Quality assurance and testing emphasis
Principles and i ntroduction : Chapters 1, 3 , 7, and 10 ; Chapters 2, 5, 9, 13 , 20, 2 3 ( quali ty) ; and Chapters
2 5 , 26, 2 7, and 2 8 (testing) .

The web site for this book, including review questions and the Encounter game case study , is
waveland. com /Extra Material /3 2306 /.
_

Eric Braude
Michael Bernstein
Boston, MA
January 20 10

Acknowledgments

We owe a de bt of gr atitude to our students at Boston University's Metropo li t an Co lIe ge. Working in myri ad
industries and busi nesses , they h ave given us inv alu ab le feed back. The Co lIege i tse lf h as provided amode lpl ace
for the te aching and le arning of softw are engi neeri ng. Our th anks go to Dick Bostwick and Tom V anCourt,
much of whose work in the first edition c arries over to this one. We are gr atefu l to the peop le who worked with
us through the p ainst aking process of writing and pu blishing this book. We are p articul arly appreci ative of the
he lp from our editors, D an S ayre and Jon ath an Ship ley ; from Georgi aKing, Yee Lyn Song, and the indef atig able
st aff. We th ank the reviewers of our m anuscript, whose feed back h as been inv alu able :
Arvin Ag ah , U niversity of Kans as
Steven C . Sh affer, Pennsy lv ani a St ate University
Stephen M. Theb aut, U niversity of F lorid a
Ar avind a P. Sist la, U niversity of I lli nois, Chic ago
James P . Purtilo, Un iversi ty of M aryl and
Li nd a M . Ott, Michig an Techno logic al University
Ji anwei Niu, University of Tex as, S an Antonio
Wi lli am Lively, Tex as A &M U n iversity
Chung Lee, C al i forni a St ate University, Pomon a
Sudipto Ghosh , Color ado St ate Un iversity
M ax I. Fomitchev, Pennsy lv ani a St ate University
L awrence Bernste i n , Stevens Institute of Techno logy
Joh n D albey, C ali forni a Po ly tech nic University
Len Fisk, C ali forn i a St ate U niversity, Chico
Ahmed M. S alem , C ali forni a St ate U niversity, S acr amento
Fred Str auss, New York University
Kai H. Ch ang, Auburn University
Andre v an der Hoek, Un iversity of C ali forni a, Irvine
S aeed Monemi , C al i forni a Polytechnic University
Ro bert M . Cu bert, U niversity of Florid a
Chris Tseng, S an Jose St ate University
Mich ael James P ayne, Purdue U niversity
C aro l A. Wel l ington, Shippens burg U n iversity
Yifei Dong, University of Ok lahom a
Peter B lanchfie ld , Nottingh am U niversity
Desmond Greer , Queen's University Be lf ast
Wei Qi Yan, Queen s' University Bel f ast
Zaigh am M ahmood, Der by U niversity
Karel Pieterson, Hogeschool V an Amsterd am
This book would not h ave been possi ble without the const ant love , p atience , and encour agement of our families.

The Goals and Terminology
of Software Engineering

Planning
� Maintenance
Testing

The Software
Development
Lifecycle

Implementation

�

\
Requirements
analysis

/

DeSign

Why is software engineering
important?
Who and what does is consist of?
What are its main activities?
What are the principles of software
engineering?
What ethics are involved?
What sorts of case studies will be
used to illustrate the subject?

Figure 1.1 The context and learning goals for this chapter

The goal o f so ftware engi neeri ng, and the theme o f this book, is the creation o f so ftware systems that
meet the needs o f customers and are reliable, e fficient, and maintainable. In addition, the system should be
produce d in an econom ical fash ion ,meeting project schedules and budgets. Thi s i s n o easy task, especially
for large , complex app l ic ations. Th is chapter i ntroduces the field o f so ftware engineering and explains how
i t addresses these goals . We first expl ain the term "so ftware engineering," showing that i t consists o f many
parts .

2

CHAPTER 1

THE GOALS AND TERM INOLOGY OF SOFTWARE ENGIN EERING

1 . 1 WHAT IS SOFTWARE E N G I NEERING?

Software engineering is an engineering discipline that involves all aspects of developing and maintai ning a
software product. Engineering disciplines such as civil , mechanical , and electrical involve the design, analysis,
and construction of an arti fact for some practical purpose. Software engineering is no excepti on to thi s­
software products certainly have practical purposes.
The IEEE defines Software Engineering [ 1] as follows:
1 . The application of a systematic, disciplined, quanti fiable approach to the development, operation and
maintenance of software; that is, the appl ication of engineering to software .
2 . The study of approaches as i n ( 1) .

A s this definition suggests, it's not only what i s produced that's i mportant but also how it is produced.
Engineering disciplines employ an established set of systematic, disciplined, and quantifiable approaches to the
development of artifacts. By thoroughly applying an analogous set of approaches to the development of software,
we can expect the production of software that is highly reliable, is maintainable, and meets specified
requirements. A disciplined approach is particularly important as the size of a software project grows. With
i ncreased size comes greatly increased complexity, and applying a systematic and disciplined approach is critical.
One of the first uses of the phrase "software engineering" was i n 1 96 8 , by a NATO Study Group on
Computer Science [ 2 ] . A conference was organized at that time, motivated by the "rapidly i ncreasing importance
of computer systems in many activities of society." The Study Group focused their attention on the problems
with software, and held a working conference on Software Engineeri ng that turned out to see far i nto the future.
The following are some quotes from the conference that summarize the cause for their concern :
The basic problem is that certain classes of systems are placing demands on us which are beyond
our capabilities and our theories and methods of design and production at this time . . . It is large
systems that are encounteri ng great difficulties. We should not expect the production of such
systems to be easy.
Particularly alarming is the seemingly unavoidable fallibility of large software, s i nce a mal ­
function in an advanced hardware-software system can be a matter of l i fe and death .
Programming management will continue to deserve its current poor reputation for cost and schedule
effectiveness until such time as a more complete understanding of the program design process is achieved.
One of the problems that is central to the software production process is to identi fy the nature of
progress and to find some way of measuring it.
Today we tend to go on for years, with tremendous investments to find that the system, which was
not well understood to start with, does not work as anticipated. We build systems l ike the Wright
brothers built airplanes-bUild the whole thing, push it off the cliff, let it crash, and start over again .
The Study Group discussed possible techniques a n d methods that might lead t o solving these problems.
They deliberately and provocatively used the term "software engineering," with an emphasis on engineering,
as they wanted to "imply the need for software manufacture to be based on the types of theoretical
foundations and practical disciplines that are traditional i n the established branches of engi neering." They
believed that if these foundations and discipline were applied to building software systems, the quality of the
resulting systems would be vastly improved.
Today, many of the issues they identified are addressed by evolving software engineering tech ni ques
and practices even as the scope of appli cations has increased dramatically. Throughout thi s book we exam ine
these practices and explain how they contribute to producing high-quality software . Before doi n g that,

WHY SOFTWARE E N G I N EERING IS CRITICAL: SOFTWARE DISASTERS

however, it is instructive to begin examining why software fails in the first place, and how some failures can
even lead to catastrophic results.
1 . 2 WHY SOFTWARE E N G I N E E R I N G IS CRITICAL: SOFTWARE DISASTERS

Even with the best of intentions, a large number of software projects today are unsuccessful, with a large
percentage never completed. Worse , quite a few software projects stil l end in disaster, causing a loss of
money, time, and tragically, even l ives. We review some representative samples here as cautionary tales. In all
cases, the methods employed were i nadequate for the complexity of the required application. Failures such as
these motivate us to conti nually ask: How can we apply software engineering methodologies to ensure the
appropriate level of quality in software applications?
1 .2 . 1 The Virtual Case File project

The FBI's Virtual Case File system was intended to automate the FBI's cumbersome paper-based case system, allow
agents to share investigative information, and replace obsolete systems. Instead, after an expenditure of $ 1 70
million, the result did not accomplish these objectives at all . The effect has been to inhibit the FBI from growing its
crime-fighting mission despite the growth in terrorism and the increased sophistication of many criminal
organizations. All of 700,000 lines of code, costing $ 1 00 milIion, had to be abandoned. Poorly defined requirements,
networking plans, and software development plans were cited by investigators as causes for this disaster.
1 . 2 . 2 The Ariane project

"On 4 June 1 996, the maiden flight of the Ariane s launcher ended in failure. Only about 40 seconds after initiation of
the flight sequence, at an altitude of about 3700 m, the launcher veered off its flight path, broke up and exploded." [ 3 ]
The cost o f developing Ariane during the preceding decade has been estimated a t $7 billion. A significant fraction o f
this was wasted o n June 4, 1 996. Ariane s itself, including its specific development, has been valued a t $500 million.
The source of the problem was described i n the official report [ 3 ] as fol l ows ( italics added) :
The internal Inertial Reference System software exception was caused during execution of a data
conversion from 64-bit floating point to 1 6-bit signed integer value . The floating-point number
which was converted had a value greater than what could be represented by a 1 6-bit signed
integer. This resulted in an Operand Error. The data conversion instructions ( i n Ada code) were
not protected from causing an Operand Error. .
The error occurred in a part of the software that only
performs alignment of the strap- down inertial platform . This software module computes mean ­
ingful results only before l i ft-off. As soon as the launcher l i fts off, this function serves no purpose.
.

.

In other words, the data conversion code itsel f was "correct" but was called upon to execute when it should
not have been . The defect lay within controlling code. This kind of problem is easy to describe but not easy to
avoid because many people are involved in large projects. Large projects become extraordinarily complex.
Development efforts like Ariane call for extensive education and coordination within project management, quality
assurance, configuration management, architecture, detailed design, programming, and testi ng organizations.
Depending on how the project was organized and designed, any one of these organizations could have been
partly responsible for seeing to it that the code in question was not called after l i ftoff.
1 . 2 . 3 Rad i ation Overdose

As software controls an ever-increasing number of devices, its reliability is coming under increasingly intense
scrutiny. In the project management magazine Baseline, Debbie Gage, John McCormick, and Berta Ramona wrote

3

4

CHAPTER 1

THE GOALS AND TERMINOLOGY OF SOFTWARE E N G I N EERING

of a lawsuit alleging "massive overdoses of gamma rays partly due to limitations of the computer program that
guided use of' a particular radiation-therapy machine. They reported the following: "The International Atomic
Energy Agency said in May 200 1 that at least five of the deaths were probably from radiation poisoning ( from the
machi ne) and at least 1 5 more patients risked developing 'serious compl ications' from radiation. " [4] The defect
did not show up until a significant time after release, and only after certain sequences of operator actions.
The followi ng describes the software defect, and is quoted from [ 5 ] .
Setting the bending magnets takes about 8 seconds. Magnet calls a subrouti ne called Ptime to
i ntroduce a time delay. Since several magnets need to be set, Ptime is entered and exited several
times . A flag to indicate that bending magnets are being set is initial ized upon entry to the Magnet
subroutine and cleared at the end of Ptime. Furthermore, Ptime checks a shared variable, set by the
keyboard handler, that indicates the presence of any editi ng requests . If there are edits, then Ptime
clears the bending magnet variable and exi ts to Magnet, which then exits to Datent. But the edit
change variable is checked by Ptime only i f the bendi ng magnet flag is set. Si nce Ptime clears it
duri ng its first executio n , any edits performed duri ng each succeedi ng pass through Ptime will not
be recogn ized. Thus, an edit change of the mode or energy, although reflected on the operator's
screen and the mode/energy offset variable, will not be sensed by Datent so it can index the
appropriate calibration tables for the machine parameters. 1
This is a fairly involved explanation but not at all beyond the complexity of many software systems in
existence today. When should this type of error have been found? I f sound software engineering discipline
had been employed duri ng all phases of the project, there would have been several opportun ities in the
development process to detect it.
1 . 2.4 More software Disasters

Readers who wish to know about more software disasters, big and small, are referred to Neumann [6], who discusses
risks, problems, defects, and disasters relating to reliability, safety, security vulnerabilities, integrity, and threats to
privacy and well-being. Another source is the ACM publication Software Engineering Notes and its Risks Forum [7].
1 .3 WHY SOFTWARE FAI LS OR SUCCE EDS

Thankfully, not all software proj ects end in the types of disasters described above, but far too many end in
failure . What does it mean for a software project to be unsuccessful? Simply put, an unsuccessful project is one
that fails to meet expectations. More speci fically, the undesirable outcomes may include the following:
•

Over budget

•

Exceeds schedule and/or misses market window

•

Doesn't meet stated customer requirements

•

Lower quality than expected

•

Performance doesn't meet expectations

•

Too di fficult to use
1

Leve n s o n , Nancy, and Turner C . S . , "An I nvestigation o f the Therac - 2 5 Acci de n ts , " IEEE Computer, Vol . 26, No. 7,

luly 1 99 3 , pp. 1 8-4 1 , copyright © 1 99 3 IEEE.

SOFTWARE E N G I N EERING ACTIVITIES

Failing to meet just one of these objectives can cause a project to be deemed unsuccessful. For example,
i f a project is completed under budget, meets all requirements and functionality, has h i gh quality, good
performance and is easy to use, it still may not be successful if the schedule was missed and no customers are
wil l i ng to purchase it as a result.
Charette [ 8 J notes that there are many underlying reasons software proj ects are unsuccessful , including:
•

U nrealistic or unarticulated project goals

•

Poor project management

•

Inaccurate estimates of needed resources

•

Badly defined system requirements

•

Poor reporting of the project's status

•

Unmanaged risks

•

Poor communication among customers , developers, and users

•

Inability to handle the project's complexity
Other contributing factors are :

•

Poor software design methodology

•

Wrong or inefficient set of development tools

•

Poor testing methodology

•

Inadequate test coverage

•

Inappropriate (or lack of) software process2

Unsuccessful software projects usually fall victim to several of these . To reiterate, the goal of software
engineering, and the theme of this book, is the creation of software systems that are reliable, efficient,
maintainable, and meet the needs of customers. Software engineering provides the tools and methodologies
necessary to accomplish these goals, resulting in the development of successful software systems .
We'll end this section on a positive note. The authors feel that software engineering has improved greatly,
when measured fairly. Projects of equal ambition can typically get done far more successfully now than 1 0 years
ago. The issue really is that the ambition and scope of applications have grown enormously. The Eclipse software
development platform , which this book uses as a case study, is an excellent example of a successful application.
This is largely due to its flexible design, inclusive requirements process, and thorough testing.
1 .4 SOFTWARE E N G I N E E R I N G ACTIVITI ES

The production of software systems can be extremely complex and present many challenges. Systems, especially
large ones, require the coordination of many people, called stakeholders, who must be organized into teams and
whose primary objective is to build a product that meets defined requirements. The entire effort must be organized
2

Charett, Robert, "Why Software Fails," IEEE Spectrum, Vol . 4 2 , N o . 9, September 2005, pp. 42-49, copyright ©

2005 IEEE.

5

6

CHAPTER 1

•

People
•

•

The software product plus associated documents.

Project
•

•

Project stakeholders .

Product
•

•

THE GOALS AND TERM I N O LOGY OF SOFTWARE E N G I N EERING

The activities carried out to produce the product .

Process
•

Framework within which the team carries out the activities necessary to build the product .

Figure 1 .2 The four " p's" that constitute software engineering

i nto a cohesive project, with a solid plan for success. Finally, to successfully develop the product, the activities of
the people must be organi zed through use of an orderly and wel l-defined process. Collectively, these activities are
known as the 4 P's of software engineering: people , product, project, and process. Successful software projects
must adequately plan for and address all of them . Sometimes, the needs of each of the P's conflict with each other,
and a proper balance must be achieved for a project to be successful . Concentrating on one P without the others
can lead to a project's failure. For example, i f people are organized into efficient teams and given the resources
they need to perform their roles, a project can still be unsuccessful if there's no defi ned software process to follow,
as chaos can ensue . The 4 P's are summarized in Figure 1 . 2 and are discussed in the sections that follow .
1 . 4 . 1 people

People are the most important resource on a software project. It is through their efforts that software is
successfully constructed and delivered. Competent people must be recruited, trained, motivated, and
provided with a growth path , which is no easy task. They are the l i feblood of any successful project.
Software development is o ften dictated by tight, market- driven deadli nes and demanding l ists o f required
product features. Because of this, only wel l - organized groups of engi neers, educated and experienced in the
methods of software engineering, are capable of conSistently carryi ng out these activities to everyone's
satisfacti o n . The alternative is often chaos and, all too frequently, disaster.
Typically, several groups of people are i nvolved with and have a stake in a proj ect's outcome. These are
called its stakeholders. They include business management, project management, the development team ,
customers , and end users. Although each group is motivated to see the project succeed, given their diverse
roles each has a di fferent perspective on the process . This is discussed next, for each of the groups cited.
Business Management

These are people responsible for the busi ness side of the company developing the software . They include senior
management (e.g., V . P . Finance), marketing (e.g., Product Manager), and development managers . Their primary
focus is on business issues i ncluding profit, cost effectiveness, market competitiveness, and customer satisfaction .
They are typically not particularly knowledgeable about or involved in the technical aspects of the project.
project Management

Project managers are responsible for planning and tracking a proj ect. They are involved throughout,
managing the people, process, and activities . They continuously monitor progress and proactively implement
necessary changes and improvements to keep the project on schedule and with i n budget.

SOFTWARE E N G I N EERING ACTIVITI ES

Development Team

Software engi neers are responsible for developing and maintaining the software . Software development
includes many tasks such as requirements gatheri ng, software architecture and design, implementation,
testing, con figuration management, and documentatio n . This book will have much to say about each of these
topics. Software engineers are motivated by many factors including technical innovation, low overhead (e.g. ,
a minimum of business-type meetings ) , and having the time and support to stay i nvolved in technology.
Customers

Customers are responsible for purchasing the software. They may or may not actually use the software.
Customers may be purchasing it for use by others in their organization. They are primarily interested in
software that is cost-effective, meets speCi fic busi ness needs, and is of high quality. They are typically
i nvolved in some aspect of specifying requirements, and since they are paying for the project, they have the
ultimate say i n defining the requirements.
End Users

End users are people who interact with and use software after it is finished being developed. End users are
motivated by software that's easy to use and helps them perform their j obs as efficiently as possible. For
exam ple, once they become accustomed to and are effective using a particular user interface , they are
typically reluctant to accept major changes to it.

1 .4.2 Prod u ct

The products of a software development effort consist of much more than the source and object code . They
also include project documentation (e.g. , requirements document, design speci ficati o n ) , test plans and results ,
customer documentation (e.g., installation guide, command reference ) , and productivity measurements.
These products are often called artifacts, and are summarized i n Figure 1 . 3 . This book describes the complete
set of arti facts .
Part I I I , on software management, describes project metrics and how they are coll ected and used to
measure productivity.

•

Project documentation

Documents produced during software defin ition and development.
•

Code

Source and object.
•

Test documents

Plans, cases, and results .
•

Customer documents

Documents explaining how to use and operate product .
•

Productivity measurements

Analyze project productivity.
Figure 1 .3 The m a i n product artifacts of a software project

7

8

CHAPTER 1

THE GOALS AND TERMINOLOGY OF SOFTWARE ENGINEERING

Part IV, on requirements analysis, explains how to produce requirements that specify what the product
is intended to be.
Part V explains how to specify software designs. Chapter 20 describes software architectures. Chapter
2 1 describes how to specify the detailed designs. Design patterns, a standard means of communicating
intelligently with each other about design , are described in Chapter 19.
Part VI discusses implementation (programming), emphasizing standards and precision. A major goal is
to help developers to write programs that are much easier to verify for correctness .
Part VII describes how to test the parts of an application, as well as the whol e . It includes test procedures
that specify how tests are conducted and the test cases that specify the input data for tests . Part VII also
describes the types of customer documentation artifacts that are produced and their purpose.
1.4.3 Project

A software project defines the activities and associated results needed to produce a software product . Every
project involves a similar set of activities: planning, determining what's required, determi ning how the
software should be built to meet the requirements, implementing the software, testing the software, and
mai ntaining it once delivered to customers . These major project activities are summarized i n Figure 1 . 4 .
In addition t o these activities, various development paradigms , techniques, a n d tools exist a n d are
employed on di fferent projects. A development paradigm is a way of thinking about the process of producing
software .
An example of a development paradigm, and one that is in wide use today, is the object-oriented paradigm. It
was invented to make designs and code match the real world. That is, an object as represented in a software
design is patterned after a real-world object. For example, suppose that a banking appl ication is to be buil t
that includes support for customers, bank accounts, and transactions on t h e accounts . In an object- oriented
paradigm, these real -word concepts are represented in the design and implementation by corresponding

•

Planning
•

•

ReqUirements analysis
•

•

Program the software.

Testing
•

•

Describe how to buil d the software.

Implementation
•

•

Define what to buil d.

Design
•

•

Plan, monitor, and control the software project.

Val idate that software meets the requirements .

Maintenance
•

Resolve problems; adapt software to meet new requirements.

Figure 1.4 Major activities of a software project

SOFTWARE ENGINEERING ACTIVITIES

Real-world concepts

��
�v ''e::: Ic£,�
1'$: <

I
Direct correspondence
I

�
�

�
Customer

object

Transaction

object

Account

object

Software design and implementation artifacts

Figure 1 . 5 A key role of the object-oriented paradigm
Source: Graphics reproduced with permission from Corel.

classes . This greatly facilitates i denti fy ing and applying modifications to a design necessitated by changes to
real -world requirements. For example, if the steps executed during a particular transaction need to change, the
design can more easily accommodate this since there's a corresponding transaction object in the design . The
design representation for transactions is encapsulated with i n the transaction obj ect, and modifications can be
applied more easily. This i s illustrated i n Figure t .5. In non-object-oriented languages, the representation of a
real -world concept such as a customer may be spread across many disconnected pieces of source code .
1 .4.4 Process

A software process is a framework for carrying out the activities of a project in an organized and disciplined
manner. It imposes structure and helps gui de the many people and activities in a coherent manner. A software
project progresses through di fferent phases, each interrelated and bounded by time. A software process
expresses the interrelationship among the phases by defining their order and frequency, as well as defining the
del iverables of the project. Figure t names the major phases and i n dicates the order in which they are usually
performed.
Spec i fic software process implementations are called software process models. There are several such models ,
but most are based on either t h e waterfall or iterative development models. Each of these i s briefly described below.
Part II covers the evolution of software processes and details these plus several other of the most important
process models.
The waterfall process is the simplest software process model, and forms the basis for most others . A pure
waterfall process dictates that phases are implemented in sequence, with no phase starting before the previous
one has almost completed. That is, phases are executed in a strictly sequential order, usually with small
overlaps. Once a waterfa l l phase is finished it's deemed complete for the project and there is no need to return
to it. Variations of waterfall exist where already completed phases may be revisited and mi nor updates
applied, as a result of work done on subsequent phases. Waterfall begins with an i nception phase, where the
product is conce ived and busi ness obj ectives defined. Next is the speci fication of the requirements, followed
by the design phase, the implementation phase, the testi ng phase, and finally the maintenance phase . Figure
t.6 illustrates the main phases and their sequence. This means that the process goe5 around the circle of
Figure t . t just once.
Software development rarely occurs i n the strict waterfall sequence. Instead, i t skips back and forth
somewhat among requirements, design , impleme ntation, and testing. In practice, then, we often use iterative

9

10

CHAPTER 1

THE GOALS AND TERMINOLOGY OF SOFTWARE ENGINEERING

Time

l

Requirements

I
1
Design

Phases (activities)

I Implementation
I Testing

I

Maintenance

I

Figure 1.6 The waterfall software development process

processes for software development, i n which all or some of the waterfall process is repeated several times.
Some processes dictate that activities may be carried out in parallel . In the agile process, programmers
typically view implementation as part of design rather than an entirely separate phase. Here, most phases i n
the circle of Figure I . I are repeated frequently-as often a s every two weeks. This book makes frequent
reference to agile methods.
When performed in a discipli ned manner, i terative styles can be highly beneficial . They are espec ially
useful when the requirements are only sketchily known at the start of a project. A subset of the system is
constructed from a partial list of requirements, customer feedback is obtained, and additional requirements
are generated . This cycle repeats until the complete system is built.
Si nce pol icy decisions about software process take place at an orga nizational level (company,
department, group, etc . ) , there is a need to assess the software development capab i l i ties of organi zati ons.
The Capab i l i ty Maturity ModeisM ( CMM) is such a measure . The CMM and its successor, the CMMI,
were developed by the Software Engineeri ng Institute . The software engi neeri ng capab i l i ty of i n dividual
engi n eers can be developed and measured by the Personal Software Process SM ( P S P ) created by
Humphrey [9]. The h i gh l i ghts of CMMI and PSP are woven through some chapters o f th is book. A
th ird level of software organization is Humphrey's Team Software Process SM (TSP) [ 1 01 which describes
the process by which teams of software engi neers get their work done. The I n ternati onal Standards
Organization ( I S O ) defines qual i ty standards against which many orga n i zations assess their software
development processes .
Wel l thought-out documentation standards make it much easier to produce useful, reliable arti facts .
Several standards are available. Many companies provide i n -house standards. For the most part, this book
applies the IEEE ( I nstitute of Electrical and Electronics Engineers) software engineering stan dards, many of
which are also sanctioned by ANSI (American National Standards Institute), Standards focus the process by
providing a baseline for engineer, i nstructor, and students. In practice, they are modified and tai l ored to
specific projects .
Software process is the subj ect of Part" of this book.
1 .5 SOFTWARE ENGIN E E R I N G PRINC IPLES

The fiel d of software engineering has matured greatly si nce it began over 40 years ago. Throughout this time
practitioners have learned valuable lessons that contribute to the best practices of today. Some have become
outdated, but many are still very relevant and widely implemented today. I n his book [Ill Alan Davis

SOFlWARE ENGINEERING PRINCIPLES

1 . Make Quality Number 1
2 . High-Quality Software Is Possible
3. Give Products to Customers Early
4. Use an Appropriate Software Process
5. Minimize Intellectual Distance

6. Inspect Code
7. People Are the Key to Success
Figure 1.7 Major principles of software engineering

gathered 2 0 1 principles that form the foundation of software engi neering. Figure 1 .7 h ighli ghts some of the
most important, and we explore each of them .
Make Quality Number 1

There is nothing more important than del ivering a quali ty product to customers-they simply will not
tolerate anything less. However, different people have di fferent ideas of what quali ty means, and it therefore
must be spec i fied and measured. Prime examples of quality are how closely sohware meets the customer's
requirements, how many (or few) defects it has, and how much it costs to produce. Quality measures need to
be spec i fied in advance to ensure the correct targets are being pursued and met. This book contains several
chapters devoted to quality but, more important, the notion of quality is behind most of i ts content.

High-Quality Software Is Possible

Although it may be difficult to produce high-quality software, following modern software engineering
methods and techn iques has proven to meet reasonable quality goals. Examples include i nvolving the
customer, prototyping, conducting inspections, and employing i ncremental software processes.

Give Products to Customers Early

Many software projects fail because customers are given their first look at software too late in the development
cycle. Th is was a major motivation for the i ntroduction of agile methods. I t's virtually impossible to know all the
requirements in advance, and involving customers as early as possible is critical to getting the requirements right.
Their early i nvolvement in helping to specify requirements is very important, but giving them working software
and havi ng them use it is critical to understanding what they really need. Customers may thi nk they want a
particular feature, or think they want a user i nterface to look a certain way, but until they get a version of software
to work with you can never be sure . Employing techniques such as agile processes, prototyping, or i ncremental
processes allow customers to get software into their hands early i n the development cycle.

Use an Appropriate Software Process

There are many software process models, and no single one is appropriate for every type of project. For
example, the waterfall process works well for projects where all of the requirements are well known up front.
Conversely, agile and other i terative processes are called for when few requirements are known i n advance.
Good software engineers and project leaders take the time to understand the type of project being undertaken
and use an appropriate model .

11

12

CHAPTER 1

THE GOALS AND TERMINOLOGY OF SOFTWARE ENGINEERING

Minimize Intellectual Distance

This pri nciple says that for any software solution to a real-world problem, the structures of both the software
solution and real-world problem should be as similar as possible. This was illustrated in Figure 5, showi ng how
object-orientation can achieve this obj ective . The closer the structures are to each other, the easier it is to
develop and maintain the software.
Inspect Code

This should be extended to read "Inspect All Artifacts," where artifacts are defined as any product of
the software development process i ncluding techn ical speci fications, test plans, documentation, and
code. I nspections have been proven to find errors as early as possible, i ncrease quality, and decrease overall
project cost.

People Are the Key to Success

Highly skilled, motivated people are probably the most important factor contributing to the success of a
software project. Good people can make up for a variety of obstacles includi ng poor tools, insufficient
processes, and unforeseen problems. Good people will figure out a way to overcome these obstacles and make
the project a success . Poor performers without any of these obstacles will probably sti l l fai l . H iring and
retaining the best people is critical to producing high-quality and successful software.
So far, we have discussed the parts, principles, and activities of software engineering. Assuming that these
are understood and assembled, we need to understand the societal responsibilities of software engineers.

1 _6 ETHICS IN SOFTWARE ENGIN E ERING

Rel i ance on the ethics of software engineers has become an essential part of contemporary culture. To take an
example, it is simply not possible for a car driver to veri fy and validate the code for his car's cruise control or
for a patient or radiologist to veri fy the correctness of the code controlling the X-ray machine pointing at his
head. At some point, there is no choice but to assume that the software created and i nstalled in these and
other systems has been implemented correctly, and i n a manner consistent with the publ ic interest. Th is is a
matter of ethics.
The Merriam-Webster [ 1 2] online dictionary defines ethics as:
1 . the discipline dealing with what is good and bad and with moral duty and obligation
2. a set of moral principles
Most disciplines operate under a strict set of ethical standards, as published in a corresponding code of
ethics, and software engi neering is no excepti o n . The ACM and IEEE have jointly developed a Software
Engineering Code of Ethics and Professional Practice [ 1 3 ]. The ACM/IEEE-CS Joint Task Force on Software
Engineering Ethics and Professional Practices has recommended the document, and the ACM and
the IEEE-CS have jointly approved the standard for teaching and practicing software engi neering. The
code includes a short and long version , with the short version l i sted in Figure 1 .8. The short version describes
the code at a high level of abstraction . The long version contains a number of clauses corresponding to each
of the eight pri nciples in the short version, with each clause providing more details and examples . Both
versions are contained in [ 1 3 ] .

ETHICS IN SOFTWARE ENGINEERING

PREAMBLE
The short version of the code summarizes aspirations at a high level of the abstraction; the clauses that are
i ncluded in the full version give examples and details of how these aspirations change the way we act as
software engineering professional s . Without the aspirations, the details can become legalistic and tedious;
without the details, the aspirations can become high sounding but empty; together, the aspirations and the
details form a cohesive code .
Software engineers shall commit themselves to making the analysis, specification, design, development,
testing and maintenance of software a beneficial and respected profession . In accordance with their
commitment to the health , safety and welfare of the public, software engineers shall adhere to the
fol lowing Eight Principles:
1 . P U B LIC - Software engineers shall act consistently with the public interest.
2. CLIENT AND EMPLOYER - Software engineers shall act i n a manner that is in the best interests of
their client and employer consistent with the public interest.
3. PRODU CT - Software engineers shall ensure that their products and related modifications meet the
highest professional standards possible.
4. JUDGMENT - Software engineers shall maintain integrity and independence in their professional judgment.
5. MANAGEMENT - Software engineering managers and leaders shall subscribe to and promote an
ethical approach to the management of software development and maintenance.
6. PROFESSION - Software engi neers shall advance the integrity and reputation of the profession
consistent with the public interest.
7.

COLLEAGUES - Software engineers shall be fair to and supportive of their colleagues .

8 . SELF - Software engineers shall participate i n l i felong learning regarding the practice of their profession
and shall promote an ethical approach to the practice of the professio n.
Figure 1.8 Software Engineering Code of Ethics and Professional Practice

Source: ACM/IEEE-CS, Software Engineering Code of Ethics and Professional Practice, copyright © IEEE.

These precepts have practical consequences and can help gui de a software engineer toward a course of
action when confronted with a difficult situatio n . A few examples follow:

Example 1. Suppose that your manager asks you to join a team at work and assumes you are sufficiently
skilled in Java. However, you don't know Java, but really want to work on the project and think you'll be
able to learn it quickly and learn a valuable ski l l . Do you mention your lack o f Java knowledge to your
manager and risk being pulled from the project, or do you say nothing, even though your i nexperience
could jeopardize the success of the project? Clause 6.05 provides gui dance: "Not promote their own
interest at the expense of the profession, client or employer." Knowing this, you could i n form your
manager that you do not currently have the necessary Java knowledge, but present a case at the same
time for how you will learn enough in time.
Example 2 . A software engineer working on several government contracts is "encouraged" by
management to charge time against the contract with the highest number of available hours. What
do you do? Guidance for this is provided by clause 4. 04: "Not engage in deceptive financial practices
such as bribery, double billi ng, or other i mproper financial practices."

13

14

CHAPTER 1

THE GOALS AND TERMINOLOGY OF SOFTWARE ENGINEERING

Example 3. You are asked to develop a complex, critical piece of software for a commercial product
you're working on. You discover a public domain version of the source code. You're tempted to use the
source code as it will save much time and effort and allow you to move onto the development of another
important part of the system sooner than expected. However, it's not l icensed to be used for commercial
purposes . What do you do? Clause 2 . 0 2 provi des guidance : "Not knOWi ngly use software that is
obtained or retained either illegally or unethically."
These are just a few examples of how software engineers can be confronted with ethical dilemmas.
H aving a set of guidelines greatly assists the engineer in making the right decisions.

1 . 7 CASE STUDIES

Reading about software engineering concepts alone
is i nsufficient for gai ning a thorough understanding
of the subject. The best way to unify and reinforce
the many topics presented in this book is to ( 1 ) learn
how they are applied to the development of real
software appl ications and ( 2 ) gai n hands-on experi ­
ence developing a software appl ication as part of a
team . To meet the first objective, case studies have
been developed or described and are presented
throughout the book. They serve as concrete exam­
ples of software applications, and include appropri­
ate artifacts as they are discussed and presented in
the text. The case studies are introduced in the next
few sections. To meet the second objective , students
worki ng in teams are provided guidance as they
apply software engi neering concepts to the

development of a group project. As they progress,
students will generate project artifacts and working
code . Arti facts generated as part of the case studies
can also be used as gui dance in developing arti facts
for the group project.
There are three cases studies used i n the text,
as i l l ustrated in Figure 1 . 9 . The Encounter video game is
a single-pl ayer, stand-alone vi deo game appl ication
that is completely implemented through the course
of this book in conjunction with online compo­
nents. [n addition, two open source projects are
used to i l l us trate how open source proj ects are
developed: the Eclipse integrated development envi ­
ronment and the OpenOffice office productivi ty
suite . Open source projects are developed di ffer­
ently from traditional software in that many

Encounter
(created for this book)

1
Case Studies

/
Eclipse

OpenOffice

(open source)

(open source)

Figure 1.9 The main case studies used in this book

CASE STUDIES

di fferent people, from various orga n i zations, de ­
velop features and functions and th�n contribute
them back to the base so ftware applicati o n . In th is
way an open source application grows i n functi on ­
ality and all new features are freely available for
others to use and buil d o n .
Various other examples are used i n this book,
i ncludi ng a video store applicati o n .

1.7.1 Encounter Video Game
The Encounter video game is a singl e-player, stand­
alone video game application. A player is assigned a
main character, and Encounter simulates all or part of
the l i fetime of that character. Success i n playing the
game is measured by attaining a life points goal for the
player or by the abil i ty of the player to survive for a
given time limit. Figure I. 1 0 shows a typical screen
shot: the courtyard area containing a player­
controlled character, Elena.
Game characters begin with a fixed number of
points allocated equally among qualities including
concentration, stamina, intelligence, patience, and strength.
The game consists of movement among a set of
areas . The main character moves between them ,
encounteri ng a game-generated character called

the foreign character. Characters engage each other
when they are in the same area at the same time . The
result of an engagement depends on the values of the
characters' qualities and on the location where it
occurs . Once an engagement is complete, the play­
er's character is moved to a random area. Players can
set the values of their qualities except while engagi ng
a foreign character. The new quality values take
effect only after a delay.

1.7.2 Eclipse Open Source Project
The second case study is Eclipse. Ecl i pse [ 1 4J is an
extenSible, h ighly configurable open source IDE
( i ntegrated development environment). An IDE pro­
vides an environment and set of tools for the devel­
opment of software applications. It provides tools to
build, run , and debug appl ications, the abil i ty to
share artifacts such as code and object with a
team , and support for and integration with version
contro l . Because Eclipse is open source, its source
code and design are freely available and readily
extensible by third parties through the use of
plug-ins. I n fact, Eclipse is considered a platform. I t
isn't a "finished" product, a n d is intended for conti n ­
uous a n d indefinite extension [ 1 5]. Numerous open

Figure 1. 10 Snapshot from the Encounter case study video game: Elena in the courtyard

15

16

CHAPTER 1

THE GOALS AND TERMINOLOGY OF SOFTWARE ENGINEERING

source extensions can be found at the home of the
Ecli pse project, www.ecli pse.org.
Ecli pse has been successfully used as a tool for
wide-ranging application types such as Java develop­
ment, Web services, embedded device programmi ng,
and game programming contests. The Eclipse plat­
form itself provides a programm i ng language-agnostic
i n frastructure . Support for specific languages is pro­
vided by plug-ins, and each plug-in must adhere to the
same rules as all the other plug-ins that use the
platform [ 1 5]. Support for the Java programming
language is provided by the Java Development Tools
GOT), which is built on the Eclipse platform and
provides a full-featured Java IDE.
A typical Eclipse screenshot is shown in
Figure 1 . 1 1 .

user i n terface and feature set similar to other office
suites such as Microso ft Office. OpenOffice. org also
works transparently with a variety of file formats,
includi ng those of Microsoft O ffice" [ 1 6]. A typical
Open Office screenshot is shown i n Figure 1 . 12.
The OpenOffice project encourages participa­
tion by developers, as the typical developer-oriented
Web page shows i n Figure 1 . 1 3 .
We will discuss the management of the Open­
O ffice project i n Part I I I. Here is a summary, quoted
from an OpenOffice Web site:
There are three categories of active proj ­
ects in OpenOffice.org: Accepted, which
is where most technical projects are
located, lncubator, which houses experi ­
mental projects and endeavors, and
Native-Lang, which includes projects pro ­
viding i n formatio n , resources, bui lds,
and forums i n a user's native language .

1.7.3 OpenOffice Project
The third case study that we will use in this book is
OpenOffice (openoffice. org), "a multi-platform of­
fice productivity suite . It i ncludes the key desktop
applications, such as a word processor, spreadsheet,
presentation manager, and drawing program, with a
J

It � :Jot.. - -* - '!HJGI} .. r»- (} - 11 c& ,.f JJ.

� IJ:''''''''''4-

It':i
"
It

�

) �Q!oW'IIMbon5test
. Ill" JRfSystem lb.-y[j2rel. ...2_01)

e-tiiJ fdp$eCore

II oro·edpse·core.boot
.. (WQ.ecbe.ccr!.rtemaI.boot
." oro·edpse·Ctlfe.Intema/.(ontent
• Of9·edpse·Ctlfe.int:«�.JCbs
.. Ot'!jJ.IKfpse.core.rItemaI.preferences

iI crg.edpse.coro.W:CfN/"e9WY
!il. Ofo·edpse·ctlre.int:emoi.1'1.rime
If] • oro·edp5e·core.ltrilne
e if orQ.edbse.COI'e.rtrti'I'Ie.tor'I:ert
EJ! !lIlCot'ItentDesoller .jltYa

!

The Accepted Projects at a point in time are
shown in Figures 1 . 1 4 and 1 . 1 5.

_===- I�:=
J \!::======
::l!
====== ir=l
=;

................................................................. _..............
IBII �ot'por:tlt.1C1n and Others.

•

Copyr10ht.

Ie)

.

AU

reeervl!!d.

t:iQht.5

2001

•

are lDllde elv.llable

Thul

Ilr.:-o("'"

an.d

tl1e

under the terlNl of
thHI dl!ltrlbuo;.ion.,

•hleh aecoII'panle:!l

http://u,,•. eelipse. org/leQal!cpl-vlO. heml

•

Contt"ibutot":I!
IB! COt"poHltlon

lnitl.a.l

IPllck.We orO. ec 1 i p:se. core. runt.
:&.porl

..

the COl'mlOn
and

•
•

API and

11'

Public

1!I "ul�le

Licen!le vl.O

o

lDlpieme:ntat.lon

une . cont.ent.;

java. io. IOlxcept.ion:

Ullworl Java. 10. Input.Stt"earn;

!?}ICo-tertType.)a<.oa
!llICont&'ltT�.iava
• orQ.edpse.core.rtrti'I'Ie.JObs
iB at orQ.edpse.core.n.rUne.preferences
SIti..RESysl«llltnry(JZIe1.4.2_0I)

.......
. '-

• IN; Test rJ Method
.Video:SI:oreDe-sql�
.vstore

"

�!p)

.. esce IConte:nt;De:scr
• I!'s�nCI! ),0
./
public interfAce IContent.De:lct:iber (
•

De.!:lcript.lon re:lulc

•

the

cOn:lt.ant.

•

�.ee IIde3crwe(Input3t.ree.JII,

intended content

�x

!!It.

fllICortentDesoiQtlon.)ItV"

.En<......
• �atIooCore
• 1m.
• .lN8asia
.lrI:�Ex�R«UI
• NorAobustRed:aoQIe
• RefactomgDerno
a RobustRectaoljJle
. "'......

.•
r

eCC'ODIJ:'l!Inyln,. 1Mr.e.r1.1s

indicat.ing Llle conLentS

eore vslid tor

typO!!! .
ICont.encDescription,

intI

Figure 1.11 A typical screenshot of the Eclipse interactive development environment

CASE STUDIES

Ii1.i Untltted2 - OpenOfflce.org 1.1.0

•
,

This is an OpenOffice Text document.

Figure 1. 12 A typical screenshot of the OpenOffice word processor
--

�Off
ice.org
Source Proiect
Surveys Home

User SUlVey (en)
Consultants Survey
OpenOffice.org:

�

Project
Project Home I � I .Ei!ti I �
Resources: � I DocumentatlOo I Source Code

Thank you!

Allintrodyctioo

Survey processed succesfully Your help is appreciated.

Documentation
OpenOffice,91g

Where to go from here

�

We Invite you to further viSit the OpenOffice org website to get acquainted with our community. our
projects and our way of bemg. You should consider visiting An Introduction to OpenOffice.org, the

� page, the Documentation, the OpenOffice org in a Nutshell page, and the � page.
Then you might consider participating

Our community is open far anyone to participate. No matter if you are not a programmer or a
technical oriented person, there is a place for you in one or more of our projects to help the
development, improvement or promotion of the OpenOffice.org free office suite.
By any use of this
Website, you agree
to be bound by
these�
Terms of Use.

The first step into the participation is by subscribing to one or more of our mailing lists inside the
project(s) you feel you can have a contribution to.
Below are some of our mailing lists that might be of interest. For a full listing please Visit the M1ilin.g
� page on OpenOffice Org website.
Recommended Mdlhng lists
'101
uSCI"s@openoftiee.org

Helve It question abol4 the OpenOffice.org suite (not project)?
SIJ;)rfW your question here: you may find an answer. A very

Figure 1.13 Typical OpenOffice communication with development

t""""";II""-l= �=
�

�

i-r;;:
�

:

17

18

CHAPTER 1

THE GOALS AND TERMINOLOGY OF SOFTWARE ENGINEERING

�
!:!=lllig,

api

The application programming interface.

Mathias Bayer,

framework

The framework for applications.

�

tools

The tools used in build process and the build environment,

dba

The database access for the applications.

documentation

End-user documentation for the various components making
up OpenOffice,org.

external

This project will host all the extemal code allowed.

graphics

The graphic applications such as Draw and Impress.

951

The Visual Class Library and other modules.

installation

Creating the installation set,

Skhmidl
�
Application Framework

Build Tools and
Environment
Database Access

Qocumentation

�

l:iirilin
MM1io

frQok
�,
�
�

�
�
�
�
l.iJlJ1ka
�
Matlin

Graphic Appljcations

Graphjc System Layer

�,
Hennes Rohljng
pirk yoe!zke

Lingycompooeot

�

lingucomponent Creating dictionaries, thesaurii, and other related tools,

Hendricks

Figure 1.14 Accepted OpenOffice projects at a point in time, 1 of 2
Source: openOffice, http://projects.openoffice.orglaccepted.html.

Localizatjon

l2imr
�,

110n

Localization, This project includes Internationalization (i18n),

marketing

The project furthering the growth and use of OpenOffice,org
technology, Efforts include: developing collateral, logos,
public outreach.

porting

Porting to new platforms.

qa

Quality Assurance: testing and qualifying all builds of
OpenOffice.org.

sc

The spreadsheet application.

ucb

Allows the applications to transparently access content with
different structures.

�

Nils Fyhrmann

�
Ka.!LJ.O
�
Martin

Ouality Assurance

Spreadsheet
Universal Content Broker

�
�Sl<2ll
l&J:,�
ShlIm
Niklas Nebel
Eike Rathke

�
�,

Andreas Bille

UNO peyelopment Kit I
Component Technology
User Interface

udk
Kay Ramme,
Kai Sommerfeld

Object model development and component technology.
Includes the old 01 and Scripting projects.

Oliver Specht

Common user interface for OpenOffice.org applications.

ui

Hennes Rohling util

LoYis Sy<1rez-

�,
Kay Schenk,

www

Word Processing

Utilities used in development,
The OpenOffice.org website; the project for establishing the
appearance of the Project.
The Word Processing Application

Figure 1.15 Accepted OpenOffice projects at a point in time, 2 of 2
Source: OpenOffice, http://projects.openoffice.orglaccepted.html.

EXERCISES

1 .8 S U M MARY

Developing complex software systems in a successful manner has historically been very difficult. The goal of
software engineering is to define a framework for creating software systems that are reliable, efficient, and
maintainable, and meet the needs of customers. As illustrated i n Section 1 . 2 on software disasters, producing
software that is unrel iable can h ave catastrophic consequences. Although most software does not end in
disaster, care must be taken to avoid the many common pitfalls and mistakes that can plague a software project.
The 4 P's of software engi neering-people, product, project, and process-encompass the different
aspects of defining, building, and managing software . The people are the most important part, as they not
only create the software but also are the customers for who the work is being don e . The work products
include not only source and object code, but also a complete set of arti facts describing the system. A software
process model defi nes a framework for carrying out the different phases of a software project. It imposes order
and structure to a project.
Underlying software engi neering is a set of time-tested pri nciples. Knowing these principles helps to
understand the motivation for the software engineering methodol ogy presented i n this book.
Software engineering is a profession that carries with i t certain ethical responsibilities. The ACM and
IEEE have jointly published a code of ethics to help guide software professionals i n their work.
This book uses three main case studies throughout as realistic examples of software proj ects .

1.9 EXERCISES

1 . Besides those listed in this chapter, what additional expectations do you think software products
may fai l to meet?
2. Research a recent real-world "software disaster." I n your own words, describe the underlying cause
of the problem . What could have been done to avoid it?
3 . What are the four P's of software engineeri ng? ( Recall them without consulting the book. ) Briefly
describe each .
4. In a paragraph, name at least two of the most important deficiencies you can thi nk of in the reporting
of project progress that contribute to an unsuccessful proj ect outcome.
5 . Explain in your own words why people are invariably the most important resource on a project.
6 . For the stakeholder groups l i sted in the text, give an example of a project motivation for each .
7.

You are developing a second-generation custom order entry application for a particular customer.
Explain and give examples of at least two types of problems that can arise if the customer is not
involved in defi ning the new application, and their first use of the application is after it is completed.

8. Why does the use of standards make it easier to generate useful , rel i able documents? Why isn't
their use a guarantee that high-quali ty documents will be produced?
9. Explai n the di fference between a software process and a software process mode l .
1 0 . Figure 8 lists t h e ACM/IEEE Software Engineering Code of Ethics and Professional Practice. Drawing either
from your own experience or from a hypothetical situation, describe a scenario that adheres to one
of the eight pri nciples. Now describe a scenario that violates one of the principles.

19

20

CHAPTER 1

THE GOALS AND TERMINOLOGY OF SOFTWARE ENGINEERING

BIBLIOGRAPHY
1. "IEEE Standard Clossary of Software Engineering Terminology," IEEE Std 610.12-1990, December 1990, p. 67.
2. Naur, Peter, and Randell, Brian, (Editors), "Software Engineering, Report on a conference sponsored by the NATO Science
Committee," Carmisch, Cermany, 7th to 11th October 1968, Brussels, Scientific Affairs Division, NATO, January 1969, pp. 8-10.
3. Lions). L., (Chairman of the Inquiry Board), "Ariane 5 Flight 501 Failure, Report by the Inquiry Board," Paris, July 1996, http'//www.
ima.umn.edu!�amold/disasters/ariane5rep.html [accessed November 1, 2009 ].
4. McCormick, John, and Thayer, Berta Ramona, "We Did Nothing Wrong," Baseline, March 2004, p. 1, http://www.baselinemag.
com/c/a/Projects-Processes/We-Did-Nothing-Wrongl [accessed November 1, 2009 ].
5. Levenson, Nancy, and Tumer C.S., "An Investigation of the Therac-25 Accidents," [EEE Computer, Vol. 26, No.7, July 1993, pp. 18-41.
6. Neumann, P. C., "Computer Related Risks", Addison-WesleylACM Press, 1995, p. 384.
7. Neumann, Peter C. (moderator), ''The Risk Digest, ACM Committee on Computers and Public Policy." http'//catless.ncl.ac.ukl
Risks! [accessed November 1, 2009 ].
8. Charette, Robert, "Why Software Fails," IEEE Spectrum, vol. 42, no.9, September 2005, pp. 42-49.
9. Humphrey, W. S., "PSP: A Self-Improvement Process for Software Engineers," 2005, Addison-Wesley, p. 368.
10. Humphrey, W. S., "Introduction to the Team Software Process," 2000, Addison-Wesley, p. 368.
II. Davis, Alan, "201

Principles of Software Engineering," 1995, McCraw Hill.

12. Merriam-Webster Online Dictionary. http.//www.merriam-webster.com/home.htm [accessed November I, 2009 ].
13. "Software Engineering Code of Ethics and Professional Practice (Version 5.2) as recommended by the ACM/IEEE-CS Joint Task
Force on Software Engineering Ethics and Professional Practices, 1999. http'//www.acm.org/about/se-code [accessed November I,
2009].
14. E.O.S. Project. Eclipse Open Source Project. http.//www.eclipse.org/.

15. The Eclipse Project Wiki. http://wiki.eclipse.org/Main_Page.
16. OpenOfflce Project. http'//www.openoffice.org/.

Introduction to Quality and
Metrics in Software
Engineering

Planning
� Maintenance
Testing

\

The Software
Development
Life Cycle

Implementation

�

What does "software quality" mean?
What are "defects" in applications?

\

What is the difference between

verification and validation in software
development?

Requirements
analysis

/

How do you measure software
quality?

DeSlgn

Figure 2.1 The context and learning goals for this chapter

Buildi ng software that exhibits a high level of qual ity is one of the major themes o f this book and is a
critical factor in the production of successful software systems. However, achieving a high quality level is no
easy task. Quality must be integrated into projects from the beginning and during every phase of product
development. This is why quality is discussed throughout the book and is being introduced at this early stage .
Throughout the l i fe of a software project, data-or measurements-are collected to ascertain the
effectiveness of the processes employed and the software being constructed. Such data are called metrics.

22

CHAPTER 2

INTRODUCTION TO QUALITY AND METRICS IN SOFTWARE ENGINEERING

Integration and
System Testing

J

Implementation
and Unit Testing

Figure 2.2 Software development phases requiring the application of metrics

These measure various aspects of a project such as the qual i ty level of the software itself, and also the degree
of the project's adherence to its schedule and other measurables such as the productivity of engineers. This
chapter provi des an overview of software metrics and an explanation of how they relate to software qual ity.
Each of the major parts of this book contai ns a chapter relating how quality is practiced and metrics
coll ected and applied to the development phase covered in that part. Figure 2 . 2 depicts the different phases
requiring quali ty practices and metrics collection.
So far, we have used the term "software qual i ty" quite freely. Now we'll provi de a concrete definition.
2.1 TH E M EANING OF SOFTWARE QUALITY

Everyone wants "quality," but what exactly does software quali ty mean? There are varying views on this. Some
measure quality in terms of categories such as reliabil i ty, portabi l i ty, and so on. However, i f one of these­
portability, for example-is not a requirement of the product in any form, then it is not relevant. Some feel
that the more an appl ication changes the world for the better, the more quality i t possesses. Others define
software qual ity in terms of how well a development process is followed, or how exte nsively the emergi ng
product is tested. Ultimately, it is best for an organization to define for itsel f and its customers what it means
by "quality." Above all, it is important that "software qual i ty" has a consistent mean i ng within the project's
stakeholders. A definition follows that will be used throughout this book.
To give some background, let us first consider a "qual ity" plain old-fashioned lead pencil ( frequently
yellow). All would agree that such a pencil must first satisfy its requirements, typically including that it "shall
be solid wood; shall have a lead core with designated hardness; shall have an eraser that can erase most of
what the lead has deposited on plain paper; shaIl have the required length; etc . " To be a quality old-style
pencil , however, we expect additional attributes such as that it is "harder than usual to break, lasts twice as
long as average pencils, has a very effective eraser, etc ." To summarize, a qual ity conventional i tem has attributes
beyond its requirements. In software engi neering, however, this is not the typical definition of quality.
What is di fferent about software applications is that they inevitably contain defects . Every defect is a
deviation from requirements, regardless of whether the requirements are carefuIly written down . Hence we
cannot think about the qual ity of software the same way we th ink about the quality of a lead penci l . Instead, a
good defin ition of software quality is the following:

The more closely a software product meets its requirements, the higher its qual ity.

Figure 2 . 3 illustrates this view of quality.

DEFECTS IN SOFlWARE

Requirements
(explicit and implicit)

1 00%

'- ,
\
I
I
I

T ypical quality focus J

Figure 2 .3 The meaning of software quality: the degree to which the actual requirements are met
Source: Graphics reproduced with permission from Core\.

We have not yet discussed how requirements are gathered and generated. For now, let us assume that
requirements are generated with the best knowledge available during requirements analysis. Even i n this case,
after the software has been developed and the product has been shipped to customers , it may be discovered
that some requirements are in fact incorrect or missing. In these cases the software is constructed using the
requirements as documented, and we would say the software meets all its explicitly specified requirements but it
may not fully satisfy its customers. There are a number of different ways this can happen .
As an example, i f customers are not consulted during requirements definition the system is constructed
without their input. When they eventualIy use the software they may find it does not function as they wish and
are dissatisfied. Even if customers are consulted and provide input, i t is possible they will stilI be dissatisfied on
using the software. For example, suppose that a software system implements a user i n terface, with screen
layouts and menus specified in a requirements document. I f customers are not given an opportunity to use the
interface before the product is released, they may find that what appears to work well on paper is actualIy
cumbersome to use. I n these scenarios and others, we would say the product does not exhibit high quali ty
because it does not satisfy the customer. Therefore a more complete definition of quality would be:

The more closely a software product meets its specified requirements, and those requirements meet the
wants and needs of i ts customers, the higher i ts quality.

Techniques for gathering requirements and ensurin g customer satisfaction are covered in Part IV on
requirements analysis.
Besides the benefit of customer satisfaction, producing high-quality software provides other advantages. It
has often been shown that a correlation exists between products with the least number of defects and the shortest
schedules. There is also a correlation between poor quality and schedule overruns, and between poor quality and
increased project costs. The more defects there are in software, the more time engineers spend fixing them,
taking time from other important project tasks. Also, the more defects that exist, the more likely that software
changes necessitated by fixing these defects will themselves result in more defects. For all these reasons and more,
quality is one of the most important attributes i n software and a key contributor to its success.
2 . 2 DEFECTS IN SOFTWARE

A defect in a phase of software application is defined as a deviation from what's required for that phase. In practice ,
most software systems contain defects and therefore do not entirely meet their requirements. The software
disasters described in Chapter 1 illustrate the cost of defects in the tens-and even hundreds-of millions of
dollars. Defects can be i ntroduced at any stage in the development process. A major goal of software engineering is

23

24

CHAPTER 2

INTRODUCTION TO QUALITY AND METRICS IN SOFlWARE ENGINEERING

identifying and removing as many defects as possible, as early as possible, throughout product development, either
by inspection of artifacts or testing of the system. For example, if software is in the implementation phase, the code
may deviate from the software design produced in the previous design phase, or it may be coded in such a way as to
produce an incorrect output. The resul t of either case is considered a defect. In this particular case, an inspection of
the code prior to testing is conducted, with a goal of identifying as many defects as possible. Once the software is
fully integrated into a system, testing is conducted to ensure that it conforms to the specified requirements.
Defects are the clearest manifestation of a quality shortfal l . The later in the development cycle they are
discovered the more they cost to repair. There fore two quality goals o f software development processes are as
follows [ 1 ]:
1 . To remove as many defects as is reasonably possible before the product is delivered to the customer.
2 . To remove as many of these defects as early in the development process as possible.
To the first point, defects discovered and repaired during software development will not be found by
customers , of course . The more defects that can be removed, the higher the quality of software is likely to be,
and the more the customer will be satisfied.
To the second point, as software is developed and defects are introduced (which is, in practice,
inevitable), the earlier they are discovered the less they cost to repair.
According to Boehm [2] and others, the cost of defect repair after software is released to customers can be
1 00 times greater as compared to fixing the same defect early in the development cycle. Various studies show
various cost escalation factors, but they all report a dramatic rise in the cost of detection and repair. Figure 2 . 4
shows o n e estimate of the relative cost o f defect repair during each stage o f development. For example, i f a defect
is introduced during the requirements phase, assume that it costs $ 1 to detect and repair if done during that same
phase. If it slips through to the implementation phase, the same defect will cost $20 to repair. If it falls all the way
through to maintenance, which is when customers are using the software, the cost can be $ 1 00 to repair.
The reason for this increase in repair cost in subsequent phases can be illustrated with an example [ 1 ].
Suppose you have an application that performs a large number of file reads and writes. As part of your
development process, at the end of the design phase you conduct an inspection of the design and discover
two defects : one in the algorithm that performs file reads and writes; the other in the allocation o f memory to
hold the file records. Assume that the work required to fix these defects after the inspection takes two days to
complete, and the steps taken are as follows:
1 . Modify the algorithm to fix the defect.
2 . Conduct an inspection of the reworked design to verify its correctness .

Requirements

S;lJ

�
Implementation

Figure 2 .4 Cost of detecting and repairing a defect during maintenance, depending on the phase in which it was injected

VERI FICATION AND VALIDATION

Suppose, i nstead, that the defects went undetected and passed through to the implementation phase .
The defects would be harder to detect and could now affect several hundred l i nes of code . I f the defects are
detected during a code i nspection, the work required to fix them could take a week to complete . The step
required would be as follows :
1 . Modify the algorithm to fix the defect.
2. Conduct an i nspectio n of the reworked design to veri fy its correctness.
3. Recode the affected portion of the code .
4. Conduct an i nspection of the reworked code to veri fy it is correct and conforms to the reworked design .
Suppose now that the defects went undetected and passed through to the testing phase . The defects
would be even harder to detect and now take more time to fix. I n addition to the one week required if found
duri ng code i nspection, the foll owing additional work would be required:
5. Assistance from the tester to recreate the defects.
6. Discovery of the exact cause of the defect within the software.
7.

Dedicated machine time to support debugging.

8. Retesting the fix to ensure it works correctly.
These activities can take an additional week to a month , dependi ng on how difficult it is to isolate and
repair the defect. This example illustrates the cost of not detecting and repairing defects as close to their
injection as possible and why every effort must be made to detect and repair defects as early as possible.
2.3 VERIFICATION AND VALIDATION

Software veri fication and vali dation (V&V) is a process implemented throughout the software l i fe cycle to
ensure the following.
1 . Each step i n the development process is carried out correctly. This is called verification.
2 . Each artifact produced meets its requirements as specified i n prior phases . This is called validation.
The IEEE Glossary [ 3J defines these terms as follows :
Veri ficatio n : "The process of evaluating a system or component to determine whether the
products of a given development phase satisfy the conditions imposed at the start of that phase . "
F o r example, is the software design sufficient t o implement the previously specified requiremen ts?
Does the code fully and correctly implement the design?
Vali datio n : "The process of evaluating a system or component during or at the e n d of the
development process to determine whether i t satisfies speci fied requirements ." In other words,
does the implemented system meet the speci fied user requirements?

Verification is comparable to keeping your balance current in your checkbook based on your daily activity_
As you write checks and make deposits, you enter the amount in the checkbook register and update the balance .

25

26

CHAPTER 2

INTRODUCTION T O QUALITY AND METRICS I N SOFTWARE ENGINEERING

Each time you make an entry you check that your ari thmetic is correct and your new balance is right. This is
analogous to ensuring that each phase i n the software development process is carried out correctly.
Validation is comparable to balancing your checkbook when the bank's statement arrives. You match all
the transactions in the monthly statement with those in your register, ensuring that none have been omitted
or entered incorrectly and that the transaction amounts in your register match those in the statement. [n
addi tion, you vali date that the ending balance in your regi ster matches that in the statement. Even though
you kept your balance up-to- date, mistakes may have been made . Val i dation catches those mistakes and
ensures the correctness of your balance . Th is is analogous to testing of a software system.
The two main activities i nvolved duri ng V & V are inspections and software testing. Inspections, and
also reviews, are veri fication activities and i nvolve peer exami nation of project artifacts ( requirements, design ,
code, etc . ) to discover defects. The idea is to find as many defects as possible as early as possi ble. Inspections
are covered in greater detail i n Chapter 5 . Testing is the pri ncipal part of val i dation.
Software testing is primarily a val idation activi ty, occurri ng at the end of a development cycle to ensure
that software satisfies i ts user requirements. Testing involves providing the system with a set of i nputs, and
val i dating that the system behavi or and output match what is expected. Any deviation from an expected
outcome is considered a defect. Testing is covered in detail in Part VII .
Note that i t is a combi nation o f veri fication-pri marily i n the form o f i n spections-an d val i dation­
primarily in the form of testi ng-that consi stently produces high- qual i ty software . Testing alone is not
sufficient. No matter how talented software engin eers are at fixing defects, i f the qua l i ty level is low
enteri ng val idati on , as measured by latent defects ( those present but not necessari ly known ) , there is a h i gh
probabi l i ty that val i dation will take signi ficantly longer than expected and the qual i ty level wi l l remain
lower than desi red. As many defects as possible must be removed from the arti facts before val i dation
begi n s .
V & V and quality practices, a s they relate t o each major software phase and activity, is included in the
quality chapter near the end of each part of this book. Figure 2 . 5 summarizes these V&V concepts .
To reinforce the veri fication/vali dation distinction, let us perform V&V on a simple example. Suppose
that the customer wants an application that "solves l inear equations of the form ax + h = c . " We translate thi s
into user requirements such as:
1 . The user shall be able to input numbers a, h , and c up to 10 digits each, with up to four places foll owi ng
the decimal point.
2. The application shall produce a solution to the equation ax + h = c that is within 1 / 1 000 of the
mathematically exact answer.
Then we implement a program to satisfy these requirements .

•

Veri ficati o n : Ensuring that each artifact is built in accordance with its spec i fications
"Are we building the product right?"
Mostly inspections and reviews .

•

Validatio n : Checking that each completed arti fact satisfies i ts speci fications.
"Are we building the right product?"
Mostly testing.

Figure 2. 5 verification vs. validation

PLANNING FOR QUALITY

It is our responsibility to ensure that we have built the appl ication correctly by checki ng that we
proceeded appropriately from the beginning of the process to the end. This is the verification process. For
convenience, we will number the development phases as follows.
1 . Cet the customer's requirements.
2. Write down the requirements in detail .
3 . Obtain the customer's approval of the requirements statement.
4. Code the application. (For simplicity, we have omitted a design phase . )
5 . Test the application.
Verification checks the followi ng questions:
1 . Do the requirements express what the customer really wants and needs? Some verification issues here are
as follows: Is ax + b = c the correct form? What are the precision requirements? What if 0 is entered for a?
2 . Are we carrying out the process of obtaining the customer's approval in an appropriate manner? Some
verification issues here are as follows : Are we allowing the customer adequate time? Are we explaining all
needed terms to the customer?
3. Does the code implement the written requirements in every respect? This requires an inspection o f the
code i tself, in which the requirements are considered one at a time and the matching code is perused.
This could include a mathematical proof. (Strictly speaking, veri fication does not call for executing the
code . )
4. Do the proposed tests adequately cover the application? For an application of real istic size, this would
include an i nspection of the test plans, test cases, and test procedures. This is separate from testing itself,
a vali dation step discussed below.
Validation of this product consists of obtaining the customer's approval of the written, completed
requirements and executing a set of tests on the completed code . For example, we enter a = 1 , b = 1 , and
c
1 , and validate that the program produces x = O.
To summarize our discussion o f the V& V process, at any given moment a software engineer is either
creating an artifact, veri fying it as he does so, or vali dati ng a completed arti fact. This i s illustrated in
Figure 2 . 6 .
=

2 . 4 PLAN N I N G FOR QUALITY

Since quality practices are impleme nted throughout the software l i fe cycle, it is important to express quality
approaches and goals i n writing early in a project-in other words, well before the goals are used in tracking
the project's quality.
Agile projects emphasize the attainment of quality through continual interaction with the customer in
person , early implementation, and continua l , cumulative testing. The IEEE has published several standards to
help meet this objective . These, and standards like them , tend to be employed in l arger projects that are not
agile or that employ agile methods only partially.
The Software Quality Assurance Plan ( S QAP) ( IEEE Std 7 3 0 - 2 00 2 ) is a document for expressing an
overall approach to qual i ty that is conducted throughout the entire software l i fe cycle. M ajor topics

27

28

CHAPTER 2

INTRODUCTION TO QUALITY AND METRICS IN SOFTWARE ENGINEERING

Artifact
under
construction
,

,

Process
",

,

,

"

Partially
completed
artifact

,

,

,

Creation

,

,

"

,

,

,

,

,

I

Process

Verification

,

Completed
artifact

/

"

"

/

/

/

"

/

"

/

7f

/

/

/

/

Validation
/

"

/

"

Software engineer
Figure 2.6 Verification and validation of an artifact: before completion VS. after
Source: Graphics reproduced with permission from Corel.

i ncluded i n the plan are l i sted below. Detail s of the SQAP are covered i n Chapter 5 . The plan i ncludes the
fol lowi ng:
•

•

The organizational structure of the qual ity team
A list of documentation to be created governing the development, verification and val idation, use and
maintenance of the software (e.g. , software requirements speci fication, veri fication and val i dation plan,
software design speci fication, etc . )

•

The definition a n d schedule of i nspections t o b e conducted a n d how they are t o b e conducted

•

The metrics to be collected, monitored, and analyzed

•

References to software test plans

•

How problem reporting is to be managed and conducted

The V&V Plan is the manner in which the Software Quality Assurance Plan is supported by veri fication
and vali dati o n . The IEEE has published a Software Veri fication and Validation Plan (SVVP) framework ( IEEE
Std 1 0 1 2-2004) to assist in documenting the speci fic V&V practices to be implemented. The contents and
appl ication of the SVVP are covered in Chapter 9.
2 . 5 M ETRICS

Metrics are numerical measures that quantify the degree to which software or a process possesses a given
attribute. Examples of metrics are "defects per thousand l i nes of code" and "average software module size."
Metrics are collected and analyzed throughout the software l i fe cycle, and help with the following:
•

Determining software qual ity level

•

Estimating project schedules

•

Tracking schedule progress

•

Determining software size and complexity

METRICS

•

Determining project cost

•

Process improvement

When goals such as software quality level and project cost are not expressed speci fically enough, they
may be subject to differi ng interpretati ons. These di ffere nces can cause confusion and conflict. For example, a
goal stated as 'The appl ication should crash very seldom" is not specific. H ow do you measure "very seldom"? Is
it once per day? Per week? Per year? A more precise goal would be "The application should crash no more
than 3 times per year." Stated this way, the goal is not open to interpretation and is measurable.
Without quantifiable, objective measures to provide visibility into a project it is difficult to measure a
project's progress in terms of whether it is on schedule, whether it is meeting its qual ity goals, and whether it
is ready to ship to customers . In addi tion, "you can't improve what you don't measure." Continuous
improvement o f an organization's processes and software is predicated on collecting metrics and setting
quantitative improvement goals for future projects .
To be successfully uti lized, metric collection commences at the onset of a project and continues
throughout the entire l i fe cycle, through maintenance. Metric collection and analysis can take a significant
amount o f managerial and engi neering effort, but the payoff is well worth it.
Software metrics can be classified into two broad categories: product metrics and process metrics. Product
metrics measure characteristics of the software product, or system, including its size, complexity, perform ­
ance, and quality leve l . For example, size can be expressed in the number of l i nes of code, performance as the
number of transactions per second, and quality level as number of defects per thousand l i nes of code , which is
commonly referred to as defect density.
Process metrics measure attributes of the software processes, methods, and tools employed during
software development and maintenance of a software system. Process metrics include project effort, schedule
adherence, defect repair rate, and productivity. For exam ple, project effort can be expressed as the number o f
person months of development, and defect repair rate a s the number of defects repaired p e r week . Many other
metrics can be collected, and they are discussed in greater detail in the quali ty and metrics chapters l ater i n
the book. Chapter 9 describes metrics collection a n d utilization in more detai l . The next section discusses
metrics and their use in measuri ng quality.
2 . 5 . 1 Qual ity Metrics

Since quality is the degree to which software satisfies its requirements, we must be able to measure this degree
of compl iance. It is useful to identi fy a set of software quality metrics, which are a subset of the total metrics
collected for a project. These metrics are speci fically focused on the quality characteristics of software and of
the processes employed during the software l i fe cycle.
As described by Kan [4], important quality metrics include the following:
•

Defect density

•

Mean time to failure

•

Customer problems

•

Customer satisfaction

Defect density is the number of defects relative to the software size. Size is typically expressed in thousands
of li nes of code ( KLOC), so defect density is expressed as defects/KLOC. Remember that a defect is defined
as a deviation from user requirements, so defect density is one of the most basic metrics used to measure

29

30

CHAPTER 2

INTRODUCTION TO QUALITY AND METRICS IN SOFlWARE ENGINEERING

qual i ty. In general, the higher the defect density, the lower the qual ity. Organizations typically characterize
defects by type or by severity, to distinguish their relative importance. The following is an example of how a
high -severity defect would be defined and of a qual ity goal based on the definition:
A class 1 defect is defined as a requirement l isted i n section 3 of the Software Requiremen ts
Specification that the appl ication fai ls to satisfy. The application shall have no more than 5 class 1
defects reported per 1 ,000 users duri ng the first month of operatio n .
Note that this definition and goal are very specific and measurable. Again, when goals are not expressed
i n a quanti fiable form , they may be subject to di ffering interpretations. For example, consider an alternative
defi n i tion to the one above: "there shoul d be very few class 1 defects reported in the first few months of
operatio n . " There is no way to measure "very few" and therefore to val idate compliance.
A common indicator of software quality is the rel iabi l i ty of a system, as measured by its availability or
the frequency of system crashes over a period of time. The typical metric used is mean time to failure (MTTF) and
i s the amount of elapsed time between system crashes . The MTTF metric is often used with safety- related
systems such as the airline traffic control systems, avionics, and weapons. For i nstance, the U . s . government
mandates that its air traffic control system cannot be unavailable for more than three secon ds per year [4] .
Another example can b e seen i n many telecommunications switches, such a s those used i n cellular networks.
Large network provi ders mandate that this equipment must have "five 9's" availability, which is an uptime of
99.999% per year. This translates to a total yearly downtime of 5 minutes, 15 seconds. The reader may well
ask, "Why not make the required MTTF 1 00 % 7" The answer is that th is is generally not attai nable, and so no
development organization would sign up to do the job.
Customer problems are classified as the total number of problems encountered by customers while using the
product. Some of the problems may be caused by valid defects in the software. Others may be caused by non­
defects, such as a confusing user interface, poorly written documentation, or duplicate defects ( i . e . , defects that
were already reported andlfixed but not known by the reporti ng party). Duplicates can be an important indicator
as to how widespread a defect is, based on the number of times the same defect is reported by different users. In
all these cases, whether a problem is caused by a defect or not, customers are encountering perceived usability
problems and as a result may not be satisfied with the software . This makes the customer problems metric an
important indicator of quality. This metric is typically expressed as problems/user/month . It and other metrics
collected after a software product is released are discussed in Part VII on testing, release, and maintenance.
Customer satisfaction metrics are commonly collected through the adm inistration of customer satisfacti on
surveys. Companies such as Cisco Systems [5] collect feedback from their customers , with satisfaction
measured on a 5 - point scale ( 5 = Very Satisfied; 1 = Very Dissatisfied) . IBM includes the CUPRIMDSO
categories ( Capabil i ty/functional ity, Usability, Performance, Rel i ability, Installabil i ty, Maintainability,
Documentation/i nformation, Service, and Overall ) . Hewlett- Packard uses the FURPS categories ( Function­
ality, Usability, Reliability, Performance, and Service) [4] . Results of these surveys are used to drive
improvement initiatives in their respective organizations.
2.6 SUM MARY

Quality software is a major theme of this book. Quality can be defined as "the more closely a software product
meets the wants and needs of its customers." There are many advantages to producing qual ity software including
i ncreased customer satisfaction, reduced development schedules, and reduced project cost. Quality practices are
implemented at the begi nning of the software life cycle and last through product release into mai ntenance.
Defects i n software are deviations from requirements. As many defects as possible should be removed
during product development, so these defects will not be delivered to customers. The earlier in the l i fe

B I BLIOGRAPHY

cycle defects are detected, the easier they are to repair and the less they cost to fix. Studies have shown that
defects detected and repaired after software is released to customers can cost up to 1 00 times as much as if the
same defects were repaired shortly after they were introduced.
Veri fication and val idation (V & V) is a process for veri fying that artifacts produced during the l i fe cycle
contain as few defects as possible and validating that software satisfies its requirements. Veri fication answers
the question, "Are we building the product right?" Val idation answers the question, "Are we building the
right product?"
Metrics are numerical measures collected throughout the software l i fe cycle, and quantify the degree to
which software and processes possess certain attributes. They help with determining quality leve l , estimating
schedules, tracking schedule progress, determining software size and complexity, determining project cost,
and improving processes. Metrics rel ated to quality i nclude defect density, mean time to failure, customer
problems, and customer satisfaction .

2 . 7 EXERCISES

1 . I n addition to the reasons stated in this chapter, name at least two other advantages to producing
quality software .
2 . It has been noted that the later in the l i fe cycle defects go undetected, the harder they are to
discover and repair. In your own words, describe two reasons why this is true .
3 . (a) Describe in your own words the di fference between verification and validation.
(b) What are the advantages and disadvantages of spec i fying a V&V plan before a plan for
conducti ng your spec i fic proj ect?
4 . (a) What are metries?
(b) Give a reason why you understand metrics to be important.
5 . (a) In your own words, describe the di fference between product and process metrics .
(b) For each of the following obj ectives, state a metric you would use to help in achieving the
objective, state whether it is a product or process metric, and explain how it would be applied.
i.
ii.
iii.
iv.

Avoid project schedule delays.
Measure conti nuous quality improvement from one project to the next.
I dentify software parts that are exhibiting qual ity problems.
Establish a baseline for improvi ng schedule accuracy.

BI BLIOGRAPHY
1. Whitten, Neal, "Managing Software Development Projects, " John Wiley & Sons, p. 1 95, 1 995.
2. Boehm, Barry, "Software Engineering Economics, " Prentice-Hall, 1 98 1 .
3. "IEEE Standard Clossary o f Software Engineering Terminology," IEEE Std 610. 1 2-1990, December 1 990, pp. 80-81.
4.

Kan, Stephen N . , 2003, "Metrics and Models in Software Quality Engineering, Second Edition, Addison-Wesley, Pearson Education Inc . ,
pp. 86- 1 00.

5. Cisco Systems, Customer Satisfaction Metrics. http://www.cisco.com/web/about/ac50/ac208/abouccisco_approach_to_quality_
customer_sacsurvey.html [accessed Nov 4, 2009].

31

Software Process

Planning
Maintenance

Testing

The Software
Development
Lifecycle

What are the main activities of
software processes?
What are the main software

\

process types?
How would a team such as a student
team go about selecting a process?

Requirements
analysis

Implementation

Design

/

Figure 3. 1 The context and learn ing goals for this chapter

A software project progresses through a series of activities, starti ng at its conception and continuing
even beyond i ts release to customers. There are numerous ways for i ndividuals and teams to organize these
activities . Typically, a project is organized i n to phases, each with a prescribed set of activities conducted
duri ng that phase. A software process prescribes the interrelationship among the phases by expressing their order
and frequency, as wel l as defining the deliverables of the project. It also speci fies criteria for moving from one
phase to the next. Speci fic software processes, called software process models-or life cycle models-are
described. This chapter is organized to first describe the i n dividual activi ties of software processes, and then
to describe process models-the various ways i n which these activities can be pursued.
In addition to the activities prescribed by process models, there is a set of generic activities, called
umbrella activities, that are implemente d throughout the l i fe of a project. For i nstance, projects contain certain

THE ACTIVITI ES OF SOFTWARE PROCESS

risks that if they come to pass can affect the successful outcome of the software . Risks need to be i dentified,
monitored, and managed throughout the l i fe of a project. This is an umbrella activity known as risk
management. Other umbrella activities i nclude project management, configuration m anagement, and qual ity
management. Project management is covered in Part III , configuration management in Chapter 6, and qual ity
management throughout, but especially in Part V I I .
People sometimes associate process with overhead, unnecessary paperwork, longer schedules, a n d s o
on. I n other words, they feel that process doesn't a d d value, or worse, that it adversely affects the success o f a
project. When implemented i ncorrectly, software processes can indeed lead to undesirable results. However,
as we explain in this chapter, if processes are applied with a degree of flexibility and adaptabi l i ty, they are of
great benefit and i nvaluable to the successful outcome of projects.
I n certain situations, a version of worki ng software containing a subset of the overall product
functionality is required early in the overall schedul e . This version of the emerging product, called a
prototype, typically implements functionality that is deemed a risk to the project. Typical reasons to build
prototypes include proving technical feasibil i ty and validating the usability of a user interface . Prototypes are
covered in detail in Section 3 . 2.3 . 1 .
To reinforce the contents o f this chapter and to provi de guidance to students a t the same time, this
chapter ends with a section devoted to getting student teams started with a term project.
3.1 THE ACTIVITIES OF SOFTWARE PROCESS
Most software process models prescribe a similar set of phases and activities. The difference between models
is the order and frequency of the phases . Some process models, such as the waterfall , execute each phase only
once. Others, such as i terative models, cycle through multiple times. This section describes the phases that
are prevalent in most software process models, and is summarized i n Figure 3 .2 . The phases i n Figure 3 . 1 and
Figure 3 . 2 are identical, except that Figure 3 . 1 combines i nception and planning. The parts are explained
below. Specific process models and how they implement the phases are covered in Section 3 . 2.

1 . Inception
Software product is conceived and defined.
2 . Planning
Initial schedule , resources and cost are determi ned.
3. Requirements Analysis
Specify what the appl ication must do; answers "whaO"
4. Design
Specify the parts and how they fit; answers "how?"

5 . Implementation
Write the code.
6. Testing
Execute the application with input test data.
7. Maintenance

Repair defects and add capability.
Figure 3 . 2 The m a i n phases o f a software project, showing Inception as a separate phase

33

34

CHAPTER 3

SOFTWARE PROCESS

Inception
This is the phase where i n i tial product ideas are formulated and a vision of the software is conceived. Whether
it is a brand new product or an improvement to existi ng software, every project starts with an i dea of what is to
be built. Major functionality and proj ect scope is defined. Target customers and market segments are
identified. Customers and stakeholders may be consulted for high-level input i n to software functionality.
However, stakeholder involvement at this stage is di fferent from that during the subsequent requi rements
analysis phase. During i nception, the goal is to gather very high level feedback. As an example, suppose a
company is considering building a video store application. A market analysis may be conducted to determine
the existence of competing video store applications. A summary of their features and an analysis of their
strengths and weaknesses is compiled. The commercial success of the proposed application is determi ned by
i dentifying potential new customers and contacti ng them for i nformation concerning:
•

Their satisfaction with their current application

•

Ideas for needed functionality and features

•

Their likelihood of adopting a new product

As an example, suppose that a currently deployed system requires custom hardware, but potential
customers would prefer using standard Windows PCs. Based on th is analysis and feedback, the need for and
viability of the proposed application is determi ned. I f it is deemed promising, high-level functionality for the
application is defined based on the feedback received, and the project proceeds to the planning phase .

Planning
Once a high-level idea for the application is developed, a plan is formulated to produce it. Si nce th is is still
very early i n the overall l i fe cycle and detailed i n formation is not yet available, the plan will be a rough
estimate . However, some plan must be in place to understand the scope and cost of the project. A project plan
that i dentifies the high-level activities, work items, schedule, and resources is developed. From this
i nformation a cost estimate can be developed. This step is very important to determine the feasibility of
a project. For exampl e , i f the cost is deemed to be too high, a reduction i n features may necessary. I f the
product release date is too late, more resources may be added. It is critical that these types of problems be
iden tified as early as possible so corrective action can be taken.
The results of this phase are typically captured in a Software Project Management Plan (SPM P ) . The
SPMP and project management are covered in Part IV. Because the plan is only a rough one at this stage , it is
necessary to modify and adapt it throughout the l i fe of the project. For example, suppose that duri ng
subsequent requirements analysis potential new customers are identified and addi tional functionality is
requested. Using the video store application as an example, suppose a request is received to add additional
workstations to stores so customers can retrieve detailed movie informatio n , such as release date , movie
studio, cast, director, producer, genre, and so on. This new functionality may require additional project
resources and changes to the schedule. The SPMP would be updated as a result. Some l i fe cycle models, such
as the spiral model described below, prescribe specific points in the process where planning i n formation is
revisited and updated when required. Agile proj ects, as will be seen , keep planning to a min imum .
In addition to the activities described above, a plan is developed for managi ng project arti facts such as
technical specifications and source code . This is known as configuration management, and includes tasks such as
tracking changes to arti facts and handling multiple versions. Configuration management is planned at this
early project stage, before the first project arti facts are generated. Configuration management is covered in
detail i n Chapter 6.

THE ACTIVITIES OF SOFTWARE PROCESS

Requirements Analysis
Duri ng this phase, detailed i nformation regardi ng customer wants and needs, and problems the software is
i ntended to solve are gathered. I nformation gathered and documented is i n much greater detai l than it was i n
the i nception phase . During i nception, o n l y enough i n formation is required t o start planning t h e project.
During requirements analysis, specific product functions and features are defined along with requirements
such as performance, reli ability, and usability. Requirements are generated i n a form that is completely
readable and understandable by customers . High-level requirements i n particular are typ ically expressed in
ordinary English (or the local language ) . Various techn iques are used to obtain this i n formatio n , including
customer interviews and brainstorming sessions. Requirements describe what the application is i ntended to
accomplish. They are specified i n sufficient detail so they can be used as i n put for the subsequent design
phase, which defines how the software will be built. The results of the analysis are typically captured in a
formal Software Requirements Specification (SRS ) , which serves as input to the next phase .

Software Design
The purpose of software design is to define how the software will be constructed to satisfy the requirements.
That is, the i n ternal structure of the software is defined. The two main levels of software design are software
architecture and detailed design . Software architecture is analogous to the overall blueprints of a house as a
whole . Blueprints specify the number of rooms and their layout, door and window locations, number of floors,
and so o n . Software architecture specifies how the software is broken into subsystems or modules and the
software interfaces between them . For example , the architecture for a video store application may consist of
components such as a user interface module , a problem domain module, and a database module. Agile
projects generally perform design, implementation, and much testing in an i n terweaved fashion rather than
calli ng out design as a separate phase .
The detailed design is analogous to the details contained in a house blueprint. I n house plans, details
such electrical wiri ng and plumbi ng are specified. I n software , details such as algorithms and data structures
are specified. Other aspects of software design include user interface design and database design . The output
of software design is specified in a Software Design Document (SOD) and is used as i n put to the
implementation phase. Software design is covered i n detail in Part V.

Implementation
This phase consists of programming, which is the translation of the software design developed i n the previous
phase to a programming language . It also i nvolves i ntegratio n , the assembly of the software parts . The output
consists of program code that is ready to be tested for correctness . For agile techni ques, design implementa­
tion and much testing are performed in tandem.

Testing
In this phase, the code produced duri ng the implementation phase is tested for correctness. Testi ng is
performed at three levels. First, individual modules are tested by developers. Second, modules are integrated
and tested to ensure that they i nterface properly. Third, once all the modules have been integrated, the entire
system is tested to ensure that it meets the user requirements. System testing is typically conducted by an
independent qual ity assurance (QA) team . Recall from Chapter 2 that this testing process is called validation.
Once system testing has been com pleted, several levels of customer testing are conducted. During beta testing
the software is as close to the final release as possible, and is given to part of the customer commun ity with the
understanding that they report any defects they find. The goal is to uncover a set of problems that could only
be discovered with this type of "real -world" testing. Once beta testing is complete, acceptance testin g is

35

36

CHAPTER 3

SOFTWARE PROCESS

conducted on the "final" release of software. Acceptance tests are comprised of a subset of system tests, and are
conducted by either the customer or a represen tative of the customer to ensure that it meets the customer's
criteria for release . Sometimes a round of acceptance testing is conducted prior to beta testing, to make sure
that the system meets certain criteri a before it is given to customers for beta testing.

Maintenance
After the software is officially released to customers, the maintenance phase commences. During mainte­
nance, modifications are made to the software that arise through one of the following:
•

The repair of software defects that are discovered during normal customer use of the system

•

Customer requests for enhancements

•

A desire to improve attributes of the system such as performance or reliability

Modifications to the software are bundled together, and new versions of the software with these
modifications are released. Maintenance is discussed in detail i n Chapter 29.
Figure 3 .3 shows examples of arti facts produced duri ng each phase for our example video store application.

•

Inception

. . An application is needed to keep track of video rentals .
•

.

Planning (Software Project Management Plan)

. The project will take 12 months, require t o people and cost $2M
•

.

.

Requirements Analysis (Product: Software Requirements Spec . )

" . . . The clerk shall enter video title, renter name a n d date rented. The system shall .
•

.

Design (Software Design Document: Diagrams and text)

classes DVD, Videostore, . .
•

.

.

, related by .

Implementation (Source and object code)

. . . class DVD( Stri ng title; . .. l ...
•

Testing (Software Test Documentation : test cases and test resul ts)

. Ran test case: Rent "The Matrix" on Oct 3; rent "Sea Biscuit" on Oct 4; return 'The Matrix" on Oct 10 . .
Result: "seaBiscuit" due Oct 4, 2004 balance of $8. (correct) .
•

Maintenance (Modi fied requirements, design , code, and text)

Defect repair: "Application crashes when balance is $10 and attempt is made to rent "Gone With the
Wind"
Enhancement: "Al low searching by director."
Figure 3 . 3 The main phases applied to a video store application

SOFTWARE PROCESS MODELS

3.2 SOFTWARE PROCESS MODELS
Software process models define the order and frequency of phases in a project. The following sections
describe the most important process models, starting with the classical waterfall process.
3.2.1 The waterfall Process Model
One of the oldest software process models was defined by Royce [ 1 ] and is called the waterfall process. Despite
i ts many weaknesses (described later in the section), the waterfall process is still i n widespread use today and
is the basis for many other more effective processes.
Figure 1.6 i n Chapter 1 illustrates the phases of the waterfall process. Note that Royce's model begins
with the requirements phase-he di d not include i nception and planning phases. In practice, organizations
implementing a waterfall process would typically start with these phases. The waterfall executes i n a
sequen tial manner through each phase, concluding with maintenance . The output from one phase is used as
i n put for the next, implyi ng that a phase is not started until the previous one has completed. It is accepted i n
waterfall processes that there is a small overlap between adjacent phases. A s an example, some personnel will
be performing the last part of requirements analysis while others will have already started the design phase.
The waterfall process is characterized by documents generated by the time each phase is completed.
These i nclude requirements specification and design specification, for example. Also, there are usually
entrance and exit criteria between phases to ensure that a phase is completed successfully before moving o n .
I n practice, an i terative relationship between successive phases is usually inevitable . F o r example, after
the requirements are completed, unforeseen design di fficulties may arise. Some of these issues may result in
the modification or rem oval of conflicting or non-impl ementable requirements. This may happen several
times, resulting in looping between requirements and design. Another example of feedback is between
maintenance and testing. Defects are discovered by customers after the software is released. Based on the
nature of the problems, it may be determi ned there is inadequate test coverage in a particular area of the
software. Additional tests may be added to catch these types of defects i n future software releases . A general
gui del i ne, often accepted to still be with i n the waterfall framework, i s that feedback loops should be restricted
to adjacent phases . Thi s minimize potentially expensive rework if the feedback were to span multiple phases.
An modified model illustrating this iterative relationship is shown i n Figure 3 . 4.

time
-

Phases (activities)

Figure 3.4 The waterfal l software development process in practice: feedback is inevitable

37

38

CHAPTER 3

SOFTWARE PROCESS

A major limitation of the waterfall process is that the testing phase occurs at the end of the development
cycle-the first time the system is tested as a whole. Major issues such as timing, performance, storage, and so
on can be discovered only the n . Even with thorough up- front analysis, these kinds of factors are difficult to
predict until encountered duri ng testing. Solutions may require e i ther complex design changes or modi fica­
tions to the requirements that the design is based on, necessi tating i teration beyond adjacent phases.
Discovering and repairi ng these types of defects so late i n the development cycle can jeopardize the project
schedule .
Major advantages a n d disadvantages of the waterfall process are summarized below.

Advantages
•

•

•

•

•

Simple and easy to use: Phases are executed and completed serially, with specific entrance and exit criteria for
movi ng between phases. Orderly execution of phases is easy to comprehend.
Practiced for many years and people have much experience with it: The process is well understood, and many people
are com fortable with i ts execution.
Easy to manage due to the rigidity of the model: Each phase has specific del iverables and a review process.
Facilitates allocation of resources (due to sequential nature of phases) : D istinct phases faci l i tate allocation of
personnel with distinct skills.
Works well for smaller projects where requirements are very well understood: It isn't necessary to add complexity of
iteration i f requirements are well known up front.

Disadvantages
•

•

•

•

•

•

Requirements must be known up front: It's di fficult to imagi ne every detail in advance . Most projects start out with
some uncertainty, and more details are learned as the proj ect progresses.
Hard to estimate reliably: To gai n confidence i n an estimate, there may be the need to design and implement
parts, especially riskier ones. Estimates become more precise as the project progresses.
No feedhack of system by stakeholders until after testing phase: The process does not facilitate i n termediate versions.
Stakeholders often need reassurance of progress and confirmation that what is being developed meets
requirements.
Major problems with system aren't discovered until late in process: The testi ng phase is where these problems are
found, but it leaves very li ttle time for correction, resulting in potentially disastrous e ffects on project
schedule and cost.
Lack of para llelism: Each phase is executed to completi o n . Disj o i n ted parts of the system could otherwise be
completed in parallel.
Inefficient use of resources: Team members can be i dle while waiting for others to complete their dependent tasks
or for phases to complete. Also, someone good at requirements analysis is not necessarily good at
programming.

Because of factors l ike these, alternative (but related) processes are often employed, and these are
covered in subsequent sections.

SOFlWARE PROCESS MODELS

3.2.2 Iterative and Incremental Development
The waterfall process is characterized by a sequential execution through the phases . It is generally agreed that
the order of the phases dictated by the waterfall is fundamental : gather requirements, create a software design
to realize the requirements, implement the design, and test the implementation. The problem arises,
however, when this is scaled up to gather all the requirements, do all of the design, implement all of the code,
and test all of the system in a l inear fashion [ 2 ] . Except for the smallest of projects this is impractical . As the
system is developed and refined, more is learned and a need arises to revisit each of the phases. That is,
software is more naturally developed i n a cyclical manner, where a part of the system is developed and tested,
feedback is gathered, and based on the feedback more of the system is developed. This reRects the fact that
not everyth ing is understood at the start of a project. Iterative processes accept this cyclical nature and are
discussed in the rest of this section. Figure 3 . 1 is drawn in a way that reRects this.
An iterative process is typified by repeated execution of the waterfall phases, i n whole or i n part, resulti ng
i n a refinement of the requirements, design , and implementation. An iterative process i s incremental if each
iteration is rel atively smal l . At the conclusion of such an iteration, a piece of operational code is produced that
supports a subset of the final product functionality and features. Proj ect artifacts such as plans, speci fications,
and code evolve duri ng each phase and over the l i fe of the project. Arti facts are considered complete only
when the software is released .
A s defined b y Cockburn [ 31 i ncremental development is " a scheduli n g a n d stagi ng strategy that allows
pieces of the system to be developed at different times or rates and i ntegrated as they are completed." Thi s
implies that iterations n e e d n o t be executed serially, but c a n be developed i n p arallel b y separate teams of
peopl e . Successive increments implement an i ncreasing set of functionality and features until the fi nal
iteratio n , which produces the final product. Figure 3 . 5 illustrates this concept for a project with three
iterations. Note that the output of each testing phase is a working subset of the fi n al product that
i ncrementally contains more functionality.
An iteration other than an i ncremental one is sometimes defined as "a self-contained mini-project, with a
well-de fi ned outcome: a stable, i n tegrated and tested release" [2] . That is, each iteration is a self-contained
time
:

MIL EST 0 N ES:

Iteration # �

:

Product released X

First iteration completed X

1

3

I
I
.............. .......... ./. ....
I

Requirements

I

3

analysis

,
I
I
I
I
........................................... .............. ............ ........... ......... .............. ·········... ··········1 ·········· ············1 ··········.... ................

OJ

I

h:�:j

:

OJ:

I

'

I
I

I

I

I

Design

I

I

I

I

I

I

I
I

I
I
I
I
I
I
I
I
I
I
I
•••••••••••••••••••••••••••••••••.•••••.•.• ..••.•••••. ''I' ··········1 ··········'1' ········· ············., ··········'1' ··········1 ·········· ············, ············'1' ··········1····

Coding

I

CD:

I
I
........................................... ............... ........... .......... .1.
I

Testing

:

�

I

rr��:�J:

I
............ .. ....... .1.•••
I

I

1

��

:

�

I

I

·

co:

I

:

<��:::

��

S ftw r

S ftw r

Final

Subset

Subset

Version

�

Figure 3 . 5 The iterative software development process: an example with three iterations
Source: Cockb urn , Alis ta ir. "Un raveling Inc re men ta l Developmen t"
. Jan ua ry 1993, http ://a lis ta ir c
. ock burn .us /Un raveling +inc re men ta l +developmen t.

39

40

CHAPTER 3

SOFTWARE PROCESS

project with its own set of activities, plan, obj ectives, and measurable evaluation criteria. The "release" is a
working version of software that is either used internally by the project team or externally by stakeholders
and customers. Types of releases can be [2]:
•

•

•

•

A proof of concept, or feasibility study, that is used to demonstrate or investigate feasibility of a particular aspect
of the software . This includes prodUcing software or simulations. These are covered in Section 3.1.3.1.
A prototype that is a working version of software demonstrating a particular capability that is deemed high
risk. Prototypes are covered in Section 3.1.3.1.
An "internal" release that is only used by the development team and is used to ensure that development is on
track, elicit feedback, and provide a basis for further development and additional capabilities.
An "external" release that is shipped to customers for evaluation .

Treating each iteration a s a self-contained project allows clear a n d manageable objectives to b e set, and
reduces overall project complexity by breaking it down into smaller pieces. By producing working software at
the end of each iteration , project progress can more easily be monitored and planned, and feedback can be
elicited to ensure that its capabilities are meeting stakeholder requirements. Typically, early iterations
generate software releases that address aspects of the project with the highest risk. I n this way, as the project
progresses the overall project risk l evel is reduced.
An example of an iterative and incremental process that is used within parts of Microsoft is reported by
Cusumano and Selby [4J, to which they give the name "synch-and-stabilize ." Product features are defined at a
high level during the initial phase of a proj ect, with the idea that many will evolve as product development
proceeds . The product is divided into parts, each consisting of a set of features, with small teams assigned to
each part. The project is also divided into parts, or iterations, each with its own completion milestone. Each
iteration includes several features. Feature teams employ incremental synchronization by combining their
work and stabilizing the resulting system on a daily or weekly basis. In this way the evolving software
application is continually kept in a "working" state .
3.2.3 Prototyping, Feasibility Studies, and Proofs of Concept
Prototypes and feasibility studies are important techniques in software development, and are explicitly
included as formal steps, or phases, in several process models. We discuss them now in more detail .
3.2.3.1 Prototyping
On beginning a software project, we are usually faced with factors that we do not yet fully understand. The
look and feel of graphical user interfaces (GUIs) that will satisfy the customer is one common example.
Timing is another. For example, suppose that we plan to build a Java application to control an airplane. A
critical issue to pin down very early would be: Will the Java Virtual Machine be fast enough? Each unknown
factor or risk is best confronted as soon as possible so that its severity can be assessed and a plan developed to
deal with it. Risk management is dealt with in detail in Chapter 8. Proto typing is an important risk management
tech nique . It is a partial implementation of the target application useful in identifying and retiring risky parts
of a project. Prototyping can also be a way to obtain ideas about the customer's requirements. An increase in
one's understanding of what is to come can save expensive rework and remove future roadbl ocks before they
occur. Agile processes contain some of the benefits of prototyping because they deal at all times with working
code . However, they do not have all of the benefits, since prototypes proceed in parallel with the main thread
of the project, whether agile or not.

SOFTWARE PROCESS MODELS

..
..
..

................
.....
...
...

Prototype implements
risky parts of this
activity first

Project
beginning

time

Main project timeline

Key: G end of a unit of time
=

E::J

=

Activity with risk

Figure 3.6 An il l ustration of prototyping in the context of a developmen t project

As Figure 3.6 shows, work on a prototype typically progresses in parallel with regular work on the
project. The risks are prioritized and the prototype is geared toward as many of the most important ones as
time allows . [n the example shown in Figure 3.6, the prototype ignores the large risk near the beginning of the
project because it will be dealt with early in the ordinary course of the project in any case .
Large programs, such as billion dollar defense proj ects, uti l ize extensive prototyping to retire risks and
to guide the requirements and design of the real thing. For example, before the U . S . Navy built the Aegis
generatio n of shipboard systems, it built an entire scaled-back version, complete with software and hardware,
i n stalled on a ship for the purpose. This prototype served to i n dicate to the Navy what the main problems
might be with the eventual systems. [t also helped the Navy to develop the requirements and design of the
eventual system .
Simple graphics showing GU[s using paint-type tools may be sufficient i f the prototype's goal is to
envision the interfaces. The more extensive the prototype, the more risks can be reti red with it and the more
easily a customer's requirements can be understood. On the other hand, prototypes are themselves software
applications, so extensive prototypes are expensive . A rough assessment as to whether or not to build a
prototype is shown in Figure 3.7. The table in the figure illustrates, for example, that a rel atively i nexpensive
prototype with high value should probably be built. "High value" means that building the prototype helps the

! Calculate payoff
j in detail

Perceived value
of prototype
low

high

Low prototype cost

maybe

yes

Hig h prototype cost

no

maybe

Calculate payoff
in detail

Figure 3.7 A rough calcul ation of whether developing a prototype would be worth it

41

42

CHAPTER 3

SOFTWARE PROCESS

t

Payoff from building
prototype ($'s saved
per $1 spent)

optimal
expenditure
on
prototype

full
project
expenditure

% expenditure
on prototype

100%

waste of resources

Figure 3.8 Concept of when it is worthwhi le to build a prototype (near the begi nni ng)

customer understand better what kind of product is likely to emerge, helps the engineers understand better
what kind of product should emerge, and/or retires a development risk.
Many cases fall into the "maybe" category of the table in Figure 3 . 7, and more detailed analysis is
required to assess the value of prototyping. We are seeking an optimal level of effort to be spent on a
prototype, as suggested by Figure 3.8 . As the expenditure on a prototype increases, its useful ness increases,
but so does its drain on the project's budget. As a result, there is a point at which the payoff is optimal (the
maximum point for the curve ) , and some point beyond which fun ds are actually being squandered (where the
curve drops below the horizontal axis) .
As an example, consider an e-commerce application in which a clothing company wants to sell goods
online, retain customer profiles, and allow customers to obtai n pictures of themselves weari ng clothing from
the catalog. A typical calculation about prototypes factors the cost of prototyping features and the potential
for using prototype code i n the final product. Figure 3 . 9 gives financial estimates for prototyping four parts of
the clothing vendor application:
I. CUI screenshots

2. Transaction security
3 . Complete transaction

4. Customer tries on clothing
For each of the four application features considered for the prototype, several esti mates can made:
the cost of building the feature, the perce ntage of the feature's im plementation that will be reused in the
application itself ( i . e . , not discarded) , and the "gross benefit" from the e ffort. The gross benefit here
estimates the gai n from prototyping the feature, excludi ng reuse of the code and excludi ng all expe nses .
For example, as shown in Figure 3.9, we have estimated that i f the "Customer tries on cloth i n g" feature
were to be prototyped, it would save a minimum $20,000 in development costs . Th is estimate is based on
factors such as the fol lowi ng:

SOFlWARE PROCESS M ODELS

Cross Benefit

Percentage

excluding code
reuse

Estimated
cost

I. CUI
screenshots
2. Transaction security
3. Complete
transaction
4. Customer
tries on
clothing

Net Payoff

code reused

min

max

in application

min

max

B

D

f

C

D-C f-C)B

f-C f-C)B

$10,000
$50,000
$80,000
$120,000

$10,000
$10,000
$10,000
$20,000

$80,000
$300,000
$400,000
$140,000

50%
80%
50%
30%

$5,000
$0
-$30,000
-$64,000

Prototype
feature

of prototype

---

..

.,.

--_._---

;

--

--

_. -

.-

:
,

-

...... ....

average
I

!

$75,900 $40,000
!
$290,000 . $145,000
$200,000 I $85,000
$56,000 1-$4,000
... , ...... - .._..

---

---_._ ............ -

I

i

-. .--...-- ---------.------ .--.

t--.---I
!

:

Figure 3.9 Payoff ca l culation exa m p l e for build i ng a prototype for a clothing appl ication

•

Preventing time wasted on proposed requirements that the prototype shows are not really needed (e.g. ,
minimum of three unneeded requirements out of 1 00; $300,000 budgeted for the requirements phase
$9000 saved)

=

•

Implementing a so ftware design for the "trying on clothes" feature, thereby retiring some development risks
(e.g. , estimate that this will save a minimum of one person-week of design time
$2000)
=

•

Rework that would have resulted from the customer changing requirements only after seeing the developed
product (e.g., rework min imum of three requirements at $3000 each
$9000)
=

The minimum savings therefore is $9000 + $2000 + $9000
$20,000. Estimating the cost of bUilding
the prototype can use approximation techniques like those described i n Chapter 8 . An estimation of code
reuse can be performed by identifying the classes of the prototype and determining which are likely to be
usable in the actual application .
This type of estimation often consists o f adding u p the estimation o f smaller parts, which i s often more
feasible. Bracketing each estimate between a minimum and a maximum can help to make this process a little
easier for the estimator.
Once these estimates are made, the best- and worst-case scenarios for each feature can be computed.
This is shown in Figure 3 . 9. The minimum payoff value is obtained by taking the most pessimistic
combination: the highest costs, the lowest gross benefits , and the lowest reuse percentages . The maximum
payoff is calculated correspondingly. For exam ple, the maximum payoff (the most optimistic alternative) for
the "CUI screenshot" prototype feature is as follows:
=

[maximum estimated benefit] - [ minimum estimated costs]
$80,000 - [ (mini mum estimated cost) x (percent not reusable)]
$80,000 - [$10,000 x 50%]
$75,000

=

=

=

43

44

CHAPTER 3

SOFTWARE PROCESS

Averagi ng is one way to deal with the spread between best and worst cases. The result suggests a
positive payoff for all proposed prototype features except for the "trying on clothes" feature , which proj ects
-$4000: an overall waste of $4000. The latter negative result is due to relatively low payo ff, high
development cost, and low reuse .
It may be advisable for the prototype to evolve into the application itself, but this should be planned for,
not accidental . By their nature, prototypes are rapidly constructed and rarely documented. They can be
implemented using languages that get results quickly but may be unsuitable for the application itself.
3.2.3.2 Feasibility Studies
It is sometimes uncertain whether proposed requirements can actually be implemented in practice . I n other
words, an entire project is at risk rather than a few specific requirements. I n addition, the project would not be
feasible if the risk were to be realized. In such cases, feasibility studies may be advisabl e . These are partial
implementations or simulations of the application . For example, consider the feasibility of a Java lnternet­
based Encounter video game, and let's say we suspect performance will be so slow that the game would be of
negl igible interest to anyone. A feasibi l i ty study could consist of setti ng up a message- passing simulation at
the anticipated rate from a number of players, but with dummy content. Delays could then be estimated by
clocki ng the simulation.
Si mulations can be expensive to create since they are applications i n themselves, sometimes requiring
software engineeri ng arti facts of their own such as a requirements specification! The author was once i nvolved
with a simulation of a large system under development. The simulation grew i nto a large program, which was
needed while engineers developed the real system . No one took the requirements for the simulation seriously
because it was not "the real thing." As a result, even though the development community relied on the
simulation, the cost of maintaining and using it became astronomical . Maki ng changes required tracki ng
down an employee who "knew the system." Feasibility simulations are common in large defense programs that
involve extensive software and hardware.

3.2.4 Spiral Model
One of the earliest and best known iterative processes is Barry Boehm's Spiral Model [5]. It is called a spiral
because Boehm conceptual ized development iterating as an outward spiral , as shown i n Figure 3 . 1 0.
Boehm's spiral model is a risk-driven process i n which iterations have the spec i fied goals shown in
Figure 3 . 1 0. (Recall that risks are potential events or situations that can adversely affect the success of a project. )
A project starts at the center, as it were , and each cycle of the spiral represents one iteration. The goal of each
cycle is to increase the degree of system definition and implementation, while decreasing the degree of risk. Risk
management is built i nto the process in that very early in each iteration, project risks are identified and analyzed
and a plan for the iteration is created that i ncludes mitigating some or all of the risks. As an example, suppose that
at the beginning of a cycle a risk is i dentified with the screen l ayout of a portion of the user i nterface . Software
could be developed to implement part of the user interface so feedback can be elicited from stakeholders. Doing
this mitigates risk early i n a proj ect and leaves ample time to implement necessary changes. Thus the overall
project risk reduces the further along you are in the process. After the major risks are addressed and mitigated,
the project transitions to a waterfall model, as shown in the outer spiral of Figure 3 . to.
Each iteration in Boehm's spiral model consists of the following steps:
1 . Identification of critical obj ectives and constraints of the product.
2. Evaluation of project and process alternatives for achieving the objectives.

SOFTWARE P ROCESS MODELS

COST
DElERMINE
OBJECTIVES,
ALTERNATIVES,
CONSTRAINTS

PROGRESS
THROUGH
STEPS

EVALUATE
ALTERNA llVES
IDENTIFY,
RESOLVE RISKS

COMMITMENT
PARTITIO

Ii

··E

Figure 3 . 1 0 Boehm's spiral model for softwa re development
Source: Boehm, B. W., "A Spi ra l Model of Softwa re Development and Enhancement." Comp uter, vol . 2 1 , No. 5, May 1 988, pp . 61 -72.

3 . I dentification of risks.
4. Cost-effective resolution of a subset of risks using analysis, emulation, benchmarks, models, and
prototypes.
5. Development of project del iverables including requirements, design , implementation, and testing.
6. Planning for next and future cycles-the overall project plan is updated, including schedule, cost, and
number of remaining iterations.
7. Stakeholder review of iteration del iverables and their commitment to proceed based on their obj ectives
bei ng met.
Each traversal of the spiral resul ts in incremental del iverables. Early i terations produce either models,
emulations, benchmarks, or prototypes, and later iterations follow a more waterfall - l ike process and
i ncrementally produce more complete versions of the software. Th is impl ies that early iterations may
exclude step 5, and later iterations may exclude step 4. Although Figure 3 . 1 0 shows four iterations, the process
does not prescribe a set number of cycles. The number is dictated by the size of a project, the number of risks
identi fied, and their rate of retirement.

45

46

CHAPTER 3

SOFTWARE PROCESS

Al though Boehm's origi nal conception was risk- driven, the Spiral Model can also be driven by a
sequence of functional ity sets . For example, i teration I for an online video-on - demand appl ication could be to
implement the database of videos and i ts API; iteration 2 could be to implement the eUls, and so on.
Key advantages and disadvantages of the spiral model are listed next.
Advantages of the spiral model
o

o

o

Risks are mana ged early and throughout the process : Risks are reduced before they become problematic, as they are
considered at all stages. As a result, stakeholders can better understand and react to risks.
Softwa re evolves as the project progresses: It is a realistic approach to the development of large - scale software .
Errors and unattractive al ternatives are eliminated early.
Planning is built into the process: Each cycle i ncludes a planning step to help moni tor and keep a project on track.

Disadvantages of the spiral model
o

o

Complicated to use: Risk analysis requires highly speci fic expertise. There is inevitably some overlap between
i terations.
May be overkill for small projects: The compl ication may not be necessary for smaller proj ects . It does not make
sense if the cost of risk analysis is a major part of the overall project cost.

Boehm's spiral model has been very influen tial in givi ng rise to many styles of i terative development
models, i ncluding, we bel i eve, the uni fied process, discussed next.

3.2.5 Unified Process and the Rational Unified Process
The Uni fied Software Development Process (US D P ) was fi rst described by Jacobson , Booch, and
Rumbaugh in 1 999 [6 J and i s an outgrowth of earl ier methodologies developed by these three
authors-namely, Jacobson's "Objectory methodology," the "Booch methodology" [ 7 ] , and Rumbaugh
et al .'s Obj ect Modeling Tech n ique [ 8 ] . The USDP is generically referred to as the Unified Process (UP).
I BM's Rational Software division has developed a detailed refinement to the UP called the Ra tional Unified
Process (RUP ) , which is a commercial product providing a set of process guideli nes and tools to help
automate the process.
The UP is a "use -case driven, archi tecture-centric, i terative and incremental" software process [6].
Iterations are grouped i nto four "phases," shown on the horizontal axis of Figure 3 . 1 1 : Inception, Elabora tion,
Construction, and Transition . The UP's use of the term "phase" i s different from the common use of the term .
I n fact, referri ng to the figure, the term "discipli ne" is the same as the common use of "phase" that we use in
thi s book.
Each UP "phase" consists of one or more i terations, shown across the bottom of Figure 3. t t.
Iterations are relatively short ( e . g . , three weeks) , the outcome of which is a tested, i ntegrated, and
executable partial system. I terations are built on the work of previous i terations, and thus the final product
is constructed i ncremen tally. Each i teration cycles through a set of n i n e disciplines, which are shown on
the vertical axis of Figure 3.1 I: business modeli ng, requirements, design, implementation and test
activities, plus supporting activities such as con figuration management, project management, and environ­
ment [ 9 ] . For example, duri ng an i teration some requi rements may be chosen, the design enhanced to
support those requirements , and the requiremen ts i mplemented and tested. The horizontal "humps" next
to each discipl i n e show the relative effort expended on each discipl i n e duri ng i terations. For example, the

SOFTWARE P ROCESS MODELS

Disciplines

Elaboration

Phases

Construction

Transition

Business Modeling

I

Requirements
Analysis & Design
Implementation
Test

:

Deployment
Configuration
& Change Mgmt
Project Management

-

•

�

:-------�--�
o

-

. -----..------ooooOiI-----I
Environment 1----....IJ
Initial

1L-"-=---'--"'c.:....J

I II I
Tran
#1

Tran
#2

Figure 3 . 1 1 The unified softwa re development process: its "phases" vs. traditional phases
Source: Adapted from Ambler , S. W., "A Manager s
' Introduction to the Rationa l Unified process (R UP)." Ambyso ti (December 4, 2(05)., http ://www.ambysoft.com /

down loads /m anagers nl tro ToR UP.pd f.

l argest requirements effort is expended during I nception and Elaboration, and the l argest impleme ntation
e ffort duri ng Construction .
The following are descri ptions of the work conducted during each of the UP "phases":
Inception
•

Establish feasibility

•

Make business case

•

Establish product vision and scope

•

Estimate cost and schedule , includi ng major milestones

•

Assess critical risks

•

Build one or more prototypes

Elaboration
•

Specify requirements in greater detail

•

Create arch itectural baseline

•

Perform iterative implementati on of core archi tecture

•

Refine risk assessment and resolve highest risk items

•

Define metrics

•

Refine project plan , includi ng detailed plan for begi nning Construction iterations

47

48

CHAPTER 3

SOFTWARE PROCESS

Construction
•

Complete remaining requirements

•

Do iterative implementation of remai ning design

•

Thoroughly test and prepare system for deployment

Transition
•

Conduct beta tests

•

Correct defects

•

Create user manuals

•

Deliver the system for production

•

Train end users, customers and support

•

Conduct lessons learned

Each U P phase concludes with a well - defined milestone, where key decisions are m ade and specific
goals defined. Figure 3 . 1 2 shows these milestones and where they are ful filled i n the process .
The typical amount of time spent in each U P phase is shown in Figure 3 . 1 3 [ 1 0 ] , However, th is varies
depending on the type of project. For example, projects that contain only m inor enhancements with known
requirements may spend more time in the Construction phase , wh ile projects for which very little i s known
about requirements may spend more time in the Inception and Elaboration UP phases.
The advantages and disadvantages of the unified rocess are summarized below.
Advantages o f the unified process
•

•

Most aspects of a project are accoun ted for: The U P is very i nclusive , coveri ng most work related to a software
development project such as establishing a busi ness case .
The UP is mature: The process has existed for several years and has been quite widely used.

l

Inception

Lifecycle Objectives
( LCO)

Elaboration

•

Scope concurrence

Lifecycle
Arch itecture
(LCA)

•

I n itial req u i rements

•

definition

1-

Req u i rements

·1

Construction

j

Initial Operational
Capabil ity (IOC)
•
•

stability

System sta b i l ity

:I

TranSition

I

Product
Release
(PR)

R e q u i rements

•

B u s i ness acceptance

sta b i l i ty

•

Operations

•

Plan concurrence

•

Arch itect u re sta b i l ity

•

Prepared stakeholders

•

Risk acceptance

•

Risk acceptance

•

Risk acceptance

•

S u pport acceptance

•

P rocess acceptance

•

Cost acceptance

•

Cost acceptance

•

Cost and estimate

•

Business case

•

Realistic chance to

•

P roject plan

•

P roject plan

acceptance

acceptance

succeed
•

P roject plan

Figure 3 . 1 2 Obj ectives for the U nified process
Source: Adapted f ro m Am ble r, S. W, "A Manage r's Int ro duction to the Rational Unified P rocess (R UP)." Am bysofl (Decem be r4, 2005)., http: //www.am bysoft. com /

down 10ads /m anage rs int ro ToR UP. pdf.

SOFTWARE PROCESS MODELS

UP Phases - Typical Time Distribution

I nception
1 0%

Elaboration
25%

Construction
55%
Figure 3 . 1 3 Typi cal ti me distribution of the rational unified process's "phases"
Source: Adap ted from Ambler, S. W., "A Manager's In trod uc tion to the Ra tional Unified Process (RUP)." Ambysoft (December 4, 2005)., htt p: //www.ambysof t.com /

downloads/managersln tro ToRUP.pdf.

Disadvantages of the unified process
•

•

The UP was originally conceived of for large projects : This is fine, except that many modern approaches perform
work in small self-contained phases .
The process may be overkill for small projects : The level of complication may not be necessary for smaller proj ects .

Practitioners and vendors of the unified process have modi fied it to be more l ike an agile process,
discussed next.
3.2.6 Agile Processes
This sectio n i ntroduces agile processes. Chapter 4 is devoted entirely to agile methods, and agility is
re ferenced and compared throughout this book.
In 200 I , a group of industry experts, disillusioned with some commonly held software engineeri ng
beliefs and practices, met to discuss ways to improve software development. Their goal was to produce a set of
values and pri nciples to help speed up development and effectively respond to change. The group called
themselves the Agile Alliance, i n essence to capture their goal or producing a methodology that was efficient
and adaptable . The result of their work was the Manifesto for Agile Software Development [ 1 1 J . also known as the
Agile Manifesto , which contains the values and pri nciples they defined. An agile software process is one that
embraces and conforms to the Agile Mani festo , which is summarized in Figure 3 . 1 4 .
Agile processes are highly iterative and incrementa l . They commonly employ the followi ng:
•

Smal l , close-knit teams

•

Regular, frequent, discipli ned customer requirements meeti ngs

•

A code-centric approach, documentation on an as- needed basis ( e . g . , high-level requirements statements
only)

49

50

CHAPTER 3

SOFTWARE PROCESS

Agi le processes value . . .
•

.

. .

individuals and interactions

over processes and tools
. .

working software

over comprehensive documentation
•

.

.

customer collaboration

over contract negotiation
. .

responding to change

over following a plan
Figure 3.14 M ain points of the Agile Manifesto

•

•

Customer representatives working within the team
The use of user stories as the basis for requirements-end-to-end accounts of how users need to accomplish
individual tasks

•

Refactoring, a kind of disciplined code improvement explained full in Chapter 2 4

•

P a i r programmi ng, in which two programmers work at a single workstation

•

Conti nual unit-testing, and acceptance tests as means of setting customer expectations

Figure 3 . 1 5 shows how the repeated i terations of an agile process are executed over time. "Story" is a task
required of the application as the customer conceives it.

Demonstrate
fulfi l l ment

Accumu lati ng

of previous
stories
Identify stories for this iteration
•

I nteract with customer

•

Cement mutual understanding

' �--------�------���------�
I mplement stories
•

Work i ncrementally

•

Develop test bank i n paral lel
Typical
" '� iterati0'l / '

Time; composed o f equal iteration i ntervals-7

Figure 3 . 1 5 The agi le process

SOFTWARE PROCESS MODELS

Key advantages and disadvantages of agile processes are summarized below.
Advantages of an agile process
•

•

•

The project always has demonstrable results : The end product of each iteration is worki ng software.
Developers tend to be more motivated: Developers prefer to produce working artifacts and tend not to l ike creating
documentatio n .
Customers are able t o provide better requirements because they can see the evolving product.

Disadvantages of an agile process
•

•

Problematical for large application : Agil e methods are more readily used for smaller projects . There is debate
about their utility for large projects .
Documentation output is questionable: Since documentation takes second place, there is a question as to whether
necessary documentation will ever be produced.

3.2.7 Open-Source Processes
Open-source software is developed and maintained by people on a volunteer basis . All project artifacts, from
requirements documents through source code, are available to anyone. There are several open- source
software development Web sites on the Internet that aggregate and reference open source projects, includi ng
SourceForge. net and Freshmeat.net. As of 2009, SourceForge .net hosted more than 1 00,000 projects and had
over 1 ,000,000 registered users . Hosting sites provide source code repositories and util i ties for project
management, issues discussion, and source control . The case studies in thi s book i llustrate two well known
open source projects: Eclipse and OpenOffice.
Open- source proj ects typically get started when someone develops an appl ication and posts it to a host
Web site. Virtually anyone can propose new requirements, and since the source code is freely available,
anyone can implement requirements that are not part of the official baseli n e . There is a process by which
proposals and implementations are elevated i n priority and a process for accepting new code and capability
i nto the baseline. If defects are found, they are reported and others may work on fixing the m . This process is
repeated, and the application grows i n capability and stability. I n this way, open -source projects are
developed in an iterative manner. In addition, by exercising an appl ication many times, the open- source
community affects a huge testing process.
Some reasons why an indivi dual or company makes a project open source are l i sted i n Figures 3 . 1 6 and
3 . 1 7, and reasons why they may not are l i sted i n Figure 3 . 1 8 . A primary reason to make a project open source
is to leverage a l arge number of resources that might not otherwise be available. A principal reason to not
make software open source is to keep artifacts hidden from current and prospective competitors . Some (e.g. ,
Ferguson [ 1 2 ] and Kapor) believe that open source may become the dominant process for producing
software.
An i nteresti ng article written by Alan Joch illustrates how the bank Dresdner Kleinwort Wasserstein
(DrKW) turned its internally developed back-end Java integration tool, OpenAdapter, i nto open source and
how it benefited from the decision. The followi ng is an excerpt from that article.
Samolades et al . [ 1 3 ] studied open-source development and compared it with closed-source
software . Using common metrics, OSS code qual ity was found roughly equal to that of CSS, and found
to be superior for maintai nability , or at worst equa l . Some o f their results are shown i n Figures 3. t 9
and 3 . 2 0 .

51

52

CHAPTER 3

SOFTWARE PROCESS

Open-sou rce users find rewards in collaborative development
By Alan Joch

2/ 1 /2005 http://www . adtmag.com/article . aspx?i d = 105 4 4
Banks pride themselves on playing things close to the vest. So, when Dresdner Klei nwort Wasserstei n's IT
group shared the code of OpenAdapter, an internally developed tool, with the development community,
it caused a sensation . "It was astonishing," recalls Steve Howe, DrKW's global head of open-source
initiatives. 'They found it difficult to bel ieve a bank was open sourcing something."
OpenAdapter, a back-end Java integration tool that helps integrate bank apps with little or no
custom progra m m i ng, had become "a famous piece of software with i n DrKW," Howe says. "Half of the
dec ision to open source it into the wider financial com munity was to try to replicate that enthusiasm ."
DrKW's motive for releasi n g the tool was hardly altruistic. By releasing the tool to the wider
financial com munity, the i nvestment bank hoped to benefit from the bug fixes and re finements other
programmers i n Europe and North America might make .
However, H owe and other ope n - source experts warn that corporations' code -shari ng projects
require a number of safeguards to protect intellectual property and keep companies from becom ing
unwitti ng victims or distributors of destructive code. Some companies believe such risks outweigh the
potential benefits and resist ope n - source business applications. DrKW and other firms bel ieve careful
ope n - source collaborati on gives them a com peti tive advantage .

Banking on open source

Dresdner Klei nwort Wasserstein (DrKW) bel ieves it fou nd development success with OpenAdapter by
creating a variation on the collaborative model the ope n -source community pioneered. .
. "We
open sourced the tool with i n DrKW and told people that if they needed to change OpenAdapter
sl ightly, they were free to do that," Howe says . "A lot of developers decided they could make a name for
themselves by contributing to the software ." Today, more than 100 applications in the bank use the
integration too l .
T o t a p s i m i l a r expertise outside DrKW, t h e bank turned t o CollabNet, a commercial project­
development platform from CollabNet i n Brisbane, Cal i forn i a . CollabNet provides a number of
services, including version con trol tools and discussion forums common in free ope n - source cleari ng­
houses such as SourceForge . . . CollabNet helped the bank establ ish a separate legal entity called the
Software Conservancy, which owns the intellectual rights to OpenAdapter.
The site publ ishes the latest stable bui ld of the software, which anyone can download. Users can
also send i n com plaints and error reports and suggest bug fixes. So far, DrKW has received input from
developers at competi ng banks and from companies outside the financial i ndustry. Collaboration
consists of techn ical subjects, not i n formation that i nvolves trade secrets or confidential customer data .
Developers interested in becoming more involved in OpenAdapter's evolution can gain access to
the source code by sign ing a legal agreement that assigns the intellectual property rights of their code
to the Software Conservancy. About 20 developers now hold such status.

Companies mix and match ope n - source and proprietary processes according to business needs.
Figure 3.21 suggests that the proporti on of open- source or proprietary software used is a busi ness deCision,
taken i n the context of expenses and revenues over time. An i m portant factor is the expense of tailoring and
maintain i ng open source.

SOFTWARE P ROCESS M ODELS

©

Leveraging large number of resources

©

Professional satisfaction

© To enable tailoring and integration
©

Academic and research

© To gain extensive testing
©

To maintain more stably

Figure 3 . 1 6 Some reasons for making a project open source, 1 of 2

©

To damage the prospects of a competitor's product

©

To gain market knowledge

©

To support a core business

© To support services
Figure 3 . 1 7 Some reasons for making a project open sou rce, 2 of 2

®

Documentation i nconsistent or poor

®

No guarantee that developers will appear

®

No management control

®

No control over requirements

®

Visibility to competitors

Figure 3 . 1 8 Some reasons against making a project open sou rce

Project
Mnemonic
Code
OSS PrA

I

I

Total Code

No, of

Application

S i ze

re leases

Type

( K LOCs)

measured

343

13

Opera t i n g

Opera t i n g system

Path
OSS project that gave
while still evolvi ng as OSS

\

appl ication

Project
Evolution

b i rth to a CSS project

system application

CSSPrA

I
I

994

13

CSS project i n i ti a ted from
an OSS project and
evolved as a commercial
coun terpart of OSSPrA

Figure 3 . 1 9 Maintainabil ity i ndex comparing ass and CSS for the same appl ication, 1 of 2
Source: Samoladas, loannis, I.Stamelos, l. Angelis, and A. Oikonomou. "Open source software development should strive for even greater code maintainability."

Communications of the ACM, Yol . 47, No. 1 0, October 2004, copyright © 2004. Association for computing Machinery, Inc. Reprinted by permission .

53

54

CHAPTER 3

SOFTWARE P ROCESS

OSS PrA va. CSS PrA
80
70

-'"
-

60
50

MI

�
'J..... ......

-

40
30

1 --- OSS PrA

20

1

10

o
2

3

4

5

6

7

8

9

___

CSS PrA

10

11

12

t

13

successive versions

Figure 3.20 Maintainability index comparing OSS and CSS for the same application, 2 of 2
SOUrce: samoiadas, loannls. I. Stamelos. L. Angelis. and A. Olkonomou . "Open source software development should strive for even greater code ma inta inability. "

communications of the ACM, vol. 47. No. 10. October 2004. copyright @ 2004 . Association (or COmputing Machinery. Inc. Reprinted by permission.

Various tools a n d e nv i ro n m e n ts are ava i lable to fac i l i tate ope n - source deve l opmen t . F i gure 3 . 2 2 shows a

s ch emat i c diagram of one such too l , Col l abn e t . "Su bvers i o n" i s an op e n - s o u r c e vers i o n con trol system used

for m a ny ope n - source projects.
Key advan ta ges and disadvantages of o pe n - ource processes are summarized below.
Adva n tages of open S O U Tce
•

The work oj many may be obtaitled Jm : Fo r proj ects t h a t m o t ivate others, work can be obta i ned fro m motivated

outsiders.
•

•

Developers tend to be mort lIfotivated, because they choose to work o n i t .
Open-soll ree app/iea tiolls are very well tested, because they a re conti nua l l y exerc i sed b y m a n y a n d usua l l y h ave
e ffi ci en t testing processes .

Release

.

S ales, service,

/"

productivity, . . .

Cumulative
revenue

��:=�====::::��====�nme
Cumulative
Open � ource
expense �
:
development : maintenance

�..,..I

��
00::=------

proP i

Figure 3.2 1

Hybrid open-sou rce/pro p r i etary processes

CASE STUDY: STUDENT TEAM G U I DANCE

Col i a b N et Tea m Fo rg e : Stru ctu re & Featu res
My Workspace

Com m u n ity & Projects

"1I!Il"" User and Project
Admin

..l1li.... . Task hierarchy,

Alert mechanism

-

BrowseSCM, tracker

• SCM Integration

l1li'''1...11 Bugs. Arti' acts
Requirements

Integrated Hudson

......111 User's personal

JlllIIII.... ()n.(Iemand servers In

workspace

public or private clouds

111.11.. . Co l lect. al'thlve at

Pe,-project:
task, tracker 1St
resource status

release packages

Ust existing, and
create new, projects

Manage monitored
artifact. and tools
by project

Rea"Ume reports
& Status

Devolopers

Non-Delle/ope,s

Personallzatlon
lettlngs

CotllbHetDHktop:
Ec..... EdItion

Discussion f o rums

..... -

vt.�1 Stuclo EdIOon

ProJect.oased WlkI

Indexed objects

300 + FUe types

" .•

,', ( O l l d iJ f1t't

(OLLABNET

Figure 3.22 CoilabNet Team Forge: Structure and Featu res
Source: CoiiabNet, http://www.open.coiiab. net/products/sfee/capabiiities.htmi.

Disadvantages of open source
•

They are available to one and all: This is part of the barga i n .

•

Documentation is questionable: Developers are n o t consistent in what they produce

•

Design documentation tends to be poor: It seems that the ope n -source process has especially great trouble keeping
designs and code synchronized, and so design documents are often poor or even nonexistent.
To reinforce the concepts on processes described i n this chapter, we continue with case studies.

3.3 CASE STUDY: STUDENT TEAM G UIDANCE
To reinforce the many software engineering concepts and practices i ntroduced in this book, it's best i f you are
developing a software project in parallel . You will gain the most if the proj ect is a team effort, as this is how
most real-world software projects are executed. At the end of most major parts of the book, a section ( such as
this one) entitled Team Guidance can be found, guiding you through the different phases of your group project.

55

56

CHAPTER 3

SOFTWARE PROCESS

You will be asked to generate specific artifacts, and examples will be provi ded showing how real and
hypothetical teams go about developing applications. We will often use the Encounter video game case study
as an example to illustrate team guidance.
Many stude nts look back on their team process as a significant learn i ng adventure . I f th e team
avoi ds a few common pi tfal ls, the adventure can be a most e n l i ghtening and useful experience. From
our past experience, the best size for student groups is four or five . Any less and the workload for each
studen t is too great. More than five doesn't afford all team members the opportunity to con tribute i n a
meaningful way .
Tips distributed throughout the text are designed to help groups maxi mize the benefit of group work. I n
addition, exercises a t the e n d of the chapter assign specific arti facts t o b e developed a s t h e project progresses
through the software l i fe cycle.
The following sections provi de gui dance for holding an initial team meeting, developing a team
communication plan, and exercising the communication plan .

3.3. 1 Team G uidance-Initial Team Meeting
To start off the project, the team shoul d have an i nitial meeting and make the decisions shown in Figure 3 . 2 3 .

Agenda
All meeti ngs should have a written agenda and specific start and end times.

Team Leader
Decide who your first team leader will be (being a team leader provides you with valuable experi ence but puts
addi tional demands on your time and communication skills ) . To distribute the benefit of team leadership
practice, it can be beneficial to swap team leadership about hal fway through the project. Both team leaders
can be chosen up front, and they can back each other up in case of emergency.

1.

Set agenda and time limits .

2 . Choose t h e team leader.
3 . Get everyone's commitment to required time.
o

Define an expected average number of hours per week.

o

Gather dates of planned absences .

4. Take a realistic census of team skills.
o

Common problem: inAated programming ski ll claims.

5 . Begin forming a vision of the application .
6. Decide h o w team w i l l communicate.
7. Take meeting minutes with concrete action item s .
Figure 3 . 2 3 I n itial student team meeting-general issues

CASE STUDY: STU DENT TEAM G U I DANCE

Time Commitment
A big source of frustration i n student teams is a lack of commitment of some team members . I t is far better to
discuss commitments at the beginning than to try to fix a problem after the project is under way. To reduce
the resentment that follows when some team members feel they are contributing much more than others, set
i n advance an expected number of hours of commitment per week. This also helps to make members work
more efficiently.

Team Skills
For student projects there is often a trade-off between producing an impressive-looking product and learning
new skills. To produce the most i mpressive product, team members would specialize along the lines of their
greatest strengths . This i s a typical industrial mode . They may also be tempted to skim p on documentation i n
order t o demonstrate more features. T o learn the most, however, team members need t o try activities with
which they are i nexperienced (e.g., team leadership) . They also need to do things right. Teams decide how
and when to trade off between goals by specifyi ng when they will specialize and when they will try new roles.
Instructors try to establish evaluation criteria that encourage learn ing.

Vision
All proj ects start out with a vision for the software to be developed. I n industry this is typically i n itiated by the
marketing department, which develops business requirements for the product. For student projects, the
product vision includes the purpose of the applicatio n , major functional ity and operations, and major i nputs
and outputs .

Communication Plan
Decisions need to be made as early as possible as to how the team will handle communication . The next
section covers this i n detail .

Meeting Minutes
Duri ng team meetings , a member is designated to write the meeting minutes. The purpose of meeting m i nutes
is twofold. First, all i mportant decisions or agreements that are reached are recorded, so they are not forgotten
and can be referred back to if necessary. As an example, during the meeting it may be deci ded that Coogle
Docs will be used for storing all project speci fications. This decision is recorded in the meeting m inutes. The
second purpose of meeting minutes is to record unresolved issues that require follow up action. These are
re ferred to as action items . Each action i tem is assigned to one or more team members with a target date for
completion. An example action item might be that Joe is to i nvestigate and recommend a source control tool
for managi ng the project's source code, and is to complete his action in one week. It is a good idea to review
open action items at the start of each team meeting.
3.3.2 Team G uidance-Commu nication Plan
When a software project is i n itiated in industry, a set of project gui delines, tools, and communication
procedures is typically established to ensure that the project is executed as efficiently as possible. This should
also be done for your group project.
Many team problems arise from a failure to communicate fully. This problem is not l i mited to student
projects. Real -world teams suffer from it as wel l . Effective verbal communication means making sure your
thoughts are fully understood and l isten ing to what others are saying. This is critical for teams to be

57

58

CHAPTER 3

SOFTWARE PROCESS

1. Listen to all with concentration
•

Don't pre-judge.

2. Cive all team members a turn
•

See the value in every idea.

3. Don't make assumptions .
•

Ask questions to clarify.

4. When in doubt, communicate
Figure 3.24 Key precepts of communication

successful. The precepts shown in Figure 3.24 w ill help you avoid many communication problems. They
sound simple but can be hard to follow, especially during times of stress.
Create policies for communicating and sharing information w ith each other, including guidelines for
group editing and merging of documents, setting up and agree ing to meeting t imes, sharing project artifacts,
and so on.
Decide on procedures for how you will generate documents for the project. You probably have to deal
with discussing the scope and contents of a document, writing initial drafts, edit ing the drafts, getting group
agreement on edits, merging drafts and producing the final document.
Many teams-including some student teams-are widely distributed geographically, and the means of
communication becomes especially important. Large projects are often developed by multiple groups at
multiple sites, sometimes in multiple countries. Mergers, acquisitions, "offshoring," dispersed specialists, and
jOint ventures often result in people at multiple sites working together on projects.
An increasing number of products are available to facilitate group work, including groupware, video
conferencing, and instant messaging. Each communication medium has spec ific strengths. In any case, well­
run face-to-face meetings are very hard to beat. If possible, schedule regular face-to-face meetings at least
once a week for an hour. It is hard to convene an unscheduled meeting but easy to cancel a scheduled
meeting. You can make it a goal to limit actual meetings to less time. However, if the committed time is
short-say a half hour -you will find it very difflcult to make longer meetings because people will build the
short t ime limit into their schedules. If you think that your team may need to meet addit ionally, it is advisable
to agree on when that would be each week. Set aside the time and aim to avoid a meeting. Th is provides a
positive goal and it avoids the problem of repeatedly trying to find a common time when meetings are
needed. When you set meeting times, specify an end time. Meetings typically expand to fill the allotted time.
You should always have an agenda for your meet ings, otherwise your meetings w ill be less organized and not
as productive as they could be.
E-mail is an essential tool, but can be problematic due to unpredictable delays. Messages can become
unsynchronized, damaging the threads of dialogs. This is espec ially serious near the end of a project when
communication is frequent and of immediate importance.
Use a shared Web site, wiki, or chat-type facility. For example, at the t ime of this writing, a number of
free collaboration tools are available from Coogle.
Do not merely state that you will use a particular tool such as Microsoft Word for word processing.
Specify a version number, and exchange a few documents to be sure everyone can read and edit them. Don't
change versions during the project without ensuring compatib ility first.
Document your decisions in a team Communication Plan, as outlined in Figure 3 .25.

SUMMARY

1. Meetings: Team will meet each Monday from . . . to . . . in . . .

Caveat: do not replace face-to-face meeting with remote meetings unless remote meetings are
clearly effective.
2. Meeting alternative: Team members should keep Fridays open from . . . to . . . in case an additional
meeting is required.
3. Standards: Word processor, spreadsheet, compiler, .
4. E-mail: Post e-mails?; require acknowledgement?

Caveat: e-mail is poor for intensive collaboration
5. Collaboration: Tools for group collaboration and discussion e.g. Yahoo Groups, Wiki tool, Google tools, . . .

6. Other tools: Microsoft Project (scheduling), Group calendar,
Figure 3 . 25 Communication planning-forms of communication

3.3 .3 Team Guidance-Test Communication Plan

It is important to test the methods specified in your Communication Plan so you can make necessary
adjustments as early as possible in the project. This will avoid scrambling for alternatives as the project
workload increases.
Search the Web for the latest information on a topic determined by the instructor. Note at least four of
its basic goals and at least five of the techniques it uses. Have everyone in the group contribute some
information. Create a document containing your group's results, and practice how you will utilize your
procedures for group editing and reviews. How will you organize this random activity? How can you obtain a
useful result instead of a conglomeration of unconnected text?
3.4 SUM MARY

A software project progresses through a series of activities, starting at its conception and continuing a\l the
way through its release. Projects are organized into phases, each with a set of activities conducted during that
phase. A software process prescribes the interrelationship among the phases by expressing their order and
frequency, as well as defining the deliverables of the project. Specific software processes are called software
process models or life cycle models.
Most software process models prescribe a similar set of phases and activities. The difference between
models is the order and frequency of the phases. The phases include planning, requirements analysis, design,
implementation, testing, and maintenance.
The waterfall process is one of the oldest and best known software process models. Projects following the
waterfall process progress sequentially through a series of phases. Work transitions to a phase when work on
the previous phase is completed.
Iterative and incremental processes are characterized by repeated execution of the waterfall phases, in whole
or in part, resulting in a refinement of the requirements, design, and implementation. At the conclusion of an
iteration, operational code is produced that supports a subset of the final product's functionality. Project
artifacts such as plans, specifications, and code evolve during each phase and over the life of the project.
Examples of iterative processes include the spiral model, the unified process, and agile processes.

59

60

CHAPTER 3 SOFTWARE PROCESS

Agile processes are highly iterative, and emphasize working code throughout, as well as frequent
interactions with the customer.
A prototype is a partial implementation of the target application useful in identifying and retiring risky
parts of a project. It can sometimes be a way to obtain ideas about the customer's requirements. An increase in
understanding what is to come can save expensive rework and remove future roadblocks before they occur.
Many iterative process models incorporate prototypes in one or more of their iterations.
Sometimes, it is unclear whether certain requirements can be implemented in practice, placing the
entire project at risk. In such cases, feasibility studies may be advisable, which are partial implementations or
simulations of the application.
In open-source processes, software is developed and maintained by people on a volunteer basis. Source
code is open to all, and there is a process for virtually anyone to suggest and implement enhancements and
submit and repair defects. This process is repeated and the application grows in capability and stability. In this
way, open-source projects are developed in an iterative manner. In addition, by exercising an application
many times, the open-course community functions as a huge testing process.

3_5 EXERCISES

1. During which process phase(s) would each of the following activities occur?
a. Creating a project schedule
b. Determining the need for a bar code reader
c. Requesting the addition of a file backup capability
d. Performing a feasibility analysis
e. Documenting the software interface to an SQL database
f.

Acceptance of the software application by the customer

2. Give an example of a software project that would benefit much more from using the waterfall
process than from using most of the alternative processes. Explain your reasoning.
3. Describe the difference between iterative and incremental development. Describe the ways in which
they are related.
4.

Give an example of a software project that would benefit more from using an iterative and
incremental process than from using most of the alternative processes. Explain your reasoning.

5. a. In your own words, explain how the spiral model utilizes risk analysis and risk mitigation.
b. Explain why the outer spiral of the spiral model utilizes the waterfall process, and how the
spiral model mitigates the inherent disadvantages of the waterfall process.

6. Give an example of a software project that would benefit much more from using the spiral process
than from using most of the alternative processes. Write a paragraph explaining your answer.
7. How do the phases of the unified process (UP ) differ from the phases usually defined for software
processes?
8. Describe the pros and cons of each value listed in the Agile Manifesto (see Figure 3.14).

EXERCISES

TEAM EXERCISES

Communication
For the following exercises, consider as a group how you will perform them, check the hints below,
then carry out the assignments.

Tl. Decide who your team leader(s) will be. Note that being team leader provides you with
practice that may be hard to get otherwise.
T2. Decide how your team will communicate, specify your communication tools and methods,
and test your communication methods. Be specific: you may change the specifics later.
T3. Search the Web for the latest information on a topic determined by the instructor (e.g., the
TSP). Note at least four of its basic goals and at least five of the techniques it uses. Post the
references to the course forum or Web site if there is one, and annotate your posting with the name
of your group. State individual or group opinions of the topic or issue.
Your team response should be 4-7 pages long.

Hints for Team Exercises

T 1 hints: To distribute the benefits of team leadership practice, it can be beneficial to swap team
leadership about halfway through the semester. Both team leaders can be chosen up front, and they
can back each other up in case of emergency. Such backing up is a good practice in any case, because
the probability of a team leader having to quit a project or a class can be high. Note that the second
half of a project typically requires the team leader to make decisions more quickly than the first half.
T2 hints: Examples are telephone, meetings, e-mail, forums, chat facilities, and Web sites.
1. Schedule regular face-to-face meetings at least once a week, if possible. It is hard to convene an
unscheduled meeting but easy to cancel a scheduled one.
2. E-mail is an essential tool, but can be problematic due to unpredictable delays. Messages can
become unsynchronized, damaging the threads (subjects) of dialogs. This is especially serious
near the end of a project when communication is frequent and of immediate importance.
3. Use a shared Web site or chat-type facility. Free services are available at http://groups.yahoo.
com/, for example.
4. Do not merely state, "We will use Superword for word processing." Specify a version number,
and exchange a few messages to be sure. Don't change versions during the project without
ensuring compatibility first.
5. Try out all the standards and methods you have chosen.
Throughout this program of study, validate your plans and intentions with practical tests
whenever possible. Try to use at least two independent tests. In general, assume that your project
will be much more demanding in the future than it is at the beginning.
T3 hints: Use this activity to stress your communication system. For example, you may want to set
up a Web site to which team members are to add new TSP information. How will you organize this
random activity? How can you obtain a useful result instead of a conglomeration of unconnected
text?

61

62

CHAPTER 3 SOFTWARE PROCESS

B I BLIOGRAPHY
I. Royce, W. W., "Managing the Development of Large Software Systems, Concepts and Techniques," IEEE WESCON 1970, August

1970, pp.I�9.
2. Bittner, Kurt, and Spence, I., 2007, "Managing [teraliDe Software Development Projects," Addison-Wesley, Pearson Education, Inc.
3. Cockburn, Alistair. "Unraveling Incremental Development," January 1993. httpJlalistair.cockburn.us/Unraveling+incremental
+development [accessed November 5, 2009].
4. Cusumano, Michael, and R. W. Selby. "How Microsoft Builds Software." Communications of the ACM, Vol. 40, No. 6(1997), pp.53�61.
5. Boehm, B. W. "A Spiral Model of Software Development and Enhancement." IEEE Computer, Vol.21, No. 5 (MayI988), pp.61�72.
6. Jacobson, Ivar, J. Rumbaugh, and C. Booch. The Unified Software Development Process, Addison-Wesley, 1999.
7. Booch, Crady. Object-Oriented Analysis and Design with Applications, Addison-Wesley, 1994.
8. Rumbaugh, James, M. Blaha, W. Premerlani, F. Eddy, and W. Lorenson, "Object-Oriented Modeling and Desl!!n," Prentice Hall, 1990.
9. Larman, Craig, "Applying UML and Patterns, An introduction to Object-Oriented Analysis and Design and IteratiDe Development," Prentice Hall,
2005.
I O. Ambler, S. W., "A Manager's introduction to the Rational Unified Process (RUP)." Ambysoft (December 4,2005). httpJlwww.ambysoft.com/
unihedprocess/ruplntroduction.html [accessed November 5, 2009].
II. Beck, Kent, Mike Beedle, Arie van Bennekum, and Alistair Cockburn, "Manifesto for Agile Software Development," Feb 200I. httpJI

agilemanifesto.orgl [accessed November 5, 2009].
12. Ferguson, Charles, "How Linux Could Overthrow Microsoft," Technology Review Uune2005). httpJlwww.technologyreview.com/
computing/I45041 [accessed November 5,2009]'
13. Samoladas, loannis, I. Stamelos, L. Angelis, and A. Oikonomou, "Open source software development should strive for even greater
code maintainability." Communications of the ACM, Vol. 47, No. 10, October 2004.

Agile Software Processes

Planning

�

What are the principles of agility?

Maintenance

Testing
The Software

\

How are agile processes carried out?
Can agile processes be combined
with non-agile ones?

Development
Lifecycle

How did agile methods come about?

Requirements
analysis

Implementation

/
Design

Figure 4.1 The context and learning goals for this chapter

In the 1990s, agile software development came into being as an alternative to the existing classical
approaches to software engineering that were perceived to be too "process-heavy." These classical
approaches emphasize the need to plan projects in advance, express requirements in writing, provide
written designs satisfying the requirements, write code based on these designs satisfying the written
requirements, and finally to test the results. As we discussed in Chapters 1 and 3, however, many projects
following these steps exhibit major problems. A primary reason is that stakeholders do not usually know at the
inception of a project entirely what they require. Agile processes address this shortcoming. This chapter
defines what is meant by agile development, describes several specific software processes that adhere to agile
principles and are thus considered agile processes, and discusses how agile and non-agile processes can be
combined.

64

CHAPTER 4 AGILE SOFTWARE PROCESSES

4.1 AGilE H ISTORY AND THE AGilE MANIFESTO
A group of industry experts met in 200 1 to discuss ways of improving on the then current software
development processes that they complained were documentation driven and process heavy. Their goal was
to produce a set of values and principles to help speed up development and effectively respond to change.
Calling themselves the Agile Alliance, the group's goal was, in essence, to produce a development framework
that was efficient and adaptable. During the 1990s, various iterative software methodologies were beginning
to gain popularity. Some were used as the basis for the agile framework. These methodologies had different
combinations of old and new ideas, but all shared the following characteristics [ 1].
•

Close collaboration between programmers and business experts

•

Face-to-face communication (as opposed to documentation)

•

Frequent delivery of working software

•

Self-organizing teams

•

Methods to craft the code and the team so that the inevitable requirements churn was not a crisis

As a result of their meeting, the Agile Alliance produced the Agile Manifesto [ 1] to capture their
thoughts and ideas, and it is summarized in Figure 4.2.
Note that the Agile Manifesto is not anti-methodology. Instead, its authors intended to restore balance.
For example, they embrace design modeling as a means to better understand how the software will be built,
but not producing diagrams that are filed away and seldom used. They embrace documentation, but not
hundreds of pages that cannot practically be maintained and updated to reAect change [2].
The four points of the Agile Manifesto form the basis of agile development. The first part of each
statement specifies a preference. The second part specifies something that, although important, is of lower
priority. Each of the four points is described next.

Individuals and Interactions (over processes and tools)
For decades, management practice has emphasized the high value of communications. Agile practices
emphasize the significance of highly skilled individuals and the enhanced expertise that emerges from
interactions among them. Although processes and tools are important, skilled people should be allowed to

We are uncovering better ways of developing software by doing it and helping others do it. Through this
work we have come to value:
1. Individuals and interactions over processes and tools

2. Working software over comprehensive documentation
3. Customer collaboration over contract negotiation
4. Responding to change over following a plan
That is, while there is value in the items on the right, we value the items on the left more.
Figure 4.2 The Agile Manifesto

AGILE PRINCIPLES

adapt the process and modify the tools as appropriate to get their job done as efficiently as possible. As
suggested in [3], agile methods offer generative values rather than prescriptive rules: a minimum set of values,
observed in all situations, that generate appropriate practices for special situations. Individuals and teams use
these rules when problems arise as a basis for generating solutions that are appropriate for the project.
Creativity is emphasized as a major means for problem solving. This is in contrast to more rigid software
processes, which prescribe a set of predetermined rules and force teams to adapt themselves to these rules.
Agile practices suggest that the latter approach is not effective and actually adds to the risk of project failure.

Working Software (over comprehensive documentation)
Working software is considered the best indicator of project progress and whether goals are being met.
Teams can produce pages of documentation and supposedly be on schedule, but these are really promises of
what they expect to produce. Agile practices emphasize producing working code as early as possible. As a
project progresses, software functionality is added in small increments such that the software base continues
to function as an operational system. In this way team members and stakeholders always know how the real
system is functioning.
Although significant, working software is of greatly diminished value without reasonable documenta­
tion. Agile practices emphasize that project teams determine for themselves the level of documentation that is
absolutely essential.
Customer Collaboration (over contract negotiation)
This statement emphasizes the fact that development teams are in business to provide value to customers.
Keeping as close as possible to your customer is a long-established maxim of good business practice. Many
programmers are disconnected from the customer by organizational layers and intermediaries; it is highly
desirable to remove this barrier. All stakeholders, including customers, should work together and be on the same
team. Their different experiences and expertise should be merged with goodwill that allows the team to change
direction quickly as needed to keep projects on track and produce what is needed. Contracts and project charters
with customers are necessary, but in order to adapt to inevitable change, collaboration is also necessary [3].
Responding to Change (over following a plan)
Producing a project plan forces team members to think through a project and develop contingencies.
However, change is inevitable, and agile practitioners believe that change should not only be planned for but
also embraced. Very good project managers plan to respond to change, and this is a requirement for teams
operating at the most effective levels, as you will see when we discuss the highest capability levels of the
CMMI in Section III of this book. As changes to the plan occur, the team should not stay focused on the
outdated plan but deal instead with the changes by adapting the plan as necessary [3]. Agile practices rely on
short iterations of one to six weeks to provide timely project feedback and information necessary to assess
project progress and respond as necessary.

4.2 AGILE PRINCIPLES
In addition to the values described in Figure 4.2, the authors of the Agile Manifesto outlined a set of guiding
principles that support the manifesto. These are quoted from [ 1] (bold added).
•

•

"Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
Welcome changing requirements, even late in development. Agile processes harness change for the

customer's competitive advantage.

65

66

CHAPTER 4 AGILE SOFTWARE PROCESSES

•

Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to

the shorter timescale.
•

•

•

•

•

Business people and developers must work together daily throughout the project.
Build projects around motivated individuals. Give them the environment and support they need, and trust
them to get the job done.
The most efficient and effective method of conveying information to and within a development team is
face-to-face conversation.
Working software is the primary measure of progress.

Agile processes promote sustainable development. The sponsors, developers, and users should be able to
maintain a constant pace indefinitely.

•

Continuous attention to technical excellence and good design enhances agility.

•

Simplicity-the art of maximizing the amount of work not done-is essential.

•

The best architectures, requirements, and designs emerge from self-organizing teams.

•

At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior
accordingly."

Many of these principles are implemented in practice by the agile methods described in the next
section.

4.3 AGILE METHODS

This section describes some of the methods by which many agile processes practice the principles in the
Agile Manifesto.
Figure 4.3 shows the manner in which agile methods implement the Agile Manifesto, as follows. Agile
processes commonly employ small, close-knit teams; periodic customer requirements meetings; a code­
centric approach; documentation on an as-needed basis (e.g., high-level requirements statements only);
customer representatives working within the team; refactoring; pair programming; continual unit-testing; and
acceptance tests as a means of setting customer expectations.
We next elaborate on the topics not already explained above.
Pair programming is a form of continual inspection by one team member of the work of a teammate.
Typically, while one programs, the other inspects and devises tests. These roles are reversed for periods of
time that the pair determines.
Documenting on an as-needed basis usually involves writing some high-level requirements but not detailed
requirements. These are frequently collected in the form of user stories. A user story is a significant task that the
user wants to accomplish with the application. According to Cohn [4], every user story consists of the
following:
•

A written description

•

Conversations with the customer that establish a mutual understanding of its purpose and content

•

Tests intended to validate that the user story has been implemented

AGILE METHODS

1. Individuals and interactions over processes and

tools
2. Working software over comprehensive

documentation

MANIFESTO ->

3. Customer collaboration over contract

negotiation
4. Responding to change over following

RESPONSES:

a plan

a. Small, close-knit team of peers

y

b. Periodic customer requirements meetings

y

y
y

y

y

c. Code-centric

y

d. High-level requirements statements only

y

y

e. Document as needed

y

y

f. Customer reps work within team

y

y

y

g. Refactor
h. Pair programming and no-owner code

y

i. Unit-test-intensive; Acceptance- test-driven

y

y

j. Automate testing

y

y

Figure 4.3 Ways to address the principles of the Agile Manifesto

Examples of user stories for a video store application are as follows:
•

"The user can search for all DVDs by a given director."

•

'The user can establish an account that remembers al1 transactions with the customer."

•

liThe user can view all available information on any DVD."

Continual interaction and contact with the customer is achieved in two ways. First, the work periods (1-6
weeks, usually) in which the each batch of requirements are to be fulfilled are specified with a team that
involves the customer. Second, a customer representative is encouraged to be part of the team.
The emphasis on working software is realized by means of coding versions of the application and showing
them to the customer. These are usually closely tied to corresponding tests. Indeed, test-driven development, an
agile approach, actually has developers write tests even before developing the code.

67

68

CHAPTER 4 AGILE SOFTWARE PROCESSES

Obtain requirements for
Obtain high-level -+--7
next period's' segment
requirements

Refactor to
Refactor to
clean u p

new
requirements

Modify code and test code base
to handle additional requirements

•

Typically 1-6 weeks

Figure 4.4 A typical agile development iteration

Refactoring is a process of altering the form of a code base while retaining the same functionality. The
usual goal of a refactoring is to make the design amenable to the addition of functionality, thereby satisfying
the agile desire to respond well to change. The very fact that the discipline of refactoring has been developed
is a major factor making agile methods possible. This book covers refactoring in Chapter 24. Although
refactoring is discussed later in the book, much of it will be useful before then and can be referred to
throughout the book.
Agile methods employ the development cycle shown in Figure 4.4. Typically, the requirements
are expressed in terms of user stories. Past experience in the project allows the team to assess its
velocity: an assessment of the relative difficulty of stories and the rate at which it is able to implement
them.
The schedule effects of agile methods can be seen in Figure 4.5. Planning is attenuated because there is
less to plan. Requirements analysis, design, and testing are often confined to high levels. The emphasis is
mostly code centered.

4.4 AGILE PROCESSES
"Agile development" isn't itself a specific process or methodology. Instead, it refers to any software process
that captures and embraces the fundamental values and principles espoused in the Agile Manifesto. The
following sections illustrate and describe three agile processes as representative examples.
•

Extreme programming (XP)

•

Crystal

•

Scrum

AGILE PROCESSES

Time line
Planning

Plan for agile methods

Requirements
Analysis

\

Detailed requirements as they emerge

1/1/1/1/111/1
Design as required

11 11 11 11 11 � 1
Implementation

Implement in agile fashion
System tests not covered by agile method:

System
Testing

Figure 4.5 The agile schedule

4.4.1 Extreme programming

In 1 996, Kent Beck and colleagues began a project at DaimlerChrysler [5] using an approach to software
development that appeared to make matters much simpler and more efficient. The methodology he
developed and used became known as Extreme Programming (XP) [6].
Beck [6] cites four "values" guiding extreme programming: communication, simplicity, feedback, and
courage. These are summarized in Figures 4.6 and 4.7. XP programmers communicate continually with their
customers and fellow programmers. They keep their design simple and clean. They obtain feedback by
testing their software, starting on day one. They deliver parts of the system to the customers as early as
possible and implement changes as suggested. With this foundation, XP programmers are able to
"courageously" respond to changing requirements and technology [5].
XP was created to deal effectively with projects in which requirements change. In fact, XP expects
requirements to be modified and added. On many projects, customers start with only a vague idea of what
they want. As a project progresses and a customer sees working software, specifics of what they want become
progressively firm.

1 . Communication
•

•

•

Customer on site
Pair programming
Coding standards

2. Simplicity
•

•

•

Metaphor: entity names drawn from common metaphor
Simplest design for current requirements
Refactoring

Figure 4.6 The "values" of extreme programming, 1 of 2
Source: Beck, Kent, "Extreme Programming Explained: Embrace Change," Addison-Wesley, 2000.

69

70

CHAPTER 4 AGILE SOFTWARE PROCESSES

1. Feedback always sought
•

•

•

Continual testing
Continuous integration (at least daily)
Small releases (smallest useful feature set)

2. Courage
•

•

•

Planning and estimation with customer user stories
Collective code ownership
Sustainable pace

Figure 4.7 The "values" of extreme programming, 2 of 2
Source: Beck, Kent, "Extreme Programming Explained: Embrace change," Addison-Wesley, 2000.

XP projects are divided into iterations lasting from one to three weeks. Each iteration produces
software that is fully tested. At the beginning of each, a planning meeting is held to determine the contents
of the iteration. This is "just-in-time" planning, and it facilitates the incorporation of changing
requirements.
As code is developed, XP relies on continual integration rather that assembling large, separately
developed modules. In the same spirit, releases are modest in added capability. The idea is to bite off a small
amount of new capability, integrate and test it thoroughly, and then repeat the process.
Extreme programming recognizes the all-too-frequent breakdown in customer developer relation­
ships, where each party develops a separate concept of what's needed and also how much the features
will cost to develop. The result of this mismatch is, all too often, a mad dash for deadlines, including
long working hours and an unsustainable pace. [n response, extreme programming promotes a modus
vivendi that's sustainable in the long term. [n addition, it requires every developer to acknowledge up
front that all code is everyone's common property, to be worked on as the project's needs require. In
other words, no code "belongs" to a programmer. This is in keeping with engineering practice, where a
bridge blueprint, for example, is the product of an organization and not the personal property of
one designer.
XP is unique in using twelve practices that dictate how programmers should carry out their daily jobs.
These twelve practices are summarized next [7].
1. Planning Process. Requirements, usually in the form of user stories, are defined by customers and given a
relative priority based on cost estimates provided by the XP team. Stories are assigned to releases, and the
team breaks each story into a set of tasks to implement. We described user stories in Section 4. 3.
A simple system is built and put into production early that includes a minimal set of
useful features. The system is updated frequently and incrementally throughout the development
process.

2. Small Releases.

Unit tests are written to test functionality, before the code to implement
that functionality is actually written.

3. Test-Driven Development.

Code is regularly modified or rewritten to keep it simple and maintainable. Changes are
incorporated as soon as deficiencies are identified. We introduced refactoring in Section 4.3 and cover it
in detail in Chapter 24.

4. Refactoring.

Designs are created to solve the known requirements, not to solve future require­
ments. If necessary, code will be refactored to implement future design needs.

5. Design Simplicity.

AGILE PROCESSES

6. Pair Programming. This was described in Section 4.3.
7. ColIective Code Ownership. All the code for the system is owned by the entire team. Programmers can

modify any part of the system necessary to complete a feature they're working on. They can also improve
any part of the system.
S. Coding Standard. For a team to effectively share ownership of all the code, a common coding standard
must be followed. This ensures that no matter who writes a piece of code, it will be easily understood by
the entire team.
9. Continuous Integration. Code is checked into the system as soon as it's completed and tested. This can
be as frequent as several times per day. In this way the system is as close to production quality as possible.
10. On-Site Customer. A customer representative is available full-time to determine requirements, set
priorities, and answer questions as the programmers have them. The effect of being there is that
communication improves, with less hard-copy documentation-often one of the most expensive parts of
a software project.
1 1. Sustainable Pace. XP teams are more productive and make fewer mistakes if they're not burned out and
tired. Their aim is not to work excessive overtime, and to keep themselves fresh, healthy, and effective.
12. Metaphor. XP teams share a common vision of the system by defining and using a common system of
describing the artifacts in the project.

4.4.2 Serum

Scrum is an agile methodology developed in the early 1990s. It is named after the part of a rugby game that, in
U. S. football terms, is a cross between the kickoff and a quarterback snap. As defined by the Merriam Webster
dictionary, a scrum is "a rugby play in which the forwards of each side come together in a tight formation and
struggle to gain possession of the ball using their feet when it is tossed in among them." In other words, scrum
is a process that follows "organized chaos." It is based on the notion that the development process is
unpredictable and complicated, and can only be defined by a loose set of activities. Within this framework,
the development team is empowered to define and execute the necessary tasks to successfully develop
software.
The flow of a typical scrum project is shown in Figure 4.S.
A project is broken into teams, or scrums, of no more than 6-9 members. Each team focuses on a self­
contained area of work. A scrum master is appointed and is responsible for conducting the daily scrum
meetings, measuring progress, making deciSions, and clearing obstacles that get in the way of team progress.
The daily scrum meetings should last no more than 15 minutes. During the meeting the scrum master is
allowed to ask team members only three questions [S]:
1. What items have been completed since the last scrum meeting?
2. What issues have been discovered that need to be resolved?
3. What new assignments make sense for the team to complete until the next scrum meeting?
At the beginning of a project, a list of customer wants and needs is created, which is referred to as the
"backlog." The scrum methodology proceeds by means of agile 30-day cycles called "sprints." Each sprint
takes on a set of features from the backlog for development. While in a sprint, the team is given complete

71

72

CHAPTER 4 AGILE SOFTWARE PROCESSES

Sprint Backlog of

It

assigned features

}

Backlog
items
expanded
____

by team

'----l .....

Product Backlog

at end of sprint

Prioritized product features desired by
customer

Figure 4.8 The serum work flow
Source: Quoted and edited from http://www.controlchaos.com/about.

control of how they are to successfully complete the sprint. At the end of a sprint a customer demonstration is
conducted for the customer. It serves several purposes, including [8]:

1. Demonstrating to the customer what has been accomplished.
2. Giving the developers a sense of accomplishment.
3. Ensuring that the software is properly integrated and tested.
4. Ensuring that real progress is made on the project.
At the conclusion of the demonstration, the leftover and new tasks are gathered, a new backlog is
created, and a new sprint commences.

4.4.3 Crystal

Crystal is a family of agile methods developed by Alistair Cockburn. Each Crystal method shares common
characteristics of "frequent delivery, close communication, and reflective improvement" [9]. Not all projects
are the same, so different Crystal methodologies were created to address differences in project size and
criticality. Figure 4.9 shows the different methodologies and the size project they are best suited to. Crystal
methods are characterized by a color, starting at clear for small teams and progressing through to orange, red,
and so on as the number of people increases. For example, Crystal Clear is geared for small teams of
approximately 6 people; Yellow for teams of 10-20 people; Orange for teams of 20-40 people, and so on. The
other axis defines the criticality of a project, where L is loss of life, E is loss of essential monies, D is loss of
discretionary monies, and C is loss of comfort. Note that the row for loss of life is not shaded in Figure 4.9.
This is because Cockburn had no experience applying Crystal to these types of projects when he created the

AG ILE PROCESSES

E6

E20

E40

E80

D6

D20

D40

D80

C6

C20

C40

C80

L = loss of life
E = loss of essential monies
D = loss of discretionary monies
C = loss of comfort

Figure 4.9 Coverage of various Crystal methodologies
Source: Adapted from Cockburn, Alistair, "Crystal Clear: A Human·Powered Methodology for Small Teams," Addison-Wesley, 2005.

chart. Crystal Clear doesn't explicitly support the E6 box, although Cockburn notes that teams may be able to
adapt the process to accommodate such projects. Another �estriction of Crystal is that it is applicable only to
colocated teams.
Cockburn believes that developers do not readily accept the demands of any process (documentation,
standards, etc). He strongly recommends accepting this by introducing the most limited amount of process
needed to get the job done successfully, maximizing the likelihood that team members will actually follow the
process.
All Crystal methodologies are built around three common priorities [9]:
1. Safety in the project outcome.
2. Efficiency in development.
3. Habitability of the conventions (i.e., the ability of developers to abide by the process itself).
Crystal projects exhibit seven properties to varying degrees [9]:
1 . Frequent delivery.
2. Reflective improvement.
3. Close communication.

4. Personal safety.
5. Focus.
6. Easy access to expert users.

7. Technical environment with automated testing, configuration management, and frequent integration.

73

74

CHAPTER 4 AG ILE SOFTWARE PROCESSES

The flrst three properties are common to the Crystal family. The others can be added in any order to
increase the likelihood of project safety and success.
4.5 INTEGRATING AGILE WITH NON-AGILE PROCESSES

The advantages of agile methods include the ability to adjust easily to emerging and changing requirements.
The disadvantages include awkward roles for design and documentation. Cockburn's Crystal family of
methodologies already acknowledges that different kinds of applications must be treated differently, even
when the methods are agile.
Software process, after all, concerns the order in which we perform activities: For example, designing
flrst and then coding from the design. One extreme is the waterfall process. As we have seen, there are many
limitations in our ability to thoroughly perform the waterfall sequence once, or even a few times, iteratively.
Changeable and unknown requirements are a principal reason. Regardless of the development process we use,
we must make trade-offs in deciding how extensively to pursue a phase before moving to another phase.
Consider, for example, the issue of how much effort to spend on planning a software enterprise.
One extreme project situation is when we are certain of obtaining all of the requirements of the end
date, of the high-level design, and of who will be working on the job. In that case, we can and probably should
develop a detailed plan.
The other extreme project situation is when we have little idea of any of these factors, believing that
they will become clear only after the project is under way. In that case, planning at a detailed level would be a
waste of time at best because it could not be even nearly accurate, and would probably even be misleading.
We have no choice in this case but to begin the process, and revisit the plans as required. The extremes are
illustrated in Figure 4.10.
Agile methods provide beneflts but also costs, and these depend on several factors. Some are shown in
Figure 4.11.
In order to gain the advantages of both agile and non-agile1 processes, we try to integrate them. The
means by which this can be performed depend on several factors, but particularly on the size of the job. As of

100%
-

-

-

-

-

-

-

-

-

� :: � � � �
: : �i
/:
-

-

-

-

. c n o t in a r q Ui e

Advisable
detail level

nt

•

Certain of end date

•

Certain of high-level design - • 1

•

Certain of personnel

I ....

•

1

¢HIGH DETAIL PLAN

of plans
•

No knowledge

,/

¢ LOW DETAIL PLAN
L-_____________ Extent of

0%

knowledge

�
100%

Figure 4.10 How detailed should plans be?
1

Some authors characterize non-agile processes. For example, one practice is to call them "plan-based." The authors

do not believe in a single characterization like this of non-agile processes; hence the blanket term "non-agile."

INTEGRATING AGILE WITH NON-AGILE PROCESSES

Benefits of Agile

Costs of Agile

© Motivates developers

®Hard for new participants

©Thoroughly tested, usually

®Sensitive to individuals

©Easier to estimate each cycle

®Hard to estimate full job

© Responsive to customer

®Limits team size

©Always demonstrable software

/\

/\

�

Figure 4. 1 1 Trade-offs between agile and non-agile processes

2009, the conventional wisdom concerning the agile/non-agile split is shown roughly in Figure 4.12: The
larger the job, the more non-agile process is required.
Agile processes emphasize code first, whereas non-agile ones advocate coding only from well­
documented designs and designing only from well-documented requirements. These approaches appear
to be almost contradictory, so combining them requires substantial skill and care. We will concentrate on
methods for doing this in large jobs, where the challenges are greatest. We will call the two options non-agile­
driven and agile-driven and will compare them.
4.5.1 A Non-Agile-Driven Approach

A common non-agile-driven approach is to initially approach the job without agility, then fit agile methods
into the process after sufficient work has been done to define the agile roles and portions. We develop a plan,
create a careful high-level design, and decompose the work into portions that can be implemented by teams
in the agile manner. One can superimpose upon each agile team a process by which the accumulating
Percent
agile vs.
non-agile

t

100%

-

-

-

-

Small

Large

Job size

Figure 4. 1 2 Conceptual agile/non-agile combination options: some conventional wisdom, circa 2009

75

76

CHAPTER 4 AG ILE SOFlWARE PROCESSES
--------.�

Time

Requirements
documentation

Design
documentation

Coding and
testing

System testing
•

High level

Figure 4. 1 3 Integrating agile with non-agile methods 1 : time line for a single iteration

requirements are gathered, and placed within a master requirements document. The same can be done with
the accumulating design. Doing this with design is more difficult because design parts may actually be
replaced and modified as refactoring takes place. Requirements tend to accumulate as much as they change.
The sequence of events is as follows :

1. High-level requirements are developed for the first iteration.
2. A high-level design is developed based on the high-level requirements.
3.

Agile development by teams begins, based on these high-level documents.

4. Full requirements documentation is gathered from the work done by the agile teams as it progresses.
5 . The design documentation is gathered from the agile teams at regular intervals to update the design
document.
6. System testing not covered by the agile process is performed at the end, if necessary.
7. The process is repeated for each iteration.

This is illustrated for one waterfall iteration in Figure 4. 1 3 . Figure 4. 14 shows this for multiple iterations.
4.5.2 An Agile-Driven Approach

For an agile-driven approach to large jobs, a (small) agile team can be set to work on significant aspects of the
project until the outlines of an architecture appear. At that point, non-agile methods are used. This may
involve reintegrating agile programming again as described in the non-agile-driven approach above. This has
much in common with building a prototype. However, the difference is that the initial work is performed
largely to develop an architecture rather than retire risks. In addition, the work is not planned as throw-away
code. One agile-driven approach is shown in Figure 4. 15.

SUM MARY

Time
T

1

M I

T

L E S T 0 N E S

First iteration ' completed X

Product released X

S C H E D U L E
teration n umber 7

1

2

3

. . ..............

...........

Requ irements
documentation

*

*

1
*

Design
documentation

.............. ......... .... .. .. .. ..... ..... ..........

..

Coding and

*

1
*

T

·

1
*

T

-J

-J

l

····· ·

1

· ·

esting

QJ

s ystem testing

�

[I:
'High level

Figure 4.14 Integrating agile with non-agile methods 2: time line for multiple iterations

Initial agile
development

c=J-- "

Requirements
documentation
Design
documentation
Coding and testing
(including agility?)

/ �
I

�

1 \

\
\

:

\
\

\

'A1L..__--'

c-=--=--=--=-....1.

---'

_
_
_
_

Figure 4.15 An agile-driven approach to large jobs

The case study sections for this part of the book (which appear in Chapters 5 and 6) contain two case
studies that combine agile and non-agile methods.
4.6 SUM MARY

Agile software development was created as an alternative to existing plan-based approaches that were
perceived to be too process heavy and rigid. A group of industry experts met in 200 I to share their vision for
an alternative to these types of processes. They created the Agile Manifesto to capture their thoughts for a
process that was adaptable, lean, and agile.

77

78

CHAPTER 4 AGILE SOFTWARE PROCESSES

Agile processes emphasize the following:
•

The need to collaborate closely with customers and other stakeholders

•

Communication over documentation

•

Frequent delivery of working software

•

Self-organizing teams

•

The need to embrace and plan for changing requirements

Any process that embraces the fundamental values of the agile manifesto is considered an agile process.
Examples include extreme programming, scrum, and Crystal.
Extreme programming is based on four principles: communication, feedback, simplicity, and courage. It
promotes practices such as test-driven development, refactoring, pair - programming, collective code owner­
ship, continuous integration, and on-site customer.
Scrum defines a framework, or a loose set of activities that are employed by the scrum team. At the
beginning of a project, a backlog of work, or requirements , is identified. Developers work on a subset of
requirements in the backlog in 30-day sprints . Once a sprint begins, the team is given the freedom to employ
any methods deemed necessary to complete their work successfully. A customer demo occurs at the end of
each sprint. A new set of work is defined from the backlog for the next sprint and the cycle continues.
Crystal is a family of methodologies that address projects of different size and criticality. Crystal
methods share the following characteristics: frequent delivery , reflective improvement , close communication ,
personal safety, focus, and easy access to expert users, and a technical environment with automated testing,
configuration management, and frequent integration.
Agile and non-agile process can be integrated on projects in order to gain the advantages of both. The
means by which this can be performed depend on several factors but particularly on the size of the project. One
approach is to initiate a job without agility , then incorporate agile methods into the process after enough work
has been accomplished in defining agile roles and responsibilities. Another approach is to initiate a job with an
agile approach until the outlines of an architecture appear. At that point , non-agile methods are used. This may
involve reintegrating agile programming again as described in the non-agile-driven approach above.

4.7 EXERCISES

I. The Agile Manifesto favors working software over extensive documentation. Under what
circumstances can this cause problems if taken to an extreme?

2. a. In your own words, explain how agile processes adapt to and embrace changing requirements.
b. Describe a scenario in which this might be counterproductive.
3. Name three benefits of the XP practice of testing software from "day one," always having working
software available.

4. During the daily I S-minute scrum meeting, the leader is only allowed to ask the same three
questions. What two additional questions might you want to ask? For each , explain its benefit
toward achieving the goals of the meeting.
5. In your own words , explain how Crystal adapts to various types of projects.

BIBLIOGRAPHY

BIB LIOGRAPHY
I. Beck, Kent, Mike Beedle, Arie van Bennekum, and Alistair Cockburn,

"Manifesto for Agile Software Development, " Feb 200 1 . http)/

agilemanifesto.org/ [accessed November 5, 2009 ] .
2 . H ighsmith, j im, "History, Agile Manifesto, " 200 1 . http )/www.agilemanifesto.org/histOly.html [accessed November 5, 2009].
3.

H i ghsmith, j im, and A . Cockburn, "Agile Software Development The Business of Innovation," IEEE Computer, Vol. 34, No. 9,
September 200 1 , pp. 120-- 1 22.

4. Cohn, Mark, "User Stories Applied, For Agile Software Development, " Addison-Wesley, 2004.
5. Wells, Don, "Extreme Programming, A Gentle Introduction. " http )/www.extremeprogramming.org/ [accessed November 1 5, 2009].
6. Beck, Kent, "Extreme Programming Explained, Embrace Change," Addison-Wesley, 2000.
7. jeffri es, Ron, "XProgramming.com, An Agile Software Development Resource. " http)/xprogramming.com [accessed November 1 5 , 2009].
8.

Beedle, M ike, Martine Devos, Yonat Sharon, and Ken Schwaber, "SCRUM, An extension pattern language for hyperproductive software

development. " http )/j effsutherland. com/scrum/scrum_plop.pdf [accessed November 1 5, 2009].
9. Cockburn, Alistair, "Crystal Clear, A Human-Powered Methodology for Small Teams, " Addison-Wesley, 2005.

79

Qua l ity i n the Softwa re
Process

�

Testing

Maintenance
The Software
Development
Life Cycle

Planning
\

Requianalreyments
sis

Implementation
� Dealgn /

What are the principles of managing
quality?
How do you plan for "quality?"
What are inspections and how do you
carry them out?
How do you carry out
reviews and audits?
How do you measure and improve
software processes?
In what way does CMMI assess
organizational quality?
What does a software quality plan
look like?

Figure 5.1 The context and learning goals for this chapter

This chapter discusses the manner in which we integrate and manage quality throughout the software
development process. This is an integral part of project planning, and it affects every phase of development.
As part of planning, documents are produced detailing the quality approach to be taken, including specific
qual ity goals, techniques to be employed, metrics to be collected , tests to be run, and the manner in which

PRINCIPLES OF MANAGING QUALITY

•

•

•

•

•

•

•

Quality principles
-overarching quality guidelines
Quality planning
-quality plan defines overall approach to quality
Inspections
-peer processes focused on quality
Reviews and audits
-external quality assessment
Defect management
-identification, tracking, and resolution of defects
Process improvement
-continuous upgrading of process effectiveness
Organizational quality
-engineering competence levels (e.g., CMMI)

Figure 5.2 Quality in the software process

defects are t o b e handled. All o f these contribute t o a n effective development process with a focus o n quality,
resulting in the development of a high-quality software product. The integration of quality in the software
process is summarized in Figure 5 . 2 . Each topic mentioned in the figure is described in this chapter.

5.1 PRINCIPLES OF MANAGING QUALITY
An overall approach to quality is guided by several principles. The planning and practices described in this
chapter are implemented with these principles in mind, as fol1ows.
First and foremost, quality is something the entire development team is responsible for, not just the
quality assurance team. This is the meaning of the first point in Figure 5 . 3 : focusing "continuously on quality."
It is thus an integral part of the development process, and each phase must incorporate quality practices. For
example, peer inspections are carried out for each artifact when it is generated. Depending on the artifact
under review, stakeholders from different functions such as marketing, customer service, software develop­
ment , customers , and so on participate in the inspection. Inspections are discussed in detail in Section 5.4.
Another example is test-driven development (TOO), which is prevalent in various agile processes. It dictates

1. Focus continuously on quality.
2. A quality assurance process must be defined.
3 . The organization must fol1ow its quality assurance process.
4. Find and repair defects as early in the development process as possible.
Figure 5 .3 Key principles of managing quality

81

82

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

If defect found . . .
Reason (by one estimate):

soon after creation

. . . at integration time

.. detect

0 . 7 to 2

0.2 to 1 0

. . repair

0.3 to 1 . 2

9+

1 .0 to 3 . 2

9.2 to 1 9+

.

.

•

Hours to ..

Total

Figure 5 . 4 Cost to repair a defect. depending on time elapsed since injection

that developers write tests before coding, and then write code to pass their tests. TDD is discussed in more
detail in Chapter 27.
Quality assurance (QA ) refers to actions taken to assure that a product under construction attains
required levels of quality. The second and third principles listed in Figure 5 . 3 state that a QA process must
be de fined and followed. This is how so much quality has been encouraged by the [nternational Standards
Organization (ISO) standard 900 1 "Qua[ity Systems-Model for quality assurance in design, develop­
ment, production, installation, and servicing." Many companies have created documents describing their
of ficial QA process. ISO insists on the existence of such documents for companies seeking its certi fication.
However, [ SO recognized that a documented procedure is only a part of quality assurance. In practice,
documented quality procedures are often ignored with impunity; hence [SO's second principle, which
ensures that employees actually following quality procedures. Quality planning is discussed in more detail
in Section 5.3.
The fourth software quality principle listed in Figure 5 . 4 is to find and fix defects as early as possible : i.e.,
to prevent them from persisting for more than a single phase. Figure 5 . 4 provides data from one of the author's
clients on the relative cost of allowing a defect to persist. Many organizations have tried to measure the
difference in cost, and it is always found to be very large. A rule of thumb sometimes used is that a defect
costing a dollar to find and repair soon after its creation costs a hundred dollars to find and repair if delivered
to the customer. The main consequence of this principle is that it most often pays to spend significant
resources finding and fixing defects as early as possible rather than allowing them to remain undetected and
active.

5.2

MANAG ING QUALITY IN AG I LE PROCESSES

Agile and non -agile projects are equally concerned with producing quality products, but agile methods go
about this in different ways. In particular, agile responses to the principles of Section 5 . 1 are as follows:

1. Focusing continuously on quality
Agile processes fulfill this principle by creating increments from close customer contact, by testing them
during development, and via prearranged customer acceptance tests.

QUALITY PlANNING

2. Defining a quality assurance process
Agi l e processes rely on the activities just listed for a QA process, rather than on documentation such as
the IEEE standards discussed in th i s chapter. Whether thi s is sufficient, especi ally for large proj ects,
remains a subject of debate.
3. Following the organization's quality assurance process

Whether or not one doubts the adequacy of agility for quality in l arge projects, team members are
general1y well motivated, and they usually fol1ow agreed-upon methods very faithfully.
4 . Finding and repairing defects as early i n the development process as possible

Here, agile methods show their greatest strength, since they are code centric and thus try out
implementation and testing of the pieces as soon as it is possible.

5.3 QUALITY PLANNING
We begin pl anning for quality early in the development l i fe cycle. D ocuments are wri tten that define an
overal 1 approac h , including qual i ty goals and techniques for every development phase (the So ftware
Qua l i ty Assurance Plan), how the product wil1 be veri fied and val i dated ( the So ftware Veri fication and
Val i dation Plan), and how testing is planned, spec i fi ed, and reported ( the So ftware Test Documents ) . The
So ftware Qua l i ty Assurance Plan ( S QAP) is described below, the So ftware Veri fication and Validation
Plan (SVVP) is described in Chap ter 9, and the Software Test D ocuments ( STD) are descri bed i n the
testing chapters o f Part V I I .

5.3.1 Software Quality Assurance Plan
The So ftware Quality Assurance Plan (SQAP) specifies the overal l quality plan, policies, and procedures that
will be fol 1owed by the team. It provi des guidel ines so that qual ity actions are not an afterthought but
someth i ng consci ously and del iberately striven for and practiced throughout the devel opment process. It
orients the project toward prevention-defining procedures for proactively monitoring and i mproving
processes and qual ity, ensuri ng that quality practices are defined and implemented, and ensuring that
probl ems are identified and resolved as early as possible. To do th is, the SQAP answers the questions posed in
Figure 5 . 5 .
The rest of thi s section addresses these questions in turn.

1. Who will be Responsible for Quality?
An individual or group is identi fi ed as being responsible for assuring quality on a project. The individual or
group is tasked with ensuring that qual ity is integrated into all activities: their existence does not alter the
princi ple that qual i ty is everyone's responsibili ty. For very small projects, there may be no explicit QA
organi zati on, maki ng QA the responsibility of the proj ect management plan. Large proj ects require several
QA people, led by a QA manager. Sometimes an organization's QA manager is the QA lead on several
projects . For truly large projects, the QA function has its own management hierarchy . In the author's
experi ence, a proj ect requi res roughly one QA person-month for every 3 to 7 devel oper person-months. This
excludes developer testing, which is usually consi dered i nternal because i t requires i ntimate knowledge of the
design and implementation. An example of estimated QA requirements is summarized in Fi gure 5 . 6 .
2 . What Quality Documentation i s Generated?
The SQAP speci fies the documents to be generated for a proj ect and how they are to be checked for accuracy .
Examples of documents are the Software Requi rements Speci fication ( SRS ), Software Design Document

83

84

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

1 . Who will be responsible for quality?
A person, a manager, a group, an organ ization, etc .
2 . What documentation will be generated to guide development, verification and val idation, use and
maintenance o f the software?
3. What standards will be used to ensure qual i ty?

Documentation standards, codi ng standards , etc .
4. What metrics will be used to monitor qual i ty?

Product and process metrics
5. What procedures will be used to manage the qual i ty process?

Meeti ngs, audits, reviews, etc .
6. What kind of testing will be performed?
7. What quality assurance techniques will be used?
I nspections, proofs of correctness, tests, etc .
8 . How will defects be handled?
Figure 5. 5 What's needed from a quality plan

(SOD), Software Veri ficati on and Validation Plan ( SVVP), User Documentati on, and the Software
Con figurati on Managemen t Plan (SCM P ) . The SRS defines the requi rements for the software, and the
SOD describes how the so ftware is designed to meet the requirements. The SRS and requirements are
covered in Part IV. The SOD and software design are covered in Part V.
The SVVP describes methods used to veri fy that the requirem ents specified i n the SRS are the righ t set
of requi rem ents, that the requiremen ts are correctly implemented by the SOD, and that the design in the
SOD is correctly implemented by the code. Veri ficati on methods include i nspection, analysis, and testi ng.
I nspection is described in detail in Section 5.4. User documentation describes how the so ftware shall be
successful ly and correctly used. I t also describes error messages and corrective actions to take as a result. The
SCMP details how changes to software and documents are managed, and is described i n greater detai l in
Chapter 7.

•

1 QA person per 3-7 developers

•

Excludes developer testing counted as developer time

•

I ncludes post-developer testing

•

Ideally perform ed by external QA personnel

Figure 5.6 Typical estimate of QA requirements per developer

QUALITY PLANNING

3. What Standards will be Used to Ensure Quality?
Adopting consistent document templates contributes to the production of qual i ty documentation. The use of
IEEE standard documents-as outlined i n this text, for example-ensures that documents contain all the
necessary content and can be easi ly read and understood by team members .
Coding standards dictate such things as variable and module naming, commenting, and logic structure.
Consistently developed code aids in di fferent team m embers being able to better understand it and make
updates .

4. What Metrics will be Used to Monitor Quality?
The S QAP defines the qual i ty metrics to be collected and analyzed. Examples of quali ty metrics i nclude
defect density, mean time to failure, customer probl ems, and customer satisfaction. Metrics are discussed in
detai l in Chapters 3 and 9 , among others .

5. What Procedures will be Used to Manage the Quality Process?
Meetings, audits , and reviews are some of the techni ques employed to m anage the qual i ty process. They are
described in more detail in Section 5 . 5 .

6. What Kind ofTesting will be Performed?
Both the So ftware Veri fication and Val i dation Plan and the Software Test Documents speci fy the tests to be
executed.
7. What Quality Assurance Techniques will be Used?
I nspections, proofs of correctness, tests, and so on are all techniques used to assure product quality. Section
5.4 i n particular describes the i nspection process i n greater deta i l . Proofs of correctness and testing are
described in thi s book as wel l .

8. How will Defects b e Handled?
As defined in Chapter 2, defects are deviations from requirements . Procedures for i dentifying and managing
them are defined in the S QAP . Defect management is covered in detail in Section 5 .6.

5.3.2 IEEE Quality Docu ments
The IEEE has published several standards related to software qual i ty, as follows :
•

IEEE 730- 2002 : Standard for Software Qual i ty Assurance P lans

•

IEEE 1 0 1 2 - 2004: Standard for Software Veri fication and Val i dation

•

IEEE 8 2 9 - 1 998: Standard for Software Test Documentation

These documents relate to the so ftware development phases as shown i n Figure 5 .7.
Fi gures 5 . 8 and 5 . 9 summarize the contents of I EEE Standard 730-2002 Standard for Software Quality
Assurance Plans . The case study section near the end of this chapter contai ns a sample SQAP for the
Encounter video game.

85

86

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

I

Project Management

I

QAPlan730

I
�

-

-';;;;;;_

1 Explains quality policies

�

""'

�

Requirements
Analysis

I

...-----.

�,

V&V Plan 1012

--

"'­

....... .......

"

\

\

I

/

I
I
I

I
--.J D
I)
esign r
!

Explains verification
and validation procedures ....... __
'\

r

"

.......

-

--

.-------,

Implementation

/

- - - �,-

__
T_e_s_ti_ng
_
8_29
__-,

Explains plans, procedures,
and test cases
Figure 5.7 The main IEEE software quality documents

6 . Reviews

t. Purpose

2 . Referenced documents
3 . Management

3. 1

Organization

3.2

Tasks

3.3

Respon sibil ities

3.4

QA estimated resources

6.1

Purpose

6.2

M i n imum requirements

6.2.1

Software speci fications review

6.2.2

Architecture des i gn review

6.2.3

Detailed design review

6.2.4

V&V plan review

6.2.5

Functional audi t

4. Documentation

6.2.6

Physical audit

4.1

Purpose

6.2.7

In-process audits

4.2

M i nimum documentation requirements

6.2.8

Managerial review

4.3

Other

6.2.9

SCMP revi ew

6.2.10

Post- implementation review

5 . Standards,

practices,

metrics

5.1

Purpose

5.2

Content

conventions,

and

6.3

7.-15. See next figure

Figure 5.8 IEEE Software Quality Assurance Plan table of contents 1 of 2
Source: IEEE Std 730-2002.

Other reviews and audits

INSPECTIONS

7.

Test

m ay reference Software Test Documentati o n .

8.

Problem reporting and corrective action

9.

Tools, techniques, and methodologies

may re ference SPMP.

10.

Media control

11 .

Supplier control

12.

Records collection, maintenance, and retention

13

Training

.

14.

Risk management

may reference SPMP.

15.

Glossary

16.

SQAP change procedure and history

Figure 5.9 IEEE Software Quality Assurance Plan table of contents 2 of 2
Source: IEEE Std 730-2002.

5.4 INSPECTIONS
An inspection is a qual ity techn i que that focuses on reviewing the details of a project arti fact (requirements,
designs, code, etc . ) in an organized and thorough man ner. Inspections are performe d periodically duri ng all
software engi neeri n g phases by the arti fact's author and by other engineers . The purpose i s to assure the
arti fact's correctness by seeki ng de fects . A meeti ng of inspectors is held at which defects are i denti fied. The
repair of de fects is the author's respo nsibility.
The inspecti o n concept was developed by Michael Fagan [ 1 ] while he was at I B M . He observed that the
author of a work is usually able to repair a defect once he recogn i zes its prese nce. Thus , a process is needed
whereby the defects i n a work are called to the author's attention as early as possible. Thi s implies that
i nspections should be a peer process because inspections are performed on work in process rather tha n on
finished product.
S i nce inspections were origi nally i n troduced to improve code, they are often referred to as "code
i nspecti ons," but their value has been shown to be greatest when used early i n the process , long be fore code is
produced . They are used profitably as soon as the first project documents are produced. For example,
requirements specifications, project management, a n d configuration plans should all be inspected.

5.4.1 Inspection Principles
Gui di n g princi ples for conducti ng i n spections are l isted below. The sections that follow describe each
of these:

87

88

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

1. Peer process

2. Spec i fied roles
3. Defect detection i n stead of defect repair

4 . Use of checkl ists
5. Arti fact readi ness
6. Adequate preparation
7. Metrics collection
8 . Time l i m i t

1 . Peer Process
I n spections are conducted by a group of individuals who are fam i liar with the arti fact u nder review. They may
be software engineers, members of other departments such as so ftware quality assurance, marketi ng, sales, or
customers . The i nspection i s a peer process with an overridi ng goal of discoveri ng defects . The work in
progress is under inspecti o n , not the performance o f the author, and therefore it is not a supervisor­
subordi nate process. An author is responsible mainly for the product he or she submits after i nspecti o n , not
before . The work brought to the i nspecti o n should be the author's best e ffort, not a draft.
2. Specified Roles
Inspecti ons work best when spec i fic roles are assigned to each partici pant.
The moderator is responsible for leadi ng the i nspection and seeing that it i s conducted i n a productive and
efficient manner. The moderator schedules the meeti ng and ensure that it starts and ends on time, with the
latter being accomplished by maintaining an appropriate pace through out. It is very easy for parti cipants to
get bogged down i n details and to try to solve problems during the meeting. It i s the job of the moderator to
preve nt th is from happening and to keep the meeti ng movi ng along. However, the moderator must also
ensure that the pace i s not too fast as to miss de fects . When defects are identi fied, the moderator is
respo nsible for ensuri ng that there is consensus from the team. Thus, to be e ffective a moderator should be
tech nically competent. The moderator is also an inspector. The j ob can sometimes i nvolve sensitive i ssues,
such as having to moderate among hosti l e participants with di fferi ng opinions. As described by Wi egers ,
"Moderators should be trained in how to conduct i nspections, i ncludi ng how to keep participants with stro ng
tech nical ski lls but low social ski lls from killing each other. " [2]
The author is the person responsible for the work product itsel f, and repairs all de fects found (o ffli ne).
The author is also an i nspector, looking for de fects along with other i nspectors . In order to avo i d bias, the
author should not serve in any other role. Authors must remain objective throughout the inspection and not
become defensive . This can be hard as others are findi n g "faults" with their work.
The recorder i s respo nsible for writi ng down descripti ons and class i fications of the de fects found,
and for recordi ng the acti o n i tems. I f the i n s pection team i s very small, the moderator could also take on
th is rol e , but i t usually i s best to h ave someone else assume thi s respon s i b i l i ty . The recorder i s also an
i n spector.
A reader i s responsible for leading the team through the work in an appropriate and thorough man ner.
Th is person selects the most effective sequence for presenting the work product and answer questions posed
by the i nspection team. The reader i s also an inspector. I n many cases, the role of the reader is handled by the
moderator or author.
An inspector is a partici pant who attempts to i denti fy defects i n the artifact under review.

INSPECTIONS

All participants in an inspection act as inspectors, in addition to any other responsib il ities they may
h ave . It is important to invite people who can make a significant contribution and h ave the expertise to
identify defects to the inspectio n . Examples of people who should atten d are other project members, those
responsible for testing or m aintaining the product, and depending on what artifact is being developed,
customer and business representatives. Depending on the artifact being inspected, there may be a
requirement for specialized inspectors . For example, a focused inspector inspects for a specific criterion
( e . g . , rel iabil ity) . A specialized inspector is a specialist in the area covered by the artifact under inspection
( e . g . , a radar expert for a radar control applicatio n ) .

3. Defect Detection, not Defect Repair
Inspections should focus on identifying defects, and specifically exclude any discussion of their repair. The repair
process is left to the author, and no time should be spent during inspections even suggesting repairs. All repair
suggestions should be made offline. This is typical\y one of the hardest things to control-many participants love
to discuss potential solutions and it is quite easy to fal l into interminable technical discussions regarding the best
approach. This is where a strong moderator is essential . It is key to not let this type of discussion continue and
instead to remind people that the goal of the meeting is to identify defects, not repair them.
4. Checklists
A checklist can be very useful in providing guidance to inspectors , describing specific areas to pay attention
to. Each type of artifact such as project plan, requirements specificatio n , design specification, configuratio n
management plan, source code, and so on should have its own checklist, as each requires different areas of
focus . Example ques tions to ask when examining a requirements specification might be as follows : I s each
requirement verifiable by testing? I s each requirement uniquely identified? For code inspections, questions to
ask might be: Are there any variables that are unused or redundant? I s the code adequately commented? Good
examples of checklists can be found in [3].
5. Artifact Readiness
The artifact under review should be in the best state of readiness that the author is capable of. For documents
there should not be many, if any, sections with "to be determined." Code should compil e cleanly. When a
group of people takes time to identify a defect that the author woul d h ave found with reasonable effort, a
significant amount of time is wasted.
6. Adequate Preparation
Inspections are not the same as reviews , management overviews, or education sessions. Inspectors h ave to
work at the same level of detail as the author. (This is what makes inspections time-consuming and thus
expensive . ) The artifact unde r review is distributed several days before the meeting, allowing inspectors
adequate time to study the material, identify defects, and prepare questions to ask at the inspectio n .
Inspectio n - aiding software c a n save time b y all owing inspectors t o enter descriptions o f defects they discover
while preparing. The recorder accesses and edits these at inspection meetings .
7. Metrics Collection
Duri n g i nspections, metrics are collected and analyzed. Examples of metrics to collect are as follows :
•

Number of defects discovered, by severity and type

•

Number of defects discovered by each category of stakeholder inspecting the artifact

89

90

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

•

Number of defects per page reviewed

•

Review rate (number of pages/hour)

For severity, a simple class i ficati o n such as trivial, minor, and severe can be used. For type, categories such as
missi ng function, i ncorrect function, performance, and usabil ity can be used. Th is classification to pic is
di scussed i n Secti on 5 . 6. 1 .
The metrics coll ected from i nspections are analyzed and the results used for several purposes . First, they
are used to predict the e fficiency of future reviews . If a company has i n formation on the rate of review for a
parti cular arti fact, it can use that to predict how long to schedule for a future review of a similar artifact.
Second, counti n g the number of de fects discovered duri n g each stage of development is useful i n predicti n g
the number of defects i n future projects. Even more speci fic, counti ng the number of defects di scovered by a
particular stakeholder (e . g. , marketi ng, customer, QA) is also useful. For example, i f duri ng a requi rements review
fewer th an expected de fects are discovered by the customer representative , it could i n dicate either a lack of
preparati on or misunderstanding o f requirements by that perso n . In either case, th is would raise a red flag and
a foll ow-up meeti ng with the customer would ensue to understand the cause for the discrepancy.

8. Time Limit
Inspections should not be marathon sessi ons, which can occur i f the moderator does not keep the meeti ng
moving along. After a certa i n amount of time, participants will not be as focused as needed. Each session
should be kept to a maximum of two hours, and i f it is not completed by then a follow-up session should be
reschedul ed.
5.4.2 Inspection Process
The i nspection process fol lows an orderly flow of steps, each adheri ng to the pri nciples described above . The
steps are summarized in Fi gure 5 . 1 0 .

..I Overview 1
}

/

Non-nominal
process

Nominal
process

Figure 5.10 The parts of the inspection process, emphasizing the main sequence of activities

INSPECTIONS

The process begi ns with plan n i ng. Thi s i ncludes deciding which inspection metrics to collect,
i dentifyi n g tools to be used i n recordi ng and analyzing these data, deciding who will participate in
inspections and when they will take place, and distributing the materi als several days prior to the
meeting. Typically, the moderator i s responsible for these tasks .

t. Planning.

lA. Overview meeting. I f necessary, an overview meeting can be organized to expl ain the arti fact
under i nspecti o n . S i nce meetings are expensive , this shoul d be avoi ded unless obvi ously necessary.
2. Preparation. The next step for each inspection consists of preparation . Here, i nspectors review the work
in complete detai l at their own workstations (e.g. , checking that the code under inspection correctly
implements the detailed design ) , possibly us ing checklists provided for guidance . What makes the
i nspection process valuable, but also expensive, is the fact that thi s time-co nsum i n g process is performed
by several people i n complete detail . The process i s not a "review," because i nspectors work at the same
level o f detai l as the author. I n spec tors frequently enter the defects they find i nto a database (e.g. , Web­
accessible ) together with descriptions and classi fications. This helps to prevent duplication, and it
m i n i m izes u n necessary meeting time. Some prefer to use paper to record thei r defects, and some consider
the number of i nspectors who recogni ze a give n defect to be a useful metric.
3. Inspection meeting. When every participant i s prepared, the inspecti on meeting takes place . Duri ng th i s
meeti ng, t h e participants h o n o r thei r design ated roles. O f particular importance i s to not try and solve
problems that are raised, but instead to ensure that they are recogn ized as defects , to record them as
action i tems only, and to move o n .
4 . Rework. Normally, the author is able t o re pair a l l defects , working alone . Th is is the rework phase . I f the
i n spectio n meeting dec i des, however, that the defects are so pervasive that a rei n spection is required,
then the i tem is recycled through the process.

4A. Causal analysis. I f the defects are due to a misunderstanding or widespread m i sconception, i t may
be necessary to call a separate meeting at which these causes are analyzed and discussed. Agai n ,
si nce meetings are expensive, these should not be scheduled casual ly.
5 . FolIow-up. After the author repairs the defects identified duri ng the i nspection meeting, a brief follow-up
meeti ng i s conducted at which the moderator and the author con firm that the defects have indeed been
repaired. Thi s is not i ntended to be a detai led review by the moderator. The onus for repair is on the author, who
is responsible for the work. I f the number of defects repaired is h igh, a follow-up i nspection may be required.
6. Improve process. Organizations should always an alyze the e fficacy of their processes and strive to
improve them . For i nspections, the group meets from time to time to review the i nspection process itself,
and deci des how it can be improved. They exam ine the metrics collected, i ncludi ng the list o f defects ,
and dec i de how the devel opment process can be im proved to reduce and/or preven t the same types of
defects in the future .
Figure 5 . 1 t shows the average relative times for each inspection process step, used as re ference data by
one of the autho r's clients .
The i nspectio n meeting t i m e i n Figure 5 . 1 1 is shown a s o n e hour for the sake of reference. I n dividual
companies or development groups record i nspection times and quantities inspected, and they estimate future
i nspections based on these historical data. The times shown in Figure 5. t I may disturb the uninitiated, who
may won der whether it really does take that long to check code . Produci n g pro feSSional - qual ity products
does i n deed take a substantial amount of time, and any fai lure to recogn ize the true costs ends up consuming
far more time i n the end. I n spections have been estimated by Gehani and McGettrick [4] to consume as much
as 1 0 - 1 5 percent of the development budget.

91

92

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

Planning

1 hr x(1 person)
1 hr x (3-5 people)
1 hr x (2-4 people)
1 hr x (3-5 people)
1 hr x (1 person)
1 hr x (3-5 people)

One company's estimates

Overview
preparation
Inspection meeting
Rework

Analysis
Total:

7-21 person-hours

Figure 5.1 1 Inspection time/costs per 100 non-commented lines of code

Inspections are expensive because they consume the time of several engineers . Nevertheless, various
studies ( for example, [ 1 ]) have shown that they pay off handsomely. This is due to the astronomical cost o f
detecting and repairing defects undiscovered until close t o delivery time. Quan tified benefits of inspections
from sources such as IBM, lel, and Standard Bank, for example, are summarized in [5] .
Appen dix D of the case study shows an example of a form for reporting the results of an inspectio n .

5.5 QA REVIEWS AND AUDITS
The QA organization works with the project leadership to define the manner in which external quality
assessment will be performed, specifies this in the S QAP, and executes it during the course of the project.
External QA activities are either reviews ( sometimes called walk-throughs), which are scheduled in advance, or
audits, which are not so scheduled. A project can expect both types of activities. Figures 5 . 1 2 and 5 . 1 3 show the
range of options for QA involvement in reviews and audits, starting from the most invasive to the least.
•

•

•

•

Participate in all meetings
Including formative sessions and inspections.
Review all documents
Participate in all inspections
(but do not attend all meetings).
Attend fi nal reviews and review all completed documen ts
Review select compl eted documents
But do not participate otherwise.

Figure 5.1 2 Options for QA reviews

•

Audit at unrestricted random times
Includes visiting with engineers.
Includes inspecting any document at any time.

•

Audit random meetin gs

•

Audit randomly from a specified list of meetings

•

Audit with notice

•

No auditing

Figure 5.1 3 Options for QA audits

DEFECT MANAGEMENT

Benefits of Freguent Intervention

Costs of Freguent Intervention

© Helps in assessing project

®Time needed to get

status

documents ready

© May help to improve process

® Engineer time taken to explain

or project

® QAtime

1\

1\

6

Figure 5.14 Comparing frequent vs. occasional QA intervention

Frequent intervention by QA has the advantage of providing QA personnel with greatly improved
understanding of the health of the project, but it may disrupt the proj ect by frequently call ing for documents
or for engineers' time. This trade-off is summarized in Figure 5 . 1 4 .

5.6 DEFECT MANAGEMENT
Projects encourage the submission of defect reports by all team members . Usually, a screening process that
ensures defect reports are val id and accurate is put in place . To manage defects, QA standardizes on the
manner in which defects are defined and tracked. These data can then be compared between differe nt
projects so that estimates can be made regarding new projects . We expl ain this standardization next.

5.6.1 Classifying Defects
Teams classify each defect by its severity (how serious it is) , priority ( in dicating when it wil l be handled), its type
(the kin d of problem) and its source ( the phase during which it was injected) . These classifications are
illustrated in Figure 5 . 1 5 .

• Severity

How serious is the defect?
• Priority

In which order will defects be repaired?
• Type

What kind of problem is involved?
• Source

During which phase
was it injected?

Figure 5.15 Defect classification

/I

DeSign

I Implementation I
I Testing I
I Maintenance I

93

94

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

No more than two decisions are required.

else

else

Defect severity is major

Defect severity is trivial

.----{ 2

Classify as "medium"

Classify as "major"

Classify as "trivial"

Figure 5.1 6 The triage decision method applied to defect severity classification

A single severity classification scheme can be used fo r all artifacts. It is possible to be very discriminating
among levels of severity, but this consumes time. The results should be worth the time. One of the authors has
frequently encountered teams using di scriminating classification schemes that consume signi ficant decisio n ­
maki ng time and yet the data that they produce are n o t util ized by t h e organization .
Deci di ng the severity level of a defect falls into can sometimes be difficult. Triage is a useful and simple
decision-making technique when con fronted with a large number of possib i l ities, a situation occurri ng often
in so ftware engineeri ng. Utilizi ng triage for defect cl assification has the advantage of being fast to perform
because each classi ficatio n requires answering just one or two questions as shown in Figure 5 . 1 6. O nce a list of
defects develops , the team approaches the major ones first ( they can be placed in order with the "major"
category if necessary) . Once they have been atten ded to, the medium severity defects can be handled. The
team gets to the trivial ones only after this, if time allows.
A simple way to classify the severi ty of defects when us ing tri age is shown i n Figure 5. 1 7.
Although triage is fast, the three-category classi ficati on lum ps together all defects that fail requirements,
whether serious or not. Thus, "name field is not purple, as required" and "system crashes every mi nute" (a
"showstopper" si nce i ts effects are catastrophic for the applicatio n ) are given the same severi ty, which is rather
extreme. Showstoppers usually need to be separated. To address this, the IEEE has de fined a more refi ned
classificati on of defect severity as shown in Figure 5 . 1 8 . The "None" category is added to collect un priori tized
defects .

•

Major

Causes a requirement to be unsatisfied.
•

Medium

Neither major nor trivial.
•

Trivial

Defect doesn't a ffect operatio n or maintenance .
Figure 5.17 Classifying defect severity by triage

DEFECT MANAGEMENT

•

Urgent

Failure causes system crash , unrecoverable data loss, or jeopardizes person nel .
•

High

Causes impairmen t of critical system functions, a n d no workaroun d solution exists.
•

Medium

Causes impairment of critical system functions, though a workaroun d solution does exist.
•

Low

Causes i nconven ience or annoyance .
•

None

None of the above .
Figure 5.18 IEEE 1044.1 severity classification

A defect's priority is the order in which the team plans to address it. Th is is somewhat aligned with the
defect's severity but is not i dentical . For example, a defect can be classified as "urgent" but it may not be
necessary to repair it immediately. For the sake of project efficiency, for example, its repair may be batched
with a set of repairs to the same part of the product.
Different phases use differe nt defect type classifications. For example, a defect in the requirements may
concern ambi guity but "ambi guity" does not apply very well to code . On the other hand, code m ay have a
logic defect but "logic" does not apply to requirements i n the same way . Some types of defects are common to
all artifacts, as listed in Figure 5 . 1 9 .
The source of a defect is the phase i n which it was i ntroduced (or injected). For example, you may discover
while testing a video store application that it does not-but should-accept the video It's A Mad, Mad, Mad,
Mad World because the requirements document stated that no word in a title should be repeated more than
once (supposedly to preven t bad data entry) . Even though the defect may have been discovere d duri n g the
testi n g phase, its source phase was requirements analysi s .

5.6.2 Tracking Defects
Table 5 . 1 shows a typical way to track known defects . The information is used to manage ongoing work and
to record defect history for postmortem and estimation purposes.

•

Omission

Someth i n g is missing.
•

Unnecessary

The part i n question can be omitted.
•

•

Nonconformance with standards
Inconsistency

The part i n question contradicts other partes).
•

Unclassified

None of the above .
Figure 5.19 Common defect types across all artifacts

95

96

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

Many bug-tracking programs are indispensable in tracki n g and managi ng defects. Bugzilla is an exam ple
o f an open source defect- tracking syste m . I t was originally wri tten by Terry Weissman. Bugzilla features
incl ude the following:
inter-bug dependencies, depende ncy graphing, advanced reporting capabilities exte nsive con­
figurability, a very wel l -understood and wel l - though t-out natural bug resolutio n protoco l , emai l ,
XML, console, a n d HITP APls. ( It is) avai lable integrated with automated software con figuration
management systems, i ncludi n g CVS [6].
Appendix B of the case study contains an exam ple o f the way in which defects can be reported, and
Appendix A contains an example of the way i n which they can be tracked.

5.7 PROCESS IMPROVEMENT AND PROCESS METRICS
Even a very good process has to adapt to changes such as new technology and new kinds of requirements. For
these reasons, very e ffective software development organizations include a meta-process with every software
process : a process for improving the process i tsel f. This usually takes the form of meetings at the end of phases
to review the effectiveness of the process used with a view to improvin g it for future projects. A meta- process
is outlined in Figure 5. 20.
To measure the e ffectiveness of a process, an organization has to use it for several proj ects and then
compare the proj ect metrics. Table 5. 2 gives an exam ple.
These results suggest that process U is the most effective , si nce i t produces the best results in every
category. Process V is the worst for the opposite reason s . Matters are not o ften so simple, however. For
example, suppose that we had to choose between Waterfall and "Waterfall + I ncrementaL" The latter process
is superior in defect count, developer cost, and customer satisfactio n , but it scores worse in the other
categories. Making the call depends o n the relative importance of the factors to the organi zatio n .
Figure 5. 2 t lists a sequence of actio ns that c a n be taken throughout the l i fe of a proj ect i n order to
con tinually improve the process.
Figure 5. 22 is an example of the kind of data that can be collected about the process . I t is applied to the
process of collecting detailed requirements, which is covered in Part IV, but the table is applicable to most
phases. The numbers are illustrative only, and should not be regarded as in dustry standards. A comparison
with the organ ization's normative ( typical) data reveals deficiencies in the team's meeting process and i n their
individual execution ( i. e . , the actual writing process). This exposes problems in meetings , for exam ple, which
were subjectively evaluated 2 out of 10 by the team . I t was determined ( though not visible in the data) that the
meeti ng process would improve if the straw man proposal brought to the meeting was more complete i.e. an
explicit proposal that can be used as a basis for discussio n .
The other problem observed i n the example shown i n Figure 5. 22 seems to occur during the execution
step, where the actual work of writing the requirements is performed. The defect rate is higher than normal
(5 versus 3) and the sel f-assessed quality is a li ttle below average ( 4). Compared with company norms, there
appears to be room to spend more time executing the work ( i. e . , as individuals), thereby reducing the defect
coun t and improving the subj ective self-assessment. You can observe from th is process that a stan dard for
counting the parts of the phase is fundamental to our ability to measure it. In this case, we are counting
"detailed requirements," a concept that will be explained in Chapter 4.
Even in the absence o f historical data, the team predicts what the values of the metrics should and will
be. With these advance predictions, teams tend to work better, and they tend to remember results . The data
collected become the basis for future historical data . Managi n g all of this is not technically difficult, but it has

Checkout screen 4
flickers when old
DVDs are checked
out by hitting the
Checkout button.

Checkout flicker

Bad fine

1

2

. ..
.. .

.. .

.. .

.. .

...

. ..

.. .

. ..

Fine not correct for
first-run DVDs
checked out for 2
weeks, as
displayed on
screen 7.

Description

Name

No.

.. .

.. .

. ..

Fannie Croft

Kent Bain

Discovering
engineer

Table 5.1 A typical way to track known defects

...

...

. ..

April Breen

Fannie Croft

Responsible
engineer

.. .

.. .

. ..

1/4/06

1/4/04

Date
opened

Defect Tracking

.. .

.. .

., .

Requirements

I ntegration

Source

.. .

. ..

...

High

Med

Severity

. ..

. ..

...

Math

GUI

Type

. ..

Resolved

Tested with suite
9023

Not worked yet

Being worked;
begun 2/10/04

Status

I

i

I

II

!

-0
'-I

Vl

()

;:0

�

s:

Vl

�

�
o

"'0

s:
m
Z
-t
»
z
o

m

�

"'0

�

Vl

�

"'0

�
o

98

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

Metric data
on multiple
projects
using the
process

Figure 5.20 The process improvement meta-process

to be done at the same time as many other urge nt activities . For this reason , the assignment of clear
responsibil ities and the regular review of the metric data are worked out at this early stage in the process. As
you will see in the next sectio n , process im provement feedback separates great devel opment organizations
from merely good ones.

Table 5.2 Data from multiple projects used to compa re processes

Waterfall

Waterfall +
Incremental

Process U

Process V

Major defects identified within first 3 months per 1000SLOC
in delivered product

1.3

0.9

0.7

2.1

Development cost per detailed requirement

$120

$100

$85

$135

Process

->

Average over 10 projects:

Developer satisfaction index (1 to 10

=

best)

4

3

4

3

Customer satisfaction index (1 to 10

=

best)

4

6

6

2

Cost per maintenance request

$130

$140

$95

$165

Variance in schedule on each phase:

+20%

+70%

-10%

+80%

+20%

+65%

-5%

+66%

23%

51%

66%

20%

100 x

�

actual duration - projec ed duration
projected duration

Variance in cost:
100 x

actual cost - projected cost
projected cost

Design fraction:

total design time
total programming time
Humphrey: Should be at least 50%.

PROCESS IMPROVEMENT AND PROCESS METRICS

1 . Identify and define metrics team wil l use by phase.
Include . .

.

time spent on research, execution, and review
size (e. g., lines of code)
number of defects detected per unit (e. g., lines of code)

include source
quality self-assessment of each on scale of \-10

maintain bell-shaped distribution
2. Document these in the S QAP .
3 . Accumulate h istorical data by phase.
4 . Decide where the metric data wil l be placed.
As the project progresses S QAP? SPMP? Appendix?
5. Designate engineers to manage collection by phase .
QA leader or phase leaders ( e . g. , design leader)
6. Schedule reviews of data for lessons learned.
Specify when and how to feed back improvement.
Figure 5.21 A process for gathering process metrics

Personal

Requirements Document:
Meeting

Research

Execution

Review

Inspection

Hours spent

0.5 x 4

4

5

3

6

% of total time

10%

20%

25%

15%

30%

% of total time: norm for the
organization

15%

15%

30%

15%

25%

Self-assessed quality 1-10

2

8

5

4

6

Defects per 100

N/A

N/A

N/A

5

Q

Defects per 100: organization
norm

NIA

NIA

NIA

3

4

Hours spent per detailed
requirement

0.01

0.02

0.025

0.015

0.03

Hours spent per detailed
requirement: organization norm

0.02

0.02

0.04

200 detailed requirements

�

Process improvement

+

Improve strawman

Spend 1 0%

brought to meeting

more time

+

0.01

executing
Summary

productivity: 2 00/22 = 9.9 detailed requirements per hour

Figure 5.22 Collecting project metrics for phases

0.03

99

1 00

CHAPTER 5

QUALITY IN THE SOFlWARE PROCESS

5.8 ORGANIZATION-LEVEL QUALITY AND THE CMMI
Software development organ izations periodically assess and upgrade their overall capabil i ty . I n the 1 980s the
non profit Software Engineering I nstitute ( S E I ) establ ished a classificatio n of capabilities for contractors on
behalf of the U.s. Department of Defense (000). The DoD's plan was to restrict bi dding on govern ment
so ftware development contracts to contractors with specified capab ility levels. The SEI's system, now
expanded i nto the Capability Maturity Model Integration (CMM I ) , succeeded i n providing concrete software
engineeri n g competence goals for organizations. Actually, the scope of CMM I is larger than software
engineeri n g, but we will restrict our attention to the latter, termed CMMI-SW. Many organ izations, de fense
and commercial alike, have used the CMMI and its predecessor, the CMM, to assess the quality of their
development process.
So ftware development organizati o n s are assessed at a CMM I level betwee n 1 (worst) and 5 (best) .
The CMMI disti n guishes two k i n ds of assessments: staged a n d continuous. The staged assessm e n t consi sts
o f identifiable step s . We will not discuss the con tinuous ki nd here . The CMM I classi fies staged
orga n izati onal capabil i ty with the steps shown in Fi gure 5 . 2 3 ( from [7] ) . These are el aborated o n in
Table 5 . 3 .

5.8.1 Level 1 : Initial
The "I n itial" CMMl level is the most pri m i tive status that a so ftware orga n i zation can h ave . Organizations
at level 1 can be said only to be capable of producin g software ( i . e . , "someth i n g") . The orga n i zation has no
recogn i zed process for so ftware production, and the qual ity o f products a n d proj ects depends entirely on
the i n dividuals perform i n g the des ign and im pleme ntatio n . Teams de pend o n methods provided by
members o f the group who take i n i ti ative on the process to be fo l l owed. From project to project, these
could be very good or very poor. The success of one project has l ittle relation to the success o f another
unless they are similar and employ the same so ftware engineers. When a proj ect is completed, noth i n g
is k n o w n or recorded about its c o s t , schedul e , or qual i ty . N e w proj ects are as u ncerta i n o f success a s
p a s t ones .
For most organizations, this is unacceptable.

Increasing
maturity

Figure 5.23 CMMI model for organization with staged processes

ORGANIZATION-LEVEL QUALITY AND THE CMMI

Table 5.3 SEI specifi cations of capabilities requi red for each level (see [7] for a full description)
Expected Outcome

Characteristics

Undefined; ad hoc

Unpredictable; depends entirely on
team individuals

Organizations often produce
products, but they are frequently over
budget and miss their schedules.

2. MANAG ED

Preceding level plus:

Measurement and control

Project outcomes are qualitatively
predictable

3. DEFINED

Preceding level plus:

Processes standardized

projects consistent across the
organization; qualitatively predictable

4.QUANTITATIVELY MANAG ED

Preceding level plus:

Processes measured

Metrics available on process;
quantitatively predictable

5. OPTI MIZING

Preceding level plus:

Improvement meta-process

Processes improved and adapted
using process metrics

Level, Title, and Summary
1. I N ITIAL

Respect organizational policies
Follow established plans
Provide adequate resources
Establish responsibility and authority
Provide training
Establish configuration management
Monitor and control: Take corrective
action
Evaluate process and product relative
to plans: address deviations

Establish process objectives
Ensure process objectives met
Establish orderly tailoring
Describe processes rigorously
Be proactive

Set quantitative goals for key
subprocesses
Control key subprocesses with
statistical techniques
Identify and remedy variants

Establish quantitative process
improvement objectives
I dentify and implement innovative
process improvements
Identify and implement incremental
process improvements
Evaluate process improvements
against quantitative objectives

101

102

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

5.8.2 Level 2 : Managed
The "Managed" CMMI level applies to organizations capable of tracking proj ects as they unfold. Such
organ izations make plans, manage configurations, and maintain records of project costs and schedules. They
also describe the functionality of each product in writing. It is there fore possible to predict the cost and
schedule of very similar projects performed by a very similar team .
Although level 2 organ izations track projects, no standard development process for the organizatio n is
guaranteed.

5.8.3 Level 3: Defined
The "Defined" CMMI level applies to organ izations that document and enforce a standard process. Such a
process is typically one of those described in the previous chapters (waterfall, spira l , etc . ) . Some organiza­
tions adopt existing standards such as I EEE's, while others define their own. Roughly speaking, as long as
management en forces coordinated, professional stan dards , and engineers implemen t them uniformly, the
organ ization is at level 3. Training is typically required for a n organ ization to reach level 3. Teams are allowed
flexibil ity to tailor the organization's stan dards for special circumstances. Level 3 includes organizatio n -wide
stan dards for project management, complete configuration manageme nt, inspections, design notatio n , and
testing.
Level 3 organizations lack general predictive capability. They are able to make predictions o n ly for
projects that are very similar to ones performed in the past.

5.8.4 Level 4: Quantitatively Managed
The "Quantitatively Managed" CMMI level applies to organ izations that can predict the cost and schedule of
jobs. A common way to do this is to use statistical tech n iques and historical data . Such an organizatio n
classifies jobs and their components; it measures and records the cost and time to design and implement these;
the n it uses these metric data to predict the cost and schedule of subseque nt j obs. As Humphrey has pointed
out, this is not "rocket science," but it does require a significant amount of organ izatio n , as well as a n ability to
analyze the data . Level 4 requires a complete, metric-oriented qual ity plan .
Even though level 4 is a high level of cap abil ity, it is not the h ighest. Software engineering changes rapidly.
For example, the object-orie nted paradigm made rapid inroads in the 1 990s : reuse and new component concepts
are having a growing impact. Future improvements and paradigms are unpredictable. Thus , the capabilities of a
level 4 organization that does not adapt and improve m ay actually decline over time.

5.8.5 Level 5: Optimizing
Rather than trying to predict future changes, it is preferable to institute permanent procedures for seeking and
exploiting new and improved methods and tools. Level 5 organ izations, at the "Optimizing" CMM I level,
buil d in process improvement. I n other words, their process ( actually a meta- process) includes a systematic
way of evaluatin g the organ ization's process itself, investigating new methods and tech nol ogies, and then
improving the organization's process . Many orga nizations aspire to this impressive capabil ity .

5.8.6 Relationship of the CMMI to the PSP, TSP
As we have see n , the CMM I is a measure of capab i l i ty at the organizational/corporate leve l . Watts Humphrey
and the Software E ngineering Institute have also defined coordinated process models at the team level and at

CASE STUDY: SOFTWARE QUALITY ASSURANCE PLAN FOR ENCOUNTER

the individual engineer leve l . These are called the Team Software Process (TS P ) and the Personal Software Process
( P S P ) , respectively. The PSP, TSP, and CMMI frameworks form a relatively coordinated set of capabilities
and procedures at the i ndividual , team, and organizational levels, respectively. We will describe the TSP in
the project management chapters and the PSP i n the implementation chapters .

5.8.7 Relationship of the CMMI to Agile Methods
CMMI appears to be almost contradictory to agi l i ty because it is process heavy . H owever, CMMI and agi l i ty
are at di fferent levels. CMMI is used to assess the capabi l i ty of organ izations as a whole to produce good
applications. Those that use agile methods are just as i n terested in such an assessment as those that are not,
and i t is reasonable to assume that CMMI will evolve to assess development organi zations of all kinds .

5.9 CASE STUDY: SOFTWARE QUALITY ASSURANCE PLAN FOR ENCOUNTER
The So ftware Qual ity Assurance Plan (SQAP) for
Encounter is based on IEEE Std 7 3 0 - 2 0 0 2 Standard for
Software QualityAssurance Plans. The table of contents
was outl i n ed in Figures 5 . 8 and 5 . 9 .
ENCOUNTER SOFTWARE QUALITY
ASSURANCE PLAN

The author is indebted to his students for inspections of this
document and for their improvements to the original.
Note to the Student:
Organizations usually have a stan dard quality
assurance procedure . The SQAP for each
project relies on this and provi des project­
specific QA plans. We will effectively combine
two such documents here .

The table of contents of thi s SQAP follows that
of IEEE standard 730- 2002 in most essentials.
Revision History

This assumes the existence of a method
whereby revision numbers of documents are
assigned .

Version 1

1 . 0 . 0 E . Braude : created 1 / 1 7/99
1 . 1 .0 R. Bostwick: reviewed 5/3 0/99, added
substance to Sections 7 through end
1 . 1 . 1 E . Braude : i n tegrated and revised contents
5/3 1 /99

Approvals:

Version 2

Title

Signature

Date

2 . 0 . 0 E . Braude : signi ficant edits of Section 5 . 2
1 / 1 8/04

Engineering Ma nager

9'. �

611 5104

2 . 0 . 1 E. Braude : edits 1 /2 3/04

QA Manager

£ Wif.ewz

611 1104

2 . 1 . 0 E. Braude : edits in m any sections respond­
ing to reviews by students 6/ 1 7/04

project Manager

a. 9''Ulitt

617104

Author

E. 91'UUUk

611104

Table of Contents
1 . Purpose
2. Referenced Documents

103

1 04

CHAPTER 5

QUALITY IN THE SOFlWARE PROCESS

3 . Management
3 . 1 Organ ization
3 . 2 Tasks
3 . 3 Responsib i l i ties
3 . 4 QA Estimated Resources

Typically, most of the content of a SQAP are
common to all of the organization's projects .
Engineers would need simply to tailor parts to
the project in questi o n .

4. Documentation
4 . 1 Purpose
4 . 2 M i n i mum documentation requirements
4 . 3 Other
5 . Standards
5 . 1 Purpose
5 . 2 Content
6 . Reviews
6. 1
6.2
6.3

Purpose
Minimum requirements
Other reviews a n d audits

7. Test
7. 1
7.2
7. 3
7.4

U n i t Test
I n tegration Test
System Test
User Acceptance Test

1 . Pu rpose
This document describes the means by which the
Encounter project will produce and mai n tai n a high­
quality product . I t is also i n tended to describe mech ­
anisms for im proving the qual i ty assurance process
i tself. "Quality" is defined as the degree to which the
application satisfies i ts requirements.

There is no separate "scope" secti on in the
IEEE stan dard, so we have i nserted it here .
"Scope" contai ns vi tal i n formation such as
whether this document applies to the first
release only or to mai ntenance as wel l .

8 . Prob lem Reporti ng and Corrective
Action

The scope o f this document com prises the
arti facts of all releases.

9 . Tools, Techni ques, and
Methodology

2. Referenced Documents

1 0 . Media Control

See Section 4 . 2 .

1 1 . Supplier Control
1 2 . Records Collectio n , Maintenance,
and Retention

3 . Management

1 3 . Tra i n i n g

3 . 1 O rga n ization

1 4 . Risk Management
1 5 . Glossary
1 6 . Sqap Change Procedure and
History
Appendix A - Metric H istory for this
Proj ect
Appendix B - Problem Reporting Form
Appendix C - Change Reporting Form
Appendix D - I nspection Meeti ng
Report Form
Appendix E Documen t Baseli n i n g
Checkl ist
-

State the roles that are i nvolved i n ensuri ng
qual ity. Actual names are provided i n Section
3 . 3 . The process described in th is case is a mix
of internal and external quality assurance.

This section assumes the description of the
organ i zational structure of the Encoun ter project
i n 4.2 of the SPMP.
Th is document will refer to the qual i ty work of
developers as "interna1 ." I n addition , for the first three
iterati ons of Encounter, a qual i ty assurance engi neer

CASE STUDY: SOFTWARE QUALITY ASSURANCE PLAN FOR ENCOUNTER

will be designated who will be responsible to the
manager o f QA. The QA leader will take the lead for
project-wide quality issues. QA tasks will be referred
to as "externa1 . "

External QA tasks shall include, for all i terations:

•

•

•

•

•

•

•

•

•

•

Maintaining thi s document
Documen ti n g the qual ity of the evolving product
and associated arti facts
Managi ng external review meetings
Ensuring that veri fication takes pl ace and loggi ng
veri fication
Preparing for and attendi n g all inspections
Post-uni t testing
Documen tation

as

per

the

Software

Test

Engagin g i n activities designed to improve the
qual ity assurance process itself
Keeping the proj ect leader apprised of QA prog­
ress through weekly written reports
Carryi ng out the audits specified in Section 6 of
this document
Providing the development team with feedback
from QA's activi ties
Assign defect repair to so ftware engineers
I dentifying methods and tools for collecting and
maintaining metrics
Internal QA tasks shall include , for all iterati ons:

•

•

•

Unit testing as per GCI manual 02 3 . 2

State what roles will ful fill what job functi ons.

Sum m arize what needs to be done .

•

•

Carrying out the reviews and inspections specified
i n Section 6 o f this document

3 . 3 Responsibil ities

3 . 2 Tasks

•

•

Each team member responsible for the qual ity of
his or her work, as defined in th is document
Maintaining an issue database
Collecting the metrics designate by th is and other
project documents

I t is the quality assurance leader's responsibility
to see to it that the tasks in Section 3 . 2 are performed
and to ensure that the prescriptions in this document
are followed, i ncludi ng scheduling the reviews spec­
i fied. For the first three i terations, the QA leader will
perform all of the qual ity control ( QC ) functions.
For subsequent iterations, the QC team,
appointed by the QA department manager, will
take over this function. The qual ity leader and the
QC team are responsible for all non-unit testing.
( See Part V I I of the book for background i n formatio n
on these types of tests ) . A description of t h e QC
team will be supplied.
The project leader will be responsible for
ensuri ng that inspections and unit tests are per­
formed. The schedules are to be placed i n the SPM P .

No names are assigned t o these roles here
because they are in the Software Project Man ­
agement Plan, which is their proper place .
Duplicating a name here woul d require us to
update m ore than one document when there
are changes .

The leaders designated in the SPMP are re­
sponsible for the qual ity of their respective areas
( requirements, design , etc . ) . They shall ensure that
the designated metrics are collected and that the
quality self- assessments as outlined in Section 5 . 2 of
this document are conducted.
Each member of the Encounter development
team is responsible for quality as speci fied i n Section
4.5 of the company document "Quality responsibil i ­
ties of engineers a t GCI . " This includes testing
i ndivi dual methods and combinations o f methods
i n a class ("un i t testing" ) .

105

1 06

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

3 . 4 QA Esti mated Resou rces

The estimated resources required for QA on Encoun­
ter are as follows :
•

•

•

•

One engi neer working half time for the first th ird
of the project
One engi neer working full time for the second
th ird o f the project
One engineer worki ng full time for the last third of
the project
An additional engineer working half time for the
last thi rd of the project

•

•

•

Software Veri ficati on and Val i dation Plan (SVVP)
Software Veri fication and Val i dation Report
(SVVR) (Note: Th is book does not cover the
SVVR. )
Maintenance Plan

I n addition to these documents, the Java source
code will uti l i ze lavadoc to generate package - , c1ass - ,
a n d function - level docume ntation . (See http ://j ava .
sun.com/j 2se/javadocl for Javadoc speci fications . )
4 . 3 other

-i ntentionally left blank

4. Documentation
4 . 1 Purpose

The purpose of this section is to identify the docu­
mentation that will be used to ensure quality.

4.2 M i n i m u m Documentation
Req u i rements

I t is customary to make a comment l i ke th is so
that no one wastes time looking for what may
be mi ssing.

5. Standards, practices, Conventions, and
Metrics
5 . 1 Pu rpose

Th is secti on li sts all of the project documen­
tati on, si nce the documentation is a major
factor ensuring the quality of the product .
Note that t h e User's Manual is excluded: it
is a del iverable rather than a project document.

The following documents will be produced:
•

Software Qual i ty Assurance Plan (SQAPj th is
document)

•

Software Configuration Management Plan (SCMP)

•

Software Project Management Plan (SPMP)

•

Software Requirements Speci fications (SRS )

•

Software Design Document (SDD)

•

Software Test Documentation and the test docu­
ment that i t refers to ( STD )

This secti on describes the stan dards , practices, con­
ventions, and metrics to be used for the Encounter
project. These are i n tended not only to ensure
quality of the Encounter product but also to obtain
quanti tative metric data on the SQA process itself.
These data are to be used to help el evate the CMM I
level of Gaming Consolidated I n dustries ( G C I ) from
level 2 to level 3 .
5 . 2 Content

Describe the standards, practices, conve n ­
tions, a n d metrics t o be used. Organization­
wide qual ity goals can be suppl ied here or in a
separate appendix. The contents of th is sec ­
tion should be as specific as possible. For
example, statements such as "qual ity should
be as high as poss ible" should be avoided.

CASE STUDY: SOFTWARE QUALITY ASSURANCE PLAN FOR ENCOUNTER

Standards:
The IEEE documentation standards as of July 1 ,
2004, with appropriate modi fications, are to be

used for all documentation . The stan dards for Jav­
adoc commenting will be followed as found at http ://
j ava. sun . com/j 2se/j avadodwritingdoccomments/
i n dex.html and http://java . sun .com/j 2se/javadod
writingapispecs/i ndex.html. Documentation stan­
dards or templ ates developed by the company may
supersede these at the discretion of management.
U n i fied Model i n g Language standards , as spec­
i fied in . . shall be used in this project.
Re fer to the Conventions secti on below for
additional stan dards .
Practices:

1 . Because del aying qual i ty is expensive, GCI Inc.
strongly encourages engineers to apply qual i ty
precepts while working, rather than as an after­
though t. This is referred to in the company as
"internal qual ity." I t incl udes all unit testi ng.
2. GCI Inc.'s policy is that the QA department
provides independent, external testi ng. The QA
department at GCI also has a role i n educati ng
engineers in the practice of i n ternal quality and
worki ng with project mangers to ensure that it
takes place .
3 . All project arti facts are i nspected and are made
easily avai lable to the team once released by the
developer.
4 . All project arti facts are placed under configura ­
tion management, where the contents can be
seen by anyone in the team at any time ( see the
Software Configurati on Management Plan for
detai l s ) .
5 . T h e development process is t o be reviewed a t
least once for i mprovement, and the written
results forwarded to the software engi neeri ng
l aboratory ( see Section 6 . 2 . 1 O).
conventions:
Where feaSible, writing conventions should conform
to the suggestions in Writing for Computer Science: The

Art of Effective Communication by Justi n Zobel ( Springer
Verlag.
The codi ng conventions as found at http ://j ava .
sun . com/docs/codeconvlhtmIlCodeConventions .doc
. html will be followed.
Metrics:

Th i s section is liable to be extens ive . The
num bers used here would be based on hi stori ­
cal data obtai ned from the group that is deve l ­
oping Encou nter.

GCI's list of standard metrics, found at http ://
xxx, should be gathered as spec i fied there . The
following i ncludes some of them .
For every process and document, metrics shall
include the followi ng:
1 . Time spent by indivi duals on preparation and
review.
2. Number of defects per unit ( e . g. , l i nes of code ) .
class i fied p e r Section 8 o f thi s document.
3. Qua l i ty self- assessment o f the QA process and
perform ance on a scale of 1 through 1 0, ap­
proximately i n a bel l - shaped distributio n ; self­
assessment scores will not be used for the
evaluation o f personnel by management; failure
to produce them, however, may negatively af­
fect the evaluation of an engineer by m anage ­
ment, however.

We would spec i fy all metrics to be coll ected
on this project. Possible metrics are described
in Chapter 6 .

The standard for defect classi fication i s given i n
Section 8 of this document.
Quality Goals:
GCI quality goals for delivered products are as
follows, measured in terms of defects detected within
two months of del ivery .

107

1 08

CHAPTER 5

•

QUALITY IN THE SOFTWARE PROCESS

No known "critical" or "serious" defects remain in
any delivered artifact.
In addition:

•

•

•

Requirements: No more than one "medium," and
no more than three "trivial" defective detailed
requirements per 1 00
Design: No more than one "medium" defect per
five diagrams . A "diagram" is any figure that uses
about a page of easily legible parts .
Pseudocode: No more than two "medium" defects per
1000 lines pseudocode is described in Chapter 1 9.

one responsible customer representative. They will
be led by the requirements leader, who will deter­
mine their frequency and scope.
6.2.1A Software Requirements Inspections
After they have been reviewed, all requirements will
be inspected in accordance with eCI, Inc's docu­
ment eCI 345678 "Inspections and Review proce­
dures at ecl." Requirements sections must be
completed and signed within a week of beginning
the design .
6.2.2 Architecture Design Reviews

The data from this project are to be reported as
Appendix 1 to this document.

This is a review of alternative architectures with the
entire team. The review will be led by the design
leader in accordance with eCI 345678 on a fre ­
quency to be determined . The team will provide
feedback, which will be reflected in the final design .

6. Reviews and Audits

6.2.2A Architecture Design Inspections

•

Code: No more than two "medium" defects per
KLoC ( 1 000 lines of non-commented code)

6.1 Purpose

The purpose of reviews and audits is to continually
focus engineers' attention on the quality of the
application as it develops. Reviews effect this in a
scheduled and thorough manner . Audits do so on the
basis of random sampling with short notice.
6.2 Minimum Requirements

Large projects require the full set of reviews
and audit listed here. Student teams should try
to conduct reviews and inspections of require­
ments and design, as well as postmortem
reviews. "Reviews" are discussions of proposed
artifacts. "Inspections" are conducted on com­
pleted artifacts presented to the team. The
SQAP does not call out inspections as a head­
ing, so the author has inserted section "A"'s for
this purpose.

6.2.1 Software Requirements Reviews
These are walk- throughs of all proposed require­
ments in the presence of the entire team and at least

After they have been reviewed, architectures will be
inspected in accordance with eCI, Inc .'s inspection
process manual, document eCI 345678. Architec­
ture sections must be completed and signed off
within a week of beginning detailed design .
6.2.3 Detailed Design Reviews

These are reviews of all proposed detailed designs in
the presence of the entire development team . They
will be led by the design leader, who will determine
their frequency and scope, but at least one design
review; will be conducted per iteration . If possible,
the ar �hitecture will be decomposed into detailed
desig ris of its parts, and these will undergo separate
detailed design reviews.
6.2.3A Detailed Design Inspections
After they have been reviewed, detailed designs will be
inspected in accordance with eCI, Inc's inspection
process manual, document eCI 345678. Detailed
design sections must be completed and signed off
within a week of beginning implementation.
6.2.3 Test Plan Reviews
These are reviews of all proposed test plans in the
presence of the entire team . They will be led by the

CASE STUDY: SOFTWARE QUALITY ASSURANCE PLAN FOR ENCOUNTER

QA leader, who will determine their frequency and
scope . The test plan will be decomposed into parts,
and these will undergo separate reviews.
6.2.3A Test Plan Inspections
After they have been reviewed, test plans will be
inspected in accordance with GCI, Inc .'s inspection
process manual, document GCI 345678. Test plan
sections must be completed and signed off within a
week of beginning testing.
6.2.4 Verification and Validation Plan Review

V&V is to be conducted by an independent team
(i .e., not associated with QA ) , following the process
detailed in GCI 345678. The QA engineer will
review the SVV plan prior to its execution.
6.2.5 Functional Audits
The QA leader shall be responsible for auditing the
product relative to the SRS. The audit will follow

company guidelines
Procedures ."

in

"GCI

8902:

Release

exceptions are at the discretion of the VP for Engi ­
neering . It is the project leader's responsibility to
schedule this review and provide the appropriate
documentation and software demonstrations .
6.2.9 SCMP Review
The QA leader shall review the status of configura­
tion management on a monthly basis in a manner
independent of the procedures specified in the
SCMP.
6.2.10 Post-Implementation Review

As with all GC I projects, the Encounter team shall
conduct post-implementation reviews to provide
data for future projects . These will include reviews
of the project phase just completed and reviews of
the QA process itself . The QA team or QA leader
shall file a process improvement report for every
phase, and for the QA process itself, with the
manager of the software engineering laboratory .
6.3 Other Reviews and Audits

-intentionally left blank
6.2.6 Physical Audits

Prior to each delivery , the QA leader is responsible
for checking that the physical software and its
documentation designated for delivery are complete
and the correct version.
6.2.7 In-Process Audits
Project personnel should expect random audits of
their work . These will consist of visits to the work
site by individuals or teams designated by division
management. A day's notice shall usually be given for
all visits , but audits without notice shall take place as
well. The subject of these audits will be the current

work of teams and individuals that has been allocated
to the project. All project artifacts will be made freely
available to all team members and auditors at all
times. It will be organized in a clear, standard
fashion, so that audits will be possible without any
notice.
6.2. 8 Managerial Review

The Encounter project shall be reviewed by the VP
for Engineering during the first week of every month :

7 . Test

This section describes how testing is to be
managed. The text here should refer to, but
not duplicate, the software test documentation .

The responsibilities for testing were described
in Section 3.3. Refer to the Software Test Documen­
tation for details on testing Encounter.
8. Problem Reporting and Corrective
Action

This section explains how defects come to be
recognized, described, and repaired. They do
not follow the details of IEEE standards. The
reader is referred to the IEEE standards, as well
as to Humphrey [ 8] for additional defec t
severity and type classifica tions.

1 09

110

CHAPTER 5

Q UALITY IN THE SOFTWARE PROCESS

The team will use the Bugzilla defect management system .

The code and pseudocode defects types are as
follows:
•

Syntax

•

Logic

•

Data ( i .e . , allows a wrong variable value)

•

Insecure (allows unacceptable security breach )

Instead of describing Bugzilla, we will de­
scribe a hypothetical manual defect system
for the sake of clarity, even though a soft­
ware-based system is common practice and
far preferable. Such systems also allow for a
dialog thread involving, typically, testers and
developers.

The workflow of a defect status is:
I. Open: defect found by tester

The Problem Reporting Form to be used by the
Encounter development team in response to a soft­
ware problem report generated by QA is shown in
Appendix B.
To use this form, engineers should retrieve the
form from www.a.b.c.d. The defect number will
appear automatically, and the site will ensure that
the appropriate fields are filled in .
The values for severity are as follows :
•

•

•

•

Critical: Causes the application to crash w ith sig­
ni ficant frequency
Serious: Causes at least one documented requi re ­
ment t o be unmet
Trivial: Could be allowed to stand ad infinitum
without impeding the user from exercising a re­
qui red feature
Medium: Is neither serious nor trivial
The documentation defect types are as follows:

•

Incorrect

•

Miss ing material

•

Unclear

•

Ambiguous

•

Incomplete

•

Redundant (within or between documents)

•

Contradictory

•

Obsolete

2. Assigned: defect assigned to an engineer
3. Corrected: defect fixed by engineer
4. Closed: defect closed by tester
If the defect is reopened, the defect will move
from the Corrected state to an Open state .
The QA leader will create and the QA team will
mainta in a database of problem reports that describe
the deficiencies, discrepancies, and anomalies fo r
Encounter. They will ensure that defects are con­
sistently recorded on this form and that they are
routed and repa i red in a consistent manner. Problem
reports shall be routed in accordance with the
SCMP. Full traceability as to the i r effects and status
shall be maintained, including after they are repai red.
After iteration three, when a problem is
encountered, the QA manager will distribute the
problem report to the members of the Change
Control Board (CC B ) . For the first three releases,
the configuration specialist will carry out the func­
tions of the QA team, and the project leader will
perform all of the CCB functions in accordance with
the SPM P . The CCB evaluates the problem report
and then assigns a priority to the report of either
immediate, to be done, or optional. T he problem report is
then assigned by the CCB to the Encounter devel­
opment team, QA , or CM for resolut ion . The CCB
determines the schedule for problem report resolu ­
tion based on problem report priority and analysis
report results . After the problem in the report is
corrected, the QA team reviews the results and the
QA manager reports on the review to the CC B . If
necessary, the process is repeated .

CASE STUDY: SOFTWARE QUALITY ASSURANCE PLAN FOR ENCOUNTER

9. Tools, Techniques, and Methodologies
SQA techniques include the auditing of standards,
requirements tracing, design verification, software
inspections, and the verification of formal methods.
The SQA tools consist of software verification pro ­
grams, checklists, media labels, and acceptance
stamps. Checklists will be obtained from the com­
pany's software engineering laboratory, and tailored
for Encounter. These are augmented by NASA
checklists at [ 9] . Checklists include the following:
•

•

•

addition, the SQA team verifies that the software
media are duplicated using only the procedures
identified in the SCMP. SQA acceptance is indicated
by an SQA stamp on the media label . The SQA audit
reports for media control are intended as further
evidence that QA procedures have been followed.
All backup media will be stored offsite as described in
the SCMP.
11. Supplier Control

Review checklists are used at formal meetings, for
document reviews, and for inspections .
Checklists w ill be used for verifying the quality of
the following activities and documents: Prelimi ­
nary Design Review, Critical Design Review, Test
Readiness Review, Functional Configuration Audit,
Physical Configuration Audit, SRS, SOD, SPMP,
and Software Development Folders .
Separate checklists and forms are used for software
audit purposes.

Th is book contains checklists throughout.
These checklists involve meeting and inspec ­
tion procedures, for example . Teams often
begin with published checklists, and augment
them according to addit ional specific needs of
the i r projects .

This section concerns relationships w i th sup­
pliers of software and hardware. It describes
how and by whom these relationships are to be
handled.

The SQA team verifies all commercial third­
party products provided by the suppliers during in­
coming inspection by reviewing the packing slips that
identify the products and their version numbers. The
QA manager is responsible for ensuring that all third­
party software and hardware meets the expected
requirements. The products will be validated by the
QA manager through installation and acceptance tests .
A QA representative will be responsible for testing all
new versions . He will also be responsible for the
relationship with the external vendor.
12. ReCords Collection, Maintenance,
and Retention

Additional SQA tools, techniques, and meth ­
odologies for configuration management are de­
scribed in the SPMP.

This section descri bes how physical records
will be handled and who w ill be respons i ble
for them . Include d isk files that are not under
configuration control .

10. Media Control

Descri be the means by which d isks, tapes, and
so on w ill be managed .

The SQA team verifies that the software media
are built and configured per the SCMP and that
authorized changes have been installed and tested . In

The SQA records collected and archived shall
include the following:
•

•

Task reports
Anomaly reports not handled by the regular problem ­
reporting mechanism

111

1 12

CHAPTER 5

•

QUALITY IN THE SOFTWARE PROCESS

Memos, including recommendations to responsi ­
ble parties

•

Logbooks of SQA activities

•

Audit reports

•

Signed-off checklists from reviews and audits

•

Minutes of inspections

•

Metrics for the QA process itself

Besides verifying the archive procedures speci­
fied in the SCMP, SQA shall separately archive its
own records at least once a week. These records are
retained throughout the operation and maintenance
phase .
13. Training

recording metrics. SQA will also conduct monthly
three-hour classes for development team members to
keep them informed of quality goals, tools, and
techniques . Team members can waive attendance
at these meetings by scoring perfectly on a multiple­
choice quiz available at GCl/monthly/SQAlquiz.
Each team member is required to attend a
three-hour course on writing styles and conventions
conducted by QA .
14. Risk Management

SQA team members are encouraged to identify risks
as early as possible and direct them to the project
leader. The procedures for risk management are
specified in Section 5.4 of the SPMP.
15. Glossary

Includes SQA training specific to this project .
16. SQAP Change Procedure and History

The SQA organization will conduct an initial
four-hour orientation on quality for the development
team. This will include a presentation on the metrics
to be used and a workshop on how to use tools for

(The material in the following appendices was
supplied by Jane Dyson . )

CASE STUDY: SOFTWARE QUALITY ASSURANCE PLAN FOR ENCOU NTER

Appendix A: Metric History for This Project

Defects

Review

Time

Time

Defect

Expected

Actual

Expected

Actual

Expected

Actual

Unit

Rate

Rate

Time

Time

Time

Time

Product

SCMP

preparation

Section

1 minor defect

per section

SPMP

Section

1 minor defect

per section

SQAP

Section

1 minor defect

per section

SRS

Section

1 minor defect

per section

SDD

Section

1 minor defect

per section

STP

Section

1 minor defect

per section

SWP

Section

1 minor defect

per section

SWR

Section

1 minor defect

per section

Requirements

D-Requirement

1 medium and

3 trivial defects

per 100

Design

Diagram

Pseudocode

KLOC

1 minor defect

per 5

2 medium

defects

Code

KLOC

2 medium

defects

Code Defects

A free online tool called "Refactorlt" from http://www.refactorit.com shall used by the Project Manager to
estimate LOC, NCLOC, and CLOC .

1 13

1 14

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

Appendix B: Problem Reporting Form

1 . Defect number:
2 . Proposed by:

_________

____________________

3. Documents / sections affected:

______________

4. Document defect type:
a.

___

b.

Missing material
Unclear

c.

___

Ambiguous

d.

___

Incomplete

e.

___

Redundant (within or between documents)

f.

___

Contradictory

g.

___

Obsolete

Source code affected (for source code defects):
5. Package(s)
6. Class (es)

________

_________

7. Method(s)

_________

8. Severity:
a.

___

High

b.

Medium

c.

Low

9. Code defect type:
a.

___

Syntax

b.

___

Logic

c.

___

Data (i.e., al lows a wrong variable value )

d.

___

Insecure (allows unacceptable security breach)

CASE STU DY: SOFTWARE QUALITY ASSU RANCE PLAN FOR ENCOU NTER

to.

Phase injected (earliest phase with the defect):
a.

___

Architecture

b.
c.

Detailed design

___

d.
e.

Requirements

Code
___

Implementation

1 1 . Detailed description:
1 2. Priority:

Intermediate

b.

Immediate

a.

c.

Deferred

1 3. Resolution:
1 4 . Status:

b.

Closed

a.

___

Open

Sign-off:
1 5. Description and plan inspected:

____

1 6 . Resolution code and test plan inspected:
1 7. Change approved for incorporation:

____

______

Appendix C: Change Reporting Form

1 . Change number:
2. Proposed by:

___

_______________________________________________ ___________

3. Documents/sections affected:

_________ __________________

4. Reason for change or addition:
5 . Enhancement:

_____________________ ___________ __
_

6. Details:
Signatures:

Description and plan inspected ( QA team leader)

____
_

Resolution code and test plan inspected ( QA team leader)
Change approved for incorporation (Team leader)

___

_____

1 15

116

CHAPTER 5

QUALITY I N THE SOFTWARE PROCESS

Appendix D: Inspection Meeting Report Form

A completed Inspection Meeting Report must be included at the end of each document. Only the latest report
is required .
Inspection Meeting Report
PROJECT:
DATE:

STARTING TIME:

ENDING TIME:

0

0

PRODUCED BY:
TYPE OF INSPECTION:

INITIAL INSPECTION

REWORK INSPECTION

DOCUMENT NUMBER AND REVISION:
BRIEF DESCRIPTION:
APPRAISAL OF THE WORK UNIT:

0

Inspection not completed (continuation scheduled for

0

No further inspection required

0

Minor revisions required

0

Major revisions required

)

MATERIALS PRODUCED

0

Issues List (Not Author's Responsibility)

0

Issues List for Author

0

Traceability Issues?

participant

Role(s)
Author
Moderator
Recorder
Inspector
Inspector
Inspector
Inspector
Inspector

Org.lDept.

CASE STU DY: SOFTWARE Q UALITY ASSU RA NCE PLAN FOR ENCOU NTER

Inspection Meeting Report Issues List
ISSUES, NOT FOR AUTHOR
Issue must be resolved prior to Document

Issue

Response

Assigned To

Baseline? YIN
1.
2. etc.

ISSUES FOR AUTHOR
Response

Issue
1.
2. etc.

Appendix E: Document Baselining Checklist
Document Baselining Checklist
Item
0

Inspection Meeting Report completed and all issues resolved.

0

Revised document sent out for consensus after Inspection.

0

All comments accepted via Word's Track Changes. Track changes feature
then turned off.

0

Check for clean requirements traceability completed. (SRS only)

0

All high-level requirements have been allocated to detailed requirements.

(SRS only)
0

Final traceability report generated and stored. (SRS only)

Comment I Initials

1 17

1 18

CHAPTER 5

QUALITY IN THE SOFTWARE PROCESS

5.10 SUMMARY
Quality practices are integrated throughout the development process . They start with planning, when
specific documents such as the Software Quality Assurance Plan (SQAP) and the Software Verification and
Validation Plan (SVVP) are produced, describing the quality policies, procedures, and practices to be
implemented .
The SQAP is the master quality plan and specifies the people and organizations responsible for quality,
the project documentation to be produced, the metrics to be collected, the procedures to be practiced, and
the techniques to be implemented. It is an important document as it sets the expectations regarding quality
early in a project and helps guide its implementation.
Inspections are an important quality technique that involve peer review of all project artifacts including
documents, test plans, and code . Their goal is to identify defects as close to their introduction as possible so
that they can be repaired quickly. Considerable research has shown that the cost to repair a defect increases
dramatically the longer it is allowed to persist in the software.
Quality reviews and audits by a quality assurance ( QA) organization are beneficial. An external QA
group is independent of the people developing the software and other artifacts and can objectively assess
quality . Again, assessing quality and addressing it throughout the development process helps identify
problems as early as possible .
Problems are identified by team members throughout the development process and are submitted as
defects. A screening process is implemented to ensure that the defects are accurate and valid. A classification
system is employed to understand the severity of each defect and priority for its repair. In addition,
maintaining metrics such as number of defects, time to repair, and so on is useful for comparison with other
projects and in making estimates for future projects.
Improving the effectiveness of the overall software process is accomplished through implementation of
a meta -process. This includes the collection of process metrics, and meetings at the end of projects phases to
analyze the metrics. In addition, lessons-learned meetings are conducted at the end of a project to analyze
project successes and identify areas of improvement.
The Software Engineering Institute has developed a comprehensive meta-process for assessing an
organization's overall capability . The process is called the Capability Maturity Model Integration (CMMI),
and it defines several levels of capability and maturity an organization can measure itself against . The levels
range from the lowest, Levell Initial. to the highest, Level 1 Optimizing. At the Initial level an organization
can produce software but has no recognized process . At the Optimizing level, an organization implements a
meta -process for process improvement.

5.11 EXERCISES
1. In a paragraph, explain why it is important to document quality procedures at the beginning of a
project rather than later on .
2.

The number of people attending an inspection can have a direct impact on the effectiveness of the
review. List the disadvantages of having either too few or too many people attend an inspection.

3. Give two advantages and two disadvantages to using standards for documentation of the various
software phases .
4. Why is it generally a good idea to have a cross-functional group be part of an inspection team?
What type of review (that is, during what development phase) might it not be a good idea?

BIBLIOGRAPHY

5.

Your instructor will pair up student project teams. Conduct an inspection of an artifact produced
by the other team, such as a SCMP or SPMP. Use an inspection checklist, such as one found in [3],
to guide your inspection .

6 . Give a n example o f a defect that might b e classified with a high severity but a low priority. Be
specific with your answer .
7. (a) In your own words, describe each of the CMMI levels .
(b ) How does applying the CMM I levels promote organizational quality? Explain this in a
paragraph or two, using your own words .

BIBLIOGRAPHY
I. Fagan, M. "Design and Code Inspections to Reduce Errors in Program Development." liM Systems Journal, Vol. 15, No. 3, 1976,

pp. 182-2 I 1.
2. Wiegers, Karl, "Improving Quality Through Software Inspections," Process Impact, 1995. httpJ/www.processimpact.com/articies/
inspects.html [accessed November 15, 2009].
3. Wiegers, Karl, "Goodies for Peer Reviews," Process Impact, .. http/lwww.processimpact.com/pcgoodies [accessed November 15,
2009].

4. Gehani, Narain, and A McGettrick, "Software Specification Techniques," International Computer Science Series, Addison-Wesley, 1985.
5. Gilb, T., and D. Graham, "Software Inspection," Addison-Wesley, 1993.

6. Bugzilla. httpJ/bugzilla.org/about.html [accessed December 10, 2009].
SM
7. Capability Maturity Model® Integration (CMMI ), Version 1.1,

httpJ/www.sei.cmu.edu/pub/documentsloz-reportslpdf/

02trf0I2.pdf [accessed December 8, 2009].

8. Humphrey, Watts S., "A Discipline for Software Engineering," SEI Series in Software Engineering, Addison· Wesley, 1995.
9. NASA Goddard Space Flight Center Software Assurance Web site. http;llsw-assurance.gsfc.nasa.gov/disciplines/quality/index.php
(2006) [accessed November 15, 2009].

119

Software Configuration
Management

Planning

�
Testing

Maintenance

The Software
Development
Lifecycle

Implementation

Design

\

What is the purpose of software
configuration management?
What activities does it consist of?
How do you plan for configuration
management?

Requirements
analysis

/

What tools are available to support it?
How is configuration management
handled in large projects, in practice?

Figure 6.1 The context and lea rning goa ls for this cha pter

Many artifacts are produced in the course of developing a software product, such as specifications (e.g.,
requirements, design ) , source and executable code, test plans and test data, user documentation, and
supporting software (e.g., compilers, editors) . Each undergoes numerous revisions, and keeping track of the
various versions needs to be managed in a reliable and consistent manner. Software Configuration Management
( SCM) is the process of identifying, tracking, and storing all the artifacts on a project. In the context of SCM,
each of these artifacts is referred to as a Configuration Item (C\).

SCM ACTIVITIES

SCM contributes to overall software quality in that it supports a reliable way to control a project's
artifacts. For example, the SCM process ensures that the proper source files are included when building the
software system and that the correct project documentation is retrieved when required .
Many activities contribute to configuration management, including identification of artifacts as
configuration items, storage of artifacts in a repository, managing changes to artifacts, tracking and reporting
these changes, auditing the SCM process to ensure it's being implemented correctly, and managing software
builds and releases . Many of these activities are labor intensive, and SCM systems help automate the process .
6.1 SOFTWARE CONFIGURATION MANAGEMENT GOALS
We first define the overall goals of software configuration management: baseline safety, overwrite safety, reversion,

and disaster recovery.
Baseline safety is a process of accepting new or changed CIs for the current version of the developing
product ( the baseline), and safely storing them in a common repository so that they can be retrieved when
needed later in a project .
Overwrite safety means that team members can safely work o n C Is simultaneously, and changes can be
applied so they do not overwrite each other . Overwrite safety is needed when the following kind of sequence
occurs.

1 . A . Engineer Alan works on a copy of CI X from the common repository.
B . Brenda simultaneously works on an identical copy of X.
2. Alan makes changes to X and puts the modified X back in the repository .
3. Brenda also makes changes to X and wants to replace the version of X in the common repository with the
new version.
Overwrite safety assures that Brenda's changes don't simply replace Alan's, but instead are added
correctly to Alan's.
Reversion occurs when a team needs to revert to an earlier version of a C I. This is typically required
when mistakes transition a project to a bad state-for example, when it is found that a new version of a C I
turns out to cause s o many problems that it i s preferable to revert to a previous version . Reversion requires
knowing which version of each CI makes up a previous version of the project .
Disaster recovery i s a stronger form o f reversion-it i s the process o f retaining older versions o f an
application for future use in case a disaster wipes out a newer version .
These four goals, fundamental for configuration management, are summarized in Figure 6. 2 .
6.2 SCM ACTIVITIES
There are several SCM activities and best practices that are implemented to successfully meet the goals just
described . They are mainly the following :
1 . Configuration identification .
2. Baseline control.
3. Change control .
4. Version control.

121

1 22

CHAPTER 6

•

SOFTWARE CON FIG U RATION MANAGEMENT

Baseline Safety

Ensure that new or changed CIs are safely stored in a repository and can be retrieved when necessary.
•

Overwrite Safety

Ensure that engineer's changes to the same CI are applied correctly.
•

Reversion

Ensure ability to revert to earlier version.
•

Disaster Recovery

Retain backup copy in case of disaster.
Figure 6.2 Major goals of configu ration management

5. Configuration auditing.
6. Configuration status reporting.
7. Release management and delivery.
Each of these is described in the following sections.
6.2.1 configuration Identification
The first step in configuration management is to identify a project's artifacts , or configuration items (CI ) , that
are to be controlled for the project. As described in the introduction, candidate Cis include source and object
code, project speci fications, user documentation, test plans and data, and supporting software such as
compilers, editors, and so on. Any artifact that will undergo modi fication or need to be retrieved at some time
after its creation is a candidate for becoming a CI. Individual files and documents are usually Cis and so are
classes. Individual methods may also be Cis , but this not usually the case . A CI may consist of other Cis.
CIs are too large when we can't keep track of individual items that we need to and we are forced to
continually lump them with other items. Cis are too small when the s ize forces us to keep track of items whose
history is not relevant enough to record separately.
Once selected, a C I is attached w ith ident ifying information that stays w ith it for its lifetime. A
unique identi fier , name , date, author, revision h istory, and status are typical p ieces of information
associated with a CI.
6.2.2 Baselines
While an artifact such as source code or a document is under development, it undergoes frequent and informal
changes . Once it has been formally reviewed and approved, it forms the basis for further development, and
subsequent changes come under control of configuration management policies. Such an approved artifact is
called a baseline. IEEE Std 1 042 defines a baseline as a "speci fication or product that has been formally reviewed
and agreed to by responsible management, t hat thereafter serves as the basis for further development, and can
be changed only through formal change control procedures."
Baselines not only refer to individual Cis but also to collections of CIs at key project milestones . They
are created by recording the version number of all the CIs at that time and applying a version label to uniquely
identify it . M ilestones can occur when software is internally released to a testing organization, or when a

SCM ACTIVITIES

A baseline is an individual or group of Cis
labeled at a key project milestone.
Each version below is a baseline.

Removal

Addition

�7
A1

E3

Figure 6.3 Transitioning from one baseline to the next

05

version of software is packaged for release to a customer . For example, a new software version is created and a
set of source files and documentat ion that constitute software release 1 .0 are grouped together, given a unique
label such as "version 1 .0," and are recorded as belonging to the same baseline. This allows all the files
constituting software release 1 .0, and their correct versions, to always be correctly identified and grouped
together. If files belonging to a baseline are added, deleted, or modified, an updated baseline is created with a
new version number. Figure 6.3 illustrates this concept.
Once baselines are created and labeled, they are utilized in a project for three primary reasons [ 1 ]:
1 . Reproducibility
2. Traceability
3. Reporting
These are explained next .
1 . Reproducibility means that you can reproduce a particular software version or set of documentation
when necessary. This is required during product development as well as during maintenance . For
example , software is shipped to customers, and different customers may use different versions. In the
meantime, the project team is developing a new software release, and as a result is updating many of the
CIs used in previous software releases. If a problem is reported by a customer running an older software
version, because it was saved as a baseline the older version can by resurrected by the project team and
used to identify and repair the source of the problem.
2. Traceability means that relationships between various project artifacts can be established and recog­
nized. For example, test cases can be t ied to requirements, and requirements to design.
3. Reporting means that all the elements of a baseline can be determined and the contents of various
baselines can be compared . This capability can be utilized when trying to identify problems in a new
release of software . Instead of performing a lengthy debugging effort, differences in source files between
the previous and current software versions can be analyzed. This may be enough to identify the source of
the problem . If not, knowing exactly what changes occurred can point to potential root causes, speeding
up the debugging effort and leading to faster and easier problem resolution . Baselines are also useful to
ensure that the correct files are contained in the executable file of a software version. This is used during
configuration audits, and is covered in Section 6. 2.5.

123

1 24

CHAPTER 6

SOFTWARE CON FIGU RATION MANAGEMENT

6.2.3 Change Control
Configuration items undergo change throughout the course of development and maintenance, as a result of
error correction and enhancement . Defects discovered by testing organizations and customers necessitate
repair. Releases of software include enhancements to existing functionality or the addition of new
functionality . Change control, also known as configuration control, includes activities to request, evaluate,
approve or disapprove, and implement these changes to baselined CIs [2] .
The formality of these activities varies greatly from project to project. For example, requesting a change
can range from the most informal-no direct oversight for changing a CI-to a formal process-filling out a
form or request indicating the CI and reason for change, and having the request approved by an independent
group of people before it can be released. Regardless of the formality of the process, change control involves
identification, documentation, analysis, evaluation, approval, verification, implementation, and release as
described next [ 2] .
Identification and documentation

The CI in need of change is identified, and documentation is produced that includes information such as the
following :
•

Name of requester

•

Description and extent of the change

•

Reason for the change (e.g . , defects fixed)

•

Urgency

•

Amount of time required to complete change

•

Impact on other CIs or impact on the system

Analysis and evaluation

Once a CI is baselined, proposed changes are analyzed and evaluated for correctness, as well as the potential
impact on the rest of the system. The level of analysis depends of the stage of a project. During earlier stages
of development, it is customary for a small group of peer developers and/or the project manager to review
changes . The closer a project gets to a release milestone, the more closely proposed changes are scrutinized,
as there is less time to recover if it is incorrect or causes unintended side effects . At this latter stage, the
evaluation is often conducted by a change control board ( CCB ) , which consists of experts who are qualified to
make these types of decisions . The CCB is typically comprised of a cross-functional group that can assess the
impact of the proposed change . Groups represented include project management, marketing, QA, and
development. Issues to consider during the evaluation are as follows:
•

Reason for the change (e.g., bug fix, performance improvement , cosmetic)

•

Number of lines of code changed

•

Complexity

•

Other source files affected

•

Amount of independent testing required to validate the change

Changes are either accepted into the current release, rejected outright, or deferred to a subsequent
release .

SCM ACTIVITIES

Approval or disapproval
Once a change request is evaluated, a decision is made to either approve or disapprove the request. Changes
that are technically sound may still be disapproved or deferred. For example, if software is very close to being
released to a customer, and a proposed change to a source file requires many complex modifications, a

decision to defer repair may be in order so as to not destabilize the software base. The change may be
scheduled for a future release.
Verification, implementation, and release
Once a change is approved and implemented, it must be verified for correctness and released.

6.2.4 Version Control
Version control supports the management and storage of CIs as they are created and modified throughout the
software development life cycle. It supports the ability to reproduce the precise state of a Cl at any point in
time. A configuration management system (also known as a version control system) automates much of this
process and provides a repository for storing versioned Cis. It also allows team members to work on artifacts
concurrently, flagging potential conflicts and applying updates correctly.
A good version control system supports the follOWing capabilities :
1 . Repository
2. Checkout/Checkin
3. Branching and merging
4 . Builds
5 . Version labeling
These are explained in the follOWing sections .
6.2.4.1 Repository

At the heart of a version control system is the repository, which is a centralized database that stores all the
artifacts of a project and keeps track of their various versions . Repositories must support the ability to locate
any version of any artifact quickly and reliably.
6.2.4.2 Checkout and Checkin

Whenever a user needs to work on an artifact, they request access (also known as checkout) from the repository,
perform their work, and store the new version (also known as checkin) back in the repository. The repository is
responsible for automatically assigning a new version number to the artifact.
Files can usually be checked out either locked or unlocked. When checking out locked, the file is held
exclusively by the requester and only that person can make modifications to the file and check in those
changes. Others may check out the file unlocked, which means it is read-only and they only receive a copy.
Concurrent write privileges can be achieved by branching, which is explained in the next section .
When checking in a file, version control systems record the user making the change and ask the person
to include an explanation of why the file was changed and the nature of the changes. This makes it easier to
see how a file has evolved over time, who has made the changes, and why they were made .

1 25

126

CHAPTER 6

SOFTWARE CON FIGURATION MANAGEM ENT

File A
(a) John branches
v1.2 of file A

.----...

(c) Sally branches
v1.2 of file A

(b) John modifies
his copy of v1 .2 of
file A

(e) John merges his
changes to file A

Figure 6.4 Branchi ng and mergi ng cha nges

6.2.4.3 Branching and Merging

Projects are most often developed by teams of people. Version control systems provide mechanisms to allow
team members to work on the same set of files concurrently (brancbing) and correctly apply changes to
common files so that none are lost or overwritten (merging). This is also known as overwrite safety.
Figure 6.4 depicts an example, in which John creates a brancb by checking out version 1. 2 of file A. A
branch is a private work area in a version control system that allows you to make changes to baselined files
without conAicting with other team members. John maintains a private copy of the file on his branch and
makes his changes . Concurrently, Sally also needs to work on file A so she creates her own branch and checks
out version 1 . 2. Her copy starts out the same as John's since he has not yet checked in his updates. Once John
finishes his changes, he checks in his files to the repository, and the file is given a new version number 1 . 3.
Later, Sally finishes her modifications to A and wants to check in the file. If the version control system allowed
her to just replace the current copy of file A (version 1.3, which now includes John's changes) with her copy,
John's changes would be lost. Instead, the version control system supports merging, which intelligently applies
Sally's changes to version 1.3 and creates a new version 1.4 with both of their changes applied correctly. If the
set of changes are made to various parts of the same file, the system can usually perform the merge operation
automatically. If the changes conAict with each other, as when the same lines of code are changed, the system
will ask the user to merge the changes manually. In this case the system will show the user which lines overlap
so that person can apply the changes correctly.
6.2.4.4 Builds

Version control systems provide support so as to reliably and reproducibly compile and build the latest
version of software files into an executable, usable file. A user can specify which branch of code to build from,
allowing concurrent development. In addition to the executable file, builds produce logs containing the file
versions comprising the build.

SCM ACTIVITIES

6.2.4.5 Version Labeling

Versions are created by applying a label to all files comprising a software build. The label is usually a version
number, such as "version 1 . 0". This allows software versions to easily be referenced and reconstructed if
necessary, and supports the construction of baselines.
6.2. 5 configuration Audits
As defined by IEEE 1 028-2008 [3], a software audit is "an independent examination of a software product,
software process, or set of software processes performed by a third party to assess compliance with
speCifications, standards, contractual agreements, or other criteria." In the context of configuration manage­
ment, the goals of a configuration audit are to accomplish the following:
•

Verify that proper procedures are being followed, such as formal technical reviews.

•

Verify that SCM policies, such as those defined by change control, are followed.

•

Determine whether a software baseline is comprised of the correct configuration item. For example, are
there extra items included? Are there items missing? Are the versions of individual items correct?
Configuration audits are typically conducted by the quality assurance group.

6.2.6 configuration Status Reporting
Configuration status reporting supports the development process by providing the necessary information
concerning the software configuration. Other parts of the configuration process, such as change and version
control, provide the raw data. Configuration status reporting includes the extraction, arrangement, and
formation of reports according to the requests of users [4]. Configuration reports include such information as
the following:
•

Name and version of CIs

•

Approval history of changed CIs

•

Software release contents and comparison between releases

•

Number of changes per CI

•

Average time taken to change a CI

6.2.7 Release Management and Delivery
Release management and delivery define how software products and documentation are formally
controlled. As defined in IEEE 1 2 2 0 7 - 1 99 8 [5], "master copies of code and documentation shall be
maintained for the life of the software product. The code and documentation that contain safety or
security critical functions shall be handled, stored, packaged and delivered in accordance with the
policies of the organizations involved." In other words, policies must be implemented to ensure that
once software and documentation is released it must be archived safely and reliably, and can always be
retrieved for future use.

1 27

128

CHAPTER 6

SOFTWARE CON FIG U RATION MANAGEMENT

3. 3.2

3. 1

Introduction

3.2

SCM management

3.3

3.2. 1

Organization

3.2.2

SCM responsibilities

3.2.3

Applicable policies , directives , and
procedures

3.2.4

Management of the SCM process

3.3.2. 1

SCM activities
3.3. 1

Configuration identification
3.3. 1 . I

Configuration control

Identifying configuration
items

Requesting changes

3.3.2.2

Evaluating changes

3 . 3 .2.3

Approving or disapproving
changes

3 . 3 .2.4

Implementing changes

3.3.3

Configuration status accounting

3.3.4

Configuration evaluation and reviews

3 . 3 .5

Interface control

3 . 3 .6

Subcontractor / vendor control

3.3.7

Release management and delivery

3.3. 1 .2

Naming configuration items

3.4

SCM schedules

3.3. 1 .3

Acquiring configuration
items

3.5

SCM resources

3.6

SCM plan maintenance

Figure 6.5 IEEE 828-2005 software Configu ration Ma nagement Plan ta ble of contents
Source: IEEE Std 828-2005.

6.3 CONFIGURATION MANAGEMENT PLANS
To specify how the software configuration is to be managed on a project, it is not sufficient merely to point to
the configuration management tool that will be used. There is more to the process, such as what activities are
to be done, how they are to be implemented, who is responsible for implementing them, when they will be
completed, and what resources are required-both human and machine [ 2] . The IEEE has developed a
standard for software configuration management plans, IEEE 8 2 8 - 2005 . This can be very useful in making sure
that all bases have been covered in the process of CM. Figure 6.5 shows the relevant contents of this standard,
which are included in Chapter 3 of the plan.
The topics to be specified in Section 3.3 of the SCM P are largely covered in Section 6 . 2 of this chapter.
Section 3.3.3 of the SCMP documents the means by which the status of SCM is to be communicated (e .g., in
writing, once a week). Section 3.3.6 applies if a CM tool is used or if configuration management i s handled by
a subcontractor. The IEEE standard describes the purpose of each section of the above outline in detail . IEEE
8 2 8 - 2 005 is used in the Encounter case study later in this chapter.
6.4 CONFIGURATION MANAGEMENT SYSTEMS
For all but the most trivial application, a configuration management system (also known as a version control
system ) is indispensable for managing all the artifacts on a project. Microsoft's SourceSafe ™ is in common
use. CVS is a common environment, as well as Subversion and others.
6.4.1 Concurrent Version System (CVS)
The Concurrent Version System (CVS ) is a commonly used, free, open source configuration management
system. CVS implements a client - server architecture, with users running client CVS software on thei r

CASE STU DY : ENCO U NTER VIDEO GAM E

•

Up-to-date

Is identical to the latest revision in the repository .
•

Locally Modified

File has been edited but has not replaced latest revision.
•

Needs a Patch

Someone else has committed a newer revision to the repository.
•

Needs Merge

You have modified the file but someone else has committed a newer revision to the repository .
•

Unknown

Is a temporary file or never added.
Figure 6.6 File status possibil ities in CVS

machines, and a CVS server storing a repository of project files. Users check out projects (using the checkout
command) ; make changes; check in (using the commit command) , and merge with the changes of others who
checked out at the same time (using the update command ) . CVS automatically increments the version number
of files or directories (e .g., from 2 .3. 6 to 2 .3.7) . The status possibilities for a file are shown in Figure 6 . 6.
6.5 CASE STUDY: ENCOUNTER VIDEO GAME
What follows is a configuration management plan for
Encounter . The Software Configuration Manage ­
ment Plan (SCM P ) for Encounter is based on IEEE
Std 8 2 8 - 2005 Standard for Software Configuration
Management Plans . The table of contents of the
relevant sectio ns is outlined in Figure 6 . 8 , which is
Chapter 3 of the IEEE specification.

Title

Signature

Date

Engineering Manager

9'. J.one6

6115104

QA Manager

£ Wifen,z

6/1 1 /04

Project Manager

a. 9'ruitt

617104

ENCOUNTER SOFTWARE CONFIGURATION
MANAGEMENT PLAN

Author

[.. fBwade

611104

APPROVALS

Revision History

Note to the Student :
It is a good idea to have each team member
sign off on the physical document . T his pro ­
cess focuses the ir attention on the fact that
they are accountable for its contents , and they
will be more likely to ensure that it is the
document they intend .

This assumes the existence of a method whereby
revision numbers of documents are assigned.
Version 1

1 . 0 . 0 E. Braude : Created first draft 5/ 1 /98
1 . 1 . 0 R. Bostwick : Reviewed 1 / 1 0/99

129

1 30

CHAPTER 6

SOFlWARE CON FIG U RATION MANAGEMENT

1 . 1 . 1 E. Braude: Expanded 3.2 1 / 1 8/99
1 . 2 . 0 E. Braude: Reviewed for release5/ 1 8/99

A specific engineer , provided by the QA orga­
nization, will be designated as the "configuration
leader" for the duration of the project.

1 . 2. 1 E. Braude : Final editing4/30/99
3.2.2 SCM Responsibilities
Version 2

2 . 0. 0 E. Braude : significant edits of section xx
5/2/99
2. 0. 1 E. Braude : edits 5/ 1 3/04
The table of contents of this SCMP follows that
of IEEE standard 8 2 8 - 2005.
3 . 1 . Introd u ction
This Software Configuration Management Plan
(SCM P ) describes how the artifacts for the Encoun­
ter video game project are to be managed.
3. 1. 1 Definitions
Approved CIs : CIs signed off by project management
Artifact: A final or interim product of the
project (e . g., a document, source code, object
code, test result)
Master file : A particular designated file for this
project, defined in Section 3.3. 1 . 2
3.1.2 Acronyms
C I : configuration item-an item tracked by the
configuration system
CM : configuration management-the process of
maintaining the relevant versions of the project
SCMP : the Software Configuration Management

Plan ( this document)

3 . 2 . SCM Management
3.2. 1 Organization

State how thi s is to be managed . Supply role
( s ) , but no names or responsibil i ties. Names
are supplied in a later section .

State the tasks that each role must carry out. If
th i s is not stated, essential activi ties will not be
done, and some ac tivi ties will be done by more
than one team member. Include backup re ­
spons ibili ties in case the main individual is
incapac i tated .

3 . 2 . 2 . 1 Configuration Leader

"Responsible" does not necessar i ly i m ply that
the individual does all of the work-merely
that he or she organizes the work and sees to i t
that the work i s done .

The configuration leader shall be responsible
for organizing and managing configuration manage­
ment (CM ). Whenever possible, the configuration
leader shall discuss CM plans w ith the development
team prior to implementation. He or she will main­
tain th is document ( the SCM P). The configuration
leader is responsible for the installation and main­
tenance of the configuration management tool (s)
specified in Section 3. 2 . 3. Archiving is to be per ­
formed in accordance with department policies
1 2 345.
The SCM leader shall be responsible for ac ­
quiring, maintaining, and backing up the configura ­
tion tools used. He or she shall also develop a plan of
action if tools become unsupported (e . g., by dis­
continuance of the vendor). Additional responsibili­
ties of the configuration leader are stated in Sections
3. 1 - 3.6.
3 . 2 . 2 . 2 Project Leader The project leader and
his or her manager will take over the configuration
leader's function only under exceptional circum­
stances . They are responsible for knowing all the

CASE STU DY: ENCOUNTER VIDEO GAM E

relevant means of access to documents throughout
the life of the project . The project leader shall ensure
that archiving is performed in accordance with the
policies in Section 3.2 .3 below.
Additional responsibilities of the managers are
stated in Sections 3.3.3 and 3.3.4.
3 . 2 . 2 . 3 Engineers It is the responsibility of each
engineer to abide by the CM rules that the configu ­
ration leader publishes. Engineers are also referred to
"Standard Engineering Responsibilities," document
56789.
Additional responsibilities of the engineers are
stated in Section 3 .3 below .
3.2.3 Applicable Policies, Directives, and
Procedures

5. C M passwords should b e changed i n accordance
with corporate security practices, with the fol­
lowing addition: No password shall be changed
until the project leader, his manager , and the
manager of QA have all been notified and have
acknowledged the notification.
6. The project leader and department manager are
to have complete access to all documents under
configuration at all times. Access verification
form www .ultracorp.division3.accessVerification
is to be submitted every two weeks by the project
leader to his or her manager .
7. The Encounter project will use SuperCMTool
release 3 .4, a configuration management product
by SuperCMT 001 .

These are fictitious names.
Activities such as CM are generally conducted
in accordance with group or corporate guide­
lines. Student teams should identify and list
their policies in this section. Policy 3 should

8 . Archiving is to be performed in accordance with
department policies 1 23456.

be included.

3 . 3 . SCM Activities
1 . Configuration management for this project shall
be carried out in accordance with the corporate
gUidelines for configuration management, cor ­
porate document 7890 version 6 ( 8 / 1 5/98 ).
2. In accordance with division software improvement
policies, midstream and post-project review ses­
sions are required, where improvements to these
guidelines are to be documented for the benefit of
the organization . These sessions are required to
help prepare the division for level 5 CMM certifi­
cation. The self-assessment results are to be sent to
the manager of Software Self-Assessment within
three weeks of the assessment session. All "room
for improvement" sections are to contain substan­
tive material, with specific examples.

3.3.1 configuration Identification

This section states how configuration items
( CIs) come into being and how they get their
names. Without such procedures being stated
and followed, chaos results.

3. All current and previously released versions of
CIs will be retained.

3 . 3 . 1 . 1 Identifying Configuration Items The
project leader shall be responsible for identifying all
Cis. Engineers wishing to propose CIs shall secure his
or her agreement, via e-mail or otherwise. If the project
leader is unavailable for one business day following the
engineer's e-mailed proposal for inclusion, the config­
uration leader shall have the authority to accept the
proposed item.

4. The master file (defined in Section 3.3. 1 . 2 ) can be
accessed only by the configuration leader and, in
his or her absence, the department manager.

3 . 3 . 1 . 2 Nam ing Confi guration Items The con­
figuration leader shall have the responsibility for

131

1 32

CHAPTER 6

SOFTWARE CON FIG URATION MANAGEMENT

labeling all Cis. The file conventions shall be as
fo llows :
Root directory: Encounter
Subdirectory: SRS or SOD or .

control through SuperCMTool. A read-only version
of the CI is avai lable to all engineers. Under no
circumstances may an engineer transfer a CI directly
to anyone .
3.3.2 Configuration Control

File N-N-N.xxx corresponding to version NNN
For example, version 2 . 4.8 of the SRS will be on
file EncounterlSRSI2_4_8 . txt .
The text fHe Master in the root directory states
the versions of the Cis that comprise the current and
prior states of the project . For example, Master could
include information such as :
The current version of Encounter is 3. 7. 1 . It
comprises version 2. 4.8 of the SRS, version 1. 4
of the SOD .
The previous version of Encounter was 3.6. I I .
It comprised version 2. 4 . 8 of the SRS, version
1.3 of the SOD.
This information shall be maintained in a table
of the following form .
Encounter SRS version SOD version .
Release
3 . 3 . 1 . 3 Acquiring Configuration Items

In specifying th is sec tion, imagine the most
stressful part of the project, which is the
i mplemen tation phase, involv ing several peo ­
ple in parallel . The process has to be very
orderly, bu t i t also has to allow engineers
reasonable access to the parts of the project
so that they can start work qu ickly .

Engineers requiring CIs for modification shal l
check them out using SuperCMToo\'s checkout
procedure . Note that SuperCMTool prompts the
user with a fo rm requesting an estimate of how
long the checkout is anticipated, and stores this
information for all requesters of the CI. Anyone
requiring a CI that is currently checked out should
negotiate w ith the current owner of the CI to transfer

This section spells out the process whereby
con fi guration items are changed. This process
should be flexible enough to allow quick
changes, bu t control led enough to keep
ch anges very orderly so that they i mprove
the appl ication, not damage i t .
3 . 3 . 2 . 1 Requesting Changes A s specified i n the
Software Project Management Plan (see Part III), the
team will designate an "inspector" engineer who is
allocated to each team member . Be fore requesting a
change, engineers must obtain an inspection of the
proposed change from an inspection team or, i f this
is not possible, from the ir inspector engineer . To
request the incorporation of a changed CI into the
baseline, form www .ultracorp.division 3 . Encounter
.submitCI must be submitted to the configuration
leader and the project leader, along with the changed
CI and the original CI.
3 . 3 . 2 . 2 Evaluati ng Changes

For larger projects, a group of people, often
cal led the Change Control Board, evaluates
and approves changes . Student teams must
make this process reasonably simple.

The project leader or des ignee w i l l evaluate
all proposed changes . The project leader must
a lso spec i fy the requ ired qua l ity standards for
incorpo rat ion.
3 . 3 . 2 . 3 Approving or Disapproving Changes
The project leader must approve proposed changes .
If the project leader is unavailable for three business
days fol lowing the submission of a proposed change,
the configuration leader shall have the authority to
approve changes.

CASE STUDY: ENCOUNTER VIDEO GAME

3.3.2.4 Implementing Changes
To avo i d chaos, it is natural to give to the CM
leader the responsibil ity for incorporating
changes; th i s can create a bottleneck at im ple·
mentation time, however. Before th i s "crunch"
occurs, th e CM leader should find ways to
remove th i s bottl eneck by di stri buting as
much work as feasible to the engineers making
th e changes.

Once a C[ is approved for i ncorporation i nto
the baseline, the configuration l eader shall be re­
sponsible for coordinating the testing and i ntegra­
tion of the changed CI. This should be performed i n
accordance with t h e regression test documentation
described in the Software Test Documentation. [n
particular, the configuration leader shall coordi nate
the bui lding of a version for testing. Version releases
must be cleared with the proj ect leader, or with the
manager i f the project l eader is absent.

3.3.3 configuration Status Accounting
The configuration leader shal l update the configu­
ration summary at l east once a week on the proj ect
con figuration Web s i te www.ul tracorp.divisi on3/
Encounter/Configurati on. SuperCMTool's status
report will be a sufficient format for the summary.

3.3.4 Configuration Audits and Reviews
[n industry, random audits are often emp loyed.
They are not commonly conducted by student
teams due to a lack of resources, although
some teams have carried them out successful ly.
Peri odic revi ews, as part of the regular team
meetings, do not take much time, and they are
recom mended.

The project m anager shall schedule a review by
the CM leader of the configurati on at least once
every two weeks, preferably as an agenda item for a
regularly scheduled weekly project meeting. The
CM leader shall review CM status, and report on
the proposed detailed procedures to be followed at
code and integration time.

Configuration efforts will be subject to random
audits throughout the proj ect's l i fe cycle by the
[V&V team.

3.3.5 Interface Control
The CM system i nterfaces with the project Web site.
Thi s interface shall be managed by the configuration
leader.

3.3.6 SubcontractorNendor Control
The configuration leader shall track upgrades and bug
reports of SuperCMT001. He or she should be prepared
with a backup plan in case the maintenance of Super­
CMT001 is discontinued. This plan is to be sent to the
project leader within a month of the project's inception.

3.4 SCM Schedules
The SCM schedule can be provi ded here, or
combined with the project schedule in the
SPMP. [n the latter case, th is section woul d
not repeat the schedule, but woul d merely
point to the S PM P.

The schedule for configuration m anagement
reporting, arch ivi ng, and upgrading is shown i n
Figure 6 . 7.

3.5 SCM Resources
The configuration leader w i l l re quire an estimated
average o f six h ours a week to m a i ntain the system
configuration for the first h a l f of the proj ect, and
twelve h ours a week for the second h a l f . We h ave
chosen not to call out sep aratel y the time spent by
the other team members on configurati o n
management.

3.6 SCM Plan Maintenance
All project documents undergo change
throughout the duration of the project. The
SCM P is especially sensitive to change, how­
ever, because it controls change itself.

133

134

CHAPTER 6

SOFTWARE CONFIGURATION MANAGEMENT

Month 1 Month 2 Month 3 Month 4 Month 5
1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4
Stable eM

!
Vendor backup plan due

eM reviews
eM process
improvement
session
Random IV and V audits
Figure 6.7 Configuration management schedule

Due to the importance of a stable SCM plan, all
ch anges to this document must be approved by the
entire CM team .
In view of the software development organiza­
ti on's goal to attain CMM level 5, the configuration
leader will do the followi ng for the CM process
improvement sessi ons :
•

Review the effectiveness of th is plan

•

Quantify losses due to defects in this plan

•

Review the effectiveness of Super CMT001

•

Investigate the l iterature for new CM methods;
quanti fy the costs and benefits of i m provements

•

Investi gate new CM tools

•

Suggest spec i fic im provements to th is CM process

•

List the benefits of i mprovements

•

Provide cost estimates on effecting the improvements

•

Pri oritize the cost/bene fit ratios of all the sug­
gested changes

6.6 CASE STUDY: ECLIPSE

CONFIGURATION MANAGEMENT IN
ECLlPSE1

Open source projects such as Ecl i pse are developed
by geographically dispersed engineers who have
1

This section is based on information from [6].

di fferent source code access requirements . Most are
developing the i r own plug- i n s, wh ich are exten­
sions to existing Ecli pse code and functi onality,
and only require access to Ecl ipse source code
for debugging their work. Others may want to
change exi sting Ecl i pse source code if they are
fixi n g a bug, or add code i f they are devel op ing
a feature . These devel opers require write - access to
Ec l i pse code .
Source code is managed in Eclipse using CVS
(Concurrent Versi oning System), wh ich is the de
facto version control system for open source proj­
ects . Ecli pse integrates a buil t-in CVS CUI, making
version control very easy to use. CVS implements a
client- server architecture , with the Ecl i pse repository
housed on a central server at dev.ecl ipse. org that
stores all the Ecl ipse source code .
In general there are two classes of Eclipse users
as fol lows:
1. Those that want to read and/or modify Ecli pse
code but don't have write access to the CVS
repository.
2.

Those that do have write permission for the
Ecli pse source code and can modify and update
the CVS repository. These people are call

committers.
The fol lowi ng is quoted from [7] and descri bes
these two classes of users.

CASE STUDY: ECLIPSE

Anonymous CVS

For people who actually want to change Ecl i pse code but who do not have the required commit ri ghts
in that area, al l elements of the Eclipse project are available via anonymous access to the development
CVS reposi tory. Using anonymous access you can checkout code, mod i fy it local ly, but cannot wri te it
back to the reposi tory. This is handy i f you would l ike to fix a bug or add a feature. Get the code via
anonymous access, do your work, and then pass the work on to a com m i tter for inclusion in the
reposi tory . .
All committers must use SSH (Secure SHeil ) to access the CVS reposi tory i f they wish to use their
user id and password (i.e., i f they want to wri te to the reposi tory).
Full CVS

Developers with commit ri ghts have indivi dual user ids and passwords in the Ecl i pse project
development reposi tory. As a com mi tter you can use SSH (Secure SHeil ) to connect to the CVS
reposi tory as fol lows . . . . . Once your information is authenticated, you can browse the reposi tory and
add proj ects to your workspace. If you do some changes that you'd l ike to contribute, after testing and
ensuring that you have fol lowed the contribution guidel ines, you are free to release your changes to the
reposi tory. Of course, you can only release changes to proj ects for whi ch you have commit rights.
Note that you can use the SSH protocol and your Ecl i pse user id to access proj ects for which you
are not a com m i tter, but you wi ll not be able to release changes .
These points are summarized i n Figure 6 . 8 .
VERSION NUMBERING

Ecli pse plug- ins use a versio n-numbering scheme
that captures the nature of the changes implemented
by the plug- in. Version numbers are com posed o f
four parts a s follows:
Major, minor, service, and quali fer. Major, minor,
and service are integers, and qua lifier is a string.

•

Maj or-this number is incremented each time
there i s a breakage in the API

•

Minor-this number is incremented for "externall y
visible" changes

•

Service-th is indicates a bug fix or other change
not visible through the API

•

Qual i fier-this indicates a particular build

Official
Eclipse
Code
Base

Write access
with password

(CVS)

General
User

Committer

Figure 6.8 Eclipse configuration management

135

136

CHAPTER 6

SOFTWARE CONFIGURATION MANAGEMENT

First development stream

1 .0.0
Second development stream

1.0. 1 00 (indicates a bug fix)
1 . 1 . 0 (a new API has been i ntroduced)
The plug- i n ships as 1 . 1 . 0
Third development stream

1 . 1 . 1 00 ( i ndicates a bug fix)
2.0.0 (indicates a breaking change)
The plug-i n ships as 2 . 0 . 0
Maintenance stream after 1.1.0

1 .1. 1
The plug-in ships as 1 . 1 . 1
Figure 6.9 Eclipse plug-in version numbering 1 of 2
Source: Eclipse Wiki, http://wiki.eclipse.orgNersion_Numbering.

The example shown in Figure 6 . 9 and 6 . 1 0,
taken from http://wiki.eclipse.org. shows how the
vers ion number changes as a result o f plug- i n devel­
opment. The description shows that bug fixes, new

application programming interfaces, and shipping to
the community are reflected i n the numberi ng in
particular ways.

6.7 STUDENT TEAM GUIDANCE: CONFIGURATION MANAGEMENT

Student teams should create a Software Con figurati on Management Plan (SCMP) for their project usi ng IEEE
Std 828-2005 as a template and the Encounter SCMP i n Section 6 . 5 guidance. The rest of th i s secti on
describes how to organize for this task.
Q)
'"
co
Q)

1.00

£

First dey stream
Q)
'"
co
Q)

03
a:
Maintenance stream after 1.1.0

Second dey stream

'--....,1--..,-----. Third dey stream
Figure 6.10 Eclipse plug-in version numbering 2 of 2
Source: Eclipse Wiki, http://wiki.eclipse.orgNersion_Numbering.

SUMMARY

1. Roughly sketch out your SCMP
o

Determine procedures for maki ng changes .

o

Omit tool references unless already identi fied one.

o

See the case study for an example.

2. S peci fy what you need from a CM tool
o

For class use, maybe only l ocking and backup.

3. Evaluate affordabl e tools against needs and budget
o

Commercial tools are in wide use .

o

For class use, try free document storage Web sites; simple method of checki ng out, e . g. , renam i ng,
can be too simple.

4. Final i ze your SCMP
Figure 6.11 Planning configuration management

Figure 6.11 shows how teams can go about dec iding their con figuration management methods .
When there is i nsufficient time to learn a CM environment, teams have succeeded reasonably wel l with
simple Web sites, such as www.yahoogroups. com.that allow document storage. A simple checkout system is
needed, one o f which i s to change the document type. For example, when the S QAP is checked out to Joe ,
the file is changed from sqap.txt to sqap.joe. Although con figuration management applies to both documents
and source code , the file-naming convention usually has to be planned separately. For example, we cannot
change myClass.java to myClassjoe without disrupting compilation. Some groups maintain two directories. One
contains the current baseline, which cannot be changed without a formal process. The other directory
contai ns versions that are currently being worked on.
Trial CM tools or free ones such as CVS and Subversion are avail able. Coogle supports free document
hosting with Coogle Docs and has support for version contro l . Be sure that your process does not rely on
excessive manual intervention, and that it does not result in a bottleneck where one person is overloaded. If
you are consideri ng using a tool, be sure that the length of the learn ing curve justifies its use . There are many
other software engineering aspects to learn besides using a particular CM too l . Whatever system you select,
try it out first on an imagi ned i mplementati o n . Make sure that the process is smooth . You do not want to
worry about your CM process duri ng the impleme ntation phase , when time is l i mited. In the work world,
however, professional CM tools are a necessity.
6.8 SUMMARY

Software con figuration management ( SCM) is a process for managing all the arti facts produced on a software
project, i ncludi ng source code , speci ficati ons, and supporting software. Planning for SCM starts early in a
project, starti ng with the Software Con figuration Management Plan. It speci fies the SCM activities to be
implemented throughout development and so ftware mai ntenance, such as identi fication, change contro l ,
version control, audi ts, status reporting, a n d release management.
Early i n a proj ect, arti facts are identi fied as con figuration items (CI) to be stored i n a repository and
managed. After a CI is reviewed and approved i t becomes part of a baseline and is officially managed by SCM
policies. Arti facts go through i nevitable change, being newly created or modi fied due to either error
correction or enhancement. SCM de fines activities to request, evaluate , approve or disapprove, and
implement changes to basel i ned Cis.

137

138

CHAPTER 6

SOFTWARE CONFIGURATION MANAGEMENT

A key requirement of SCM is the ability to reproduce the precise state of all Cis at any point in time. A version
control system (also known as a configuration management system) automates much of this process and provides a
repository for storing versioned Cis. It also allows team members to work on artifacts concurrently, flagging
potential conflicts and applying updates correctly. Version control systems include functionality for checking in
and checking out files, branching and merging, building the software, and creating software versions.
Configuration audi ts, which are typically conducted by the quality assurance group, are used to ensure
that agreed upon SCM procedures and pol icies are being followed, and that software being produced is
comprised of the correct components.
Configuration status reports support the audit process by provi ding a detailed history for each CI
including when it was created and modi fied, how it was modified, and by who m .

6.9 EXERCISES

1. In your own words, de fine the term configuration item and describe its purpose.
2. Why is it necessary for compilers to be identified as configuration items? Describe a scenario that

illustrates when thi s is necessary.
3. Describe the four goals of configuration management in your own words, and explain why each is
important.

4. If you are developi ng a so ftware application using an incremental process, at what poi nts would
you mi nimally create baseli nes?
5. Explain the di fference between change contro l and version contro l .

6. Agi le processes promote conti nuous i ntegrati o n , wh ich results i n branching a n d mergi ng at very
freque nt intervals (as often as every few hours). Describe one advan tage and disadvantage of
branching and mergi ng so frequently. Describe one adva ntage and di sadvantage of branching and
mergi ng less frequently.
7. As mentioned in the Team Gui dance secti on ( Section 6.6) , for small teams it may not be necessary
to utilize an automated configuration management system. Describe the process you would fol l ow
to perform branching and mergi ng without such a system.
8 . Research

a con figurati on management system such as Subversion or CVS. Describe how it
implements the seven SCM activi ties listed in Section 6.2.

TEAM EXERCISE

For the team exercise, consider as a group how you wi l l perform it, check the hi nts below, and then
carry out the assignment.

eM Plan
Produce a software configuration management plan for your team proj ect using IEEE standard 8281990. The case study should guide your team, but your document will be more specific, reflecting the

BIBLIOGRAPHY

particular resources available to you. Do not include material unless it contributes to the document's
goal s . Avoid bottlenecks and unnecessary procedures. Include procedures for what to do if people
cannot be reached and deadlines loom.
Before you begi n, estimate the number of defects per page the team thi nks it will discover during
the fi nal review. Keep track of and report the time spent on th is effort by individual members and by
total team effort. State the actual defect density (average number of defects per page ) . Assess your
team's effectiveness in each stage on a scale of 0 to 1 0 . Summarize the results using the numerical
results, and state how the team's process could have been improved.
Criteria:

1. Practical i ty: How wel l does the plan ensure that documents and their versions will be secure ,
coordinated, and avai lable? (A

=

plan very l ikely to ensure coordination and availability)

2. Specifics: How speci fic i s the plan i n terms of suitably naming places and participants? (A

=

no

doubt as to what engineers must do)
3. Process assessment and improvement: To what degree did the team understand the strengths and
weaknesses of i ts process, and how specific are its plans for improvement? (A
full , quantitative
understanding, with plans for improvement very speci fic and real istic)
=

Hints for Team Exercise
Do not fill in sections that are as yet unknown; add only parts that you are confident of being abl e to
implement with i n the semester. Make your plan real istic. For example, don't state that "all other team
members will review each contri butor's work" unless you are reasonably sure that this can be done
with i n the probable constrai nts of your project. It is too early to make any assumptions about the
architecture and design of the application.

BIBLIOGRAPHY
1. Bellagio, David, and T. Milligan, "Software Configuration Management Strategies and IBM Rational Clearcase, A Practical
Introduction," IBM Press/Pearson pic, 2005, p. 7.
2. "IEEE Standard for Software Configuration Management Plans," IEEE SId 828-2005, August 2005.
3. "IEEE Standard for Software Reviews and Audits," IEEE SId 1028-2008, August 2008.
4. Hass, Anne M. J.. "Configuration Managemenl Principles and Practice," Addison-Wesley, 2003, p. 25.
5. "Systems and software engineering-Software life cycle processes," IEEE SId j2207-2oo8 Second edition, January 2008, p. 69.
6. Eclipse, httpJlwww.eclipse.org [accessed August 13, 2009].
7. Eclipse, httpJlwww.eclipse.org/eclipse/ [accessed August 13, 2009].

139

principles of Software project
Management I: Organization,
Tools, and Risk Management

Planning

�"""."'. \
Testing
The Software
Development
Lifecycle

Requirements
analysis

Implementation
�DeSign /

How are software development
projects organized?
What is an appropriate team size?
What happens when teams are
geographically distributed?
What tools and techniques are
available to support projects?
How do you handle risks?
How are projects managed in
practice? In student teams?

Figure 7.1 The context and learning goals for this chapter

Software project management is the process of plan n ing, organizing, and monitori ng the development of a
software project from its i nception to its completio n . It incorporates a set of tools and tech niques practiced by
the person or people responsible for a project during every phase of development. The person responsible is
the project manager (a term usually used for larger projects) or team lea der (a term typically used for smaller

PRINCIPLES OF PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

•

Customers are seldom sure of what they want.

•

Customers change their requirements and plans m ay not be updated.

•

It is hard to estimate up fron t the magnitude of the effort required.

•

I t is hard to coordinate the many requirements, the design elements corresponding to each requirement,
and the corresponding code.

•

There m ay be unforeseen technical difficulties to overcome.

•

It is not easy to mai ntain constructive interpersonal team dynamics. Time pressures cause stress, and team
members have di ffering opi nions.

But these obstacles can all be overcome!
Figure 7.2 Some challenges of software project management

projects or teams) . Sometimes the person responsible is called the project manager and has one or more
subordinate team leaders . In all cases, these people practice project management. Critical to the success of a
project is the organization of the project team . Many di fferent organizational structures are possible, each
with a set of strengths and weaknesses.
It is very difficult to del iver a quality, fully accepted software applicati on on time and with i n budget.
Figure 7.2 gives some of the main reasons. Software project management addresses these issues by
i ncorporating a range of activities and structure into a project, i ncludi ng project organization, tools, and
support, management of project risks, project estimation and scheduling, project documentation and
tracking. These are summarized i n Figure 7.3 and explained i n this chapter.

•

Organization
o

•

Project Management Tools
o

•

How long will the project take to complete and how many resources are required?

Scheduling
o

•

H ow are risks to the project's success identified and mitigated?

Estimation
o

•

What tools are available to support project management?

Risk Management
o

•

How is the project team structured?

What are the di fferent parts of the project, in what order will they be completed, and who will work
on each part?

Documentation and Monitoring
o

How is a project plan created, and how is the plan monitored to e nsure that the project is progressing
on time and with i n budget?

Figure 7.3 What does software project management address?

141

142

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

The rest of this chapter focuses on the organ izational structures, tools, and risk management that
support project management. The next chapter, which completes our discussion of proj ect management
pri nciples, covers methods that can be employed, includi ng estimati on, schedul ing, and planning.
7. 1 SOFTWARE PROJECT ORGANIZATION

The way in which a com pany is organ ized has a direct beari ng on how proj ects are executed. Some
companies organ ize around their proj ects. In these com pan ies proj ect managers have great auto nomy, wi th
team member directly reporting to them . Other compan ies organ ize around functional areas such as
development, marketi ng, finance, and so on, givi ng proj ect managers respo nsibil i ty for monitoring and
reporting on project progress . Other com pan ies employ an organizati on that mixes both of these. I n general ,
there are three types of organ izational structure: project-oriented, Junction-oriented, and matrix. We examine each of
these in the secti ons that follow.
7. 1 . 1 project-Oriented Orga n ization

In project-oriented organizations, personnel are organ ized around the projects of the com pany. When a new
proj ect is ini tiated, a project manager is assigned to head up the project. One o f their first tasks is form ing the
team , which is made up of new hires or people who are finishing other projects. The proj ect team comprises
people from multiple functional areas such as marketi ng, finance, devel opment, and so on. Team members
report to the proj ect manager, who is their ultimate boss . They are attached in all ways to a particular project,
and have no organ izati onal affil iation with people on other proj ects . This type of organization is illustrated in
Figure 7.4.
The princi pal reason to organ ize aroun d proj ects is to develop loyalty to the proj ect rather than to the
functional manager [1]. Since employees are dedicated to a si ngle project, they can focus their time and
energy on that project. This i ncreases the predictability of schedules as there is less chance of team members
spending unscheduled time on other proj ects . However, this type of organ ization has the potential
disadvantage of isolating engineers professio nally and reduci ng the amount of reuse and pro fessi onal
stimulation between projects as a result of th is isolati o n .

Senior
Manager

I

I
Project
Manager

Project
Manager

Project
Manager

Project Team
(Marketing, Fi nance,
Software, QA)

Project Team
(Marketing, Finance,
Software, QA)

Project Team
(Marketing, Fi nance,
Software, QA)

Figure 7.4 Project-oriented organization

SOFTWARE PROJECT ORGANIZATION

President

I

I

Finance

Marketing

i

I

I

Development

QA

I

I

I

I

Finance
Managers

Marketing
Managers

Software
Managers

QA
Managers

I
Finance
Personnel

l
Marketing
Personnel

I

I

Software
Engineers

QA
Engineers

Figure 7.5 Function-oriented organization

7 . 1 .2 Fun ction-Oriented Orga nization

Function-oriented organizations are a very common type of structure. A company is organi zed into groups based on
their functions, such as marketing, finance, development, QA, and so on. This type of structure is i l l ustrated i n
Figure 7.5.
In this form , functional organizations have projects, but the scope o f their projects is limited to the
boundaries of their group responsibilities. As an example, i f a software functio nal group is working on the user
i nterface ( U I ) software of a larger software product, only the UI software being devel oped is considered the
current project for that group.
Functional managers i n this kind of organ ization act as project managers, respo nsible for their projects
as well as the hiri ng, firing, and salary of their team members. Managers may be responsible for multiple
projects. Th is structure has the advantage of clear and responsible decisio n-maki ng channels. However,
because managers are responsible for multiple projects , their knowledge of projects is necessarily limited by
their avai lable time. In addition, they must weigh carefully the needs of each and ensure that they don't favor
one over the other. If one of their projects is fal l i ng behind schedule, for example , they may shift personnel
from another project to the laggi ng project. Th is may cause a delay i n the other project.
7 . 1 .3 Matrix Organization

Matrix organiZations are a cross between project- and function-oriented organizations. They try to gain the
advantages o f both project-oriented and function-oriented organizations. I n a matrix organization, employ­
ees belong to a functio nal group (e.g., marketi ng, engineering) but are loaned to projects based on their
expertise. Thus, a so ftware engi neer's supervisor-who is responsible for evaluating that person-would be a
member of the software engineeri ng functional unit. With i n each project on which the person is working,
however, he or she would be supervised by a project leader. Engineers are usually i nvolved on a regular basis
with one project, sometimes two, but seldom more.
Figure 7.6 illustrates the reporting structure of a matrix organization. In this structure, a project manager is
assigned to each project. For example , Oscar Mart is a member of the marketing department and assigned to the
airline reservation project, headed by Al Pruitt. For all project-related activities, Oscar reports directly to AI.

1 43

144

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

Project

Matrix Organizati on

Project
management

Airline

Bank

Molecular

Fluid

reservation

accounting

analysis

mechanics

project

project

project

project

AI Pruitt
Full time

Qu inn
Parker
Full time

Ruth Pella
Full time

Fred
Parsons
Full time

Oscar Mart
Full time

Pete Merri ll
Full time

Sue More
Hal f time

Elto n
Marston
Full time

Hal Egberts

Ben Ehrl ich

Mary
Ericson

Len Engels

dept

to
c:
o

ti

c:
::l
u..

Marketing
dept Oulia
Pitt, mgr)
Engineering
dept Ooe
Roth, mgr)

Figure 7.6 Matrix organization

However, Oscar's boss is Jul ia Pitt, a manager in the marketing department. Jul ia woul d consult with AI when
doing performance appraisals.
An advantage to th is approach is that project managers maintain focus and have responsibility for the
success of their projects. Functional man agers are focused on the content of their functional area and can
more easily coordinate the efforts of their group members, some of whom may work on multiple projects . For
example, the so ftware manager of a database group might recogn ize that multiple projects have similar
requirements for accessing a database . The manager can coordinate a software design that is general enough
to be used by multiple projects . We will consider team size next .
7. 1 .4 Agile Orga n ization

Agile teams consist of technical people. Their pri ncipal nontechnical contact is with the customer. Sti l l ,
functions of the kind mentioned above conti nue t o b e required. An example is finance. Every organization
needs to understand the costs and benefits of projects . Agile teams become adept at estimation , and so finance
people-who are not part of the agile team itsel f-have goo d short- term data and forecasts but are required
to be agile as wel l . This i s because agile teams are not plan-driven. The upshot is that the nontechnical people
must base their work on good but relatively short-term data . They perform their work by interacting with the
customer and with the development team .
7.2 TEAM SIZE

To be precise, a "team" is a group of people who work closely together on a daily basis . One m i ght imagine
that the appropri ate size of a team depends strongly on the size of the application ( large teams for large
applications, etc . ) but this is not so. Large teams (not necessarily groups-keep the definition of "team" i n
m i n d ) have the advan tage of divi ding the work i nto many parts but the disadvantage of communication that i s

TEAM SIZE

Effectiveness
per developer

Developer communicates
regularly with 11 people.

Developer

� communicates
regularly with no one.
�
�

Number of people with whom
developer must interact frequently

Key:

0

=

engineer

Figure 7.7 Options for team size showing extremes

time-consuming and error-prone. A significant aspect of such communication is the need for team members
to explai n what they are doing. Having to keep forty people up-to-date on a daily basis, for example, requires
a lot o f meeti ng time . I n his classic work, The Mythical Man-Month [2]. Fred Brooks poi nted out that addi ng
people to a failing project i nvariably makes matters worse. I n other words , for many projects the disadvantage
of increased communi cation channels, which are particularly heavy during the learning process of new team
members, may often outwei gh the advantage of division-of-Iabor.
What is the optimal size of a team? This i s a matter of trading off the benefit of having many helping
hands agai nst the cost of communication among them. The optimal size depends on the nature of the project:
Routine projects can usually benefit from larger team sizes because a lot is understood about what each person
should do . Let's consider extremes for a typ ical project, shown in Figure 7.7. The vertical axis reflects the
e ffectiveness per devel oper.
Experience of the authors and others shows that the number of developers with whom each developer needs
to i nteract on a regular basis should normally be between three and seven. (Humphrey [3J suggests four to eight.) .
Formal studies on the effect of team size on performance are rare. At one extreme shown in Figure 7.7, the developer
works without interacting regularly with anyone on an individual basis. Although no time is spent on
communication, such isolation typically results in misunderstandings of what is required of that developer, leading
to a relatively low level of effectiveness. At the other extreme, the developer has to interact regularly with so many
individuals that there is not enough time left to perform development itself, again resulting in relative
ineffectiveness. In particular, true "regular communication" could entail speaking with someone for an average
of approximately two hours a week. If an engineer were in regular communication with ten others, then fully one
half of his time would be spent communicating, leaving only half of the week for his individual contribution. Project
organizers, whether planning twenty-person or hundred-person projects, have to account for this. Figure 7.S
illustrates these points as follows. If you pick a team size-such as three-and draw a vertical line, it intersects the
blue area between two values of "effectiveness per developer." The inexactness of this measure leads us to talk in
terms of ranges rather than absolutes. We are interested in picking a team size that yields the most efficient work on
a per-developer basis. Figure 7.S shows this occurring between team sizes of about three and seven.
As the number of partici pants i n a project grows, an organization where everyo ne is a peer becomes
impossible to use because the number of communication l i nks (between all of the pairs) grows with the square
of the number of participants. Three people entai l three l i nes of communication, four people entai l six, five
people ten , six people fi fteen: n people require (n - 1) + (n - 2) + ... + 1 n (n - 1)/2 lines of commun icatio n .
This grows with the square of n. One hundred people would have t o participate regularly i n 4,950 l i nes of
communication! One alternative for large projects is the organization shown i n Figure 7 . 9, i n which peer
=

145

146

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

Effectiveness
per developer
,
,
,
,
,
,

Developer communicates
regularly with 11 people.
Communication time
outweighs benefits of
interaction.

Developer communicates

� regularly with no one.

No communication time is
lost, but developer is too
isolated and has no help.

Number of people with whom
developer must interact frequently

Key:

0

=

engineer

Figure 7.8 Range of optimal size for beneficial interaction

Figure 7.9 A peer organization arrangement for larger projects

groups rem ain small, and one member of each group is designated the communi cator with the other peer
groups. This type of organ izati on tries to preserve the bene fits of small teams, but it harnesses the large
number of people to build a large applicati o n . Note that team leaders have double the amount o f
communication t i m e than non-team leaders .
7.3 GEOGRAPHICALLY DISTRIBUTED DEVELOPMENT

Independent of whether a team is project-oriented, function-oriented, or matrixed, team mem bers may be
either collocated or geographically distributed. The latter presents a uni que set of challenges.
Managers naturally try to make use of worldwide programming talent to optimize costs and improve
quality, a process sometimes called offshoring. The Internet and collaborati on tools have made offshori ng
i ncreasingly practical. The per-hour costs o f remote programmers are traded off against the communication

GEOGRAPHICALLY DISTRIBUTED DEVELOPMENT

Same office area

•

+

ideal for group communication
l abor rates suboptimal

•

Same city, di fferent offices communication fair

+

reasonably good communication

+

common culture
l abor rates suboptimal

•

Same country, di fferent cities

+

common culture
communication di fficult

•

Multi -country

+

labor rates optimal
communication most difficult
cul ture issues problematical

Figure 7.10 Possible locations of distributed team
Source: Graphics reproduced with permission from Corel.

problems incurred by physical remoteness . This trade -off depends l argely on the degree of need for conti nual
interaction with the customer. Options for remote teams are illustrated in Figure 7. 10.
B ob Schudy, a colleague of the authors who has extensive experience with offshori ng, lists its
advan tages:
•

Work can be done around the clock

•

Good- qual i ty work is avai lable

•

There is potential for cost savi ng
He l ists the following as disadvantages:

•

I ncreased di fficulty for the o ffshore personnel to understand requirements

•

The l ack of i n formal "chatter" that can smooth progress

•

Time di fferences for (virtual ) meetings

147

148

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

Costs of Offshoring
Benefits of Offshoring

® Communications hampered

© Lower offshore labor rates

® Cultural differences

© Work continues during U.S.

® Increased project

management costs

night time

/\

/\

�
Figure 7.11 To offshore or not to offshore
•

Surpri ses in skil l sets

•

Traveling ills, especially for westerners in the East
Schudy i ncludes the following i n his remedies for these disadvantages .

•

Meet face -to- face initially and peri odically.

•

Use various media (chat, VOIP, conference calls, etc. ) .

•

Make sure there i s stro ng onsite management.

Some of the trade -offs that are accounted for i n deciding whether and how much to offshore are shown
in Figure 7.11.
Figure 7.12 is an example of how a project can be distributed among "near-shore" (same country; remote
location) and offshore. Figure 7.13 shows how tasks could be allocated in a distri buted development project.
The particular al locations are shown as examples only, and were quoted by a group at IBM.
IBM lists the methods in Figures 7.14, 7.15, and 7.16 for dealing with distributed development. The word
"requirements" in the figures refers to what is needed about the process, not the requirements of any one application .
GOD stands for geographically distributed development. UML is a design notation covered in this book.

en

.�
Cij
c
«

c
.�
en
Q)
0

-0
c
'"
c
a
0-B

jj
Q)
'-'
c
'"

E

a
c"t
::::J Q)
LL Cl.

en
�
C

c
Q)
E

Q)
en

Q)
c

C
Q)
E

E

a.

8.
a
0

>a

Q)
0

�
'"
E

�

'0'
ct

Figure 7.12 Example of how tasks can be allocated in a distributed development project.
Source: IBM, copyright © International Business Machines Corporation, reprinted with permission, http://www3.software.ibm.com/ibmdllpub/software/rational/

web/guides/GC34-2500-00.pdf.

GEOGRAPHICALLY DISTRIBUTED DEVELOPMENT

Remote subcontractor

In-house team
•

Testing on pre-release builds

New feature development and related testing

•

Testing maintenance releases of current version

Requirements: capturing, documenting, and

•

Build and deployment

managing

•

Selected project management

•

System architecture, modeling

•

Maintaining current version

•

Project management

•

•

Business analysis

•
•

Unit testing components modified during
maintenance

•

Creating and modifying requirements for
maintenance

Figure 7.1 3 An allocation of tasks
Source: IBM, copyright © International Business Machines Corporation, reprinted with permission, http://www-128.ibm.com/developerworks/rational/library/

apr05/cammarano/index.html.

REQUIREMENTS

IBM RESPONSE

United teams despite

•

diverse languages and

•

cultures

Enable browser-based access to the same knowledge base for all teams
Provide easy access to guidelines, template and tool mentors based on
underlying best practices

•

Visually communicate discipline workflow and interactions with the Unified
Modeling Language (UML)

•

Reduction in work
transfer issues

Implement a framework based on core process workflows from business
modeling through deployment

•

Use a phased approach to software development that details execution for
each discipline

•

Easy-to-navigate pro­
cess that is not over­

Jump-start planning and get new team members up to speed fast with
knowledge assets and guidance

whelming for users

•

Allow users to create personal process views that are central to individual
needs

•

Provide intuitive navigation with a browser-based interface

Demonstrated progress

•

Track metrics throughout the project life cycle

toward expected return

•

Report on variance measurements and adjust process to achieve desired results

on investment for GDD

•

Track project progress and quality through quantitative analysis

--------------------�

projects
Ability to assess and
manage distributed re­
sources efficiently

I. Maintain a broad and deep understanding of an organization's capacity, skills
inventory, total workload and resource demand

•

Optimize skill usage with resource planning to align mission-critical resources
with high-priority projects

Figure 7.1 4 Tools and methods for distributed development, IBM, 1 of 3
Source: IBM, copyright © International Business Machines Corporation, reprinted with permission, http://www3.software.ibm.com/ibmdl/pub/software/rational/

web/guides/GC34-2500-00. pdf.

149

1 50

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

Demonstrated progress
toward expected return
on investment for GOD
projects

•

Track metrics throughout the project l i fe cycle

•

Report on variance measurements and adjust process to achieve desired results

•

Track project progress and quality through quantitative analysis

Ability to assess and
manage distributed
resources efficiently

•

Main tain a broad and deep understanding of an organization's capac i ty, ski lls
inventory, total workload and resource demand

•

Optimize skill usage with resource planning to align mission-critical resources
with high-priori ty projects

Scalable project
management solution

•

Central ize sensitive schedule, budget and resource data while allOWing
secure, high - performance access anywhere in the world

•

Implement native scheduling, resource loading and "what-iP' scenarios that avoid
performance issues by integrating with third-party scheduling products

•

Capture and reuse successful GOD engagement models, work breakdown
structures and workAows to ensure execution against IT governa nce re­
quirements and best practices

•

Enable reusable project templates and task guidance based on a proven
process, so teams never have to start planning from scratch

•

Accurately track l abor expenses and budget for time and materials or fixed­
bid resources

Consiste ntly executed
processes

Accurately tracked
labor costs for in -house
or extern al resources

Figure 7.1 5 Tools and methods for distributed development, IBM, 2 of 3
Source: IBM, copyright © International Business Machines Corporation, reprinted with permission, http://WWW3.software.ibm.com/ibmdl/pub/software/rational/

web/guides/GC34-2500-00.pdf.

IBM RESPONSE

REQUIREMENTS

Quick and easy Im ple­
mentation to start col­
laborating in days, not
months

•

Facil itate discussions, set up chat rooms and combine team calendars with
ready-to-use templates

•

Leverage out-of-the box functional i ty that users can customize themselves

•

Centralize instal lation on one server

Consolidated work area
where teams can more
effectively communi­
cate and collaborate on
project issues

•

Create a centralized l ocation to post and share project documents that can
be viewed and modified by other team members

•

Share team member project calendars

•

Track feedback from other team members

•

Enable the creation of forums and parti cipation in threaded discussions

•

Allow team members to share flies in real time via Web conferencing

Figure 7.1 6 Tools and methods for distributed development, IBM, 3 of 3
Source: IBM, copyright © International Business Machines Corporation, reprinted with permission, http://www3.software.ibm.com/ibmdl/pub/software/rational/

web/guides/GC34-2500-00.pdf.

THE TEAM SOFTWARE PROCESS

REQUIREMENTS

On dem and communi­
cation options for dis­
tributed team members

Ability for all disparate
project members to se­
curely connect to the
tea m workpl ace
through the intranet,
In ternet or mobile
devices

IBM RESPONSE
•

Let users know which team members are available for coll aboration through
i ntegrated presence awareness

•

Provide instant messagi ng for real -time, person-to-perso n communication

•

Leverage browser-based con ferencing to share presen tations and meeting
materials

•

Enable ful l - featured browser-based and mobile access to presence, instant
messaging and team spaces

Figure 7.1 6 (Continued )

7.4 T H E TEAM SOFTWARE PROCESS

Teams avoi d rei nve nting procedures that are common to several software development proj ects : Organiza­
tions create procedures or gui de l i nes i n advance for teams to apply. Watts Humphrey's Team Software ProcessSM
(TS P ) [3 ] does this in a detailed manner. The TSP provi des gui dance to groups on each of the project
development phases after requirements analysis. Humphrey has reported encouragi ng results i n establishing
maturity goals and procedures for software teamwork . The obj ectives of the TSP are shown i n Figures 7.17
and 7. 18. Whether or not a team uses the TSP, much can be learned fro m it. TSP shares several characteristics
with agile teams, such as the autonomy of teams. TSP is heavi ly metric- oriented, and al though agil e methods
are not, they do take seriously the vel ocity measure.
The TSP's em phasis on team initiative and bottom -up interaction encourages an i ncreased degree of
professionalism among software engi neers. For example, Humphrey states that i t is unprofessional for
engi neers to provide management with schedules that cannot be accomplished, even when requested to
do so. He counsels negotiation in such a situation. The phil osophy here is similar to that for agi le proj ects .

Bui l d self- directed teams
• 3-20 engi neers
• establish own goals
• establish own process and plans
• track work
• Show man agers how to manage teams
• coach
• motivate
• sustain peak performance
•

Figure 7.1 7 Objectives of the Team Software Process, 1 of 2
Source: Graphics reproduced with permission from Corel.

151

152

CHAPTER 7

•

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

Accelerate CMM i mprovement
•

make CMM 5 "normal"

•

"Provi de improvement guidelines to high - maturi ty organizations"

•

"Facilitate university teaching of industrial-grade teams"

Figure 7.18 Objectives of the Team software Process, 2 of 2

Professional ism, Humphrey rem inds us, i nvolves an obl igation to serve society responsibly, in addition to
serving employers . Also noteworthy is the TS P's emphasis on "coach i ng" by management extern al to the team .
Management is expected not simply to give orders and speci fy deadl ines, but to provi de guidance, tools, and
other required resources . In th is respect, TSP is better able to handle teams with varying degrees of experience
and skills. TSP is organi zed around iterations of the waterfall sequence; it requires that the team "launch" each
i teration at a meeti ng where a number of prede fined issues are addressed. Humphrey provides numerous
detailed scri pts and checkl ists to support the TSP . Figure 7. 1 9 summarizes these points regardi ng TSP.
The phases can be iterated several times, requiring several launches . Launch issues to be settled are
shown i n Figure 7. 2 0.
Humphrey recommends that the items listed in Figure 7.2 1 be produced by each phase launch . Much of
this is covered by procedures and IEEE documents discussed i n thi s book.
7.4 . 1 Introductory Tea m Software Process (TSPi)

Formal training for TSP is beyo nd the scope of a student team working together duri ng a so ftware
engi neeri ng course. For example, it requires the already extensive Personal Software Process. The TSPi is
a scaled- down version of the TSP designed to fit in an academic semester. The TSPi roles are team leader,
development manager, planning manager, quality/process manager, and support manager. In the TSPi the "support manager"
is responsible for obtai ning and supplying all the tools and environments, such as compil ers, for exam ple .
Humphrey describes a specific semester-long schedule for the TSP i , consisting of three i terati ons (he
calls them "cycles") as shown i n Figure 7. 2 2 .
The idea of this schedule template is that data obtained from each cycle i s used t o estimate the metrics
for the next cycle. Cycle 1 is com paratively long because i t i ncludes the team's first progression through the
stages. It is i ntended to be a "m inimal function working subset of the final product." Cycle 3 is long enough to

•

Team initiative

•

Bottom-up interaction

•

Professionalism among software engi neers

•

Negotiate schedules

•

Emphasis on "coaching" by management Provi de gui dance, tools, and other required resources

•

Participants required to be PSP trained

•

Organized around iterations Each requires a "launch"

•

Numerous detailed scripts

Figure 7.1 9 TSP practices

SOFTWARE PROJECT TOOLS AND TECHNIQUES

D

Process to be used

D

Quality goals

D

Manner of tracking quality goals

D

How team will m ake decisions

D

What to do if quality goals not attained
o

D

fallback positions

What to do if plan not approved
o

fallback positions

D

Define team rol es

D

Assign team roles

Figure 7.20 Issues to settle at TSP launch
Source: Humphrey, Watts S., " Introduction to the Team Software Process (The SEI Series in Software Engineering)," Addison-Wesley, 2000, p. 496. Graphics

reproduced with permission from Corel.

wrap up the job completely. This l eaves a rel atively short middle cycle. "Strategy" (phase 1 of an Iteration i n
Figure 7 . 2 2 ) refers t o the overall way in which the team w i l l g o about building t h e cycle in question. This
requires a high - l evel discussion of the requirements, a conceptual design , and an overal l assembly plan for the
components . The results are then made into the concrete plan ( phase 2 ) , the written requirements ( phase 3 ) ,
and so on.
7 . 5 SOFTWARE PROJECT TOOLS AND TECHNIQUES

Project managers and teams use a variety of tools and techni ques to manage a software project, such as CASE
tools, build vs . buy decisions, language selection, decision making with triage , and the use of project
variables. Each i s described i n the sections that fol l ow.

1 . Written team goals
2 . Defined team roles
3. Process development plan
4. Quality plan
5. Proj ect's support plan computers, software , personnel, etc .
6. Overall development plan and schedule
7. Detai led plans for each engineer
8. Project risk assessment
9 . Project status report
Figure 7.21 Artifacts to be produced at launch
Source: Humphrey, Watts S . , " Introduction to the Team Software Process (The SEI Series in Software Engineering)," Addison-Wesley, 2000, p. 496.

153

1 54

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

Week

M i lestones

1 1 1 1 1 1

1 1 1 1 1 1

1

1 2 3 4 5 6 7 8 9 o 1 2 3 4 5
Delivery !
Cycle 1 launch

I

1I

1 . Strategy
2. Plan

Iteration 1

I

3. Requi rements
4. Design
5 . Implementation
6. Test
7. Postmortem

Iteration 2
Iteration 3

,

I

! Cycle 2 launch
Cy_cle 3 launch !

I

I I

I

1

I

I

I

1 1 . Strategy . . . . I
I
I
1 1 . Str,ategy. . . . I
I I
,

Figure 7.22 TSPi cycle structure (Humphrey)
Source: Humphrey, Watts S., "Introduction to the Team Software Process (The SEI Series in Software Engineering)," Addison-Wesley, 2000, p. 496.

7 . 5 . 1 Tool Selection

A number of vendors sel l tools and environments for helping engineers to develop so ftware applications.
These are sometimes re ferred to as com puter- a i de d so ftware engi neeri ng ( CAS E) tools, and sometimes as
"integrated tools . " Many are packaged with or connected with development environ ments such as M icroso ft's
Visual Studio. They may also be a collection of tools obtai ned from unrelated sources . Figure 7. 23 l ists some
possible tools. They include schedul i ng tools such as M icroso ft Proj ect, configuration management tool s
such a s SourceForge or CVS, requirements management tools such as Rati onal's RequisitePro , design
representation, typically with UML tool s such as Borlan d's Together, code - bu i l ding tools l ike Ant, and
testing support tools such as Rational's TestManager. Large proj ects simply cannot be managed without at
least some o f these components; in particular, configuration management tools are i ndispensable.

Schedul ing
Configurati on management
Managing requirements
Drawing designs especiaIIy UML
Code bui l ds
Testing test case management automation
Figure 7.23 Potential CASE tool components
Source: Graphics reproduced with permission from Corel.

SOFTWARE PROJECT TOOLS AND TECHNIQUES

tHd I

cost Buy oost
(in thousands)

Comments
multi-year costs not accounted for

Supplies

$ 0

$40

Purchase Ajax engine

First-person perspective

$ 5

$ 0

Ajax has this feature

3-D

$1 0

$ 1

Customize Ajax application

Light reflection

$1 5

$1 0

Customize Ajax application

r-----..

TOTALS

( $30 ) $51
'--/'"'--- Build, do not buy

Figure 7.24 Example of build vs. buy decision making for a video game graphics engine

7 . 5 .2 Build or B Uy Decisions

Tools and applications that promise to help or form the basis for new applications are often available. For
example, in planning for a Web -based auction application, we woul d compare the purchase of ready-made
auction software with developing our own application from scratch. Typically, we del ay these decisions until
the requirements are known , but they are discussed here si nce they are a part of project management.
A rational manner for approaching th is kind of decision is to m ake a list o f expenses and to estimate the
magni tude of each al ternative . An example is shown in Fi gure 7 . 2 4, which illustrates the decision-making
process concerning the purchase of the (hypothetical ) Aj ax graphics software that would help us enhance the
graphics of our video game.
Figure 7.24 reduces the decision to a comparison of numbers, which is a common way of deciding among
alternatives. In other words, it computes the bottom line with and without purchasing Ajax's software. It breaks out
the relevant desired graphics features and estimates the cost of each. Ajax implements Feature 1 , first-person
perspective, completely ( i . e . , continually displays the view of the scene from the player's perspective). On the other
hand, Ajax does not do a complete job of handling 3-D (Feature 2 ) , so we will have to program to compensate for
this. Finally, we need light reflection (Feature 3 ) , where the scene gives the impression of a light source shining onto
it from a single direction. Ajax helps here, but we will have to perform considerable programming to make it work.
The table in Figure 7.24 could be an appendix to the project plan or the Software Design Document. A more
realistic version of the table would compare the costs on a multiyear basis, and would include maintenance
expenses . The more features we are required to implement ourselves, the less attractive the purchase.
Many decisions can be framed in a cost comparison form l ike this. Maintaining a written record of
decisions such as quantitative build- or-buy trade -o ffs helps in communicating these decisions to the team and
others . The form can be refined and updated as more i n formation becomes known , and it aids postmortems
and process improvement.
7.5 .3 Language Selection

Although the identi fication of an implementation language or languages is frequently a design dec ision ,
languages are often identified near the begi nning of the proj ect. Sometimes th is decision is straightforward, as
when the organization mandates a language , or when a language is the only one capable of i mplementing the

155

156

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJ ECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

DeneSt of

DeneSt of

Weight

Language 1

Language :2

(1 - 1 0)

1 to 1 0 = best

Internet-friendly

�

8

:2

Familiarity to devel-

.!!.

3

9

Compilation speed

1.

:2

8

Runtime speed on

i

7

3

1 * 8 + 1! * 3 + .1 * 2 +

1 * 2 + 1! * 9 + .1 * 8 +

1 * 7 = 65

1* 3 = 121

Factor
�

opment team

I to 1 0

=

best

-

processor p

Score

Figure 7.25 Example of method for deciding language choice

requirements. Someti mes, however, the implementation must be chosen from several alternatives. A common
way to dec i de among alternatives is to first list the factors i nvolved, and then to give factor each a wei ght
(measure of importance ) . After that, each alternative is scored relative to each factor. Calculations are then
made that produce a total score for each alternative . Figure 7 . 25 shows examples of factors and weights that
could enter i nto such a determ i n ation. The weights are factors i n arrivi ng at the bottom l i ne. For exam ple, the
score for language 1 i s 1 * 8 + 1! * 3 + .1 * 2 + 1 * 7 (weights underl ined).
Deci s i o n - m aking tables such as th is are not substitutes for making judgments: they merely decompose
large decisions ( e . g. , what language to choose ) i nto smaller ones ( e . g. , Java is m ore Web - friendly than C + + ) .
Such decom positi ons provi de more stab i l i ty, but the conclusions that they provide are sensitive to the
weighting chose n , the factors selected, and the judgments made. Their results should be compared with
common sense conclusions.

7 . 5 . 4 Decision Making with Triage
Executing proj ects is frequently an overwhelming experience. For exam ple, a "to do" list of wants and needs
accumulates quickly, grows duri ng the project more than it shrinks, and can easily i n duce a fee l i n g of futi l i ty.
The natural way to deal with this is to prioritize. A complete prioritization is frequently overwhelmed by
events, however. For example, if we have a list of 100 th i ngs to do, and time for probably only 20 of the m ,
t h e n it i s a waste of t i m e t o meticulously order all 100 . Triage can be useful for situati ons like th i s .
Instead of a lengthy decision process, triage requires one t o make no more than two decisions about
each item, as shown in Figure 7 . 26 . Once thi s has been performed, i tems from the "do at once" category are
•

Among top items in importance�

Il

ll

I f so, place it i n ldo at oncel category
•

Otherwis e could we ignore without substan tially affecting project�
,

If so , place it i n
•

III l ast to do Ill category

Otherwise (do not spend decision time on this)
Pl ace in

III mi ddle I category

Figure 7.26 using triage in project management

SOFTWARE PROJECT TOOLS AND TECHNIQUES

Number of weeks
before delivery

Number of
reqUirements

( ......

SChe_
dU
_I_
e____

)
i
y
t
ual
Q

Defect count

(Functionality

Figure 7.27 Variables available to the project manager

carried out until they are exhausted ( i f ever) , and then we move on to the m i ddle l ist, and so on. When
necessary, items can be pri oritized with i n the i r category . The benefit of thi s is that little time is wasted in
splitting hairs or wonderi ng about the exact order of actions that will never be performed. As reported in
Business Week [4], for example, triage teams were used by Microsoft i n combing through bug reports during the
debugging of Windows™ 2000 .
Next, we consider what tools the proj ect manager has at hand to steer h i s or her proj ect to success.
7.5.5 project Variables

To ach ieve project objectives, the proj ect leader has four variables that conceivably can be mani pulated: cost,
schedule, quality, and functionality. As Figure 7.27 suggests, this is someth i ng of a balancing act, because there are
many trade -offs among these four attributes.
For example, i f the proj ect leader is asked to spend less time producing the appl ication (affecting
schedule) , he or she has to negotiate for reduced requirements (affecti ng functionality), increased defect
expectations (affecting quality), or i ncreased labor (affecting cost; assuming that more people can be used
effectively) in order to o ffset the reduced time.
Proj ect management deals constantly with trade -offs among these variables. To m ake the best decisions,
we quantify these trade -offs whe never we can . One way to visual ize them is by means of a "bulls-eye" diagram,
suggested for this purpose by Humphrey. I n a bulls-eye diagram, each o f the variables i s plotted by means of
an axis originating at the center. This is shown for the cost parameter in Figure 7. 2 8 .
The axes are drawn symmetrically rel ative t o each other. I n the bulls-eye diagram shown i n Figure 7.29,
there are four vari ables, so that they form 90- degree angles.

Parameter:
Projected cost ($)
Unfavorable

Target : $70K .................... . . ... . ..

Favorable
Most favorable : $OK .... . .......

Figure 7.28 Introduction to bull-eye figure for project variables

.

1 57

158

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

Projected cost

Target: 1 00%

($)

Target: $70K

Projected
Projected
functionality ----''r--=--.,:,.:::;::...:..::,--+----""*-- schedule
(tota/ weeks to
( % requirements
complete)
satisfied)

Target: 4 defects/Kloc

Target: 30 wks
Projected quality
(defect density)

I
Figure 7.29 Bulls-eye framework example for project variables

The variables have to be arranged so that on each of these axes, the origin is the most favorable value, and
the target value is marked on each axis the same distance from the origin, forming a quadrilateral. (If there
were five variables, they would form a regular pentagon, etc.) For example, on the "projected functionality"
axis, the origin denotes "many more than the designated requirements satisfied, " while the unit mark
represents " 1 00% of the requirements satisfied. " The actual values could lie outside the polygon if they exceed
goals, as shown in Figure 7.30.
The status of a project can be visualized using the solid polygon obtained by joining the values on the
axes and filling in the resulting polygon. The more the resulting polygon lies within the original regular
polygon, the healthier the project. The example project shown in Figure 7. 30 falls short on two of the variables
but performs well for the other two. This visualization helps a project manager to alter priorities and achieve
goals in an even manner. For example, the leader of the project represented in the figure should cut costs and
push for an increase in functionality, even if this results in higher defect rates and longer project duration.
t

Projected cost

Target: 1 00%

Actual:
$90K

Actual:

Target: $70K

90%
\

Projected
schedule

Projected \,
functionality- - - - -

Target:

Actual:

1.5 defectS/Kloc

Target: 4 defects/Kloc

,

\

30 wks

Actual:
Projected
quality

Figure 7.30 Bulls-eye figure for project variables on a particular project

20wks

RISK MANAGEMENT

Organizational
1. The team may not have the required Java skills to execute the job on time because several of them

have not used Java in a business environment.
2. We may lose a team member.

Technical
3.

4.

An off-the-shelf database management system may not be versatile enough to cover the types of
operations required of a video store.
We intend to use Web services, but no one in the team has used these before.

Figure 7.31 Example risks in video store application

7.6 RISK MANAG EMENT

All projects involve a degree of risk. These are issues that can potentially cause problems such as a delay of the
schedule or increased project costs. Figure 7. 3 1 shows some risks from the video store example.
We try to confront risks as soon as possible rather than waiting for them to confront us in the process of
building the application. This is called risk management, and it consists of the activities in Figure 7. 32.
Perhaps the hardest part of risk management is identification, because it requires imagining parts of the
process that may not seem at first to harbor any risks. Once a risk is identified, it is important and very useful
to express the risk with as much precision as possible. For example, "a team member may get sick" is too vague
a description. Much better would be "sick time will exceed the company norm by 50% due to an unusual
number of young parents in the team."
Figure 7. 33 illustrates a way to thinking about risks. It shows two obstacles to a project.
We generally deal with risks with one of two different strategies. They are conquest (such as building a
traffic light at the road) or avoidance (e.g., routing the path around the house). These two strategies are
illustrated in Figure 7. 34.
Teams develop a plan to address each risk and assign an individual who sees to it that the plan is carried
out. The challenge here is to develop a concrete plan and avoid general statements such as "we will all learn
Java." For example, we can address the "inadequate Java skills" risk mentioned in Figure 7.3 1 by conquest:
'Tom, Sue, andJack will pass level 2Java certification by December 4 by attending a Super Education Services

1. Identify risks by imagining all worst-case scenarios: lasts for approximately first third of project.

2. Analyze each risk to understand its potential impact on the project.
3. Typically too many risks given time. Hence, prioritize identified risks to enable focus on most serious.
4. In dealing with each risk, choose to conquer or avoid it. Conquering a risk means investigating it and
taking action so that the event does not materialize. Avoiding means changing plans so that the issue
never occurs.
5. Finally, develop a plan to retire each risk.
Figure 7 . 3 2 The main risk management activities

159

1 60

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

•.....

Risk 1: Road blocks path

•

---.-- ....
.
.
.
.
.
.
.

Figure 7.33 Retirement by conquest or avoidance-risk examples
Source: Graphics reproduced with permission from Corel.

Intermediate Java course." Alternatively, the risk can be retired by avoidance: "Use C+ + instead of Java"
(assuming that the team is skilled in C++). A retirement strategy for the "Web services knowledge immature"
risk is to set up a couple of sample Web services and write access code for key video store functions that use
them. If the results are satisfactory, we will have employed risk retirement by conquest.
Table 7. 1 illustrates one way to perform risk prioritization. First, the risks themselves should be
described fully. The priority depends on factors such as the likelihood of the risk and the seriousness of its
impact on the project. A high-priority task has a low-priority number because people usually refer to their
"highest priority" as priority number 1 . The more expensive it is to deal with a risk, the lower its priority. In
particular, when managing a risk becomes a very large amount of work, we may be better off not working on it

2. Retirement by

avoidance

1. Retirement by

conquest

Figure 7.34 Retirement by conquest or avoidance
Source: Graphics reproduced with permission from Corel.

.

2

1

.

.

NO.

.

web services
immature: See
note 2

Insufficient Java
skills: See note 1

Title

Estimated

3

8

with 1 lowest
like-lihood)
9
2

7

(M:1-10 with 1
lowest cost)

8*4*2=64

3*2*9=54

See note 4

See note 3

plan

(11-Lh(11-I)*M

Jen

Jared

person

Retirement Responsible

handled first)

priority number
(lowest number

Estimated cost
of managing

9

with 1 lowest
impact)

occurring (L:1-10 impact (1:1-10

likelihood of

Estimated

Table 7.1 A way to perform risk prioritization

date

8/3

10/15

completion

Target

....
Q\
....

m
Z
-i

S

�
m

z

S
»

A

Vi

::0

162

CHAPTER 7

PRINCIPLES OF SOFlWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

in advance at aIJ, but simply dealing with the issue involved when it actually arises. For example, if the only
way to anticipate a risk is to construct an expensive simulation, then we may simply have to accept the risk.
Note 1. The risk is that the team does not have enough skiIJ in Java to handle the programming required
by this project within the time required.
Note 2. The risk is that although Web Service technology is a good choice, technicaIJy speaking, it is
new to the industry at the time of this project, and its immaturity may create difficulties.
Note 3. Jen, Oscar, and Aif should pass level two Java certification by October 1 5 by attending an Ajax
Education Services Intermediate Java course.
Note 4. Jen will instaIJ three Web services typical of DVD inventory management, and run 1 ,000 typical
transactions against these, gathering timing data.
Not every risk can be dealt with earlier than its natural occurrence. To take an extreme example, suppose
that the team has a week to add significant functionality to an application. The goal would be: Add the
capability to show future investment growth graphically for a financial application. There is probably little to
be gained from performing risk analysis and retirement in this case. Since the time frame is so short, the team's
time may be better spent simply starting the design at once. Doing so takes a chance, but the time required for
risk analysis may not leave enough time to do the job.
7.7 STUDENT TEAM GUIDANCE: ORGAN IZI N G THE SOFTWARE PROJECT'S MANAG EMENT

This section describes how the student team organizes for the development task, provides a hypothetical
account of interactions among students, and guides students in producing a Software Project Management Plan.
7.7.1 Team Guidance-Student Team organization

Student teams are usuaIJy organized as peers. To make peer teams effective, the team leader encourages
consensus but keeps the schedule firmly in mind, making clear and timely decisions when required. In student
teams, team leaders tend to intervene too little. Meetings drag on unreasonably in the quest for consensus or
agreement, and the team leader is not experienced enough to make a resolution. Being firm without alienating
team members is a valuable skill. A key to this is ensuring that team members' opinions are respected­
whether adopted or not.
Figure 7.35 lists the steps for organizing a team, particularly a student team.
One effective management arrangement for a team is to pair up developers by having them work
together some-or even aIJ---of the time. The latter is caIJed pair programming. Another way is to designate
team members as leads for the project phases with a backup for each. T ypicaIJy, the lead and the backup work
together, or the backup serves as a continual inspector, ready to take over the lead role if necessary. The
project arrangement shown in Figure 7.36 is designed to make each person the backup for the activity on
which his or her primary activity is dependent.
Once a project leader has settled the procedural aspects of team organization, it is time to consider what
reaIJy counts with team members: how they feel about what they are doing. If a person belongs to a motivated
and weIJ-organized team, he wiIJ probably enjoy his work and the team wiIJ probably produce a good
product. People are motivated when they are respected and are engaged in an activity that they feel enriches
them. Part of each member's job is to create those conditions for himself and others. The project leader
creates a weIJ-organized project by setting schedules and limits, with the team's agreement. In particular,
when it comes to meetings the issues in Figure 7.37 can be useful.
In the case of student teams, uneven contribution is often a major problem: some team members may feel
that a member is not contributing enough. A team member who feels this way should discuss the issue with
the project leader. If there is general agreement about this, the project leader should speak privately to the

STUDENT TEAM GUIDANCE: ORGANIZING THE SOFTWARE PROJECT'S MANAGEMENT

1 . Select team leader.
Responsibilities:
o

ensure that all project aspects are active

o

fill all gaps

2. Designate leader roles and document responsibilities.
team leader: proposes and maintains
configuration management leader:
quality assurance leader:
requirements management leader:
design leader:
implementation leader:

SPMP

SCMP
SQAP, STP
SRS
SDD
code base

3. Specify leaders' responsibilities.
o

propose a straw-man artifact (e.g., SRS, design)

o

seek team enhancement and acceptance

o

ensure that designated artifact is maintained and observed

o

maintain corresponding metrics if applicable

4. Designate a backup for each leader
Figure 7 .35 One way to organize a team

individual. If no significant change is observed in that person's behavior after about a week, the project leader
should confirm the team's concern and then discuss the issue with the instructor. Instructors will either
remove the individual from the team or discuss ways to apportion credit accordingly.
7.7.2 Team Guidance-Team Meetings

One activity regularly required of project managers is to hold meetings. Figure 7.38 lists some good meeting
practices from which all team members can benefit.
The items marked with a single asterisk should be performed before the meeting. Since groups are
not particularly good at creating artifacts from scratch (especially designs) , it is far better for someone
to bring to the meeting a tentative ("straw-man") version of the artifact to form the basis for discussion.
For example, the design leader brings a tentative design, or the team leader brings a tentative work
breakdown. The version should not be overly specific, because there must be plenty of room for input
by the members.

Team leader
Configuration management leader
backs
up ...

Quality assurance leader
Requirements management leader
Design leader
Implementation leader

Figure 7 . 36 A way to back up leaders within a team

1 63

1 64

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

Develop an agenda in advance of meeting, with everyone's agreement.

•

Set time limits for meeting as a whole and for each agenda item. Allow extra ten or fifteen minutes for
unanticipated items.

•

Designate someone to take minutes, at least for action items.

•

At meeting, begin by briefly reviewing the agenda and time limits.

•

Designate someone to watch time and warn of time limits.

•

Insist on one person speaking at a time. Listen to people, even if their ideas seem outrageous. (Probably
aren't. )

•

Move unproductive discussions offline.

•

Figure 7 . 3 7 Planning and conducting meetings

Many meeting partICipants, but especially students, complain that meetings last too long without
accomplishing enough. When the approximate time for discussions is agreed to in advance, however,
members tend to focus on the issues to be resolved, and meetings can be quite effective. Deciding when to
allow further discussion and when to break it off is a duty of the team leader. The keys to doing this are
whether the discussion is productive, and whether the discussion of the present topic is preventing the
discussion of more important ones, given the time remaining. It is also the leader's task to ensure that the
discussion remains focused and that a conclusion is reached. At times, the leader must step in and make a
decision, because consensus is not always possible. The member recording action items also records decisions
taken. This should generally be done in a crisp form-minutes are meant primarily to remind everyone of the
decisions made.
t.

'Distribute start time, end time, and agenda with approximate times.
o

List important items first.

2. 'Ensure that "straw-man" items are prepared.
3. Start on time.
4. Have someone record action items.+
5. Have someone track time and prompt members.
6. Get agreement on the agenda and timing.
7. Watch timing throughout, and end on time.
o

Allow exceptions for important discussion.

o

Stop excessive discussion; take offline.

8. Keep discussion on the subject.

9

.

••

E-mail action items and decision summary.

*in advance of meeting

+actions members must perform

Figure 7 .38 Team guidance-team meetings

**after meeting

SUMMARY

I. Get agreement on agenda and time allocation

2. Get volunteers to:
record decisions taken and action items
watch time and prompt members

3. Report progress on project schedule
4. Discuss strawman artifact(s)
5. Discuss risk retirement
6. ,7., .

-

-

10

-

10

min

x min

min

. <more agenda items> (Include metrics and process improvement?)

n. Review action items

-

5

min

Figure 7 . 3 9 Specifying agendas

One good management practice is to create and follow agendas for meetings. Some items, such as
concise status reviews, are almost always appropriate. Risk retirement (covered in Section 1 0. 4) should be a
mandatory agenda item at most meetings during the first third of the project. Metrics and process
improvement are sometimes appropriate topics. These are discussed after a phase has been completed,
not necessarily at every meeting. An example of a generic agenda is shown in Figure 7. 39.
7.8 SUMMARY

Software project management is the process of planning, organizing, and monitoring the development of a
software project from inception to completion. A project is typically headed by a project manager, who is
responsible for the daily project activities.
Companies can be organized in several different ways, each having an effect on how a project team is
organized and run. In a project-oriented organization, people are organized around the projects of the company.
Every employee is assigned to a project, which is their primary focus. In afunction-oriented organization, people
belong to a functional group such as marketing or software development. Each functional group has its own
projects centered around their area of responsibility. Managers assume the role of project managers. A matrix
organization is a cross between project- and function-oriented organizations. Employees belong to a
functional group (e. g. , marketing, engineering) and are loaned to projects based on their expertise. They
directly report to their functional manager, who is responsible for directly supervising them. They also
indirectly report to the project manager, who is responsible for the daily activities of the project.
The size of a project team has a direct effect on the success of a project. Teams that are large can divide
the work into manageable parts. However, large teams have the disadvantage of requiring communication
that is time-consuming and error-prone. Experience shows that the optimal number of people with whom a
person needs to interact with on a regular basis should normally be between three and eight.
Not all project teams are collocated. With the advent of using remote developers, project teams may be
split across continents. This is known as offshoring. There are many advantages to using remote teams, such
as cost savings and the benefit of quality work. However, there are disadvantages to be overcome, such as time
zone differences, cultural differences, and potential communication difficulties. Setting up regular face-to­
face meetings and having strong on-site management are key elements to making offshoring work.
SM (TSP) defines a set of detailed procedures for building project
Watts Humphrey's Team Software Process
teams, establishing team goals, and distributing team roles. It emphasizes team initiative and encourages an

1 65

1 66

CHAPTER 7

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I: ORGANIZATION, TOOLS, AND RISK MANAGEMENT

increased degree of professionalism among software engineers. As an example, Humphrey states that it is
unprofessional for engineers to provide management with schedules that cannot be accomplished, even when
requested to do so.
Project managers and teams carry out many tasks as part of their job, including project scheduling,
configuration management, requirements management, drawing designs, building code, and testing. As much
as possible, they utilize automated tools to support their work. These tools are sometimes called computer­
aided software engineering (CASE) tools.
When planning and developing an application, existing software may be available that can form the
basis for the new application. In order to determine whether it makes sense to build from scratch or leverage
existing software, project teams make a rational decision by comparing the costs of each option.
Another decision to make is the use of programming language. A decision-making table helps to
determine the pros and cons of different language choices.
Project managers have several variables at their disposal that are manipulated as they manage a project:
cost, schedule, quality, and functionality. Changing one variable has a direct effect on the others. For example, a
project manager may want to speed up a project by pulling in the completion date (schedule) . In that case,
one or more of the other variables must be adjusted-you cannot pull in a schedule unless you change
something else. The manager must reduce functionality, add resources (cost), or reduce quality. Bulls-.eye figures
can be useful in visualizing these variables in a project and as an aid in seeing how each variable affects the
others.
All projects contain some amount of risk, which are issues that can potentially cause problems such as a
delay of the schedule or increased project costs. Risks are of two basic types. Organizational risks are primarily
caused by people's behavior, such as resigning from the company. Technical ones are caused primarily by errors
in hardware or software, such as a defect in a third-party application. Early in a project risks are identified and
mitigation strategies created. Each risk is actively managed throughout the project.

7.9 EXERCISES

1 . a. Describe in your own words the structure of a project-based organization, and explain how it
promotes the successful delivery of software.
b. Name two long-term disadvantages of a project-based organization.
2. a. Describe in your own words the structure of a function-based organization, and explain how
it promotes the successful delivery of software.
b. Name two long-term disadvantages of a function-based organization.

3. a. Describe in your own words the structure of a matrix organization, and explain how it
promotes the successful delivery of software.
b. Name two long-term disadvantages of a matrix organization.
4. Write a paragraph explaining why adding people to a project does not necessarily improve its
schedule-and may worsen it.

5. Consider a project team you have been a member of, either as part of a student team or in industry.
Describe the organization of the team, and describe in sufficient detail two aspects that worked
well and two that did not work well.
6. Consider a software project under development, with half of the engineers in one time zone and
the other half in another time zone twelve hours away. How would you recommend the project

BIB LIOGRAPHY

team be organized? Describe two challenges that need to be overcome due to the time-zone
difference.
7. a. Explain how a bulls-eye diagram can help visualize the progress of a software project.
b. Suppose you are managing a project that has the following goals:
-Cost: lOOK
-Schedule: 1 2 months
-Quality: 1 2 defects/Kloc
-Functionality: 90% requirements implemented
Draw a bulls-eye diagram that shows only one of these goals being met or exceeded.
8. Why plan for risk identification and retirement when developing a project plan? In a paragraph or

two, answer this in your own words.

9. Describe a kind of project under which risk identification and retirement would probably not pay
off. Explain.
10. Suppose that your team is tasked to implement a system that provides Web-based books. The

application is intended to execute on desktops, be downloadable, and be automatically upgraded
over time via the Internet. You are to assume the following:
i. The team includes employees who are based at a new offshore site.
ii. The application is to be ready in a month.
iii. Preliminary plans call for a Java implementation on a PC model that is due to arrive in two
weeks. No one in the team is well versed in Java. They all know C++ well.
You are concerned about the risks associated with items (i) and (iii) above. Explain the kinds of
risks these are, your specific responses, and the kind of solutions you are proposing.
I I. You have been tasked to build a system for managing online DVD rentals. Describe four plausible

risks and indicate how you would retire them. Be as concrete as possible in describing the risks.

BIBLIOG RAPHY
1. Heldman, Kim, "PMP Project Management Professional Exam, Study Guide," SybexlWiley Publishing Inc., 2007, p. 17.
2. Brooks, Frederick P., 'The Mythical Man-Month, Essays on Software Engineering, Anniversary Edition, Addison-Wesley, 1995.
3. Humphrey, Watts. S., "Introduction to the Team Software Process (The SEI Series in Software Engineering)," Addison-Wesley, 2000, p. 496.
4. 'The Mother of All Software Projects," Business Week, February 22, 1999.

1 67

principles of Software project
Management II: Estimation,
Scheduling, and Planning

Planning

�n

Testing

len.nco

The Software
Development
Lifecycle

What are good ways to go about creating

\

a project schedule?
What does a Software Project
Management Plan look like?

Requirements
analysis

Implementation

�DeSign

How do you estimate the cost of a
software job?

/

How are projects planned in practice?
What are good ways for student teams to
plan their projects?

Figure 8.1 The context and learning goals for this chapter

This chapter explains the methods that project managers use to estimate the costs of a project and ways
to schedule it. It also explains how to write a project plan.

COST ESTIMATION

8.1 COST ESTIMAT ION

The process of estimating project costs (i. e., for fixed capabilities, quality level, and schedule) often starts at
the inception of a project and continues even after coding has begun. There are several specific techniques
used to estimate costs that are described in the following sections. Before doing so, however, let's examine
how precise we can expect such estimates to be.
8.1.1 Estimate Precision

When a project is initiated, the team can typically have only a vague idea of its cost. The more we learn about
the requirements for the product and the more design we perform, the more precise we can be about its cost.
This is illustrated in Figure 8.2. Since complete precision is a practical impossibility in most cases, a range is a
good way to express projected cost. There is always a need to estimate a "ballpark range" from a summary
requirements statement, hence the cost estimation following conceptualization shown in Figure 8.2.
Our assumption here is that the goal consists of attaining a set of capabilities rather than starting with a
fixed amount and asking what capabilities can be implemented for that amount (a related but different
process) .
The fourfold estimation error shown in Figure 8.2 is from a study reported by Boehm [ 1 ]. For an
application that will eventually cost $100,000, for example, estimates made after the application's concept has
been developed can be as low as $25,000 and as high as $400,0001 We use various techniques to sharpen our
estimate of a project's cost as early as possible, which amounts to reducing the height of the vertical lines in
Figure 8.2. Only at the latter end of implementation can we have complete confidence in our estimates. (The
estimates are far less useful at that time, however, since most of the funds will already have been spentl)
It puzzles some people that we can even begin to think about the costs of a project without detailed
requirements, but this is a common practice in other fields. For example, one can gain a rough estimate of the
cost of building a house without any design or detailed requirements. One can use rules of thumb such as

$4
Rough range of cost estimates after

+---- conceptualization phase.

eventual, actual cost of $1

Conceptual­
ization
phase

$1

Assumes

$3

$.25
__

Requirements

$1

analysis
r-------,

Design

Rough range of cost estimates
after requirements analysis

I

t

$2
$1

L--_---'IT
�plementation

I

$1

.

lntegrationlTest

Figure 8.2 Range of error in estimating costs narrows as the project progresses

1 69

170

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT Ii: ESTIMATION, SCHEDULING, AND PLANNING

"houses in this area cost about $100 per square foot to build," and so a 1,OOO-square-foot house will cost about
$100,000.
A good way to approach project cost estimation at the very early stages of a project is to develop
estimates in several independent ways and then combine the results. One can even weigh the estimates
obtained according to one's level of confidence in each of them.
It takes experience to properly use cost estimation tools, and the first time one uses them the results are
often unreliable. With time, feedback, and calibration, however, one learns to use them with increasing
precision. The rest of this section describes the techniques used to estimate projects in summary form. The
chapter then describes them in detail.
8_1.2 Estimation Methods

Cost estimation methods for agile projects, described in Section 8.1.6, focus on estimating the upcoming
iteration ("sprint" in scrum terms) , based on its required user story or stories, as well as experience from past
iterations. These are small-scale estimates but it is part and parcel of the agile philosophy that large projects
are composed of small deliveries. Now let's turn to estimation of projects in the large that are not necessarily
agile in whole or in part. Whether or not one actually uses the methods described, they do contain many
hard-won ideas that can be configured for various situations, including variations in agile estimation.
Figure 8. 3 shows a typical road map for the early estimation of project cost and duration. The next
section shows an example of the use of lines of code and past projects. The function point methodology and
CO COMO (Constructive Cost Model) are explained below.
8.1.3 Estimating Lines of Code without Function Points

This section discusses ways to estimate lines of code at a very early stage, well before any design has been
performed. Once design work is performed, the methods are based on the parts of the design and become far
more precise, as indicated in Figure 8.2.
Several estimation methods, notably the COCOMO and COCOMO II model, depend on the number
of lines of code. "COCOMO" stands for Boehm's "Constructive Cost Model" [1]. At the very early stages of a
project, COCOMO may not sound very useful because coding is a long way off when one is in the project
planning stage. By comparing the product with other products, however, estimating lines of code may well be
feasible. For example, we could estimate that our current satellite control job is comparable to our last satellite
job, which required 3 million lines of FORTRAN. However, our current job has the additional requirement of
being able to monitor hurricanes. It may be possible to roughly estimate the size of this additional piece based
on other hurricane trackers (700,000 lines of FORTRAN, for example). When implementation languages
change, industry-standard language conversion factors are used.

1. Use comparisons with past jobs to estimate cost and duration directly or to estimate lines of code.

and / or
Use function point method to estimate lines of code.
i.

ii.

Compute unadjusted function points.
Apply adjustment process.

2. Use lines of code estimates to compute labor and duration using COCOMO (II) formulas.
Figure 8.3 A roadmap for estimating the cost of a software project

COST ESTIMATION

Organizations working above Capability Maturity Models level 1 must b e able t o record the person­
hours and duration of the parts of jobs. In the absence of such data, we would have to compare our Encounter
video game, for example, with other games. It is difficult, impossible even, to obtain data directly from
companies other than one's own, although trade publications and general industry studies sometimes provide
partial data. For example, we may know from industry announcements that "BugEye Inc." has worked on its
new game for two years: The announcement may even mention a number of programmers. Such data is
suspect, however, since companies regard their development knowledge as a corporate asset, and commonly
exaggerate or underreport numbers as the case may be.
In the absence of historical data, it may be necessary to compare the project with related projects,
(simulations, for example, in the case of our video game). Let's say that we have very little experience
programming games, and some experience programming simulations and Java. Our lines-of-code estimation
may have to be something like the following:
I once wrote a nongraphical simulation of a simple queue in C+ +, which required about 4-8 pages
of code. At about 30-50 non-comment lines per page, this totals 120-400 lines. We will assume
that Java requires the same number of lines. The first commercial release of Encounter has 4-15
such queues and 30-90 additional components of comparable size to make it interesting, so that
yields between [(120 lines) x (34 components)] minimum and [(400 lines) x (105 components)]
maximum as our range, or approximately 5,000 to 42,000 lines of code. The use of graphics
multiplies the effort by 1.5 to 4, depending on the degree of sophistication, so this gives us a range
of 1.5 x 5,000 to 4 x 42,000
7.5 to 170 K-lines (thousands of lines) of code. (Note: The case
study in this book encompasses a prototype, which is far less ambitious than the version on which
this estimate is based.)
=

By documenting such data on a spreadsheet, we establish a baseline, and we can then sharpen our
estimates as the project goes forward. Note that the range 7.5 to 170 K-lines is consistent with Figure 8.2, in
which a 16-fold range in estimates is expected at the conceptualization stage. The preceding calculation is a
bottom-up approximation, since it estimates the cost of the whole from the cost of the parts.
An example of a top-down approximation follows, using industry data (or, preferably, historical data
from the organization performing the work). Suppose we know that a very good video game required the
services of 5-20 expert programmers for 1-2 years. Since we can invest only 1/10 of the amount that was
invested in that game, we will assume that ours will have about 1/10 of its capability. Assuming 5-25 lines of
(fully tested!) Java code per day, this yields
(1/10 capability of the famous game) x (5 - 25 lines per day) x (5 - 20 programmers) x (1 - 2 years)
x (48 - 50 weeks per year) x (35 - 60 hours per week)
� 4.2 - 300 K - lines of code
This range is different from the bottom-up estimate obtained previously, but it helps to ground our ideas
about the job's magnitude, since the method used this time is quite different.
Free estimation tools, such as those at www.construx.com. are also available on the Web.
8.1.4 Function Points

Starting in 1979 with Albrecht [2], the more fundamental notion of function points was developed to assess the
size of a project without having to know its design and without having to make any a priori assumptions about
code size. The function point technique is a means of calibrating the capabilities of an application in a
uniform manner, as a single number. This number can then be used to estimate lines of code, cost, and

171

1 72

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLANNING

duration by comparison with the function point values of other projects. Function points are attractive in
concept, since they try to get to the heart of a future product's capability. However, it takes a great deal of
practice to apply them in an accurate and consistent manner.
8.1.4.1 Calculating Function Points

Function point calculation comprises the following steps:
Function Point Step 1
Identify the functions (e.g., "retrieve," "display") that the application must have. The International Function
Point Users Group (IFPUGi see [3]) has published criteria as to what constitutes a "function" of an application
in this sense. They consider user-level functionality, rather than programming-level functions as in C.
Typically, a function is the equivalent of processing a screen or form on the monitor. For our role-playing
video game prototype, for example, we can identify the following functions.

1. Set up the character representing the player.
2. Encounter a foreign character.
Function Point Step 2
For each such function, compute its function point contribution from the sources shown in Figure 8.4.
The following summarizes the sense of each contributing factor. The guidelines have to be carefully
followed, otherwise it is hard to obtain consistent estimates.
•

External inputs: Only inputs that affect the function in a different way from each other are counted as
separate. Thus, a function of an application that subtracts two numbers would have EI 1, not EI 2. On
the other hand, if the character A can be input to request an addition and S for subtraction, these would
contribute 2 to EI.
=

•

=

External outputs: Only outputs that account for true separate algorithmic or nontrivial functionalities should
be counted. For example, a process that outputs a character in several fonts would be counted as 1 i error
Internal

� Logical Files
.:::������::::::
,,,
(ILF)*
::.:::".,:. .,,,�!!
.. . .,,,,.,

External

Function

Inquiries

..

(EIN)

External

+�

Inputs (EI)�

�
External
�. Outputs
(EO)

•

Internal logical

grouping of user
data into files

Figure 8.4 Function point computation for a single function
Source: International Function point users Group, http://www.ifpug.org.

COST ESTIMATION

PARAMETER

Complex

Simple

. .. 7

or . . . 10 or

. . . 5

or . . . 7 or
Count Total

Figure 8.5 Function point computations (lFPUG)

messages are not counted. Chart representations of data are counted as 2 (1 for the data and 1 for the
formatting), and data sent to separate nontrivial destinations (e.g. , printer) [3].
•

•

External inquiry: Each independent inquiry is counted as 1.
Internal logical files: This counts each unique logical group of user data created by or maintained by the
application. Combinations of such logical groupings are not counted; each functional area of the
application dealing with a unique logical grouping increases the count by one.

•

External logical files: This counts each unique grouping of data on files external to the application.

Function Point Step 3
As shown in Figure 8. 5, each of these parameter values is then factored by a number, depending on the degree
of complexity of the parameter in the application. IFPUG [3J has published detailed descriptions of the
meaning of "simple" and "complex" in this context.
Applying this process to the two selected functions of the Encounter video game mentioned above, we
obtain the spreadsheet tables shown in Figures 8.6 and 8.7. These figures are highly preliminary, but they do
begin to provide estimate parameters for the job. The total unadjusted function point estimate for these two
Encounter functions is 25 + 16
41.
=

Function Point Step 4
Next, one computes weights for the fourteen general characteristics of the project, each between 0 and 5.
This is shown for the two selected Encounter functions in Figures 8.8 and 8.9. We have actually used a range
for each of these to reflect our current uncertainty about the application. Once again, it takes consistent
experience to assess the appropriate values for these variables. For example, factor 6 asks for the degree of
certainty that online data entry is required. We are certain that the user will need to input characteristics for
the game characters, and so the value chosen is the highest: five.
The total General Characteristics value (1 through 1 4) is between 24 and 4 1 .

1 73

1 74

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLANNING

Medium

Simple
count

count

factor

count

4

3

Ext. inputs
comments:

Factor

Name

Ready/move

Complex

Sub­

factor

totals

6

13

Qualities

Ext. outputs

0

4

0

5

0

7

0

Ext. inquiries

0

3

0

4

0

6

0

7

0

10

0

15

7

0

10

5

Int. logical files
comments:

Total

25

Data about the user's character
5

Ext. interface files
comments:

0

7

Data about the user's character

Figure 8 . 6 Unadjusted function point computation for first Encounter functions: "Set up player character."

Medium

Simple

Ext. inputs

factor

count

factor

count

factor

totals

0

3

0

4

0

6

0

4

0

5

0

7

3

0

4

0

6

0

7

0

10

0

15

7

comments:
Ext. interface files

0

10

5

Total

Report Ol! results

comments:

Int. logical files

Sub-

count

Ext. outputs

Ext. inquiries

Complex

0

16

Data about the user's character
5

0

7

- comments on about the user's character
Figure 8 . 7 Unadjusted function point computation for first Encounter functions: "Encounter foreign character."

COST ESTIMATION

Average

Incidental

0 --­

-----

Moderate

None

Essential

2 ----- 3 ----- 4 ----- 5
Significant

Case Study
0-2

1. Requires backup/recovery?
2. Data communications required?
3. Distributed processing functions?
4. Performance critical?
5. Run on existing heavily utilized environment?
6. Requires online data entry?
7. Multiple screens for input?

0- 1
0
3-4
0- 1
5
4 -5

(continued)
Figure 8.8 General characteristics for function point adjustment, numbers 1-7

Function Point Step 5
Finally, the (adjusted) function point total is calculated by the formula shown in Figure 8 . 10. This equation
states that if there are no special demands at all on the application ( total general characteristics 0), then the
function point measure should be scaled down from the unadjusted (raw) score by 35% (which explains the
"0. 65"). Otherwise the measure should be scaled up from the unadjusted amount by one percentage point for
each general characteristic unit.
For the case study, a reasonable allocation of general characteristics is shown in Figures 8 .8 and 8 . 9 . The
total value of these is between 24 and 43, so the final (i.e., adjusted) function point computation is
=

41 X [0.65 + 0.01 x (24 to 4 t)]

=

41 x [0.89 to 1.06] � 36 to 43

8.1.4.2 Converting Function Points to Lines of Code

Once accurately obtained, function points are very useful. For example, they can be used as comparison
metrics, allowing organizations to estimate jobs based on function point metrics of previous jobs. They can be
converted to lines of code using standard tables. Lines of code can then be used to estimate total effort in
person-months as well as duration (see the next section on COCOMO). For example, [4] estimates 53 lines
of Java source per function point. Using this factor for the Encounter example, we anticipate
Average

Incidental

0 ----None

Essential

-----2-----3----4
- -----5
Moderate

Significant

8. Master fields updated online?
9. Inputs, outputs, inquiries of files complex?
10. Internal processing complex?
11. Code designed for reuse?
12. Conversion and installation included?
13. Multiple installation in different organizations?
14. Must facilitate change and ease of use by user?

Case Study
3-4
1-2
1-3
2-4
0-2
1-3
4-5

Figure 8 . 9 General characteristics for function point adjustment, numbers 8-14

175

176

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT I I : ESTIMATION, SCHEDULING, AND PLANN ING

(Adjusted) Function Points
[Unadjusted function points] X
[0.65 + 0.01 X ( total general characteristics)]
=

Figure 8.10 Computation of adjusted function points

(36 to 44) 53 � 1 . 9 - 2. 3 K- lines of Java source. As expected, this is much lower than the previous estimates
of 4.2-300 and 7.5-170 K-lines of Java source. This is true because it applies to only two "functions" for
Encounter, whereas the larger estimates were for a full game.

8.1.4. 3 A Further Function Point Example

Let's consider a system that tracks video rentals. We will confine the application to a customer-oriented
application, in which customers rent videos and need information about availability.
We assume that the application requires two files only: one for customers and a second for videos. The
unadjusted function point computation is as shown in Figure 8. 1 1 .
Now we estimate the adjustment factors, as shown in Figure 8. 1 2, yielding a "General Characteristics"
total of 3 5.

T

i

r

Simple

count

I

I

-

I

factor

l

-

3

Ext. i nputs

2

- explanation:

Name, ph. #

Ex t. out pu ts

0

.-

4

- explanation:
3

0

Ext. i nquiries

I

- explanation :

Ext. i nterface files

count

�

Complex

I

-

Total

Sub-

factor

count

factor

tota ls

4

0

6

10

I
�

f---- --

Video data
I

I

j

5

Amount due

I
j

4

t

7

0

I

,

6

0

f--- . . ----

5

33

4

Availability

- explanation :

Int. logical files
--

Medium '

I
I

2

I

7

--

I

0

to

-I-- -

0

f--

-

t5

I

Customers; Videos
0

5

0

7

0

Figure 8 . 1 1 Unadjusted function point scores for vide store example

14

--

to

0

-

..

--_ _._-,.

COST ESTIMATION

None

Incidental

0 ----

Moderate

---

Average

Significant

Essential

2 --- 3 ---- 4 --- 5

1 . Requires backup/recovery? ........................... .

4

2. Data communications required? .................... .

0

3 . Distributed processing functions? ................. .

0

4 . Performance critical? .................................... .

3

6 . Requires online data entry? ........................... .

5

8 . Master fields updated online? .................. ..... .

5

5 . Run on existing heavily utilized environment?

7 . Multiple screens for input? ........................... .

9 . Inputs, outputs, inquiries of files complex? .... .

1 0. Internal processing complex? ...................... .
1 1 . Code designed for reuse? ........................... .

3

2

3

1 2. Conversion and installation included? ......... .

3

1 4 . Must facilitate change case of use by user? ..

2

1 3 . Multiple installation in different orgs.? ........ .

3

Total
35

Figure 8 . 1 2 FP adjustment factors for video store example

The Function Point formula gives
Function points

[unadjusted function points] x [0.65 + 0.0 1 X (total general characteristics)]
33 x [0.65 + 0.0 1 x 35]
33

This yields 33 x 53
1, 749 lines of non-commented source lines of Java code.
The function point method is summed up by Capers Jones in [5], a practiced advocate of function point
application. See also [6].
=

8.1 .5 Estimating Effort and Du ration from Lines of Code

Once lines of code have been estimated, either through use of historical data, by comparison to related
projects, or via function points, they can be used to estimate labor requirements and project duration using
Barry Boehm's COCOMO models [ 1]. COCOMO is based on the idea that project outcomes, plotted as
graphs, have a consistent basic shape. A parameterized formula is found for the shape, so that to obtain the
graph for a particular project, he simply has to determine the parameters for it.
8.1 .5.1 COCO M O I

Boehm observed that the labor required to develop applications tends to increase faster than the application's
size. He found in his initial research that the exponential function, with exponent close to 1. 12, expresses this
relationship quite well. Boehm's model also says that the duration increases exponentially with the effort, but
with an exponent less than 1 (the exponent used in this case is close to 0.35). This reflects the observation that
after a certain size (the "knee" in curve (2)), additional required effort has only a gradual lengthening effect on the
time it takes to complete the project. These are illustrated in Figure 8.13, where LOC is short for "lines of code."

177

1 78

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLANNING

(2) Duration for

(1 ) Effort" for
increasing LOC

(y 3X1 .12)
�

Applies to design through integration and testing
"Effort total person-months required
=

Figure 8 . 1 3 Meaning of the COCOMO formulas
Source: Boehm. Barry, "Software Engineering EconomiCS," Prentice Hall, 1 98 1 .

Using data from numerous projects, Boehm estimated the parameters for these relationships, assuming
an exponential relationship. His formulas are iJlustrated in Figure 8. 1 4. In this system, organic applications are
stand-alone applications such as classical (i.e. , non-Web-enabled) word processors-or our Encounter case
study. Embedded applications are integral to hardware-software systems (e.g., an antilock braking system). Semi­
detached applications are in between. A Web-enabled Encounter, for example, is semi-detached: it is not
organic, but neither is it as heavily embedded as the code in an antilock braking system, for example.
Encounter would communicate with the Internet via signals that are only occasional when compared with the
frequency of CPU instruction execution.
Boehm's model says first that the required effort and duration have separate models (formulas) for each
type of application (differing in factors a and b ) . For example, a stand-alone job with 20,000 lines of code
would take 2.4 x 20 1 .05 � 5 1 person-months duration if organic (stand-alone) but about 3.6 x 20 1 .2 � 76
person-months if embedded.
The duration formula can be expressed directly in terms of line of code (KLOC) as follows:
Duration = c x Effortd = c x (a x KLOCh )d = c x i X KLOCbd
At first glance, Boehm's duration formula may appear strange because the relationship between effort
and duration seems to be simpler than his formula indicates. For example, if we know that a job requires 1 20

Effort in Person-months = a X KLOCh
Duration = c x Effortd

Software Project

�

b

Organic
Semi-detached
Embedded

2.4
3.0
3.6

1 .05
1.12
1 .20

Figure 8 . 1 4 Original COCOMO I formulas
Source: Boehm, Barry, "Software Engineering EconomiCS," Prentice Hall, 1 98 1 .

�
2. 5
2.5
2.5

d
0.38
0.35
0.32

COST ESTI MATION

179

person- months, and we put ten people onto it, won't it get done in 12 months? This would indeed be the case
if we could usefully and consistently employ all 10 people on the project from day 1 through day 365, but this
is not usually possible. Consider, for example, day 1. Since all the engineers can't know much about the
project (it has just begun), what useful activities could all ten engineers do that day? It follows that if we
allocate 10 engineers from the first day, the 120 person- month job will actually take longer than 12 months.
Boehm's duration formula has the strange property of being independent of the number of people put on
the job! It depends only on the size of the job. Actually, the formula assumes that the project will have roughly
an appropriate number of people available to it at any given time (for example, one on day 1, thirty on day
100, assuming that is what's needed).
Boehm's model, which has been tested extensively and is widely respected, has been refined over time,
and has been largely updated with the more complex COCOMO II, described next. A great deal of practice is
required to use even COCOMO I effectively. It is best used along with an independent method and a healthy
dose of common sense (sometimes called a "sanity check"). Using Boehm's basic formula on the prototype
version of Encounter (consisting of two basic functions), with 4-300 K-lines of code, we obtain 10 to 1,000
person- months of effort, and 6 to 35 months in duration, as shown in Figure 8. 15.
8.1 .5.2 COCO M O I I

COCOMO (I) is somewhat identified with the Waterfall process because it does not specifically account for
iterative development. It must be used anew for each iteration, and does not account for factors such as
whether the iteration is early or late in the process. For this reason and others, Boehm updated it to
COCOMO II. (See, for example, http://sunset.usc. edu/research/COCOMOII/.) The a of COCMO I can be
interpreted as a scaling factor. COCOMO II replaces it with a product of various scaling factors SF I , SF2, SF3,
SF4, and SF5. This allows for a more refined set of parameters. The b parameter in COCOMO I expressed the
number of times KLOC is multiplied. CO COMO II replaces this with a product of seventeen quantities EM;

b

K

�

-

approx.

-

a

Effort

LO

2.4

HI

2.4

I
I

4.2

1.05

3 00

1.05

P

�

d

I
I

KA b
10

--�

approx.

cp A d

Duration

LO

2. 5

HI

2. 5

I

10
1000

I

0. 3 8

6

0. 3 8

35

Figure 8 . 15 Using COCOMO I to estimate the magnitude o f the Encounter effort

I

1000

180

CHAPTER 8

PRINC IPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLANN ING

Effort in Person-months
=

a x n;= 1 1 7EM;

where a
1 .0 1 + �j = 1 SFj
EM; are multiplicative cost dri vers
SFj are scaling cost drivers
=

5

Figure 8. 1 6 Basic COCOMO I I Formula
Source: Boehm, Barry, "Software Engineering Economics , " Prentice Hall, 1 98 1 , http://sunset.usc .edu/research/COCOMOII/.

(so each replaces KLOC in COCOMO I ) . These are called multiplicative cost drivers, and they allow for more
refinement in describi ng the product and project.
The COCOMO II Effort formula is shown in Figure 8.1 6. The symbol ? (capital p) is the product symbol.
For example , nt= l k2 means 1 2 x 22 X 32 X 42
Figure 8 . 1 7 lists the types of the quantities SF; and EMj . The SFs parameter, for example, allows for
factoring in the maturity of the development organization. The SF3 parameter allows for the degree of risk
remai ning in the project. The value of SF3 is high for initial iterations and low for later ones. The EM' 6
parameter accounts for the modern practice o f developing in several physical locati ons. Each o f the
parameters has a defined scale .
8.1.6 Assessments for Agile Projects: Story Points and Velocity

This section discusses esti mation techni ques for agile projects . In order to commit to deli vering capabili ty
at the end of a cycle, a team must assess the e ffort requi red. As wi th function points, story points are a means
by which to measure the size of a story as it relates to imple mentation. Unlike function points, however,
which attempt absolute measurement, story points are a relative measure. In other words, they compare
stories within a project only. The s i ze range is typically between 1 and 1 0, and the size of a story is based
on the team's hi story of implementing stories in past cycles of the project . One way to establish story
points is �o take an executed story that the team considers to be average, assign i t 5 story points, and use i t
a s a yardstick for future stories. Another is t o select a very smal l implemented story, count i t a s 1 point, and
then calculate all other stories as mul tiples of i t. A more sophisticated way is to create a plot as shown in
Figure 8 . 1 8.
A big advantage of agile methods i s that they i nvolve many entire creation cycles. In a pure waterfall,
team members find i t difficult to estimate the size and completion time of a job because they will not
usually h� ve performed one just like this in the past, with the same partici pants. Agile methods, on the
other halld, facilitate the assessment of how much completed work a team is capable of producing by
relying O N observed past performance wi thi n the same project. Recall that in physics, velocity is de fined as
distance covered per time unit. Similarly, agile project ve l ocity is defined as the amount of functionality created per time
unit. This translates into story points per cycle. Assum ing the constancy of cycles (e. g. , always two weeks ) ,
the reliability o f a velocity calculation depends only on the ability t o accurately assess story points. With
the experience of repeatedly making this estimate, teams increase the i r esti mation accuracy as the project
progresses. See Figure 8 . 1 9 .
As e ffective as this kind of agile esti mation is, it requires augmentation when larger scale estimation is
required. The reader is referred to Cohn, Agile Estimating and Planning, Prentice Hall, for example, for further
reading.

COST ESTIMATION

I

I Sym .

,

I SF .
1I

-

PREC

Precendentedness

FLEX

Development Flexibility

RESL

Architecture and Risk Resolution

:

-

SF2
SF3
__H_

!

Name

Abr.

--

------_.-

--

,

--_.-

.-

--

,

.---

-

-

,
,

Team cohesion

TEAM

SF4

PMAT
Process Maturity
SF5
Ir-----+-------�-----------------

----------

I

I

I

EM .

RELY

Required Software

EM2

DATA

Data Base Size

EM3

CPLX

Product Complexity

EM4

RUSE

Required Reusabi l i ty

-

-

DOCU

Documentation Match to Life-cycle Needs

TIME

Time Constraint

STOR

Storage Constraint

EMs

PVOL

Platform Volati l i ty

EM9

ACAP

Analyst Capability

EM I O

PCAP

Programmer Capability

EM • •

AEXP

Appl ications Experience

EM 1 2

PEXP

Platform Experience

EM5

j...

-

EM6
� - -- -_._-

--

EM7

i
I

I

I

I
I

r

- - -------+--- ----

EM . 3
-

r----

�

-

EM . 5
-

: EM . 6

-

-- -

---

PCON

-

--

TOOL

-

I
- --- ---�

---------

Use of Software Tools

--

SITE

--

i EM . 7
i

-

Personnel Continuity

--- - -------

--

I

Language and Tool Experience

LTEX
..

-

I EM . 4
I

--- - �

SCED

Mul ti - S i te Development
-------

-

Required Development Schedule

Figure 8 . 1 7 Basic COCOMO II cost drivers
Source: Boehm. Bar ry. "Software Engineering Economics," Prentice Ha ll, 1 98 1 , http://sunset .usc.edu/research/COCOMOI1/_

181

1 82

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCH EDULING, AND PLANNING

10

Upper bound
o Estimated size in story points

•

• Actual size in person-hours

o

•

o
•

•

!!
1 . Compute past error %

2. Estimate using comparison,
". 3. factored by trend in past errors %
o
•
2

3

4

5

6

7

8

Cycle number

Figure 8. 1 8 Estimating story points

•

•

Definition: Number of story points the team can execute per cycle
Relies on history of performance and consistency of story points
°

•

Within this project and past ones

Depends on accurate story points

Figure 8 . 19 Velocity in agile development

8.2 SCH E D U L I N G

Project estimates are used as input for constructing project schedules . Teams develop schedules so that
everyone knows what to expect, what to do, and when to do it. Figures 8 . 20, 8 . 2 1 , and 8 . 2 2 step through a
typical schedule construction using a spreadsheet. Substantial projects are best performed with special i zed
tools such as Microsoft Project.
Software project scheduling confronts a fundamental chicken-and-egg problem, as foll ows. Part of a
software engineering project is to gather the requirements but until we know the requirements for the
application, we can't say how long it will take to do the job and so, strictly speaking, we can't schedule it.
There are several approaches to breaking out of this loop. One is to develop a schedule only after the
requirements have been specified. Although this is logical, it is not often used. The main reasons for this are as
fol lows:
1 . As mentioned before, it is usually impractical to specify all requirements up front.
2 . Management usuall y needs to know up front how much time the project wil l consume and how much it
wil l cost.

A common way to approach these issues is to begin with deadlines and to accompl ish as many of the
important requirements as possible with the specified time and financial resources, and then to iterate this
process. For the purposes of discussion, this is the approach used here.
The first step is to show the deadl ines for deliverables to the customer. In our case, we will suppose that
the customer wants to see a prototype after four weeks and the completed project after four months. One

2

4

4

Prototype X

3

i

i

I

Mana��

i

2

1

2

February

1

February

3

3

1

-

2
3

1

March

2

3

X Freeze requirements

4

4

,

!
!

:

i

i

1

!
! April

I
I

2

)

4

1

April

�

2

Schedule for VideoStore Application

X Freeze requirements

4

March

Develop configuration management plan

�

2

Figure 8.21 Building a schedule Part II-showing phases

Milestones

1

January

i

i

1

Prototype X :

3

Figure 8.20 Building a schedule Part I-setting milestones

Milestones

1

January

I

Schedule for VideoStore Application

4

1

May

4

1

May

Final product X

3

Final product X

3

I

i

co
w

�

C)

Z

(/)
()
::c
m
o
C
r-

4

Prototype X

3

EdA

10

7

3

Cumulative

3
16

3
13

1

1

1
1

1

4
22

2
18

1

1
1

1

Manage risks

1

2
3

X Freeze requirements

4

March

1
2
24

1
1
2
26

1

3
29

4
33

1

1

1
1

1

1

1

Design

Requirements analysis

Soh"�""� with ',bo, ,,,,,,,,,,

__

3

Figure 8.22 Building a schedule Part I I I-showing work breakdown structure

3

4

1

1

1

1
1

1

3

1

1

1
1

1
1

1

eMP'"

(person-weeks)

Weekly totals

Pat S

Dave M

All K

SueC

2

Build prototype

1

February

�

2

Work Breakdown Structure

Milestones

1

January

1
2
3

1

4

1
5
42

1

1

1

1

1
3
45

1

1

1
3
48

1

1

2
50

1

1

Test

Final product X

4

May

�

37

1

1

1

1

4

April

Schedule lor VideoStore Application

2
2
Z
Gl

s;:

Z
o
»
2
o
-0

r-

i5
2
_
Ul
(")
:J:
m
o
C

�

m

�
�

�

s::
»
2
»
Gl
m
s::
m

Cl

m

e

::0
m
-0
::0

�

-0
::0
Z
(")
�
r­
m
Ul
o
"TI
Ul
o

::0
00

�
m

»

(")
:J:

...
00
�

THE SOFTWARE PROJECT MANAGEMENT PLAN

Dependencies: subset of schedule

Critical paths: sequences of dependencies

Figure 8.23 Dependencies shown in schedules

techn i que used in setti ng a schedule is to buil d in buffers to compensate for factors that we don't or can't know
about. For example, our schedule assumes four weeks per month, which provi des at least one unscheduled
week. This is shown in Figure 8.20. Some project managers frown o n approaches l i ke thi s because they h i de
thi ngs .
Now we work backward from the milestones to show the times for the various phases, as shown i n
Figure 8.21.
Finally, the team needs to ensure that people are available to do the work. This requires a work breakdown
structure (WBS) showing who will do what work. Figure 8 . 2 2 , for example, includes a W B S .
I n t h e example of Figure 8.22 , t h e l ast week of design requires just one person and t h e first week of
i mplementation requires two engi neers .
Schedules show the i ntended order of tasks . I f task A i s scheduled to be performed prior t o task B , this
does not necessarily imply that B depends on A. For example, we may h ave selected the order because i t i s
more convenient to perform task A before B . However, i f task X depends o n task Y, the n task Y should b e
scheduled t o complete before task X begi ns, and the dependency should be made clear o n t h e schedule.
We can denote dependencies o n a schedule, as shown i n Figure 8.2 3 . These become i mportant
whenever we want to alter the schedul e . They are also necessary in determi ning the project's critical paths: the
sequence of activi ties that must be performed, and the order in which they must be performed. To summari ze:
The dependencies form a subset of the schedule , and the critical paths are sequences of dependencies.

8 .3 THE SO FTWARE P ROJ ECT MANAG E M E NT PLAN
The project plan i s documented so that everyone knows what to do and when to do it. There are many
formats for such a plan . We will use I EEE Software Project Management Plan ( S PM P) standard 1 058- 1 998 for
this purpose . The table of contents for 1 058- 1 998 i s shown in Figure 8. 24, and is used in the case study i n

185

186

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION. SCHEDU LING. AND PLANNING

1 . Overview

6. Technical process plans

1.1

Proj ect summary

6.1

Process model

1.2

Evolution of the SPMP

6.2

Methods, tools , and techni ques

6.3

Infrastructure plan

6.4

Product acceptance plan

2 . References
3 . Definitions
4. Project organization

4.1

External i n terfaces

4.2

I n ternal structure

4.3

Roles and responsibil i ties

5. Managerial process plans

5.1

Project start-up plan

5.2

Work plan

5.3

Control plan

5.4

Ri sk man agement plan

5.5

Project closeout plan

7. Supporting process plans

7.1

Con figuration management plan

7.2

Verification and validation plan

7.3

Documentation plan

7.4

Qual i ty assurance plan

7.5

Reviews and audits plan

7.6

Problem resolution plan

7.7

Subcontractor management plans

7.8

Process improvement plan

8. Additional plans

Figure 8.24 IEEE 1058-1998 Software Project Management Plan table of contents

Section 8.4. The IEEE standard is sometimes viewed as belonging only to "document-heavy" proj ects. In fact,
i ts parts should be used when and only when they provide value . Agile project leaders can gai n by perus ing
the topics and deciding how and when the issue mentioned i s to be handled. Non - agile proj ects are not
bound to use a section unless the effort is worth it. Problems arise when needed issues are ignored and when
documentation i s used for no productive purpose .
Section 1.1 i n the S PM P-the overview-should i denti fy the project but should not cover i ts
requirements ( i . e . , descriptions of its behavior) . These are covered in the Software Requirements Specifica­
tion, described i n Part I I of th i s book . Repeating that material i n the SPMP woul d violate the principle of
single-source documentation ( to say each th ing i n one place only) . Section 1 . 2 describes the ways i n which
the SPMP i tself is expected to grow and change . The Software Configuration Management Plan ( SCMP)
should have been developed by th is time (see Chapter 6), so that versions o f the SPMP can be properly
control led. A re ference to the SCMP i s provided here .
Section 4. 1 describes the ways i n which organizations will communicate with the developmen t team.
This depends on the project's stakeholders ( the people who have an interest in i t ) . For example, how will
engineerin g i n terface with marketing ( regul ar meeti ngs, E-ma i l , etc. )? Section 4. 3 speci fies the responsi b i l i ­
t i e s of project person nel .
Section 5. 2 , the Work Plan, can conta i n the project's schedule . Section 5. 3 , the Control Plan, specifies
who will manage , contro l , and/or review the proj ect, together with how and when th is is to be done. For
example, senior management needs to know how proj ects are progressing, so we would describe the process
for keeping them i n formed here . Risk management ( Section 5. 4) was described in Chapter 7.
Constraints on the languages and tools used are provided in the "technical process plans," Section 6-for
example , 'This project shall use}ava from Sun, version 1. 2 . 1, and Rational Rose version 1 . " Section 6. 1 refers to
the software development process to be used (e.g. , waterfall , spiral, incremental ) . Possible "organizational
structures" were discussed in Chapter 7. Section 6 can i nclude i n formation on reuse requirements.

CASE STUDY: ENCOUNTER PROJECT MANAGEMENT PLAN

In Section 7, the "Supporting Process Plans" references or describes activities that support the
devel opment process, such as configuration managemen t and quality assurance. If the support function is
described i n separate documen ts (e.g. , the con figuration management plan or the quality plan ) , we reference
those documen ts. Otherwise, we describe the support function i n full . These and other aspects of the SPMP
are explained further in the case study at the end of this part of the book.
The reader will find a sample SPMP for the E ncounter cases study i n Section 8.4 of this chapter, which
conforms to IEEE stan dard 1058-199 8. Excerpts from management documentation for the Eclipse and
OpenO ffice open source projects can be found in Sections 8.5 and 8.6 respectively. I n compari ng them, the
reader will notice the benefits of using a standard but also some of the l imitations i n flexibility.

8.4 CASE STU DY: ENCOU NTER PROJ ECT MANAG E M E NT PLAN
The S o ftware Project Man ageme n t P l a n for
E ncounter shown i n th i s secti o n is based on IEEE
Std 1058-1998 Standard for Software Project Management
Plans. F i gure 8. 24 is the table of c o n tents for the
docume n t.
Approval s

Title

Signature

Date

Engineering Manager

9'.�

7115104

QA Manager

£Wifen,z

7111104

Project Manager

a.9''IUitt

717104

Author

Eo :H1UUl.de

711/04

Revision History

Version I
1.0.0 E. Braun: Created first draft 6/1/9 8
1 . 1 .0 R. Chadwick: Reviewed 1/ 1 1/99
1. 1 . 1 E. Braun: Expanded 3 . 2 1 /19/99
1.2.0 R. Chadwick: Reviewed for release 5/19/99
1 . 2 .1 V . Brahms: Final editing 4/30/99

Version 2
2.0.0 E. Braun : Updated to 1998 standard
5/18/2004

1. Overview
1.1 Project Summary
,------,

Note to the Student:
Th is should b e a t a high enough level that it
does not need to change much over time.
Detai ls should appear i n subsequent sections,
not this one. This summary should not substi ­
tute for any part of the requirements document.

This project is organized to produce a role­
playing video game called Encounter. This game
will be developed in several stages since the customer
i ntends to speci fy the requirements in stages, with
each stage following the demonstration of each ver­
sion . The early versions are i ntended for educational
purposes , as examples o f software e ngineeri ng prac­
tice, and as legacy systems on which students may
build their own video games. The later versions are
expected to be either freeware games or commercial
products marketed by a game marketing organization.
1.2 Evolution of the SPMP

Explains how and by whom this document will
be mai ntai ned. It will have to be modi fied i n
several ways (e.g. , with a more detailed sched ­
u l e a s more is known about the requirements).
If a concrete plan is not put in place to
mai ntai n th is document, it will be worked
on sporadically or not at al l .

187

188

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLANNING

Th i s docum e n t w i l l be m a i n ta i n e d o n a
weekly basis by the proj ect l e ader. I t is subject
to c o n fi gura t i o n manage m e n t by means o f the
SCMP. I t i s the p roj ect leader's respo n s i b i l i ty to
subm i t th i s docum e n t as a C I , a n d to keep i t up to
date . Th i s S P M P m a i n l y fol l ows the format o f I E E E
1058. 1-1998.

SPMP = Software Project Management
Plan (this document)

SRS

=

Software Requirements
Specification

SDD Software Design Document
STP = Software Test Plan
tbd to be decided
=

=

2. References
4. project organization
[IEEE] The applicable IEEE standards are publ i shed
i n "IEEE Standards Collecti on," 1997 editi o n .
[MPACL5] Thi s document i s to conform to the
company's "Master Plan for the Attainment of CMM
Level 5."
[Braude] The principal source of textbook ref­
erence material i s Software Engineering: An Object-Ori­
ented Perspective by E. Braude (Wiley, 2000).

3. Definitions

CI
CMM

=

Configuration Item

=

Capability Maturity Model, the

4.1 External Interfaces

Name the people and organ i zations with
whom the team should communicate .

The project team will i n terface with the follow­
ing i n dividuals and organizations: VP, Engineering
( for techn ical and standards direction), Marketing
( for requirements ) , Game Laboratory ( for advanced
game features), and the qual i ty assurance engineer.

SEI's model for organizational
improvement

4.2 Internal structure

tronics Engineers

Figure 8 . 2 5 shows the organi zation of the E ncounter
project within Gaming I n dustries Consolidated.
The project will be organized as a team of peers
with designated roles. The roles are team leader,
configurati o n management leader, quali ty assurance
leader, requirements management leader, design

IEEE = Institute of Electrical and Elec­
QA = Quality Assurance
SEI = Software Engineering Institute,
Pittsburgh, PA

SCMP

=

Software Configuration
Management Plan

,l'v&v I
I
: Software
- Engineering
Labs

Figure 8.2 5 organization of Gaming Industries Consolidated

CASE STUDY: ENCOUNTER PROJECT MANAGEMENT PLAN

Requirements
Member

Liaison
Responsibility

Team

eM

QA

Management

Design

Implementation

leader

Leader

leader

Leader

Leader

Leader

VP

Marketing

Software

Engineering

engineering
lab

Document

SPMP

SCMP

Responsibility

SQAP

SRS

STP

Figure 8.26 Encounter project responsibilities

l eader, and implementation leader. In addition, there
are l i aison roles to m arketing and to the software
engineering laboratory.

1

SOD

Code
base

5. 1. 1 Estimation Plan

As a project progresses, our ability to estimate
its cost and duration improve (but also become

4.3 Roles and Responsibilities

progressively less useful). This section explains
when and how we intend to perform these

The responsibil ities of the participants i n the project
are shown i n Figure 8.26.
Being responsible for a document i ncludes the
foIlowing:

estimations.

•

•

•

Maki ng sure that the docume n t i s created on time
Havi ng the team leader identify the writers o f the
docume n t
Keeping t h e document up-to- date throughout the
project l i fe cycle

5. Managerial Process Plans
5.1 Project Startup Plan

This section specifies the planning activities that
wiIl be conducted once the project is under way.
It is a plan to conduct planning-a meta-plan, if
you like.

Estimations of project cost and duration wiIl be
made foIlowing the specification of high - l evel re­
quirements (using function points), detailed require ­
ments (using a method t o be determi ned), and after
high-level design . The latter estimates will be made
by comparison with past projects .
Before begi n n i n g requirements analysis, we
have estimated the size of this effort in three di ffer­
ent ways:
1.

Using an i n formal top - down estimate based on
the experience of team members with somewhat
similar projects.

2. Using a top -down approximati o n with i ndustry
game development data.
3 . Using function points on two known functions,
extrapolating to the entire applicati o n .
The results are shown i n Figure 8. 2 7.

189

190

CHAPTER 8

PRI NCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLA N N I N G

Comment

Method*

Mini

Max

(1)

7.5**

170

(2)

4.2

3 00

(3)

1 1.4

46

Most conservative

1 1.4

3 00

Maximum of minimums and maximum of maximums

Least conservative

4.2

46

Minimum of minimums and minimum of maximums

Widest range

4. 2

3 00

Minimum of minimums and maximum of maximums

Narrowest range

1 1.4

46

Maximum of minimums and minimum of maximums

1.9-2.3 for two identified functions: 6-20 times as many in
complete application

Figure 8.27 very rough estimate of application size prior to requirements analysis

development staff. Some of these are shown in

The impleme n tation leader will ensure that al l
team members are supplied with the selected devel­
opme n t environment withi n two weeks of project
start.

Figure 8.27. In the absence of written require­
ments, estimates are necessarily very rough. The

5.1.4 Project Staff Training Plan

There are many ways of presenting this data,
depending on the needs of management and the

estimates themselves can be an appendix to this
document instead of here within the body, and
updated as the project progresses.

The reason for the very wide range is that the
figures have been obtained with negl igible i n terac­
tion with the customer.

5.1.2 Staffing Plan
The roles will be filled as fol lows .
5.1.3 Resource Acquisition Plan

All staff members whose Java proficie ncy level is less
than "advanced," as defined by the Aj ax certification,
will be trained by Un iversal Tra i n i ng Inc. courses
with i n the first month of the project. The obj ective
will be to attain advanced-level proficiency.
5.2 Work Plan

5.2.1 Work Activities
This section specifies how the work will be
subdivided.

This section indicates how resources will be
obtained other than staff (computers, soft­
ware, etc.)

The work on thi s proj ect will be divided i n to
configuration management, qual ity assurance (i n­
cluding testi ng), requi reme nts analysis, design , and

CASE STUDY: ENCOUNTER PROJECT MANAG EMENT PLAN

Leader

Facilitator

Responsibilty

Report at weekly meeting

x

Marketing

QA

Game lab

Risk

liaison

liaison

liaison

retirement

x

x

x

Circulate weekly report
Circulate biweekly report
Circulate monthly report

*Report formats
see CI 34: "monthly project status form"
2

see CI 87: "monthly marketing status form"

3

see CI 344: "weekly QA status form"

4

see CI 48: "biweekly game lab result form"

Figure 8.28 Program monitoring and control

Requ.
Name
Ed Braun

Team

CM

QA

Mngmnt

Design

Implementation

Leader

Leader

Leader

Leader

Leader

Leader
X

X

AI Pruitt

X

Fern Tryfill

X
X

Hal Furnass

X

Karen Peters
Liaison with

VP Eng.

Figure 8.29 Staffing plan for Encounter

Marketing

Soft. Eng. Lab

19 1

192

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLAN NING

J
1 1 1 1 1 1 1 1 1 1 1 1 JJJJ
Month 3

Month 2

Month 1

Month 5

Month 4

1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4
SCMP complete
Milestones

6

Begin system testing 6

A SQAP complete

6 SPMP reI. 1 complete

Delivery 6

Freeze requirements 6

J

Iteration 1

Iteration 2
Risk identification
and retirement

I

I

1
PreQ. for maintenance

CJ

Figure 8.30 High-level chart of tasks with fixed delivery date, ordered by completion

implementation . The project roles and responsibi l i ­
ties are shown i n Figure 8.26.

5.2.2 Schedule Allocation

If we are given a fixed completion date and
have identified the process that we will use, we

5.2.4 Budget Allocation
The budget al l ocati on, shown i n Table 8.1, matches
the work breakdown structure shown in Figure 8. 3 2 ,
and i ncludes an addi tional 1 0 percen t t o cover
unanticipated costs . Loaded I l abor rates are $4,000
per week.

5.3 Control Plan

may have enough information to provide a
high-level schedule. We increase the amount
of detail in the schedule as more becomes
known about the design.

The IEEE describes this section as "metrics,
reporting mechanisms, and control procedures
necessary to measure, report, and control the
product requirements, the project schedule,

The schedule is shown in Figure 8. 3 0 . Refer to
the SQAP for the schedule of qual i ty activities.

budget, resources, and the quality of work

5.2.3 Resource Allocation

team meetings (typically weekly; sometimes

The work breakdown structure is shown in Figure
8. 31. The bottom l i ne shows the perso n - months
avai lable for each month .

processes and work products."
It is usually advisable to schedule regular
short daily stand-up meetings). When there
is no business to conduct, such meetings can
easily be canceled. On the other hand, sched­
uling a meeting on short notice may be difficult

We have not yet performed any design, so it is
too early to name the engineers who will work
on specific parts. These names will be added
here after the designs for the various configu­
rations have been determined.

I

i.e., including benefits

when team members have other commitments.
Even teams that work together every day need
to schedule regular review meetings to avoid
drifting. The meeting convener should nor­
mally cancel a meeting if there are no agenda
items.

CASE STUDY: ENCOU NTER PROJECT MANAGEMENT PLAN

Month 1

Month

\ 2 \3 14

1

1

6 SCMP
6 SQAP
I) SPMP reI. 1

2

Month

2 3 4

1

3

Month

2 3 4

1

,

Milestones

Month

2 3 4

1

6Freeze requirements
,

Delivery

Iteration

2

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

J. Pruitt

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

F. Tryfill

1

1

1

1

1

1

1

1

1

1

1

1

1

H. Furnass

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

K. Peters

1

1

1

1

1

1

1

1

1

1

1

1

TOTAL

6

I

E. Braude

F. Smith (tech support)

61'

,

Iteration 1
Riskl&R

5

2 3 4

Complete testing

,

Tasks

4

.5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 1.5
�5i�5!�51�514�14�1�514�i3�
5.5! 5.5 i 5.5 15.515.5 !5.5

Figure 8.3 1 Work breakdown structure, excluding clerical work

The entire team will meet at the begi n n i ng of
each phase (requi rements, design , and implementa­
tion) with i n each i teration. There will be weekly
project meetings on Tuesdays from 10:00 a . m. to
noon. Team members are requested to keep Fri day
morn i n gs from 9:00 a.m. to t t :00 a.m. open for an
additional meeting, in case such a meeting becomes

necessary. The team leader will i n form the team by
Thursday at 4:30 p . m . i f the l atter meeting is to take
place.

5.3.1 Requirements Control Plan
The requirements leader will report to the project leader
on the status of the SRS in writing each Tuesday.
5.3.2 Schedule Control Plan

Table 8. 1 Budget allocation

The project leader will report to the team on the
status of the schedule in writing each Monday.

Month Number

Allocation

1

$96,800

2

$96,800

5.3.3 Budget Control Plan

3

$87,120

The project leader will report to management on the
status of the budget in writing every second Monday.

4

$87,120

5

$77,440

5.3.4 Quality Control Plan

Total

$445,280

The QA representative will provide written reports
to the manager of QA, with copies to the project

193

t

this project

pulled off

maybe

Alan Gray

Java skills

Deficient

3

9

7

6

10

3

Superimpose

images

impact

likely

given above)

,.

, =/east

I - I 0 , = least

(details

�

9

8

cost

, =Iowest

Cost 1-10

Retirement

Figure 8.32 Sample risk analysis for Encounter case study

3

2

#

1-10

Likelihood

Risk Title

Impact

288

80

8

handled first)

number

Priority (lowest

Alan's work

Susan Ferris to inspect all of

level 3 certification by 4/15/99

certification by 3/1/99 and

Corp, obtain Java level 2

ning 1/5/99 at Ultra Training

attend training course begin-

H.T., K.M.,V.I.,and L.D. to

Experiment with Java images

Retirement / Mitigation Plan

S.F.

H.L.

P. R.

Engineer

Responsible

Continual

4/15/99

2/1/99

Date

Completion

Target

2
2
Z
G)

S;

:::z::
m
o
C
;Z
.G)
l>
2
o
-0

C/)
(')

(5
.2

�

�
�

m

�
m
2
-i

�
m

�
l>
2

Cl

m

e

;0
m
-0
;0

�

o

"
C/)

o

rn

;-

-0
;0
z
(')
'U

;0
00

�
m

l>

(')
:::z::

....
-0
�

CASE STUDY: ENCOUNTER P ROJECT MANAGEMENT PLAN

l eader, on a schedule to be determ i ned by the
manager of QA.

a n d even if they are, we do not know how l ong i t
w i l l take to come u p to s peed . Th i s could damage
the project i rreparably.

5.3.5 Reporting Plan
The wri tten reports referred to in thi s secti o n (5. 3 )
will b e via e-mai l . I ssues affecting human safety will
be reported to all project personnel and manage­
ment, regardless of the plans in this document.

5.5 project Closeout Plan

Encounter will not be maintai ned and released be­
yond 2006. A phase-out plan for the second half of
2 006 will be developed.

5.3.6 Metrics Collection Plan
See the Software Quality Assurance Plan.

6. Technical Process Plans

5.4 Risk Management

Here is wh ere we describe the process to be
used (waterfall, i terative, etc . ) .
Elaborate on the risks as specific "bad hap pen ­
i ngs"; do not leave as generic ti tles . For exam ­
ple , "deficient Java ski lls" by itself does not
spec i fy the issue. Perhaps the project can be
perform ed adequately by a team whose Java
skills have deficiencies.

Fi gure 8. 3 2 shows a format for risk reporti ng
and retirement. Each project meeting i s to have an
agenda item for risk i denti fication bra i nstorm i n g and
reporti ng on risks that have been i denti fied.
Risk # 1: "Superimposing i mages" concerns
image m a n i pulation i n J ava . Th i s i s a requ ired
capabili ty, because characters have to m ove about,
superi m posed o n backgrou nd i m ages . No one i n
the team has experience w i th placing the i m age o f a
character aga i nst a background w i thout c arrying a
rectangle a l o n g w i th the character. We do not
know whether this i s easy, di fficu l t , o r i m possible
to do .
Risk #2 : "Deficient Java ski l ls" i n dicates the
fact that 40 percent of the team is not sufficien tly
skilled in Java to i m plement the m ovement a n d
i n teraction o f ch aracter im ages. W e anti c i p ate th at
i t w i l l also be necessary to scale the game enviro n ­
ment, b u t n o o n e o n t h e team h a s a n y experience
w i th thi s . We do not know whether the capabili ties
that our customer has in m i n d are doable w i th Java,

6.1 Process Model
The first two versions of this proj ect will be executed
using a spiral development process with an i teration
corresponding to each version. The first i teration will
be a working prototype but will be fully documented.
The second i teration will resul t i n version 1 of
Encounter. The number o f subsequen t iterations
and the nature of version 2 are to be decided after
the customer has witnessed a demonstrati o n .

6.2 Methods, Tools, and Techniques
The Encounter project will use Rationa l Rose™ for
des ign and will be implemented i n Java. Object­
Orientation is to be used throughout. J avadoc will be
used for documentation as much as possible (see the
SRS for this requirement) . Refer to Section 2.1
(process model) for a description of the process.

6.3 Infrastructure Pl an
The Encounter team will require model 981234 pes ,
I n ternet access, 100 GB storage on Fel ix, and the
Aj ax team collaboration appl ication support.

195

196

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLA N N I N G

The hardware resources required are .

implemen ted for Ecl i pse. T h e shaded materi al con­
sists of the authors' comments.

6.4 Product Acceptance Plan

ECLIPSE DOC U M E NTATION

Management and investor representatives will final­
ize acceptance cri teria withi n three weeks of proj ect
start. Acceptance tests will take place at the MGC
offices with i n a week o f the project completion date.

The home page for Ecli pse documentation is at
http://www. ecl i pse.org/ec l ipse/i ndex . ph p - "docu­
mentatio n . " This i ncludes user manuals . Documen­
tation i s classi fied as a subproject i n i tself.

7. Supporting Process P lans

Note to the Student:
Documentati on is so substa ntial that it is
designated as a (sub )project unto i tsel f.

Th is section references plans supporting pro­
cesses that span the duration of the so ftware
projec t such as the SCMP, SVVP, and SQAP

ORGAN IZATION OF THE ECLIPSE PROJ ECT

8. Additiona l Plans
None

8.5 CASE STU DY: PROJ ECT MANAG E M E NT
I N ECLIPSE

The materia l in this section is quoted, edited, or
adapted from the Eclipse Web sites as they existed at
vari ous poi nts i n time. I t is not a formal SPMP but
rather a descri ption of how project management i s

The Ecli pse project consists of several 'To p ­
Level Projects . " A managemen t committee is
responsible for each of these. Each top-level
project consists of several (non-top-Ievel )
projects. Each project h a s a projec t lead, the
project plans, and the devel opment team. The
devel opment team consi sts of devel o pers and
"commi tters . " Only the latter have the author­
i ty to comm it artifacts to the baseli ne. These
are exp lained later in this section. Th is is
largely special to open source projects .

See Figure 8. 3 3 for the project structure.

Proposed Eclipse Project Structure and Roles
Top Level Project A

Project 1

Project Lead

Top Level Project C

Top Level Project B

Project 2

Development Team

Lcommitters
L

Project 3

Subsystem(s)

Developers

�

Project Management Committee (PMC)

proj

T::Task2
:

PMCLead
Arch Council Rep
Planning Council Rep

1

L Task

3

Figure 8.33 Eclipse project-proposed structure and roles
Source: Eclipse Project. http://www.eclipse.org/org/documents/Eclipse%20Development%20Process%202003_11_09%20FINAL.pdf.

CASE STUDY: PROJECT MANAGEMENT IN ECLIPSE

CHARTER FOR THE ECLIPSE TEC H NOLOGY
(TOP-LEVEL) PROJ ECT

The "Eclipse Technology Project" differs from
the "Eclipse Project." The following document
includes a description of project management
in Eclipse. It is found at http://eclipse.org/
technology/technology-charter.html and has

small, informally structured projects that add new
capabilities to the Eclipse software base (Incubators
Stream), foster greater community awareness and
understanding of Eclipse (Education Stream), or
explore research issues in Eclipse-relevant domains
such as programming languages, tools, and develop­
ment environments (Research Stream). The Eclipse
Technology Project is intended to:

been reformatted and annotated by the author.

1. Provide the open source community with a

As described below, a project can migrate from

lighter-weight alternative to the larger scale,

being an "Eclipse Technology Project" to be­

more structured development activities carried
out by other PMCs, and

ing an "Eclipse Project." This "charter" docu­
ment mainly describes organization and
management. Without committing this kind

2. Create opportunities for researchers, academics,

of thing to paper, there would be little chance

and educators to play a significant role within
the Eclipse community.

of a successful outcome.

Overview

Scope
A "Scope" section in a document often refers to

This is a good overview. It includes the overall

the scope of the document itself; that is, the

motivation for the project and, as with all good

extent that the document is intended to cover.

overviews, does not attempt to provide com­
plete descriptions. It starts by providing the

That is not the case here. This section de­
scribes the scope of the actual Eclipse Tech­

motivation for Eclipse.

nology Project.

The Eclipse Technology Top-Level Project
(the "Eclipse Technology Project") is an open source
software research and development project, which
encapsulates three related activity streams, each of
which is based on or uses the Eclipse Platform and/or
Eclipse Tools:
1. Academic research projects and other explora­

The scope of the Eclipse Technology Project
will encompass a wide variety of small projects rather
than a few large ones. Although anticipating enor­
mous diversity in the content of these activities, from
a process-oriented viewpoint they will all share
important common characteristics, which argues
for a common management envelope:

tory investigations ("Research Stream");
•

Focus on precompetitive development and research

•

Use of informal development processes

•

Fluid project tracking due to frequent plan changes

2. Development of educational materials, teaching

aids, and courseware ("Education Stream");
3. Incubation of small-scale, innovative platform

and tools projects ("Incubators Stream").

Mission
The mission of the Eclipse Technology Project is to
provide a home within the Eclipse Foundation for

•

•

•

Flexible milestones that adapt based on partial
results
Small teams
Resource commitments tentative, due to volunteer
labor or lack of sponsor funding

197

198

CHAPTER 8

•

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLAN N IN G

Development often cross-cuts the scope of several
other Ecl i pse Foundatio n Projects

The Ecl ipse Technology Project serves as a
si ngle point of focus for such teams , and provi des
them with a home with i n the Ecl i pse community
. I n many cases successful Research Projects will
evolve i nto incubators , and incubators i n turn may
migrate to other Project Management Committees
(PMCs ) , either by mergi ng i nto an existing proj ect,
or by formi ng the basis for a new one . .

removi ng obstacles, solving problems , and resolv­
ing co nAicts .
•

•

Th i s section speci fies the Ec li pse project man­
agement by spec i fying the respo nsibilities of
the projec t ma nagement commi ttees .

•

•

•

Each project operates effectively by providing
leadership to gui de the project's overal l direction
and by removing obstacles , solvi ng problems , and
resolving conAicts.

•

•

•

All project plans, tech nical documents, and reports
are publicly available.
Al l projects operate using open source rules of
engagement: meritocracy, transparency, and
open partici pati o n . These pri nciples work to­
gether. Anyone can participate i n a project. Th is
open i nteraction, from answeri ng questions to
reporti ng bugs to making code contributions to
creating designs, enables everyone to recogn ize
and uti l ize the contributions.

Working with the Ecl i pse Managemen t Organiza­
tion ( the EMO ) to establ i sh the development
processes and i n frastructure needed for the devel­
opment team to be effective.

Documents should explain abbrevi ations the
first time they are introduced, like th is, but
also i ncl ude them in a glossary so that the reader
knows where to look for an expl anation . The
reader is expected to know the meaning of "the
Eclipse Management Organization." This is
normal: the project management for a software
developmen t effort typically reports to a higher­
level person or body within the company .

project Management Committee

The proj ects under this charter are managed by
a group known as the Project Managemen t Com­
mittee. PMCs are expected to ensure that:

Ensuri ng that project plans are produced.

•

•

•

•

Recommendi ng new projects to the EM O .
Recommendi ng the i n i tial set of proj ec t commi t­
ters for each new project overseen by the PMC,
and establishing the procedures consistent with
this charter for voting in new commi tters .
Helping to ensure that the projects overseen by the
PMC have enough con tri butors, and working to fill
vacancies i n ro les .
Producing "how t o get i nvolved" gui deli nes t o help
new potential contri butors get started .
Coordi nating relationships with other Ecl i pse
Foundation Proj ects.
Facil itating code or other donations by i n dividuals
or companies.
Maki ng recommen dati ons to the Ecl i pse Founda­
tion Board

The PMC has the following responsibi l i ti es:
•

•

Providing the leadership and vision to guide the
project's overall direction in a manner consistent
with the Eclipse Foun dation Architectural Roadmap.
Providing assistance and support to the developers
and researchers working on the project by

(This is the overall controlling body for
Ecl i pse. )
regarding contributions proposed under licenses
other than the standard one used by Ecli pse.

CASE STUDY: PROJ ECT MANAG EMENT IN ECLIPSE

•

Working with the EMO and committers to ensure
that i n -bound contributi ons are made in accord­
ance with the Ecl i p se Foundation I P .

( I ntel l ectual Property )

Policy.
•

Acting as a focal point for the commun i ty i n
representing t h e projects i t oversees .

Since Ecli pse is open source, this documen ta­
tion has to include procedures that ensure the
conti nued existence and health of the Project
Management Commi ttees ( PMCs) themselves.
The PMC lead is appointed by the Board. The
i nitial PMC is selected by the PMC lead. Thereafter,
to become a member of the PMC, an in dividual must
be nomi nated by another member of the PMC and
unan imously approved by all PMC members .
I n the unl ikely event that a member of the PMC
becomes disruptive to the process or ceases to
contribute for an extended period, the member
may be removed by unanimous vote of remaining
PMC members. PMC members may resign at any
time by del ivering n otice o f their resignation to the
PMC lead.
The PMC is responsible for producing and
maintai ning the project charter. Development
must con form to any rules or processes outl i ned i n
the charter, so a change t o the development process
may necessitate a change to the charter. Changes to
the charter are approved by the board.
The work of the PMC is shared by the PMC
members . All PMC members are expected to con­
tribute actively. I n particular, PMC members are
expected to take responsib i l i ty for overseeing certai n
areas of work in the project, and reporting to the
PMC on these areas.
Active participation i n the user newsgroups and
the appropriate develo per mai l i ng l i sts is a responsi ­
b i l i ty of all PMC members , and is critical to the
success of the proj ect. PMC members are required to

monitor the main roject mail i ng list and the devel ­
oper mailing l i sts for all projects and components
they are overseei ng.
Roles

Many rol es in an open source development are
typically di fferent from commercial develop­
ment roles. They depen d on volun teers and
not paychecks. For that reaso n , there is in­
creased poten tial for participants to come and
go. Th is documen t describes polic ies to deal
with th i s .
T h e projects under t h i s charter are operated a s
meritocracies: t h e more y o u contribute, and the
h i gher the qual i ty of your contribution, the more
you are all owed to do . However, with this comes
i ncreased responsibil ity.
U sers

Users are the people who use the output from the
project. Output will typically consist of software and
research . Software in this context means i n tell ectual
property in electronic form , i ncludi ng source and
b i nary code, documen tati o n , courseware, reports,
and papers .
Developers

U sers who contribute so ftware or research become
develo pers. Developers are encouraged to partici­
pate i n the user newsgroup ( s ) , and should monitor
the developer mailing list associated with their area
of contributio n . When appropri ate, developers may
also contribute to development design discussions
related to their area of contributio n . Devel opers are
expected to be proactive in reporting problems in the
bug tracki n g system .
Committers

Developers who give frequent and valuable contribu­
tions to a project, or component of a project ( i n the

199

200

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLANNING

case of large projects), can have their status promoted
to that of a "committer" for that project or component
respectively. A committer has write access to the source
code repository for the associated project (or compo­
nent) , and gains voting rights allowing them to affect
the future of the project (or component).
The following paragraph descri bes a formal
process, which is essential to the smooth
run n i ng o f the Ecl i pse project.

In order for a developer to become a committer
on a particular project overseen by the PMC, another
committer for the same project (or component as
appropriate) can nominate that developer, or the de­
veloper can ask to be nominated. Once a developer is
nomi nated, the committers for the project (or compo­
nent) will vote. I f there are at least three positive votes
and no negative votes, the developer is recommended
to the PMC for commit privi leges. If the PMC also
approves, the developer is converted into a committer
and given write access to the source code repository for
that project (or component). Becomi ng a committer is a
privilege that is earned by contributing and showing
discipline and good judgment. It is a responsibility that
should be neither given nor taken lightly.
A good ma nagement document antIcI pates
negative circumstances l i ke the foll owing.

At times , commi tters may go i n active for a
variety of reasons. The decision-maki ng process o f
t h e proj ect rel ies on active committers w h o respond
to discussions and votes i n a constructive and timely
man ner. The PMC is responsible for ensuri ng the
smooth operation o f the project. A committer that is
disruptive, does not partici pate actively, or has been
i n active for an extended period may h ave h i s or her
commi t status removed by the PMC.
Active partici pation i n the user newsgroup and
the appropri ate devel oper mai ling l i sts is a responsi­
b i l i ty o f all commi tters, and is critical to the success
o f the proj ect. Commi tters are required to mon i tor
and con tribute to the user newsgroup.

Commi tters are required to mon i tor the devel ­
oper mail i n g l i s t associated with all projects and
components for which they h ave commi t privileges .
This is a condition of bei ng gran ted commit rights to
the project or component. It is man datory because
commi tters must participate in voting (which i n
some cases requires a certai n mi n i mum number o f
votes) and must respond to t h e mai l i n g l i st i n a timely
fash ion i n order to faci l i tate the smooth operation of
the proj ect. When a commi tter is granted commi t
rights he or she will be added to the appropriate
ma i l i n g li sts. A committer must not be un subscribed
from a devel oper mai ling list unless their associated
commit privi leges are also removed.
Committers are required to track, participate i n ,
and vote on relevant discuss ions in their associated
projects and components. There are three voting
responses: + 1 (yes ) , - 1 (no, or veto ) , and 0 (abstai n ) .
Commi tters are responsi ble for proactively
reporting problems in the bug tracking system,
and annotati ng problem reports with status i n forma ­
ti o n , explanations, clarificati ons, or requests for more
i n formatio n from the submi tter. Commi tters are
responsible for updati ng problem reports when
they have done work rel ated to the problem.
projects

The work under th is Top- Level Project is further
organi zed into projects . New projects must be con­
sistent with the mission o f the Top- Level Project, be
recommended by the PMC, and confirmed by the
EMO . Projects can be disconti nued by decision o f
t h e board.
When a new project i s created, the PMC
nomin ates a project lead to act as the technical
leader and nomi n ates the i n itial set of commi tters
for the proj ect, and these nomi nations are approved
by the EMO . Project leads are accountable to the
PMC for the success of their proj ect.
project organization

Th is section describes the organization o f
projec ts with i n Ecli pse.

CASE STUDY: PROJECT MANAGEMENT I N ECLIPSE

Given the fluid n ature of Eclipse Technology
Projects , organ i zational changes are possible, in par­
ticular: divi ding a Proj ect i n to components; divi ding a
Project i n to two or more i n dependent Projects; and
merging two or more Projects i nto a si ngle Project. In
each case the i niti ative for the change may come
either from with i n the Project or from the PMC, but
the PMC must approve any change, a n d approval
must be con firmed by the EMO .
I f a project wishes t o divide i nto components,
commit privileges are normally gran ted at the com­
ponent level , and the committers for a given com ­
ponent vote on i ssues specific to that component.
Compo nents are established and discontinued by the
PMC. When the PMC creates a component it ap­
points a component lead to act as the technical
leader and names the i n itial set of commi tters for
the component. The component lead i s design ated
as a committer for the project and represents the
component in discussions and votes pertaining to the
project as a whole. Component committers do not
participate in votes at the level of the project as a
whole, unless they are also the component lead.
In cases where new proj ects are bei ng created,
either by spl i tting or by merging, the usual proce­
dures as set forth in this charter are fol lowed. I n
particular, develo pers w i l l n o t necessarily have the
same rights after an organizational change that they
enj oyed in the previous structure.
Infrastructure

Th is section is a useful checklist for most
software projects .

The P M C works with the EMO t o ensure the
required i n frastructure for the project. The project
i n frastructure will i nclude, at m i n i mum:
o

o

o

Bug Database-Bugzilla database for tracking bugs
a n d feature requests .
Source Reposi tory -One or more CVS reposito­
ries containing all the software for the projects.
Web S ite-A Web site will conta i n i n formation
about the project, i ncludi ng documentation,

reports and papers, courseware, downloads of re­
leases, and this ch arter.
o

o

o

General Mai l i ng List-Mailing list for develop­
ment discussions pertai n i n g to the project as a
whole or that cross projects . This mailing list i s
open to t h e publ i c .
Project Mai l i ng List-Development mail i n g l ist for
techn i cal discussions related to the project . This
mailing list is open to the publ i c .
Component Mai l i ng List-Development mail i n g
l i st for technical discuss ions related to t h e compo­
nent. Th is mailing list is open to the publ i c .

The Development Process

In this sectio n , the phrase "release cycle" will refer to
a sign i ficant block of project activity, which corre­
sponds to an actual release cycle in the case of
incubators or E ducatio n Projects , or to a major stage
of a phased Research Project.

Th is assumes an interactive development pro­
cess. However, each iteration is actually released,
and so must be a usable version of the product.

Each project lead must produce a development
plan for the release cycle, and the development plan
must be approved by a majority of committers of the
project. The plan must be submitted to the PMC for
review. The PMC may provide feedback and advice on
the plan, but approval rests with the project committers.

The document mandates here that each project
provide a requiremen ts documen t. It would
have been better to be more spec i fic about
where such documents are depl oyed : it is not
easy to find Ecli pse requi rements documents in
practice, and it is questionable that they exist in
many cases . Even for non- o pen source projects ,
it can be di fficul t to un dersta nd the extent of
documen tation . This is greatly clari fied when
an organizati on standardizes on documenta­
tion types (e.g. , selected IEEE standards ) .

201

202

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULIN G , AND PLANN IN G

Each project must identi fy, and make available
on i ts Web site, the requirements and prioriti zations
it is working against in the curren t release cycle. I n
addition, each proj ect must p o s t a release p l a n
showi ng t h e date and content o f t h e n e x t major
re lease , i ncludi ng any maj o r mi lestones, and must
keep th i s plan up to date .
The commi tters of a project or component
decide which changes may be committed to the
master code base of a proj ect or component, respec­
tively. Three + 1 ("yes" votes) with no - 1 ("no" votes
or vetoes) are needed to approve a code change .
Vetoes must be fol lowed by an explanation for the
veto with i n 24 hours or the veto becomes inval id. All
votes are conducted via the developer mailing list
associated with the project or component.
Special rul e s may be estab l i shed by the PMC
for projects o r components with fewer than three
commi tters . For e fficiency, some code changes
from some contri butors ( e . g . , feature addi t i o n s ,
b u g fi x e s ) m a y be approved i n advance, o r a p ­
proved i n p ri n c i p l e based o n an outl i n e o f the
work, in wh ich case they may be commi tted first
and changed as needed, w i th confl icts resolved by
maj ority vote of the c o m m i tters of the p roj ect or
component, as appl icab l e .
T h e m aster c o p y o f t h e c o d e b a s e m u s t res i de
on the p roject Web s i te , where i t is accessible to
all users , deve l opers, a n d commi tters . Commi tters
must check th e i r changes and n ew work i n to the
master code base as promptly as possible (subj ect to
any check - i n vot i n g rul es that may be in e ffect) i n
order t o fo ster coll aborati o n among widely d i stri ­
buted groups a n d so that the l atest work is always
avai lable to everyo n e . The PMC i s responsible for
work i n g with the Ecli pse Foundati o n to estab l i sh a
re lease engi neeri ng and bui l d process to e n sure that
bui l ds can be rel i ably produced on a regular and
frequent basis from the master code base a n d made
ava i l able for download from the proj ect Web s i t e .
B u i l ds i n th i s context are i n t e n de d to i nclude n o t
only code b u t also reports , documentati o n , a n d
courseware .
Each project is responsible for establ ishing test
plans and the level o f testing appropriate for the
project.

Th is docum ent does not establ ish qual ity
goals. As a result, there is signi ficant vari ation
in the qual i ty of Ecli pse projects. A commer­
cial e ffort would be much more specific in this
respect.

All development technical discussions are con­
ducted using the development mailing lists. [f discus­
sions are held offline, then a summary must be posted to
the mailing list to keep the other committers informed.
Licensing

All contributi ons to proj ects un der th is charter must
adhere to the Eclipse Foundation I ntel lectual Prop­
erty Policy . "
Ecli pse is organ ized i n to t h e Platform , JOT,
and POE subprojects as fol lows [7].

[ n describing the management of a project, it
may be necessary , as here, to re fer to particular
requirements or design issues. Otherwise, we
try to separate project processes from require ­
ments. Requirements are n o t known duri ng the
first iterati on of project management docu­
ments but they do become known more duri ng
subseque n t iterations.

Pl atform

"The platform proj ect provi des the core frameworks
and services upon wh ich all plug- i n extensions are
created. [t also provides the runtime in which plug­
ins are loaded, integrated, and executed. The primary
purpose of the platform subproject is to enable other
tool developers to easily build and del iver i n tegrated
tools . "
J DT

'The JOT (Java Development Tools) project provides the
tool plug-ins that implement a J ava [DE supporti ng the
development of any J ava appl ication, including Ecl ipse

CASE STUDY: PROJECT MANAG EMENT IN ECLIPSE

plug-ins. It adds a Java project nature and Java
perspective to the Eclipse Workbench as well as a
number of views, editors, wizards, buil ders, and code
merging and refactoring tools. The JOT project
allows Eclipse to be a development environment for
itself."

PDE

'The POE (Plug-In Development Environment) project
provi des a number of views and edi tors that make
is easier to bui l d plug- i n s for Eclipse. Using the POE,
you can create your plug- i n manifest file (plugi n .
xml ) , spec i fy your plug- i n runtime a n d other required
plug- i ns , define extension poi nts, i ncludi ng the i r
spec i fi c markup, associate XM L Schema fi l e s with
the extension point markup so extensions can be
val i dated, create extensions on other plug- i n exte n ­
sion points , e t c . T h e POE m akes integrating plug- ins
easy and fun . "
These subprojects are further decomposed. For
example, the Platform subproject is broken down
i nto components. Each component operates l i ke a
project unto i ts own , with its own set of commit­
ters , bug categories, and mai l i n g l i sts. These are as
foll ows [ 8] :

A method of prov i d i n g some short- term doc ­
ument history.

Please send comments about this draft plan to the
ecl ipse - dev@eclipse . org developer mailing list.

As an appl ication, Ec l i pse has featu res. As a
platform , Ecl i pse has to have an API set: a
means for i n terfaC i n g with i t for program mers
extending i t .

Thi s document l ays out the feature a n d API set
for the next feature release of Eclipse after 2 . 1 ,
designated release 3 . 0 (Why Ecli pse " 3 . 0"?) .

A hyperl i nked table of contents l i ke the fol ­
lowing i s usefu l . Notice the emphasis here on
del iverables and schedule, expressed i n the
first i tem .

Release deliverables
Release m i lestones

Project Name

Description

Ant

Ecli pse/Ant i ntegration

Compare

U n iversal compare faci l i ty

Target operati ng environments
Compatibility with previ ous rel eases
Ecli pse Platform subproject
Java development tools UDT) subproject

DRAFT PROJ ECT PLAN FOR ECLIPSE
RE LEASE 3.0

The fol l owing i s excerpted and quoted from the
project plan for release 3 of Ecli pse [9]. It provi des
an example o f a specific project plan when com pared
with the charter.
Last revised Friday, January 3 0, 2004 C marks
interesting changes since the previous draft of October 2 7,
2 00 3 ) .

Plug- i n development
subproject

environment

( POE)

Th i s part i s a scope statement. I t also speC i fies
the management of this document and pro ­
vi des an overv i ew.

Plans do not materialize out of nowhere, nor are
they entirely static. To ensure that the planning process

203

204

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLA N N IN G

is transparent and open to the entire Eclipse commu­
nity, we (the Eclipse PMC) post plans i n an embryonic
form and revise them throughout the release cycle .

PMC

=

Project Management Com m i ttee .

The first part of the plan deals with the i mpor­
tant matters of release deliverables, release m i l e ­
stones, target operati ng environments, a n d release­
to -release compatibi l i ty . These are all things that
need to be clear for any release , even if no features
were to change .
The remainder of the plan consists of plan i tems
for the various Eclipse subproj ects . Each plan i tem
covers a feature or API that is to be added to Eclipse,
or some aspect of Eclipse that i s to be i mproved. Each
plan i tem has its own entry in the Eclipse bugzilla
database, with a titl e and a concise summary (usually
a single paragraph ) that explains the work i tem at a
suitably high enough level so that everyone can
readi ly understand what the work item i s without
havi ng to understand the n itty-gritty deta i l .

With the previous release as the starting point,
this is the plan for how we will enhance and improve
it. Fixing bugs, improvi ng test coverage , docume n ­
tation, examples, performance, usabi lity, a n d so on,
are considered routine ongoing maintenance activi ­
ties and are not i ncluded in thi s plan unless they
would also i nvolve a significant change to the API or
feature set, or i nvolve a significant amount of work.
All i n teresting feature work is accounted for in this
plan.

Th is provi des more on the scope of th is docu­
ment. The activities l i sted are considered
"maintenance," covered in the last part of
this book. A three- part scheme for require­
ments priority i s used, with the added "re ­
j ected" category. Th i s merely keeps track o f
requirements that were proposed a t some
point and rejected.

The curren t status of each plan item i s noted:

Committed plan i tem-A commi tted plan i tem
Note that, in place of a detai led requirements
document, the detailed requirements are e ffec ­
tively provided via the Bugzilla database, where
there is no real distinction between required
features and a bug in what's been implemented.
Bugzilla is an open source defect tracking appl i ­
cation. See http://www. bugzi lla.org/. A refer­
ence on Ecl ipse's spec ific use of Bugzilla is at
https://bugs.eclipse.org/bugs/docslhtml

is one that we h ave deci ded to address for the
release .

Proposed plan item-A proposed plan i tem is
one that we are cons i deri ng address ing for the
release. Although we are actively i nvestigati ng
it, we are not yet i n a position to comm i t to i t or
to say that we won't be able to address it. After
due consideration, a proposal will e i ther be
comm i tted, de ferred, or rej ected.

Deferred plan item-A reasonable proposal

A series of dots, as here (an "el l i psis"), indicates
that the author omitted material from the
origi nal in the interest of brevity. The activi ­
ties l i sted in the next paragraph are considered
"mai ntenance," the topic covered in the last
part o f this book.

that will not make it i n to this rel ease for
some reason i s marked as deferred with a brief
note as to why i t was de ferred. Deferred plan
i tems may resurface as committed plan i tems at
a later point.

Rejected plan i tem-Plan items that were pro­
posed but judged unworkabl e are marked as
rejected plan items, with an accompanying sum ­
mary of why they were dismissed. Keeping track
of rejected i tems avoids repeating the discussion.

CASE STUDY: PROJECT MANAGEMENT FOR OPENOFFICE

Th is is more or less a tri age classificat i o n ,
except t h a t i t e m s consi dered and rej ected
are maintained for re ference.

Release Del iverables

The release del iverables have the same form as
previous releases, namely:
•

8.6 CASE STU DY: PROJ ECT MANAG E MENT
FOR OPENOFFICE
The case study i n this sectio n provides excerpts from
the OpenOffice proj ect management plan. For the
most part, we will use the same headi ngs as found i n
the official OpenOffice documentati o n .

OPENOFFICE PROJ ECT G U I D E LI N ES

Source code rel ease for Ecli pse Project, avai l able as
versions tagged "R3_0" in the Eclipse Proj ect
CVS repository.

Note to the Student:
The fol l owing is taken from http://www .open­
office . o rg/dev_d ocs/gu i d e l i n e s . h tm l , with
minor editing. I t is titled "Cuideli nes for Partici­
pating in OpenOffice. org" and constitutes a proj ­
ect management subject.

Release Milestones

Release milestones occurri ng at roughly six-week
i n tervals exist to facilitate coarse -grained planning
and stagi ng. The m ilestones are as fol lows .

There is an attempt here to pace m i lestones at
regular in tervals to fac i l i tate regular commun i ­
cation. O therwise, l o n g gaps wou ld occur in
which no commun ication is guaranteed, which
is undesirable .

•

•

Fri day June 6, 200 3-Milestone t ( 3 . o M 1 ) , stable
bui l d reflecti ng progress
Friday July t 8, 200 3-H as been tested and val i ­
dated i n the target operating con figurations l isted
below.

The re m a i n d e r o f the m a terial at h t t p : //www.
e c l i p s e . o rg/e c l i p s e/ deve l o p m e n t/e c l i pse_
proj eccplan_3_0 . h t m l consists o f re q u i re ­
m e n t s , a n d are excerpted i n Chapter t 8 , the
Req u i re m e n ts Analysis part o f th i s book.

OpenOffice. org is an open source project
through which Sun Microsystems has released the
technology for the StarOffice (TM ) productivity suite .
Sun sponsors and partici pates i n OpenOffice. org;
Coll abNet hosts and helps manage the proj ect. The
overall name of the Proj ect is OpenOffice. org, as i s
t h e n a m e of the so ftware product.
OpenOffice. org's main features incl ude the
fol l owing:
•

•

Downloadable sources and i n formatio n
Community and communication
such as mailing l ists and forums

mechan isms,

OpenOffice . org has established the necessary
faci l i ties to m ake th is open-source technology ava i l ­
able to all i n terested participants. Pri nci pal proj ect
objectives are as fol l ows:
•

•

Establishment of ope n , XM L-based standards for
office productivity file formats and l anguage - i nde ­
pendent bindings t o component APls
Open access to the source code via CVS version­
ing to enable innovation for building the next
generatio n of open - n etwork productivity services

205

206

CHAPTER 8

PRI NCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLA N N I N G

GOVERNANCE

OpenOffice participant: members, developers,
and project leads. These are explained next."

For a proprietary project, this would corre­
spond to a management section.

M E M B E RS

Open Office . org is governed by the Community
Counci l which is constituted by members from the
OpenO fice.org community. They created the charter
establishing the Counci l . The Council holds periodic
meetings by IRC as well as conducting busi ness via
discuss@counci l . openoffice .org mail list. Both IRC
records and mai l - l ist archives are public. Agenda i tems
may be proposed by any member and should be sent to
agenda@council .openoffice . org. For more informa­
tion, go to the Council Web site.
The following secti ons describe gui deli nes
regardi ng techn ical roles and responsibil ities at
OpenOffice. org and handling of source code. Sub­
stantial enhancements or modi fications of these
gui de l i nes need approval of the Commun i ty Council.
For guidelines on the protocols for proposing
proj ects to OpenOffice. org, please see Protocols for
Project Proposal .

f

ROLES AN D RESPO N S I B I LITIES

Everybody can help no matter what their rol e . The
more a person gets involved in the proj ect, the more
he or she develops a trusting relati onship with
others. Those who have been long- term and valuable
con tributors to the proj ect earn the right to com m i t
directly to t h e source repository.
O p e n O ffice . org respects the rights of its c o m ­
mun i ty to post messages and u s e the m a i l i n g l i sts t o
further the a i m s o f t h e p roj ec t . I n fact, we e ncour­
age people to use the ma i l i n g l i sts. To th i s end, we
will do our best to l i m i t "spam" and to e n sure that
communication among commun i ty members i s car­
ried out p o l i tely and efficiently. We h ave po sted
some "Mail - Li s t Gui de l i n es" that detail our
comm i tm e n t .

W e would state here something like the fol­
lowing:

'There

are

several

categories

of

"Members" refers to those persons who have joi ned
the proj ect by registeri ng with OpenOffice . o rg and
have a username. A member may not h ave subscribed
to a mailing l i st, and a subscriber to a mailing l i st who
is usi n g the project may not h ave regi stered; only
those who have registered are members . It is strongly
encouraged that all members j o i n the general and
relevan t specific proj ect l i sts as well as j o i n i n g a
particular project. I n i tially, one can only j o i n as an
observer , a role that allows one to contribute to the
proj ect and otherwise parti ci pate in it.
DEVELOPERS

Written rules like these are essential for get­
ting the job done. Without them, there would
be chaos and no OpenOffice.

Project members who give frequent and valu ­
able contributions t o a project c a n have the i r status
promoted to that of a "develo per" for that p roj ect. A
developer has write access to the source code re pos­
i tory. A "co ntent devel o per" has wri te access to a
project's documentation but not to the source code.
I n order for a contributor to become a devel oper,
another developer has to nominate that contributor.
The project lead may co nvert the contributor into a
developer and give write access to the source code
repository for the project.
At times, developers may go inactive for a
variety of reasons. A developer who has been i n ­
active for s i x months or more m a y l ose his or her
status as a developer. I n this case or i f the value of a
developer's con tributi ons dim i n i shes, write access
may be revoked by the responsible project lead.
A committed change must be reversed if this is
requested by the responsible project lead or by the
Community Council or its delegates and the conditions
cannot be immediately satisfied by the equivalent of a

CASE STUDY: PROJECT MANAGEMENT FOR OPENOFFICE

PROJECT LEADS

charge of. Any member of the affected project may
ask for the Commun i ty Counci l to recon s i der a
project l ead, or to i n tervene i n disputes or questions
concerni n g proj ect leadersh i p . A decision by the
Community Counc i l is required to revoke project
lead status .
Any member of a project is eligible for electi on
to project lead of that proj ect. Elections are arrange d
b y the project concerned. A l ist of our curren t
project leads can be found i n t h e l i st of projects .

There are three main categories of public projects i n
OpenOffice . org:

SCH E D U LE

"bug fix" commit. The situation must be rescinded
before the change can be included i n any public release.
Th i s paragraph belo ngs in a location where
spec i fic rules are given for committing code to
OpenOffice .

•

Accepted proj ects ("projects")

•

Incubator

•

Native - lang

All accepted proj ects must have two leads . It is
up to each project to determi n e the actual content of
the roles each lead will take on. Native -lang and
i n cubator proj ects may have one lead. Size and
complexity are the determ i n i ng factors : a large proj ­
ect requires two leads .

Presumably, the requirement for two commit­
ted project leads m i n i m i zes the risk that a lead
becomes unavailable, thereby threatening the
health of the project. Th i s is a facet of risk
management.

A project lead is responsible for giving guid­
ance and directi ons for his or her project and its part
in the OpenOffice . org effort. The lead especially
should make sure that questions about h i s or her
project are answered and that a friendly a n d sup­
portive environment i s created. Contributions, mail­
l i st discussions, and forum i n terchanges, as well as
i ssues and other adm i nistrative duties should be
handled in an encouragi n g and productive fash i o n .
Loss of proj ect l e a d status may occur not o n l y
due to contribution i n activity (as described for d e ­
velopers) b u t a l s o because o f m i ssing ful fillment o f
responsi b i l ities for t h e project the project l e a d is i n

See http://development.openoffice .org/releaseslOOo_
2_0_timetable.html .
SOURCES

Th is section is e ffectively a Software Con figu­
ration Man agement Plan.

The codebase is maintained i n shared i n forma­
tion repositories using CVS . Only developers a n d
project l eads have write access to these repositories .
Everyone has read access via anonymous CVS or the
Web fro nt end.
All source code commi tted to the proj ect's
repositories must be covered by LGPL and S I S S L .
Files i n the rep o s itory m u s t c o n t a i n a header
according to the O p e n O ffice . o rg templ ates ( avail ­
able for code a n d m ake fi l es ) . Con tributors o f
source code l arger than small change s must h ave
signed the j o i n t copyright assignment form before
their contribut i o n can be c o m m i tted to the
reposi tory.
S traightforward patches and feature implemen­
tations can be committed without prior notice or
discussion. Doubtful changes and l arge -scale over­
hauls need to be discussed before committing them
i nto the reposi tory. Any change that affects the
semantics of an existi ng API function, configuration
data, or file formats or other m ajor areas must receive
approva l . A project lead may i n formally approve
changes within his or her project. There are three
di ffere n t types of changes :

207

208

CHAPTER 8

PRINCIPLES OF SOF1WARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLANNING

Informational notice about an API

Info

change; no developer action necessary.
Recommended

Use the new API as soon as possible.
The old API is obsolete and might go

into practice by a hypothetical student project
team , using the Encounter case study as an
example.

away in the near future. New code
should always use the new API.
Required

Not complying with the new API will
break the build or cause runtime failure.
Developer action is mandatory.

This gives a great deal of discretion to project
leads. A more formal process, involving more
people , may be im practical for an open source
project like this .
Proposals for interproject changes of type "rec­
ommended" or "required" must be published with the
suggested change date to the interface discussion
mailing list. After one week of review, a change
announcement must be published to the interface
announce mailing list. During this announcement
period, depending projects have to prepare their
projects for the changes so that the following build
will not break. They are responsible for reflecting the
change in their project, not the requester. Within the
two weeks of discussion/announcement, project leads
may raise a flag, and project leads maj ority has to
decide about cancellation of the change request.
These documents proVide a flavor for the man­
agement of the OpenOffice project. They are
not intended to be complete .
8.7 CASE STUDY: STUDENT TEAM
GUIDANCE

This section describes a hypothetical account of inter­
actions among students as they prepare and conduct a
project planning meeting, and guides students in
producing a Software Project Management Plan.
8.7.1 Team Guidance: Steps to a Project
Management Plan for Encounter

Note to the Student:
This section explains how the principles
explained in this part of the book are translated

Before beginning the Software Project Man­
agement Plan ( S PM P ) , the team met at least once to
discuss the project in general terms, and Ed Braun
was selected as team leader. The configuration man­
agement plan (SCMP) and quality plan (SQAP) were
written .
PREPARING FOR THE PROJECT PLANNING
MEETING

Well before the meeting, Ed looked through the
IEEE SPMP headings (refer to Figure 8. 24) for the
major issues, and drafted material for each of the m . I n
the case o f the Encounter video game, he considered
these to be the project organization (primary and
backup roles, and their responsibilities) ( Section 4 . 3
in Figure 8. 1) , risk management (5. 4 ) , and the sched­
ule ( 5. 2) . Ed also drafted a brief paragraph for
Section 1 . 1 (project summary). He left the staffing
plan blank ( i. e . , who fills what role) because he felt it
best to have members volunteer for roles at the
meeting. He planned for the remaining issues to
be filled in after the meeting. Via e-mail , Ed asked
for a volunteer to perform cost estimation, since this
is a technical task that requires significant lead time,
and is best done by one or at most two people.
Ed wrote up options for objectives and priorit­
ies rather than selecting the top priority, since he did
not want the group to feel railroaded into a decision.
He included "attaining quality goals," "developing
something that the members can use" (a favorite of
hiS ) , and "complete project on schedule" as options
for the top priority. He was pretty sure that the group
would agree to a flat role-based organization as
described in Section 9. 4, so he wrote this into the
straw man document.
Via e-mail , Ed asked team members to think
about the risks that they consider threatening to
the project, and to send write -ups to him 48 hours
before the meeting, in the form of Table 8. 1 in
Section 1 0 . 4 . Karen was concerned about the
group's Java capabil itie s . She communicated with
the rest o f the team about their knowledge of Java,

CASE STUDY: STUDENT TEAM GUIDANCE

and described thi s risk as speci fically as she could.
She also researched companies that provi de o n - s i te
tra i n i n g at short notice. H e r step -by-step risk
retirement plan was i n cluded i n the m ateri al she
sent to Ed. H al Furnass had a concern about super­
imposing i mages in J ava, and he sent his risk
identification and retirement write-up to Ed. The
latter collected these in the straw man SPMP, a n d
l i sted t h e m i n priority.
Ed then drafted the following agenda for the
meeting.
Meeting to be held i n Engineering 397 at 10 : 00
a . m . to 1 1 : 30 a.m. Fri day, September 1
1.

Appoint record keeper and time keeper (5 min­
utes, 10:05)

2. Approve agenda and times for this meeting ( 5
m inutes, 10: 10)
3 . Review SPMP sections supplied by Ed (25 min­
utes, 10: 3 5)
4 . Allocate remaining SPMP section to writers ( 20
m i nutes, 10: 55)
5. Arrange review process (via e-mail and/or meet­
i ng) ( 5 mi nutes, 11 :00)
6. Brainstorm for addi tional risks ( 10 m inutes,
1 1: 10)
7. Review action items ( 5 minutes, 1 1: 15)
8. Miscellaneous business ( 10 m inutes, 11 :25)
Ed e -mailed the agenda and his straw man
SPMP to the team members two days before the
meeting, and asked them to read it over before the
meeting. His version of the SPMP contained all of
the IEEE headings.

THE INITIAL PROJECT PLANNING MEETING

At the meeting, Ed asked Fern to record acti o n
i t e m s a n d m aj or dec i s i o n s , a n d asked A I to watch
the time and re m i n d the team if i t exceeded
p l a n n e d l i m i ts . I t was un derstood that these two
roles would rotate among the members i n future
meeti n gs . Most o f Ed's i deas were accepted. Sev­
eral changes to Ed's proposed schedule were

suggested. H a l pushed very h ard for a buffer
week in which n o tasks are assi gned. Karen
p o i nted out that n o work shoul d be assigned
duri ng the week be fore the m i dterm . There was
also a discussi o n o f us i n g a s i m p l e waterfa l l to
avo i d the complications o f revi s i t i n g document,
but th i s was dismissed as not reflecting the real
worl d. Fern pushed for i n crem e n tal deve l o p m e n t
because she w a n t e d to begi n codi ng as soon as
poss i b l e , but there was little support for this
because the team did n o t even have arc h itecture
yet. Members felt that "qual i ty" was an area they
needed the most practice with.
After considerable debate about building an
exciting computer game, the team decided that
"the attainment of the speci fied quali ty parameters"
would be i ts top priority. It was recogni zed that a
quality game worth playing was out of the question
i n the time available, and that the actual capabilities
would be have to be minimal. When the team arrived
at role allocation, Karen volunteered immediately for
the "design leader" role. There were three volunteers
for "implementation leader" and none for QA leader.
Ed compromised by suggesti ng that two of the three
people split roles as QA and impleme ntation leaders,
switching halfway through the semester. The other
roles were filled, and Ed rem inded them of their
responsibilities, and of their additional backup roles,
as stated i n the SPMP.
The discuss i o n o f how to allocate the writi ng
o f the S P M P went over its p l a n n e d li m i t , but the
discussion was productive a n d to the p o i n t , so Ed
did not try to curtai l it. I t was deci ded that o n ly
two team mem bers besides Ed would wri te t h e
S P M P , a n d the r e s t w o u l d review th e i r writ i n g ,
since i t would be too di fficul t i n a short time t o
m a n age more people writ i n g. After 1 0 m i nutes,
the team foun d i tse l f discuss i n g very small sec­
t i o n s , a n d Ed cut off discus s i o n , pro m i s i n g to
resolve the sm all di fferences o ffli n e , and e -m a i l
t h e two members c o ncerned a deta i l e d a l location
o f the secti o n s . The team dec i ded that the writers
would comp lete their sections by Fri day at 6:00
p . m . , a n d Ed would create the docume n t from
these and c i rculate the results to the team by
Saturday at 3 : 00 p . m . Everyone would provi de
comments to Ed by Sun day at 3 :00 p . m . , a n d Ed
would take a l l of these comments into account to

209

210

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLANNING

final ize the document. A tentative mee ting was set
fo r Monday a t 11:00 a . m . in Arts 283 in case it was
necessary, and E d was tasked with inform ing the
team by Sunday nigh t at 8:00 p .m . whether the
meeting woul d be re q uired o r not .
Fern reviewed the decisions made , who was to
write what sections, and when the due dates were.
The meeting adjourned.
COMPLETING THE PROJECT MANAGEMENT
PLAN

In writing the document details, the team realized that
various issues had not been discussed at the meeting,
including the details of "monitoring and controlling"
(Section 5. 3 in Figure 8. 24). Hal's initial write-up of
this section spoke of many meetings at which the
project was to be reviewed, but most of the other
members fel t that many of the meetings were un­
necessary. After reading several proposals, Ed tried to
resolve the e-mail discussion by proposing that project
monitoring be accomplished at weekly meetings, sup­
plemented by meeting at the inception of each phase
(which he would try to fold into weekly meetings as
well). The team agreed. To allow for the possibility
that more project meetings would be needed, a second

weekly time was selected which members would keep
available, but would be used only if required.
The case study conta ins material concerning
liaison activities. These are shown for illustra­
tion purposes, and would not normally be the
responsi bility of student teams. Some teams
might want to designate a member as l iaison to
the i nstructor. Th is is usually best performed
by the team leader. If the project has a true
customer (i . e . , the project is not just an inven­
tion of the team itself), then a liaison to the
customer would be required: the requi rements
leader would normally have this task. If the
project were an agile one , a customer repre ­
sentative would be part of the team .

8.7.2 Team Guidance-Software Project
Management Plan

Student teams should create a Software Project
Management Plan (SPMP) for their project using
IEEE Std 1 058-1998 as a template, the Team Guid­
ance in the previous section, and the Encounter
S PMP in Section 8. 4 as guidance.

8.8 SUMMARY

Project costs are estimated as early as project initiation, wel l before the requirements are defined. The earlier
the estimate is made the greater the margin of error, and we therefore use ranges as a way to calculate
estimates. For example, during conceptualization, cost estimates can have a fourfold estimation error; after
design, a twofold error.
Project estimates are done by first finding something objective to measure, such as l ines of code (LOC).
Since this is done before any code is written, the application is compared to the LOC of similar or related
software produced in the same company, and the LOC of the new application is extrapolated from that.
Another way to produce LOC is to compute function points, which objectively measure the intended
functionality of the new software . The function point calculation produces a single number that is then
converted to l ines of code using a standard conversion. Once LOC are calculated, the CO COMO model can
be used to compute an effort estimate .
Agile projects can be estimated by the use of story points, which are assigned based on a comparison of
new stories to existing stories. For example, an average story is given a score of 5, and all new stories are
compared to that story.
Once an estimate is made, a detailed schedule is constructed that l ists all the tasks , their duration, their
dependence on each other, and the resources assigned.

EXERCISES

A project plan is created that includes all project information i ncluding project organization, roles and
responsibil i ties, project estimate, schedule, and risks. It also includes references to such documents as
configuration management, and verification and val idation plans.

8.9 EXERCISES

1 . Describe in at least one paragraph at least two consequences of failing to develop a written project plan.
2. Suppose you are tasked with computing the number of function points for a small applicatio n .
Assume the application implements the following functional ity measures, all of which c a n be
characteri zed as havi ng medium complexity:
- number of external inputs : 4
- number of external outputs : 5
- number of external queries: 2
- number of internal logical files: 2
- number of external files: 3
- Suppose also that the application has the fol lowing general characteristics :
- requirements backup: 0
- data communications : 0
- distributed processing:
- performance critical : 2
- heavily util ized: 1
- online entry: 4
- multiple screens: 3
- master fields : 3
- file inquiries: 2
- internal processing: 3
- reuse : 2
- conversion and installation:
- multiple install ations: 0
- change and ease of use: 5
Compute the number of function points for this application.

3 . Cost estimation is important, but can you cite a circumstance under which it is probably not
worthwhile perform ing at all? Explain your answer.
4 . Cive one major advantage and one major disadvantage to the use of function points i n estimation.
5. list a part of the SPMP that your student team is probably unable to supply at this stage of the project.
This refers to a part you will have to return to after more work has been performed on the project.
6. Explain why project planning is considered one of the phases in the software l i fe cycle and also an
umbrella activity that stretches across several phases .

211

212

CHAPTER 8

PRINCIPLES OF SOFTWARE PROJECT MANAGEMENT II: ESTIMATION, SCHEDULING, AND PLANNING

TEAM EXERCISE
SPMP

Develop a Software Project Management Plan for your project. Use (or tailor, or improve upo n ) the
IEEE standard, as shown in the case study below. Include at least two iterations in the schedule . Obtain
a rough estimate of the size of the product.
Before you begi n , estimate the number o f defects per page the team thinks it will discover duri ng
its fi nal review. Keep track o f, and report the time spent by indivi dual members and by total team
effort in the following stages: research, document preparation, review (includi ng inspections) . Show
the actual defect density (average number of defects per page ) . Assess your team's effectiveness in
each stage i n a scale of 0 to 1 0. Summarize in a narrative, using the numerical results, and state how
the team's progress could have been improved. The team is encouraged to use additional metrics i f
they contribute t o effectiveness i n this a n d future efforts .
Criteria :
1 . Degree of clarity of the p l a n a n d addendum . (A
especially o f risk retirement)
2. Degree of realism of the plan and addendum . (A
ambitious nor too modest))

=

very clear writing; all specifics incl uded,
sets realistic goals and procedures (neither too

3 . Extent to which the plan and addendum i nclude all relevant speci fics . (A
relevant speci fics included)
4. Extent to which the plan and addendum exclude irrelevant material . (A
irrelevant)

=

=

> 95% o f knowable,

< 5% if details supplied

5. Useful ness o f your self-assessment.

BIBLIOGRAPHY
Boehm, Barry, "Software Engineering Economics," Prentice Hall, 1981.
2. Albrecht, A. J.. "Measuring Application Development Productivity," Proceedings of the Joint SHARE/GUIDE/IBM Application Development

Symposium, October 1979, pp. 83-92.
3. International Function Point Users Group (December 1999). httpJ/www.ifpug.org [accessed November 15, 2009]
4.

"Function Point Languages Table Version 3.0," Quantitative Software Management, April 2005. httpJ/www.qsm.com/?q=resources/
function-point-Ianguages-table/index.html [accessed November 15, 2009]

5. Jones, Capers, "Applied Software Measurement, Global Analysis of Productivity and Quality," 3rd edition, McGraw-Hili Osborne Media, 2008.

6. Dorfman, M., and R. A. Thayer (eds and contributors), "Software Engineering," [EEE Computer Society, November 1999.
7. Eclipse. httpilwww.eclipse.org/eclipse/index.php [accessed December 10, 2009].
8. Eclipse. httpJ/www.eclipse.org/platform/index.php.
9. Eclipse. httpJlwww.eclipse.org/eclipse/deveiopmentieclipse_project_plan_3_0.html.

Quality and Metrics in project
Management

Planning

� Maintenance
Testing

The Software
Development
Lifecycle

What are examples of project metrics?

\

How do you use metrics to improve
projects?

Requirements
analysis

Implementation

�DeSign

How do you cultivate a quality
mind-set in a project?

/

What is a software verification and
validation plan?
What is a good example of a planned
verification and validation?

Figure 9.1 The context and learning goals for this chapter

Software quality does not come about by acci dent. Achieving it starts by cultivating a quality culture
with i n the proj ect team . It also requires careful planning and mon itoring, with project managers continuously
asking questions such as the following throughout the l i fe of a project .
•

Is the proj ect on schedule? Is it l ate?

•

Are too many defects being discovered? Too few?

214

CHAPTER 9

QUALITY AND METRICS IN PROJECT MANAGEMENT

•

Are defects being fixed too slowly?

•

Is testing progressi ng at the desired pace?

Agile teams become adept at answering these questions for team - l evel work. Continual interaction with
the customer, short, mutually defined sprints, and continual testing mean that questions like these are bei ng
continually asked and answered in the context of the team and customer representative. On the other hand,
the scope of the project can exceed a si ngle group, in which case vari ous non -agile techni ques are applied as
wel l .
A s introduced i n Chapter 2, the answers t o these a n d similar questions are provided b y metrics, which
are data collected and analyzed throughout a project.
Examples of project metrics are defects per KLOC (thousand lines of code), lines coded per man-month (MM),
and test case execution rate. Each provides an objective measure of a project and its processes. Metrics are an
important tactical tool of the project manager. They allow the manager to continuously assess project qual ity
and schedule, identify problem areas, and gain insights into the project that allow him or her to make
proactive decisions to head off problems. As an example, if during the testing of the software an unusually
high number of defects are discovered i n a particular software m odule, action can be taken to proactively
remedy the root cause, such as conducti ng a code i nspection, redesigning the module, or executing unit tests.
Without metrics, it is di fficult to know h ow a project is executing and the qual ity level of the software. Metrics
help not only current proj ects but also future ones. This is because future projects base metric targets on past
ones.
Targets must be established to effectively uti lize the metrics collected. For example, i f 50 test cases are
executed duri ng the first week of system testing, is the testing team maki ng good progress or poor progress?
The answer depends on the test case execution goal defined during project planning. I f the plan called for
executing 100 test cases, then the answer is poor progress; if the plan was 20 test cases, then the answer is
good progress. This also assumes a standard for "test case." The goals are establ ished by analyzing metrics
collected duri ng prior projects and using them as basel i nes.

9.1 CULTIVATING AND PLANNING INTERNAL QUALITY

Internal qual ity refers to the quality activities undertaken by the development team itself. This calls for
cultivating a quality culture among the development team, an attribute of good leadership. The essential goal
here is a sense of shared responsibility and pride among the team members. Fundamental gains in a qual ity
attitude accrue when the project leader continuously ensures that the work is very orderly, and that the team's
efforts are focused on appropriate pri orities.
We plan for the management of a project and i ts i nternal quality assurance procedures at the same time.
Internal quality procedures, standards, and habits are active throughout the project management plan, the
requirements, the design, and the code.
External provision for quali ty is specified i n a separate set of documents: the qual ity assurance plan, the
veri fication and validation plan, and the test documentation. The relationship of i nternal and external qual ity
activities is illustrated in Figure 9.2.
The internal management of quali ty is as much a mind-set as a document set. It begins with a
configuration management plan that ensures consistent and safe documentation . (For example, if we were to
implement the wrong version of the design document, the code would not match the requirements for the
implementation , and thus would hardly be a high - quali ty product!)
Most project management plans designate team members with specific responsibi l i ties. Table 9 . 1 shows
an example of responsibility designation in which each member also has a backup responsibility. Each activity

PROJECT METRICS

Internal quality activities

Perform
requirements
analysis

Include tests for each requirement

Include tests for each unit
Perform unit tests
Perform inspections

External quality activities

Perform system testing

Figure 9.2 Managing quality-internal and external activities to promote quality in projects

leader promotes an attitude of qual ity for his activity. The backup members can act as pair inspectors for each
leader.
9.2 PROJECT METRICS

Project metrics are those that apply across the board or h ave broad impl icati ons during a project rather than
being very focused. The metrics process starts by i dentifying which metrics to collect, setting target goals for
each , and regularly moni toring and reviewing them throughout the project. This is described in detail in the
sections that follow.

Table 9.1 Example of responsibilities for documentation, with backup
Name

primary Responsibility

Backup Responsibility

Alice Jarman

Team leader

Configuration management

Bruce Stern

Configuration management

Security

Bob Crowder

Internal quality

Team leader

Sarah Fournier

Security

Internal quality

Hans Lightman

Requirements

Release

Vladimir Norsk

Design

Requirements

John Green

Implementation

Design

Susan Klein

Release

Implementation

215

216

CHAPTER 9

QUALITY AND METRICS IN PROJECT MANAGEMENT

9.2 .1 Identification

During proj ect planni ng, the metrics to be collected are identified. Some are applicable to all phases (e.g. ,
defects) while others only apply to a speci fic phase (e.g. , test case execution ) . Wh ile there are many metrics to
chose from, some of the most useful are as follows [ 1]:
•

Project mi lestones

•

Testing progress

•

Defect detection and defect injection per phase

•

Defect resolution
We discuss each of these next.

Project Milestones

A plan is created early in a proj ect that contains a detailed schedule, includi ng mi lestones, which are concrete
objectives that must be achieved at specific times. A project manager monitors the progress of a project
against these milestones to determine whether it is on schedule . Project scheduling and the establishment of
milestones were covered i n Chapter 10. The obvious metric here is the number of days between a milestone's
schedule and the day on which it was actually reached.
Testing Progress

A test plan is usually constructed before any formal testi ng commences. It includes information regardi ng the
types of test cases to run and detailed i n formation regarding each test case . The most common metrics to
collect during formal testing are the rate of test case execution and the number of passed test cases. With these two
metrics, project managers can determine whether testi ng is proceeding on schedule.
Defect Injection and Detection

Defect metrics are probably the most common type of metric collected. Defects occur duri ng each
development phase , but such defects may have been incurred (or "inj ected") during a previous phase .
The defect detection rate is measured for a given detection phase and a given i njection phase . For example, a
"defect detection rate of 0 . 2 per 100 requirements defects at the implementation phase" means that one defect
in the requirements is detected, on average, when implementing a set of 500 requirements. Figure 9.3 shows
an exam ple project in which these data have been collected. It also shows the longevity of defects: phase of
injection vs . phase of detection. For the sake of simpl icity, we have omitted the test and post-del ivery phases,
which would complete the picture .
Let's focus on the detailed requirements part of Figure 9 . 3. It shows that two defects per 100 were
detected duri ng the requirements phase ( assessed by means of inspections) . This compares favorably with the
organization's norm of 5 per 100 . Looking across the "detailed requirements" row, we observe that our process
detected fewer than the normal rate of requirements defects during subsequent phases. Thi s seems to tel l us
that our project, and possibly the process we are using, is com paratively effective when it comes to producing
quality requirements. However, it is also possible that our detection process is worse than usual ! Th is bears
investigation. To complete the table, we would include similar defect data collected duri ng testing, and
during a specific time (e.g., three months) after product delivery.
The results for design defects i n Figure 9 . 3 are as follows. We detected more than the usual number of
design defects duri ng inspecti ons at the time they were inj ected, but recogn ized fewer design defects at later

PROJECT METRICS

Defects detected:
Per 100 requiremen ts/per .
in the design/per KLoC, etc .
This project/nann
Phase in which
defect was
injected

Detailed
requirements

Phase in which defect was detected
Detailed
requirements

Design

Implementation

2/5

0.5/1.5

0.1/0.3

Deployment

Design

113

312

Implementation

212

513

Deployment

3/12

Figure 9.3 Examples of defect count-injection phase VS. detection phase

stages . Si nce it is more expensive to detect and repair a defect l ater in the process, this i n dicates that our
project seems to be superior to the organization norms. Figure 9 . 3 also contains i n formation about defects
detected after deployment to customers, which is surely the most important metric in the end.
Defect Resolution

Tracki ng defect detection tel l s us the rate at which we are finding defects, giving an indication of the quali ty
of the evolving product . Equally important is the metric defect resolution, which measures the rate at which
defects are being resolved. Defect detection and defect closure are complimentary. For example, even i f
defect detection i s meeting o r beati ng the plan, i f the defect resolution rate is below plan, the backlog of open
defects i ncreases and the quali ty and schedule of the project suffer.
9 .2 . 2 Planning

Once the set of metrics to be collected is identified, a plan is established with targets for each metric. The best way
to derive targets is to use the metrics collected during previous projects as a baseline, adjusted as necessary.
Without projections based on previous projects, it is very difficult for project managers to know whether a project
is meeting expectations. An example of a plan used to track defect detection and defect resolution is shown in Figure 9.4.
Figure 9.4 tracks the number of defects submitted and resolved weekly versus the plan. Each week the
actual number of defects discovered is filled in and compared with the plan . In thi s example, note that the
number of open defects for the first three weeks is greater than what had been anticipated. At the end of week
3/ 1 0-3/16, 1 03 defects are open vs. a plan of 66. Armed with this knowledge, the project manager can take
appropriate corrective actio n . Similar plans are created for each of the other metrics collected.
9 .2 .3 Monitor and Review

Duri n g the l i fe of a proj ect it is a good i dea for key members o f the project team to review the metrics
o n a regular b a s i s , usua l l y weekly . One good way to do th i s i s for the project man ager to create a packet
o f i n formation conta i n i n g metrics charts as shown i n F i gure 9 . 4 . Th i s helps present the i n formation i n a
concise format for easier review. However, j ust presen t i n g these overview ch arts m ay n o t be en ough.
For exam p l e , in addi t i o n to the defect p l a n shown in F i gure 9 . 4 , add i t i o n a l i n formation such as deta i l e d

217

218

CHAPTER 9

QUALITY AND METRICS IN PROJECT MANAGEMENT

Actual

Figure 9.4 Example of tracking defect resolution-recognizing problems with defects remaining open

defect reports may be i n c l uded to be tter u n derstand the source of th e proble m s bei n g di scovered. I f th i s
i s do ne f o r e a c h of the metri cs i n c l uded i n the report, t h e amount o f i n form a t i o n can become
overwhelm i n g . Although i t i s sti l l a good i dea to i nc l ude i t a l l , it is common to create a sum mary,
sometimes i n the form of a project dashboard. A das hboard presents a c o n c i s e , graphical summ ary o f
essential i n formation regardi ng th e general h e a l th o f a proj e c t . This i s anal ogous to an auto m o b i le
dashboard, which conta i n s gauges such as fuel leve l , odometer, and engi n e te m perature, to quickly
ascerta i n the general status a n d h e a l th of a c ar. F i gure 9. 5 shows an exa m p l e dashboard from th e

Earned Value
(BCWP)

i
2.75

i
5.5

i
8.25

III 2.75i

i
5.5

i
8.25

$ Milhons

Actual Cost
(ACWP)
$ Millions

0

I --:
ir-

Figure 9.5 Example of a project management dashboard
Source: Software Program Managers Network (SPMN), http://www.spm n . com. Provided by AMERICAN SYSTEMS with permission.

USING METRICS FOR IMPROVEMENT

Software Program Manager's Network [2]. The type of i n form a t i o n contained in a dashboard i n cludes the
fol l ow i n g :
•

Milestone completion

•

Requirements changes

•

Configuration changes

•

Staff turnover

•

Staff overtime hours

•

Quality metrics such as defects per phase

•

Risk analysis

With this concise project information, stakeholders can focus their attention only on those metrics not
conforming to plan . For example, it can be noted from Figure 9.5 that the plan calls for two requirements changes
per month, but in the period covered by the dashboard three requirements changed. Stakeholders can now look
at more detailed information regarding the requirements that changed to determine whether they pose a risk to
the project. Other metrics that are meeting or beating the plan need not be examined i n great detail .
9 .3 USING METRICS FOR IMPROVEMENT

Companies strive to improve thei r project executi on in two ways :
•

By improvement withi n a project, from one phase to the next

•

By improvement across projects, from one project to the next

But how do you i dentify what needs improvement? There is a wise saying that "you can't improve what
you don't measure ." Metrics provide the measures that allow project managers to identify how a project is
performing, the areas requiri ng the most improvement, and the objective data needed to measure the rate of
improvement. The next two sections describe how this is accomplished within and across projects .
9 .3.1 Improvement within a project

The first step to improve quality from one development phase to the next is to collect metrics duri ng each
phase . Table 9 . 2 shows a summary chart that can be used, which i ncludes provisions for comparison with past
projects. The data can be used in two ways :
1. To assess the health of each phase's arti facts.
For example, if the defect rate for our requirements is 0.7 per page and the company's average is 0 . 3
p e r page, then w e have identified an issue with o u r requirements. (The concept of a defect i n a page of
documentation has to be carefully defined to ensure consistency . )
2 . T o assess our management of this project.
For example, if our defect rates are l ower than the company's norms for most phases so far, then we
are probably managing our project well . A final judgment on thi s would depend on the defect rate of the
delivered project compared with the norm.

219

220

CHAPTER 9

QUALITY ANO METRICS IN PROJECT MANAGEMENT

Table 9.2 Oata on activities relating to document creation and error rates
Research

Meeting

DraftingTO

1
TimeL

120

30

210

130

140

30

660

% Time

18%

5%

32%

15%

21%

10%

N/A

2
(Average % time)L

-14%

-7%

-15%

-30%

-16%

-18%

N/A

QuantityL3

N/A

N/A

22

N/A

N/A

N/A

28

Productivity

1
T SO l

TSOl

1

6.3

TSOl

1

1
TSOl

N/A

2
2.51

(Average productivity)

TS O

l1

T SO l

1

1
TSOl

1
TSOl

TSO

l1

TSOl

1

18 .31

Self-assessed qualityL4

3

5

2

1

5

9

N/A

oefect rateL5

N/A

N/A

1.513

N/A

TSOl4

N/A

N/A

(Average defect rate)

N/A

N/A

(1.1)

N/A

TSO

N/A

N/A

Process improvement
note #

(1)

(2)

(3)

ReviewingT1 FinalizingT2 Post-mortem

TOTAL

2

(4)

The information in Table 9.2 is examined, column by colum n , i dentifying data that are di fferent from
par. For each datum below par, we devise concrete acti ons that the team will perform di fferently for the
next phase . For each datum above par, we look for beneficial techniques that may be applied i n future
phases . "Sel f-assessments" are comparative, subjective scores that the team assigns various activities. One
way to collect them for four activities, let us say, i s to ask each team member to a l locate 5 x 4 20 poi nts
among the four activities, each score being between 0 and 10. The averages i n dicate how well the team as a
whole th i nks it performed on each activity . Th is is a subjective measure that can be profitably compared
with other metrics.
Here is an explanation of the superscripts in Table 9.2.
=

Left-Hand Column
LI
L2

l3

IA

Spent by entire team, in person-hours
The average amount of time spent on these activities in one of the following (select one): entire
organization on all projects, entire organization on sim ilar projects (the ideal ) , this department on all
projects , this department on similar projects, thi s team o n prior phases.
For documents: total number of pages produced i n the case of documents . For code: x 1 000 l i nes of
non-commented code . A li n e of non-commented code is defined as <A precise defin ition is provided
here, perhaps showing examples of how to count lines for common constructs such as for loops. >
This is a judgment that the team makes about the quality of the activity's product. It i s subjective but
can be very useful . A good way to obtain self-criticism is to force the average of these numbers to be
five on a scale of 0 to 1 O.

USING METRICS FOR IMPROVEMENT

L5

This is a key metric . It is necessary to define the following:
•

What severity of defects will be counted (usually any besides trivial)

•

When i n the process these are counted (so as to be consistent for the sake of comparison)

Top Row
TO

TI
T2

Spent by team members preparing the artifact to the best of their ability; before submitting artifact to
the rest of the team for review
I ncludes i nspections
After review; responding to comments from the rest of the team

Interior of Table
II
12

Measuring productivity for these activities is a more advanced concept and is covered later.
Pages per hour

=

( total pages)*60/(total time in mi nutes)

13

Found during the "finalizing" stage

14

This metric is determined by the end of the project-or even during maintenance-when defects are
detected that were injected during this phase .

The following notes correspond to the last row in Table 9 . 2 and are examples of spec i fic process
i mprovement actions.
1. Our sel f-assessed quality measure on research was 3. The team spent a percentage of time on this activity
that is close to the norm , so the remedy is not to spend more time on research . I f there were known
reasons why research was on the poor side (e.g., a new procedure or very unfamiliar type of application)
then the data here may not be a cause for alarm. Otherwise, the team would discuss how to improve the
research process in the future.
2. The drafting of the arti fact was poor in several respects. It took more than twice as long to draft a page than
is usual; the product of drafting was signi ficantly poorer than the self-assessed average of five; and the
defect rate was signi ficantly higher than the norm . The table by itself provides no explanations or trade ­
offs to deal with this, it merely indicates the problem . The team considers the particular circumstances of
the activity and decides what went wrong and how to fix it. For example, perhaps the main reviewer was
Ed and his mother became ill during the activity. The team may conclude that there was not enough
backup for lead writers, for example.
3. The next problematical activity was reviewing, where the score was lowest: 1. Since the team spent 20
percent of i ts time reviewing compared with the norm of 30 percent, the team's first conclusion is
probably to spend more time reviewing. This has to come at the expense of another activity. The team
would probably take the time from the postmortem activity, where its score was very high , and finalizing,
where it spent more than the usual amount of time .
4. To capture beneficial practices for the future, the team notes areas where it performed wel l . This applies
to the postmortem activity, where it performed highly to its satisfaction and used less time than is usual . The
team must i denti fy the reasons. An example is any unusual activity, such as team members bringing to the
postmortem prepared statements of process improvement.

221

222

CHAPTER 9

QUALITY AND METRICS IN PROJECT MANAGEMENT

Our self-evaluation gives scores of 3 to review and 8 to research out of a forced average of 5 . We spent
15% of our time on review and 25% on research. We will spend 20% on each of these activities for the
next phase .
Our defect rate decl ined steadily except for this phase, when it rose. This seemed to be due to a lack of
common vision prior to dividing the writing. I n past phases, we succeeded i n establishing a common vision
of what we wanted to do before beginning to write our parts. Before beginning to write the next document
we will con firm a shared vision.
The ratio of requirements time to design time was 1 . 2, which is lower than this ratio from past successful
projects i n the company. Our design sel f-evaluation was 6, more than average. On our next project, we
plan to spend 10% more time on requirements analysis at the expense of design time.
Figure 9.6 Using project metrics to improve software development processes

Teams set aside time at the end of each phase to assess the conclusions drawn from metrics, and to write down
how it will improve its process during the next phase. Figure 9.6 shows examples of improvement conclusions.
9 .3 .2 Improvement across projects

Companies strive to i mprove their performance from project to project. No matter how efficient they are, the
best organizations know they can always improve . They i dentify areas for improvement and specify actions
that will lead to the desired improvements in those areas on subsequent proj ects .
Steps that c a n b e taken t o achieve these i mprovements are a s follows:
1. Identify several areas for improvement that are important to the company. Examples include quality,
schedule predictability, and efficiency.
2. I denti fy and collect metrics that measure perform ance in each of these areas. These metrics are used as
basel i nes for setting goals in future projects .
3. As part of project planning for a future project, establish goals for i mprovement in each of the identified
areas, using metrics from prior projects as a basel ine.
4 . Identi fy speci fic actions to implement that will support achievement of the goals.
As an example, Figure 9.7 l ists four areas that have been identified for improvement: schedule, predictability,
efficiency, and time-to-market. A metric is identified to accurately measure project performance in each area. Note
that there may be several appropriate metrics to use in each area, but for simplicity we are only identifyi ng
one. An improvement goal is identi fied for each category, and specific actions are defined to be impleme nted
in the next project i n order to reach the targeted improvement goal.
Figure 9. 8 contains a generic set of actions to be implemented in order to reach the first quality
improvement goal l isted in Figure 9 . 7: reducing defectslKLOC by 10 percent. Note that in this example we are
only focusing on the defectslKLOC as a measure of quality; in practice there are others we would focus on as well .
The first of the improvement steps is t o identify those parts of the software that contained t h e most
defects during the prior release . The areas are then targeted for additional design and code reviews to
understand why they contained a high number of defects, and a plan is devised to refactor those areas duri ng
the subsequent project to improve their quality. Provisions are made i n the planning of the subsequent project
to i ncorporate these actions.

SOFTWARE VERIFICATION AND VALIDATION PLAN

Improvement
Goal

Category

Metric

Description

Qual i ty

Defects/KLOC

New defects found duri ng
formal QA testi ng, per
churned KLOC

10%

Predictability

% schedule accuracy
improvement

% improvement across releases

5%

Efficiency

MM/KLOC

Pre-QA development effort
per churned KLOC

10%

Time to Market

Calendar time/KLOC

Pre -QA calendar time per
churned KLOC

15 %

Figure 9.7 Improving projects across the organization-€xamples of improvement goals

9 .4 SOFTWARE VERIFICATION AND VALIDATION PLAN

Recall that verification responds mainly to the question "Are we correctly building those artifacts i n the present
phase that were speci fied i n the previous phases?" Validation responds to the question "00 the arti facts just
completed in the present phase satisfy their speci fications from previous phases?"
IEEE 1 0 1 2-2004 Software Veri fication and Validation Plan, whose headings are reproduced i n Figure
9.9, provides a framework for expressing the manner in which V&V is to be carried out. Thi s speci fication i s
written during i nitial project planning, and compl iments the Software Quality Assurance P l a n covered i n
Chapter 6 a n d the case study i n Chapter 8.
The annexes to IEEE V&V Standard 1 0 1 2- 1 998 are as follows:
Annex
A. Mapping of ISO/IEC 12207 V&V requirements to I EEE Std 1 0 1 2 V&V activities and tasks
B. A software integrity level scheme
C. Definition of i n dependent veri fication and vali dation (IV&V)

Improvement Category: Quality
Actions:

1 . Identify components of software that contained most defects.
2. Plan to conduct design and code reviews i n these areas.
3. Plan to refactor several of these areas during subsequent project.
Figure 9.8 Example improvement plan

223

224

CHAPTER 9

QUALITY AND METRICS IN PROJECT MANAGEMENT

1. Purpose
2. Referenced documents
3 . Definitions

5.4

Operation V&V

5.5

Maintenance V&V

6. V&Vreporting requirements
6.1

Reporti ng

Organization*

6.2

Adm inistrative

4.2

Master schedule

6.3

Documentation

4.3

Software integrity level scheme

4.4

Resource summary

7.1

Anomaly reporting and resolution

4.5

Responsibilities

7.2

Task iteration policy

4.6

Tools, techniques, and methodologies

7.3

Deviation policy

7.4

Standards, practices, and conventions

4. VV
&
overview
4.1

5. V&Vprocesses
5.1

Management of V&V

5.2

Acquisition V&V

5.3

Development V&V

7. V&Vadministrative requirements

8. V&Vdocumentation requirements
*Subheadings are typical examples ( IEEE)

Figure 9.9 IEEE 1012-2004 Software Verification and Validation Plan-table of contents
Source: IEEE SId 101 2-2004.

C 1 Technical i n dependence
C2 Managerial i n dependence
C3 Financial independence
C4 Forms of independence
C4 . 1 Classical I V&V
C4 . 2 Modified I V&V
C4 . 3 Internal IV&V
C4. 4 Embedded V&V
D. V&V of reusable software
E. V& V metrics
E.l Metrics for evaluating software development processes and products

E . 2 Metrics for evaluating V&V tasks and for improving the quality and coverage of V&V tasks
F. Example of V&V organizational relationship to other project responsibilities
G. Optional V&V task descriptions
H.
I.

Other references
Defin itions from existing standards ( normative)

Copyright © IEEE 200 3
A n ideal procedure is for an outside group t o perform V&V. This i s called Independent Verification and

Validation (lV&V).

CASE STU DY: SOFTWARE VERIFICATIO N AND VALIDATION PLAN FOR ENCOU NTER

The next section in the chapter gives an example of a S VVP case study.
9 . 5 CASE STUDY: SOFTWARE VERIFICATION AND VALIDATION PLAN FOR ENCOUNTER
4 . 3 Resou rce S u m m a ry

Note to the Student:
This section shows an example of Software
Verification and Validation Plan for the Encoun­
ter video game project, organized in accordance
with IEEE 1 0 \ 2-2004. In the interests of space,
various sections have been omitted.

1 . Purpose

Thi s document provides the veri fication and valida­
tion procedures that will be followed for the devel­
opment of the Encounter video game.

This section describes the person-hours re­
quired for V& V or the amount required to
fund an external organization for IV&V.

Veri fication will be performed internally. Valida­
tion will be performed partly by project engineers. The
costs of this internal work are built into the SPMP.
Validation will also be performed by one external QA
engineer. This person will consume four person-months.
4.4 Software Integrity Level Scheme

2. Referenced Documents

The integrity level of software expresses how
critical it is. Software components that potentially
threaten safety have the highest integrity level.
The IEEE standard describes four levels: high,
major, moderate, and low. A tool supporting
informal research, for example, would probably
be required to have only a low integrity level.

Software Project Management Plan
Software Configuration Management Plan

3. Defin itions

None
4. V&V Overview
4 . 1 O rga n ization

This section describes how the V&V effort will
be organized ( i n terms of roles) and how it
relates to the development phases.
The veri fication and validatio n of Encounter is
coordinated with each phase of every i teration.

The Encounter appl ication is required to have
moderate integrity.
4 . 5 Responsi b i l ities

The development team members will
•

•

•

Perform verificatio n activities throughout the proj ­
ect, i ncluding inspections with i n all phases
Perform and document all unit testing using J U n i t
Val idate requirements documents with the market­
ing manager

4.2 Master Sched u l e

The QA engineer will
Because of the organization of V&V as described i n
Section 4 . 1, the V& V schedule follows directly t o the
project schedule as defined in the SPMP.

•

Verify that the team has followed its documented
procedures, i ncluding those described in this document

225

226

CHAPTER 9

Q UALITY AND M ETRICS IN PROJECT MANAG E MENT

•

Perform all post-unit testi ng

•

•

Report the results to the team and management

•

•

Maintain this document

4.5 Tools, tec h n i q ues, a n d method ologies

To be supplied

5 . Life Cycle V&V

The V& V effort on Encounter (internal and external) will
be supervised by the manager of Quality Assurance.

•

•

•

Each of the following sections describes how
V& V of every process will be con ducted.
When th is is to be performed in ternally, it
can be included in the corresponding docu­
ment ( S PMP, SRS, etc ) , and th is V& V docu­
ment can refer to those .

5 . 2 Acq u i sition V&V

"Acquisition" is the process by which an orga ­
nization obtains software . Using th ird-party
software relieves the development organiza­
tion of having to reinvent the wheel. However,
it places a burden on the organization to
certify the quality of such software, Many
disasters have been experienced because this
step was avoided .

Are all critical requirements that were i dentified
duri ng the concept phase specified?
Is the SRS organized in a way that facilitates
traceability?
Does the SRS account for all required interfaces
with other systems?
Does any requirement imply a Signi ficant risk to
project completion? If so, should that requirement
be mitigated?

The Encounter SRS will be val idated by expos ­
ing it to the marketing department and to a sample of
3 0 game pl ayers .
5. 3. 3 Design V&V
The Encounter SOD will be veri fied by answeri ng
the following questio n:
•

Are all requirements accommodated by the design?

5. 3. 4 Implementation V& V
The im plementation of Encounter will be veri fied by
answeri ng the following questions:
•

•

Each vendor-supplied tool used for the develop­
ment of Encounter will be validated by the QA engineer.

Does any concept imply a signi ficant risk to project
completion? If so, should that concept be mitigated?

5. 3. 2 Requirements V& V
The Encounter SRS will be veri fied by answeri ng the
followi ng questions:
•

5 . 1 Ma nagement of V&V

Are all critical marketing factors identi fied?

Are all requirements fully veri fied?
Is the code organized i n a way that facilitates
traceability back to design and requirements?

•

Is all code documented accordi ng to standards?

•

Is all code thoroughly documen ted?

5 . 3 Deve lopment V&V

5.3. 1 Concept V& V
Conceptual work on the Encounter game concept
will be verified by answeri ng the following questions:

5. 3. 2 Test V&V
The test documentation of Encounter will be veri fied
by answering the following veri fication questions,
and the validation questions that follow.

CASE STU DY: SOFTWARE VERI F I CATION AND VALIDATION PLAN FOR ENCOU NTER

•

•

•

•

Are all critical requirements intended to be fully
tested at every level of detail ( e . g . , human safety)?
Is the test
requirements?

philosophy

adequate

for

the

Are the test plans complete as speci fied i n the test
philosophy?
Are the test cases complete as specified in the test
philosophy?

For the test plans and procedures, the reader is
referred to the Software Test Documentation. These
plans and procedures are designed to accommodate
the following val idation questions.
•

•

•

Do the defect count, defect rate, outstandi ng
defec ts , and defect severity attest to an acceptable
product?
If not, what success rate will be required to attain
acceptabi l i ty?
Do they account for all of the metrics speci fied in
the SQAP?

6 . 1 Reporti ng

The QA person attached to the project reports the
status of V&V weekly to the manager of QA and
copies the team leader.
6.2 Ad m i n istrative

Th is describes who is responsible for the V&V
reporti ng effort.

The project leader is responsible for ensuri ng
that all V&V reporting is performed.
6.3 Documentation

A single report that includes all versions of the results of
the tasks described in this document is maintained.
7. V&V Administrative Req uirements

This describes who is responsible for the V& V
effort.

5 . 8 Operation V&V

Th is part veri fies that the application is appro ­
priately supported after deployment t o users .

To be supplied
5.9 M a i ntenance V&V

The mai ntenance plan shall be verified against com ­
pany maintenance criteria , speci fied in the com­
pany's maintenance requirements and procedures,
document 8 90.23 .

7 . 1 Anoma ly Reporti ng a n d Reso l ution

The QA engineer attached to the Encoun ter project
will maintain the current state and the history of each
defect found. The QA engineer will maintain all
metrics identi fied in the SQAP on a Web site and
will e-mail a list of all anomalies ( i ncludi ng defects)
that he or she deems to have excessive repair time­
l i nes. This includes defects with no repair duration
estimates and those that have exceeded their planned
completion date. The Bugzilla facility will be used.
7 . 2 Task Iteration pol icy

6 . Reporting Req uirements

This includes who reports the results of the
V& V effort and to whom do they provide
these reports .

Th is section explains the circumstances under
which V& V tasks are repeated because of
results obtained or because of changes in
the project.

227

228

CHAPTER 9

QUALITY AND M ETRICS IN PROJECT MANAG EMENT

V&V tasks will be repeated at the discretion of
the QA represen tative, but these will include the
following criteria.
•

•

•

An i nspection whose defects count is more than 20
percent greater than the norm .
A test whose defects count is more than 20 percent
greater than the norm .
An entire phase if the previous phase changes by
more than 20 percent.

7.3 Deviation pol i cy

Describes the procedures required to deviate
from th is pla n .

Any proposal to deviate from this plan requires
the approval of the QA manager and the project
manager.
7 . 4 Sta nda rds, practices, and Conventions

These are set down for all company projects at http ://
8. V&V Documentation Req uirements

Section 6 described what should be reported .
Section 8 covers t h e means for noting i n
writi ng t h e results of V&V. It speci fies the
form that all V& V documentat ion must take .
For exam ple, it could be organized as an
appendix to th is document.

9.6 SUMMARY

Quality in proj ect management begins by cultivating a quali ty culture with i n the proj ect team . Members
develop a shared responsibil i ty and pride . Many projects designate team members with spec i fic responsibil i ­
ties , a n d each activity leader promotes an attitude of qual ity for his activity.
Ensuring quali ty requires careful planning and monitoring throughout. Metrics are collected and
analyzed, providing means of concretely assessing how well a project i s executi ng. There are many useful
metrics; some of the most basic are project milestone planned vs. fulfilled, defect counts, and test execution.
After identi fying the metrics to be collected, a plan is created with goals for each . Targets are created by
analyzing previous projects and using metrics from those as a baseline. [f targets aren't established, project
managers will not know whether a project is on track.
Duri ng the course of a project, the team meets regularly to review the metrics. [ n addition to the detailed
data, a graphical summary often known as a project dashboard is created. The dashboard presents the key metrics
in a clear, concise manner, allowing the team to quickly ascertain how each is aspect of the project is
performing against the plan .
Successful companies strive to improve the overall quali ty of their performance , both during the course
of a project and between successive projects. Metrics are analyzed in each case to i dentify areas requiring the
most improvement. SpeCific actions are then enacted, and metrics objectively measure whether the
improvements are providi ng the antici pated results.
The Software Veri fication and Val idati on Plan is an important part of project quality. It speci fies a plan
for generating artifacts based on speci fications of previous phases (verification), and for building software that
meets customer's wants and needs (validation). IEEE 10 12-2004 provides a framework for this document.

9.7 EXERCISES

1. [n your own words, define "project metrics" and explain how they are used i n managing a project.
2. The defect plan in Figure 9. 3 shows the number of open defects falling behind plan starti ng i n week
1. Assum ing you are the project manager, at what point would you start taking corrective action?

B I B LIOGRAPHY

Would it be after the first week, or would you wait a number of weeks to see whether the situation
i mproves? Are there any other metrics you m ight collect to help you deci de? Write a p aragraph to
explain your answer.
3. Describe i n your own words how a proj ect manager could utilize a project dashboard i n managing
a project.
4. What metrics related to software testing might you i nclude i n a weekly project metrics report to
provide insight i nto the status of the testing process? Explain your choices .
5 . For each of the remaining categories in Figure 9. 7 ( predictability, effiCiency, time to market) ,
create an action plan to reach the stated improvement goals. Use Figure 9.8 as a template for your
plans. Include a min imum of three actions to take for each category.

TEAM EXERCISE
V&V Plan

Produce the relevant parts of a V& V plan using IEEE standard 10 12- 1986. Measure and report on
the metrics described i n Team Exercise Tl i n Chapter 6.
T 1.

Criteria:
Practicality: How well does the plan ensure that the work will be adequately verified and val idated?
(A
completely practicable in the environment of the proj ect)
=

2 Speci fics: H ow specific is the plan i n terms of suitably naming places and participants? (A
o u t exactly h o w V&V w i l l be performed i n the environment of the development)

=

spell s

3 Team participant percepti o n : To what degree are participants l ikely to perceive your plan as a help
to them? (A
written in a way that respects the time and efforts of engineers)
=

SQAP

Produce a realistic software quality assurance plan for your project. Measure the time spent on this
effort by individual members and by the complete team. Provide the corresponding metric data and
self-assessment for this assignment, as described in Team Exercise i n Chapter 8.

T2.

Criteria : as for Team Exercise in Chapter 8.

BIBLIOGRAPHY
1 . Laird, Li nda M., and M. Carol Brennan, "Software Measurement and Estimati o n , A Practical Approach," Wiley-Interscience, 2006,
pp. 18 1 - 192.
2. Software Program Managers Network (SPMN). httpJlwww.spmn.com.

229

princi ples of Requirements
Analysis

Why the term requirements "analysis?"

Planning
What is the value of written requirements?

� Maintenance
Testing

The Software
Development
Lifecycle

Where do requirements come from?

\

What is the difference between high-level
and detailed requirements?

Requirements
analysis

Implementation

� DeSign

/

What is the difference between functional
and nonfunctional requirements?
How do you document requirements?
What does traceability mean?
How do agile teams handle requirements?
How can student teams gather
requirements?

Figure 1 0.1 The context and learning goals for this chapter

Before a software system is designed and im pleme nted, one needs to understand what that system is
i ntended to do. This i ntended functionali ty is referred to as the requirements, and the process of gai ning the
necessary understanding of this is called requirements analysis. An application for video store management, for
example, could mean different things to different people, each a somewhat di fferi ng set of requirements. One
interpretation could be an application that tracks employee time and outputs paychecks; another, an e-m ai l

SOURCES OF REQUIREM ENTS

•

•

The process of understanding what's wanted and needed in an appl icatio n. For example, you may know
that you want a colonial house i n New England, but you may not know that you will probably need a
basement for it.
We express requireme nts in writing to complete our understanding and to create a contract between
developer and customer.

Figure 1 0.2 The meaning of requirements analysis

application that processes customer ren tal requests; a third, an appl ication that records rented videos and
computes charges; and so o n . As in most busi ness endeavors, the reliable and professional way to specify what
is agreed upon is to express it in writing. Therefore the output of requirements analysis is a software
requirements speci fication (SRS ) . These points are summarized in Figure 1 0 . 2.
A requirement speci fies what the customer wants. This normally does not include anything about how the
application is designed or programmed. Specifying a requirement is l ike tell ing a contractor that you want a
12 foot by 15 foot room added to your house. You generally do not specify how you want the contractor to
build the addition-that is a design and construction issue .
1 0 .1 THE VALUE OF REQUIREMENTS ANALYSIS

A defective requirement ( i . e . , one not repaired before the requirements document is finalized) turns out to be
very expensive. It is an estimated 20 to 100 times more expensive to repair if allowed to slip through the
development process compared with repairi ng it soon after it is incurred. In financial terms, if the cost of
finding and repairing a defect at requirements time is $ 1 , then the cost of finding and fixing that same defect at
the end of the development process is $20 to $ 1 00. The damage that results from the customer's poor
experi ence with the appl ication is a factor addi tional to the expense i nvolved.
Given the tremendous benefit of detecti ng and repairing defects at requi rements time, why are so many
proj ects damaged by poor or nonexistent requirements analysis? A pri ncipal reason is that customers usually
do not know at the begi nning of a project all that they want or need. Instead, they learn to understand what
they themselves want only while the project progresses. The Encounter case study is an example of this
uncertainty; it has a purpose, but one whose details are still in formation. This book emphasizes iterative
development and the close alignment between the requirements, design , and i mplementatio n . Agil e methods
are a prime example. Engineers using a wel l -organized iterative process gather requirements, design for those
requirements, and implement for them in coordi nated iterations.
1 0 .2 SOURCES OF REQUIREMENTS

We usually think of customers as the source of requirements since applications are built for them . In practice,
matters are rarely simple here because the people paying for an appl ication, the people who will be using the
application, and the people designated to work out the requirements may be di fferent. I t is wisest to consider
the wishes and needs of a spectrum of people. All of the people with an interest i n an application's outcome are
known as its stakeholders. To simplify matters in this chapter, however, we will usually use the term "customer."
There are two main requirements analysis challenges. First, as already mentioned, customers rarely
know exactly what they want when a project begi ns. The complexity of modern applications makes such
completeness all but impossible. Second, customers rarely know all that they need, either. Sometimes, they are
not equipped to know it. To return to the house addition analogy, i t may take time for a homeowner to realize
that for the addition he wants, he will desire windows on all walls. He may have to be educated to understand
that he needs to support the addition with piers rather than with a regular foundatio n .

23 1

232

CHAPTER 10

PRINCI PLES OF REQUIREMENTS ANALYSIS

t

Decision support system for military tactics

•

Unconstrained
Encounter video game
•
•

Type of
appli cation
•
•
Highly

•

•
Corporate payroll system

Factory control system

Enhancement to corporate payroll system

Flight control system for airliner

Missile guidance system

constrained

Relatively
low

Approximate % of requirements
gathered from people

Relatively
high

Figure 1 0.3 Source of requ i rements-people and other sou rces
Source: Adapted from ··Software Requirements-SEI Curriculum Module SEI-CM - 1 9 - 1 . 2 . ,. by John W. Brackett, copyright © 2009 carnegie Mellon U n iversity with
special permission from its Software Engineering Institute.

Requirements arise from multiple sources: mostly from stakeholders, but also from documents and even
from books. As shown i n Figure 1 0 . 3 , Brackett [ 1 ] has plotted several types of appl ications to illustrate the
degree to which requirements are gathered from people, as opposed to other sources such as written material.
Figure 1 0. 3 classifies applications by the degree to which they are constrained by nature-restrictions on the
application that cannot be altered. For example, an application that describes the trajectory of a ball is constrai ned
by gravity; chemical reactions are constrained by physical laws. Generally speaking, the less constrained a
problem, the more its requirements must be obtained from people. At one constraint extreme, for example, is our
video game case study. Being the product of pure imagination, it rel ies on people for most of its requirements.

1 0 . 3 HIGH-LEVEL VS. DETAILED REQUIREMENTS

A typical requirements document is large . A detailed description of every requirement, although necessary in
some form or other, can be m i n d- numbing to read. Imagine, for example, a document that spells out every
detail of every property of Microsoft Word™ . It would certainly not read l ike a novel! For thi s reason, we
often divide requirements documents into two parts: high-level and detailed.
The first part of a requirements document is an overview, which is relatively readable and is well suited to
customers . I ts contents are referred to as the high-level or business requirements . Anyone wanting to get an i dea of
what the application is all about reads the high-level requirements. I n many organizations, the marketing
department prepares this material based on market research and conversations with customers. Although not
formally necessary, the high-level requirements often i nclude a description of why the application is being
built, and they state the benefits to both the developing organization and the customer [2] . I n some
organizations the high - l evel requirements form a separate document such as a "market requiremen ts"
document. In this book we will include the high-level requirements in the SRS . As an example, the video
store application high-level requirements might contain sentences like the following:

NONFUNCTIONAL REQUIREMENTS

The Video Store application shall enable clerks to check DVDs in and out.
The following shows a sketch of the main user interface: . . .
The second part of a complete requirements document consists of the complete particulars . They are
especially useful for developers, who need to know precisely what they have to build. These are the detailed
requirements. Although detailed requirements are used frequen tly by developers, they should be understan dable
to the customer, and should not contain developer jargon where possible. Here are some examples from the
video store applicatio n .
The daily late charge on a D V D shall b e computed at hal f t h e regular two- day rental rate, up to
the value of the DVD listed in the "Intergalactic Video Catalog." When the amount owed reaches
this value, the total l ate charge is computed as this amount plus $5.
When the "comm it" button is pressed on CUI 3 7, the CUI shall disappear and CUI 15 shall
appear with a superimposed green border ( RCB 6, 3 2 , 8) and the name and address fields filled
with the data for the customer.
=

One challenge of writing the high - l evel and detai led requirements is to ensure that they remain
consistent over time. This is facilitated by keeping the high - l evel requirements at a high enough level-for
example, "Clerks can enter customer particulars." Th is kind of statement tends not to change very much . On
the other hand, the details are provided i n full in the detailed requirements and are much more l iable to
evolve . A correspondi ng example is, "Clerks can enter the customer's first name of 1 to 1 0 alphabetical
characters i n the text field shown in figure 3 4, a second name of 1 to 15 alphabetical characters . . . .
"

10.4 TYPES OF REQUIREMENTS

Requirements are commonly classified as either functional or nonfunctional. This classi fication applies to both
high- level and detailed requirements. Each type is described in the sections that follow.
10.4.1 Fu nctional Requi rements

Functional requirements, also known as behavioral requirements, spec i fy services that the application must provide
( e . g. , ''The application shall compute the value of the user's stock portfolio."). An application allows entities
interacting with i t (typically users) to accomplish tasks. Such an entity is frequently a person, but it can also be
a mach i ne or even another program . A functional requirement speci fies something speCi fic that the application
allows such an entity to accomplish . I n our video store appl ication, for example, the following are functional
requirements.
The appl ication allows clerks to check out DVDs.
The application allows clerks to display the customer's account status.

10.5 NONFUNCTIONAL REQUIREMENTS

Any requirement that does not specify functional ity provided by the application is nonfunctional. For example,
a requirement such as "the application shall display a customer's account status in less than two seconds" is not
functional, because it does not specify a specific service. I nstead, it qualifies a service or services (speCi fies

233

234

CHAPTER 10

PRINCIPLES OF REQUIREMENTS ANALYSIS

something about them). Nonfunctional requirements need to be specific, quantifiable, and testable. Consider
a nonfunctional requirement that reads:
The system shall retrieve user i n formation quickly.
This requirement is vague (e.g. , what does retrieve mean?), not quantifiable (e.g. , how fast is quickly?), and
therefore not able to be tested. An improved version of the requirement would be as follows .
Once the OK button is pressed on the "Retrieve Account Information" screen, the user's account
information shall be displayed in less than 3 seconds .
This requirement is specific (because it identifies a specific button o n a specific screen), quantifiable
(because of the specific response time), and testable. The documentation should make it clear exactly what
"the OK button" refers to.
Major nonfunctional categories are: qualities (e.g . , reli abil ity, availability, maintainabil ity, etc . ), constraints
(on the appl ication or its development), external interfaces (hardware, software, communication) and error
conditions. These are summarized in Figure 10.4 and elaborated upon in succeeding sections.
10. 5.1 Qual ity Attributes

Reliability requirements specify "the abili ty of the software to behave consistently in a user-acceptable manner
when subjected to an environment in which it was intended to be used." [ 3]. I n other words, it i s the extent to
which defects will be detected by users during normal operatio n . This kind of requirement recogn izes that
applications are unlikely to be perfect, but limits the extent of imperfection in quanti fied terms. The fol lowing
is an example, and assumes that a definition of "level one faults" has been provided.
The Airport Radar Application (ARA) shall experience no more than two level -one faults per
month.

•

Quality attributes
•

Reliability and availability (observed faults , average uptime)

•

Performance (speed, throughput, storage)

•

Security (malicious and nonmalicious compromise of data or functionality)

•

Maintainability (cost to maintain)

•

Portability (move to a di fferent operati ng environment)

•

Constraints on the application or its development

•

External interfaces that the application "talks to"
•

Hardware

•

Other software

•

Communication with external agents

•

User interfaces

•

Error handling

Figure 10.4 Nonfunctional requirement categories

NONFUNCTIONAL REQUIREMENTS

Availability, closely related to reliability, quantifies the degree to which the application is to be available
to its users . The following is an example .
ARA shall be available at level one on either the primary or the backup computer 1 00% of the
time .
ARA shall be unavailable on one of these computers at level one or two for no more than 2% of
the time in any 30-day period.
Often, high - availability requirements are speci fied in terms of "the nines." For example, five - n i nes, or
99. 999% availability, means that a system can only have a yearly downtime of 5 . 256 minutes . This type of
requirement might be documented as follows.
The system shall support "five - n i nes" availabil ity.

Performance requirements speci fy timing constraints that the appl ication must observe . These i nclude
elapsed time for computations (speed ) , through put, and storage ( e . g . , RAM usage, secondary storage usage ,
etc). The following is an example.
The Stress Analyzer shall produce a stress report of type five in less than a minute of elapsed time.
Performance requirements are a cri tical part of real-time appl ications, where actions must complete with i n
specified t i m e limits. Examples i nclude collision avoidance software, flight control appl ications, and antilock
brake controls. The following is an example.
The computation of brake fluid pressure shall complete with i n one millisecond.

Security requirements concern malicious intent toward a system. This makes security di fferent from other
requirements, which speci fy application behavior when used by well-intentioned people. One can specify
requirements that contribute towards security. These call for concrete measures, such as login procedures,
password lengths, and so on, that contribute to making the product more secure. On the other hand, implicit
security requirements are far more di fficult to deal with . Implicitly, no one wants an application that is vul nerable
to attack, so the requirement exists in the abstract. However, the nature of many future attacks is not predictable ,
a n d so there is no way t o specify a requirement for their defense except in general terms that are of little value .
Maintainability requirements speci fy how easy or di fficult it is to modi fy the software, as a result of fixing a
defect or implementing an enhancement. For exam ple, the easier it is to understan d the software, the easier it
is to maintai n . Maintainability can be measured by the time it takes to repair defects . The following is an
example of a maintainability requirement.
The average time for a maintenance engineer to repair a severity - 2 defect shall be no greater than
8 person-hours .

Portability requirements identify those parts of the software that may need to run in different operating
environments, as well as how easy or difflcul t it is for those parts to be ported. The following is an example.
The graphics subsystem shall be designed so it can run i n both the Wi ndows and Linux operating
systems.

235

236

CHAPTER 10

•

Platform
•

•

PRINCIPLES OF REQUIREMENTS ANALYSIS

Example: The application must execute on any I GH Li nux computer.

Development Media
•

•

Example: The appl ication must be implemented in Java.
Example: Rational Rose must be used for the design .

Figure 10.5 Examples of constraints

The maximum amount of effort to port the graphics subsystem from Windows to Linux shall not
exceed 2 person-month s .
10.5.2 Constra i nts

A constraint on an application is a requirement that l i m i ts the available options for developing it. Recall that
requirements are generally "what" statements. "How" is usually left to the design . Constraints can be thought
of as exceptions to this . Figure 10.5 shows some examples .
Design or implementation constraints describe l imits or conditions on how the application is to be
designed or implemented. These (nonfunctional) requirements are not intended to replace the design
process-they merely speci fy conditions imposed upon the project by the customer, the environment, or
other circumstances. They i nclude accuracy, as i n the following exampl e .
The damage computations of the Automobile Impact Facility (AEF) s h a l l be accurate t o with i n
o n e centimeter.

Tool and language constraints are often imposed. These i nclude historical practices with i n the organization,
compatibil ity, and programmer experience . Here is an example.
The AEF is to be implemented in Java and developed on the Eclipse platform .

Design constraints are imposed on the project because stakeholders require the m . They can be speci fied in
the requirements document or the design document. Such constraints restrict the design freedom of
developers . The followi ng requirement is an example.
The AEF shall uti l i ze the U niversal Crunch Form to display impact results .
The constraint of having to follow certain standards is often determi ned by company or customer
pol icies. Here are examples .
Documentation for AEF shall con form to Federal Gui deline 1234.56.
The AEF code is to be documented using company code documentation guidel i nes version 5.2.
Projects are frequently constrained by the hardware platforms they must use . The following is an
example.
AEF shall run on Aj ax 999 mode l 1 2345 computers with at least 128 megabytes of RAM and 1 2
Gigabytes o f disk space.

NONFUNCTIONAL REQUIREMENTS

•

Hardware
•

•

Software
•

•

•

Example: 'The appl ication must i n terface with a model 1234 bar code reader."

Example: 'The application shall use the company's payroll system to retrieve salary i n formation . "
Example: 'The application shall use version 1. 1 of the Apache server."

Communications
•

•

Example: 'The application shall communicate with human resources appl ications via the company
i n tranet."
Example: "The format used to transmit "article expected" messages to cooperating shipping companies
shall use XML standard 183.34 published at http ://. . . . "

Figure 10.6 Types of external interface requirement for an application, with examples

10.5.3 External I nterface Req u i rements

Applications are frequently required to i nterface with other systems. The Internet is a common example of
such an external system . Interface requirements describe the format with which the application commu­
nicates with its environment. Figure 10.6 shows the common types, with examples of each .
10.5.4 User I nterface Req u i rements: P ri n c i ples

User i nterface design is sometimes i ncluded with the "design" phase of software development, but it can more
properly be considered part of the requirements phase. Thi s book takes the l atter perspective , i ncluding only
software design i n the "design" phase, and not graphic design.
Customers commonly conceive of an application by visualizing its graphical user i nterface (GUI) , so a good
way to help them describe the application is to develop draft GUls. Our goal here is to provide some of the
essentials of user i nterface design. This is quite different from the technical design of the application , which is covered
in Part IV. The latter i ncludes considerations of what GUI classes to select and how to rel ate them to other classes.
In developing user interfaces for applications, it is ideal to work with a professional designer, who is
trained in user behavior, color usage, and techn iques of layout design. For many projects, however, especially
smaller ones, software engineers must design user i n terfaces with no such assistance. Thus, we list some
guide l i nes for user i nterface design .
Gali tz [4J provides eleven steps for developing user i nterfaces . We have adapted these, as shown
i n Figure 10.7. Each of these steps is appl icable to the high-level requirements process a nd/or the detailed
requirements processes. Steps 1 and 2 are described in Chapter 1 1. Steps 3- 1 1 are explored in Chapter 1 2.
10.5.5 ErrO r-Handl i ng Req u i rements

Requirements analysis deals with two kinds of errors. The first are those that actors make (entities i nteracti ng
with the appl ication such as a user or other system); the second consists of errors that developers make. Error­
handli ng requirements speci fy how the appl ication responds to different types of errors . Figure 10.8 l ists some
of the ways of deali ng with errors.
Regarding the first kind of error, error-handling requirements explain how the applicatio n must respond
to anomalies in its environment. For example, what should the application do if it receives a message from

237

238

CHAPTER 10

PRINCIPLES OF REQUIREMENTS ANALYSIS

Step 1: Know your user
Step 2: U n derstand the business function in question
Step 3 : Apply principles of good screen design
Step 4: Select the appropriate kind o f windows
Step 5: Develop system menus
Step 6 : Select the appropriate device -based control s
Step 7 : Choose the appropriate screen-based controls
Step 8 : Organize and lay out windows
Step 9: Choose appropriate colors
Step 10: Create meaningful icons
Step 11: Provide e ffective message, feedback, and gUidance

( H2 )
( H)
(H, D 3 )
(H, D )
( H, D )
(H)
(H)
( H, D )
(D)
( H, D)
(D )

Figure 10.7 Steps for constructing user interfaces
Source: Adapted from Galitz, W., "The Essential Guide to User Interface Design: An Introduction to GUI Principles and Techniques," John Wiley & sons, 1996.

•

Ignore

•

Warn user

•

Allow unlimited retries

•

Log and proceed anyway

•

Substitute default values

•

Shut down

Figure 10.8 Options for error-handling requirements

another application that is not in an agreed-upon format? It is preferable to specify this in the requirements
document rather than leave the course of action to programmers alone.
The second kind of error refers to actions that the application should take i f it finds itself having
committed an error-that is, because o f a defect in its construction. Thi s kind of error requirement is applied
very selectively, because our aim is to produce defect-free applications i n the first place rather than cover our
mistakes with a large set of error-handling requirements. [n particular, when a function is called with i mproper
parameters, we program a continuation o f the application only if such an erroneous continuation is preferable
to the actual cessation of the application. As an example, suppose that we have to spec i fy the requirements for
a device that automatically applies doses of intravenous drugs . Users are entitled to assume that the
application is thoroughly specified, designed, impleme nted, and inspected, so that the drug composition and
dosage com putations are correct. Nevertheless, i t would be wise i n a case l ike this to specify an i n dependent
check of the composition and dosage of the drugs before adm i nistering them, and to spec i fy error handling
accordingly. Error-processing requirements i n this case may consist o f a complete stop of the application, or a
temporary halt and a notificatio n to the operator of the device i n dicatin g the problem.
10.6 DOCUMENTING REQUIREMENTS

The output of requirements analysis is what the [EEE calls the software requirements specification (SRS ) .
There are several ways i n which a n S RS c a n b e organized. A s w e will see i n Chapter t t a n d beyond, the
Eclipse open source project is organize d arou n d three "subprojects ." With i n each, requirements are organized

AGILE METHODS AND REQUIREMENTS

1 . Introduction
1 . 1 . Purpose
1 . 2 . Scope
1 . 3 . Definitions, acronyms, and abbrevi ations
1 . 4 . References
1 . 5 . Overview
2 . Overall description
2 . 1 . Product perspective
2 . 1 . 1 . System interfaces
2 . 1 . 2 . User interfaces
2 .1 . 3 . Hardware i n terfaces
2 . 1 . 4 . Software interfaces
2 . 1 . 5 . Communications interfaces

2 . 1 . 6 . Memory constraints
2 . 1 .7. Operations
2. 1 . 8 . Site adaptation requirements
2 . 2 . Product functions
2 . 3 . User characteri stics
2 . 4 . Constraints
2 . 5 . Assumptions and dependencies
2 . 6 . Apportioning of requirements
3 . Specific requirements
(see Figure 9 )
Appendixes

Figure 10.9 IEEE 830-1998 Software Requirement Specifications table of contents, 1 of 2
Source: IEEE Std 830-1998.

aroun d several "themes." The OpenOffice open source project organizes i ts requirements in four main parts: a
word processor, a spreadsheet, a presentation facility, and an illustration too l .
I n this b o o k w e w i l l o ften use-a n d modify-IEEE stan dard 8 3 0 - 1 99 8 [ 6 ] , shown i n Fi gures 1 0 . 9
a n d 1 0 .10. The I E E E stan dard was developed a n d m a i n ta i n e d b y a commi ttee o f very experi enced
so ftware e n gi neers. I t i s very h e l p fu l , but i t requires modi fication a n d tai l ori ng to res p o n d to changes in
tool s , l a n guages, a n d practi ces. The fi rst two secti o n s o f the stan dard, "I n troductio n" a n d "Overa l l
descri ption ," correspond to t h e h i gh - l evel requirements a n d a r e covered i n Chapter 1 1 . S e c t i o n 3 o f the
standard, the "Speci fic requirements," corresponds to the deta i l e d requirements . I t is expanded a n d
a p p l i e d i n Chapter 1 2 .
Next we turn our attention to the essential l i nks of the SRS to the rest of the project.

10.7 TRACEABILITY

Traceability is the ability to readily understand how the parts of separate project arti facts relate to each other.
I n particular, it links i ndividual requirements with other project arti facts . (See, for example, [7] ) . A detailed
requirement is traceable i f there are clear l i nks between it, the design element that accommodates it, the code
that implements it, the inspection that veri fies it, and the test that vali dates it. Figure 1 0. 1 1 shows
relationsh ips between the arti facts, based on a single requirement.
Table 1 0 . 1 is an exam ple of how a change i n a requirement for DVDs i n the video store appl ication
causes changes in the remaining arti facts .
Hyperl i nking is a convenient way to transition easily between arti facts . In particular, the requirements
document can be placed on the Internet or an i ntranet, and dependent arti facts can be connected via
hyperlinks .
10.8 AGILE METHODS AND REQUIREMENTS

Agile processes speci fy requirements analysis by first establishing a shared vision of the applicati o n . This is
done via di scussions among the team members and the customer. After that the requirements are gathered in
relatively small stages. The vision stage is intended to form a concept of the ultimate product that is simple

239

240

CHAPTER 10

PRINCIPLES OF REQUIREMENTS ANALYSIS

3.1

External interfaces

3.2

Functional requirements

-organized by feature, object, user class, etc .
3.3

Performance requirements

3.4

Logical database requirements

3.5

Design constraints

3.5.1
3.6

3.7

3.8

Standards compliance

Software system attributes

3.6.1

Rel i ability

3.6.2

Availabil ity

3.6.3

Security

3.6.4

Mai ntai nability

3.6.5

Portabi l i ty

Organizing the specific requirements

3.7.1

System mode - or

3.7.2

User class - or

3.7.3

Objects (see right) - or

3.7.4

Feature - or

3.7.5

Stimulus - or

3.7.6

Response - or

3.7.7

Functi onal hierarchy - or

Additional comments

Figure 10.10 IEEE 830-1998 software Requirement Specifications table of contents, 2 of 2-detailed requirements
Source: IEEE Std 830-1998.

and clear enough for all stakeholders to understand and relate to. This vision is kept as concise as possible
without compromising the share d vision itsel f. Examples are as fol lows:
An application that allows video store personnel to manage DVD rentals
A Web-based calendar program for i ndividuals and departments
A system that analyzes i n divi duals' susceptibili ty to disease based on their genetic i n formation
The vision stage is followed by multiple iterations that are typically 2-4 weeks in duration. Such an
iterative style has the advantage of keeping misunderstandings to a m i n i mum and allowing all concerned to
grapple with the requirements being considered. The requirements for each cycle are gathered by means of
user stories-narratives, always told from the user's perspective, of how the application is to be used. This
process is summarized i n Figure 1 0.12 and described in more detail i n the sections that follow.

UPDATING THE PROJECT TO REFLECT REQUIREMENTS ANALYSIS

accommodates

verifies

verifies

verifies

verifies

Figure 10. 1 1 Traceability among project artifacts
Table 10.1 How a change in a requirement for DVDs in a video store application causes changes in other artifacts

Requirement

The title of a DVD shall consist of between 1
and 15 English characters.

Design element

Code

Revised version

Original version

Artifact

The title of a DVD shall consist of between 1
and 15 characters, available in English,
French, and Russian.

I

DVD
I
I
I title: String I

Title
title: String

I

{
String title . ..

Title title

.

}

.

.

.

.

..

}
class Title

Test report

I

class DVD

class DVD

{

Inspection report

�

DVD

.

Inspection # 672:

Inspection # 935:

4 defects; follow-up inspection #684.

1 defect; no follow-up inspection required.

Test # 8920 ...

Test # 15084 ...

10. 9 UPDATING THE PROJECT TO REFLECT REQUIREMENTS ANALYSIS

A project's document set is a livi ng entity-it has to be "fed and cared for" at regular intervals throughout the
l i fe of the project. Typically, when a phase is executed, several documents must be updated.
For very large projects, the process of analyzing the customer's requirements is formal and organized.
For example, the U . S . Department of Defense (000) often publishes a request for proposals (RFP) to develop

24 1

242

CHAPTER 10

PRINCIPLES OF REQUIREMENTS ANALYSIS

Develop

Each

detailed req uirement
Each cycle:

test

Code

end

detailed req u i rement

Figure 10.12 Agile requirements analysis

an SRS alone. Such an RFP contains a very high level description of the project. The RFP can be thought of as
specifying the high -level requirements. Contractors respond to the RFP, and a winner is chosen who creates
detailed requirements. To ensure that the requirements are satisfactory, numerous meeti ngs are held. These
involve contractor personnel , civil servant specialists and managers, uniformed officers of the Navy or Air
Force, and others . The resulting SRS can be thousands of pages long. The winning contractor may or may not
be chosen to perform the actual design and development of the applicati o n .
O n c e high-level requirements have bee n gathered, t h e SPMP c a n be updated as shown in Figure to. 1 3.
Such updating occurs throughout the l i fe cycle of an applicati o n .
The resulting schedule woul d typically be l ike that shown i n Figure 1 0. 1 4, containing more detail than
the schedule shown when the SPMP was originally drafted (Chapter 8) but sti ll not very detailed. In

Status after

Status after Obtaining

Initial Draft

High-Level Requirements

Milestones

Initial

Risks

Identify initial risks

More milestones; more specific
Retire risks identified previously; identify more risks
now that more is known about the project
Preliminary project schedule

Schedlj/e

Very rough

Personnel

Designate high-level

Designated engineers for detailed requirements

requirements engineers

analysis

Very rough

First estimates based on job content

Cost Estimation

Figure 10.13 Updating project plans after obtaining high-level requirements

SUMMARY

I

I

Task Name

I July

June

5117

5131

SI14

S128

August

7112

7r2S

819

Comple1e release 0.0.1
Comple1e release 0.0.2

I November
I October
I September
I 9/6 I 9120 I 1014 1 10118 1111 11115
+8122:
i
.11113
8123

El Develop release 0.0.1
C-requirements
D-requirements

�

Arch�ecture

� De1.,led design
:f Implement
Integrate
Test

El Develop release 0.0.2

l

l�'�"""�"""""�""�"'"

0e10.0.1 C·requiremenls
0.0.1 tasks TBD

Figure 10.14 Typical schedule after obtaining high-level requirements

particular, we may know that release 0.0.2 should be made on November 1 3, but it may be too early to decide
other parts of the schedule .
Cost estimation can be improved once high - l evel requi rements have been analyzed. The mai n
i mprovement stems from the i ncreased understanding that developers gain concerning the scope a n d nature
of the applicati o n . Function point estimates (described in Chapter 8) can be made more complete, and so can
the estimates derived from them for schedule and labor. Direct bottom-up estimates can be improved as wel l .
Another factor limiting the number of iterations of the requirements is the high degree of coordination
required to keep the project documents and the source code coordinated. This is one reason that highly
iterative development techniques such as agile methods do not really attempt to write detailed requirements
documents .
10.10 SUMMARY

Requirements analysis is the process of understanding what's wanted and needed in an applicati o n . The
output o f requirements analysis is a software requirements speci fication (SRS), which serves as input i n to the
design process . The S RS document used in this book is IEEE standard 830- 1 998.
Requirements are divided i nto high -level and detailed requirements. High-level requirements are also
called business requirements. These describe why the application is being built and state the benefits to both
the developing organization and the customer. Detailed requirements provide complete specifics about the
requirements that developers must know in order to implement the applicati o n .
Project requirements often change a n d evolve throughout the life of a project. When they do, other project
artifacts such as the design and implementation must change accordi ngly. Traceability allows for maintaining
associations between individual requi rements and other project artifacts to facilitate updating them .
Both high - level and detailed requirements are classified as either functional or nonfunctional . Functional
requirements speci fy services that the appl ication must provide to the user. Non functional requirements
speci fy qualities, constrai nts, interfaces, and error handl i ng of the applicati o n .
Agile requirements analysis starts b y defining a concise vision statement about the i ntended applicati o n .
Next, 2-4 week development cycles are executed, with the first step of each defining t h e requirements for that

243

244

CHAPTER 10

PRINCIPLES OF REQUIREMENTS ANALYSIS

i teration. Each requirement is usually based on a user story along with an explicit acceptance test. A user story is
a high-level piece o f required functionality as seen by the anticipated user. Detailed requirements are usually
expressed i n terms of unit tests rather than being written explicitly.
After requi rements analysis is completed (or after each i teration in an iterative process) , the project plan
is updated to reflect the new details known about the appl ication. The more requirements that are known , the
closer the schedule comes to bei ng finalized.

10.11 EXERCISES

1 . Explain why a defective requirement could be 1 00 times more expensive to fix after software is
deployed versus being fixed duri ng requirements analysis .
2. Give an example o f a software application in which the customer is the same a s the e n d user. Give
an example in which they are di fferent. In each case, identify the customer and end user.
3. In your own words, explain the difference between high-level and detailed requirements. Give an
example of a high-level and detailed requirement for a typical word processi n g applicati o n .

4 . I n your own words, describe the di fference between functional and nonfunctional requirements.
5. Explain why the followi ng requirement is not sufficient. How would you amend it?
" The order entry system shall not crash more than 5 times per year. The system shall recover
from each crash as quickly as possible to avoid down time."
6. Brackett makes the point that the more constrained an application, the less reliance we have on
people as the source of requirements. (Refer to his graph in Figure 10. 3 compari ng "approximate
percent of requirements gathered from people" with "type of application.") Can you thi nk of any
applications that do not fall on the graph's diagonal?
7. Agile requirements gathering calls for a customer representative to work continually with the
development team generati ng requirements. Describe a scenario in which this type of arrangement
may produce poor requirements.

8. What are three major advantages and disadvantages o f describing detailed requirements with unit
tests?

BIBLIOGRAPHY
I. Brackett, J. "Software Requirements: SEI Curriculum Module SEI-CM-19-1.2," January 1990. httpJlwww.sei.cmu.eduilibrary/

abstracts/reports/90cmOl9.cfm [accessed November 15,2009]'
2. Wiegers, Karl E., "More About Software Requirements, Microsoft Press, 2006, p 5.
3. Davis, Alan M., "Soflware Requirements: Objects, Functions, and Stales, Prentice Hall, 1993, p. 310.
4. Calitz, W., "The Essential Guide to User Intetface Design: An Introduction to GUT Principles and Techniques," John Wiley & Sons, 1996.
5. Alexander, lan, and Neil Maiden (Editors), "Scenarios, Stories, Use Cases: Through the Systems Development Life-Cycle" (paperback), John
Wiley & Sons, 2004.
6. "IEEE Recommended Practice for Software Requirements SpeCifications," IEEE Std 830-1998, June 1998.
7. Wiegers, Karl E., "Software Requirements," Microsoft Press,2003.

Analyzing High-Level
Requirements

�

Testing

Maintenance
The Software
Development
Lifecycle

Implementation

Planning

What are examples of customer wants?
What does stakeholder vision mean?

\

Requirements
analysis

�DeSign /

How do you i nterview for and document
requirements?
How does one w rite an "overview"
req u i rements section?
How do you write "main functions" and
use cases?
What agile methods are there for dealing
with high-level requirements?
How do you specify user interfaces at a
high level?
How does one frame secu rity
requirements?
How do you use diagrams for high-level
requirements?
What are examples of high-level
requirements in practice?

Figure 1 1.1 The context and learning goals for this chapter

246

CHAPTER 11

ANALYZING HIGH-LEVEL REQUIREMENTS

High - level requirements describe the purpose of an appl ication and its inte n ded functionality. They can
also describe the application's benefits to both the customer and the developing organization . Th is chapter
describes the process whereby we collect, analyze, and spec i fy the requirements at a high level. It is helpful to
express high-level requirements using both text and diagrams, in order to convey a complete understanding
of the i nten ded application . High -level requirements are o f great i n terest to all stakeholders, particularly
customers, who purchase and ultimately use the appl ication based on i ts requirements.

11.1 EXAMPL ES OF CUSTOMER WANTS

Typically, at the time that requirements analysis commences, the customer is sti ll forming concepts of what
he or she wants and needs . This is analogous to the requirements-gathering phase between an architect and a
client. For example, a client may want a house with four bedrooms and a large living room, but nevertheless
relies on the architect to help clari fy what he wants and needs (e . g . , a ranch house with a living room with
seating for ten).
As an exam ple, consider the Encounter case study. The following i s a fragment of customer thinking
obtai ned by a myth ical marketing department.
Encounter is to be a role-playi ng game that s imulates all or part of the player's li fetime. It should
be of i nterest to both male and female game players .
Figures 1 1 .2 and 1 1.3 summarize the high-level requireme nts for the Encounter case study. The complete
description o f Encounter h igh-level requirements i s contai ned in Section 2 of the SRS: Overall Descri ption . The
requirements statements in Figures 1 1 .2 and 1 1 .3 are at a very high level with detail purposely omitted. For
example , the requirement "Each qual ity has a value" does not specify what those values are . Speci fic values are
documented in the detailed requirements of Secti on 3 of the SRS .

•

•

•

•

•

Role- playi ng game that simulates all or part of the l i fetime of the player's character.
Came characters not under the player's control called "foreign" characters .
Came characters have a number of qualities such as strength, speed, patience, etc .
Each quality has a value.
Characters "encounter" each other when i n the same area, and may then "engage" each other.

Figure 1 1.2 High-level requirements for Encounter, 1 of 2

•

•

•

•

The result of the engagement depends on the values of their qualities and on the area in which the
engagement takes place .
Player characters may reallocate their qualities, except while a foreign character is present.
Reallocation takes e ffect after a delay, during which the player may be forced to engage .
Success is measured
o by the "life points" maximum attained by the player - or o by living as long as possible.

Figure 1 1.3 High-level requirements for Encounter, 2 of 2

STAKEHOLDER VISION

At this stage i n requirements analysis, there are usually unresolved issues such as whether there is to be
one or several characters under the control of the player, what should occur when two characters interact, and
whether the game can be played over the I nternet. It is the task of the development team to work with
customers to clarify their wants and needs. A common process is to interview the customer, which is
described in Section 1 1 .3.
Customer needs can be subtler to classify than their wants, since customers are typically less conscious of
them . For example, a customer may want a music application that alJows computer novices to write music but
may need a periodic auto -save function to avoi d losing work. Whether such a feature is a requirement or part of
the design depends on what is agreed between the developer and the customer. I f the customer, h aving
understood auto-saving, wants this feature, then it becomes a requirement. The customer may be content,
however, to leave it to the designer as to how to accommodate the computin g needs of novice users . I n that
case, auto-saving would not be a requirement, but a design element.
11.2 STAKEHOLDER VISION

The people who have some interest in the outcome of the product are called its stakeholders. As an example,
consider the creation of an e -commerce Web site . One set of stakeholders consists of the site's visitors .
Typically, their primary requirement is the ease with which they can fi n d and purchase needed items. The
company's owners are stakeholders, too . Their primary requirement may be profit, short- or long-term . For
this reason, they may want the site to emphasize high-margin items. Marketing, another group of stake­
holders , may requi re the Web site to track visitors. The application's developers are stakeholders , too . For
example they may want to use new development technology to keep up to date .
In the case of packaged (shrink-wrapped) applications such as word processors, spreadsheets, and
development environments, as well as their equivalents (such as downloaded applications) , the development
team pays a great deal of attention to the acceptability of the application by as many users as possible.
Although this can be a di fficult marketi ng problem, it is clear that the users are the most significant
stakeholders . For many large projects, i denti fying the most important stakeho lders is complex. The
"customer" is often the party paying to have the application developed, but even this is not clear-cut.
For example, the Navy may be paying for an application, but the developers' day-to-day customer may be a
civil servan t rather than a naval officer. Then again, are not the taxpayers the "customers," si nce they are
actually paying for the application? The customer of a subcontractor is the prime contractor. The customer
for shrink-wrapped applications is a composite of potential customers established by the marketing
department. When an application is intended for internal company use, such as claims processing within
an insurance company, the customer is an internal organizati o n .
Conflicting stakeholder interests c a n easily result in inconsistent requirements. An exam ple of this
occurs when two di fferent groups within a company, with di fferent motivations, apparently want the "same"
application built. When requirements cannot be reconciled, projects tend to flounder and are frequently
canceled. Even when stakeholders' requirements are consistent, they may be too expensive to satisfy entirely.
Developers-yet another stakeholder community-are subject to professional responsibilities, which can
profoundly affect requirements. Suppose, for example, that developers are asked to build software for a medical
device with a fixed budget, but they come to understand that the required features cannot all be adequately tested
within that budget. Unless the budget is changed, they would need to elimi nate features for professional reasons.
A good deal of stakeholder identification and management involves managi ng the scope of the
requirements to make them buildable within given budgetary and schedule constraints. The good project
leader surmounts these di fficul ties-a process that requires managerial, personal, business, and political skills.
Customers develop a vision-sometimes unconscious or incomplete-of how their appl ication will
operate . This vision is sometimes referred to as the appl ication's model or concept of operations. Di fferent people

247

248

CHAPTER 11

ANALYZING HIGH-LEVEL REQUIREMENTS

may hold di fferi ng concepts of what a software application entails. For example, the possible concept of
operations for "a weather system" could be
•

•

•

a faci l i ty for turning raw weather service i n formation into graphical form
or
a real - time system for forecasting the weather
or
an application for alerting users to weather anomalies

These di ffering concepts of operations lead to very di fferent applications!
The project manager or requirements engineer helps the stakeholders to clari fy their concept of
operations. Si nce customers usually l ack the means wi th which to express such concepts, engineers can
propose appropriate techni ques such as use cases, data flow diagrams, or state transitions, which are described
below. These techniques are also used for design, as shown in Part IV.
11.3 THE INTERVIEW AND DOCUMENTATION PROCESS

Much of the analysis of requirements is a person-to - person activi ty, organi zed to produce an appl ication
sati sfyi ng the customer. Figure 1 1 .4 summarizes the process of preparing for and i n terviewi ng the customer to
elicit their requirements.
Since there are typically several stakeholders who want to provide their input, the first issue is deciding
whom to interview. Recall that requirements coming from di fferent stakeholders may be contradictory. I t is
often effective to interview a small number of primary stakeholders, and then solicit comments from other key
stakeholders. Two interviewers at each session are preferable to one, since a typical i nterviewer tends to miss
poi nts. Bringing a recorder can help, with permission requested in advance. The most significant person to
i nterview is often the most difficult to schedule time with , so perseverance is called for. Interviewi ng the wrong

Before interview:

1 . List and prioritize "customer" interviewees.
most likely to determine project's success .
2 . Schedule interview with fixed start and end times.
at least two from development team shoul d attend.
prepare to record?
•

•

•

At interview:

3. Concentrate on listening.
Don't be passive: probe and encourage .
persist in understanding wants and explori ng needs.
walk through use cases, also data flow? state diagrams?
Take thorough notes .
•

•

4. Schedule follow-up meeting for val idation .
After interview:

5. Draft SRS high- level requirements using a standard.
6. Contact customer for comments.
Figure 1 1.4 One way to handle interviews with the customer

DESCRIBING MAIN FUNCTIONS AND USE CASES

people can result in wasted time and e ffort. The serum agile process in particular i nsists that the customer
community supply just one representative for requirements . Th is puts the onus on the stakeholders to provide
consistent requirements rather than having developers adjudicate among differing customer communities.
Although i t is important to listen carefully to the customer at the interview, one usually cannot obtain
requirements by one -way l istening alone. Typically, the customer formulates some of the requirements as he
goes along, and needs help. Although the vision created is primarily the customer's, the interviewer and the
customer develop a vision jointly to an extent. Customers usually require some prompting to fill out thei r
vision, a l i ttle (but n o t too much ! ) like a witness on the stand. D e n n i s [ 1 ] suggests aski ng three types of
questions: close-ended, open-ended, and probing. Close-ended questions, such as, "How many videos do you
expect to keep in stock?" provide important detailed i n formation about the syste m . Open-ended questions,
such as, "What are the shortcomings of your current video store system?" allow the interviewee to elaborate
on his requirements. Probing questions, such as "Can you give me an example of why the user i nterface is
difficult to usd' are follow-up questions designed to gather more detailed i n formation .
Use cases, described i n Section t 1 . 5 are an effective way to obtain and express requirements for a wide
variety of applications. Some requirements need to be diagrammed, and ways to do this are described in Section
1 1 . 9. To validate the requirements as written out, the i nterviewers follow up via e-mail, holding a subsequent
meeting if necessary. Recall that the detailed requirements have yet to be gathered and require additional meeting
time.
After the meeting, the high - l evel requirements are drafted in a format such as the IEEE standard. The
draft should be provided to the customer community for comments, and successive interviews are conducted
until there is satisfaction with the high -level requirements .
The great challenge w e face is expressing clearly what customers want a n d need. Words alone can be
appropriate, but for many applications, narrative text needs to be supplemented by figures of various kinds.
The fol lowi ng sections describe how to express high- level requirements .
11.4 WRITING AN OV ERV I EW

An overview is i ntended to allow readers to quickly understand the main purpose of the intended applicatio n.
Otherwise, it should be as short as possible and should seldom need alteration when project details change .
The challenge of writing a good overview is usually underestimated, probably because it is often thought that
if one knows what a subject is about then summarizing it should not be difficult.
The following is an example for the video store application; i n this case, a single sentence suffices.
VStore i s i ntended to help video stores manage DVD i nventory and rentals .
It is tempting to add more details to this, but good requirements documents are organized to provide
details in orderly stages, so adding more details here would result i n dupl ication and could reduce readability.
"Manage DVD i nventory and rentals" provides substantive i n formation but is general enough so that changes
i n requirements details are unlikely to force it to change .
11.5 D ESCRIBING MAIN FUNCTIONS AND US E CASES

Following an overview section, high - l evel requirements usually list the major functions such as "enter new
video" and "rent video." Since users typically util i ze applications through a rel atively small number of
common back-and- forth i nteractions, this can be a good way to summarize functionality. An effective way to
document these interactions is through writing use cases, origi nally coined by Jacobson [ 2 ] . Use cases describe
the typical sequence of interactions between users of an application and the application itself, and provide a

249

2 50

CHAPTER 1 1

ANALYZING HIGH-LEVEL REQUIREMENTS

narrative of how the application is used [ 3 ] . They have become a very effective way to express many
functional high-level requirements . As an example, when using a word processor, we usually ( 1 ) retrieve a file,
(2) change and add text, and then ( 3 ) store the result. Functional high - l evel requirements are often naturally
expressed as an interaction between the appl ication and agencies external to it, such as the user.
Agile projects tend to employ the idea of user stories. These are sim ilar to use cases but are broader in
scope and have distinct criteria . User stories are described i n Section 1 1 . 6.
A use case is identified by its name and by the type of user o f the application, called the actor. The main part
of a use case documents a typical interaction between an actor and the appl ication, often called a scenario. A
scenario consists of a numbered list of steps. Each step should be simply described and i nclude who is carrying out
the step. A good way to start writi ng a use case is to l ist the main success scenario, which is the sequence of steps that
lead to a successful outcome. A single use case should not attempt to account for a significant number of branches.
Other scenarios of the use case, such as error conditions, are typically documented as extensions. For example,
Retrieve a File would be a typical use case for a word processor, with the user as actor. The main success scenario
contains the following sequence of seven steps. Note that each step starts with the entity that executes the step. In
the case of an error in opening the selected file, an alternative is documented i n the Extensions section.
Retrieve a File

Main Success Scenario
1 . User clicks File menu
2. System displays options new and open
3. User cl icks open
4 . System displays file window

5. User enters directory and file name
6. User hits open button
7. System retrieves referenced file into word processor window Extensions
7a. System displays error indicati ng file could not be opened
It is possible for a single person to use a system in several different ways, adopting the roles of different actors.
In UML, a use case diagram shows the actors, the use cases, and the relationship between them . A use case diagram
is a useful tool for diagrammatically summarizing the set of actors and use cases without having to show all the
details of the use cases. Figure 1 1 . 5 is an example of a use case diagram, with the names of the use cases shown in the
ovals, and the actors drawn outside the rectangle with lines connecting them to the use cases they interact with .
As further examples of use cases, Figures 1 1 . 6 and 1 1 . 7 contai n examples of use case scenarios for the
Initialize and Engage Foreign Character use cases for the Encounter case study.
The actor in each of these use cases is the player of Encounter. Each use case is a sequence of actions taken
by the player and the Encounter game, as shown for the Initialize use case . The Engage Foreign Character use case is a
typical sequence of actions by Encounter and the player, whenever the player's main character and a foreign
character are in the same area at the same time. The actor in the Set Rules use case is a game designer. The actor
describes the ability of Encounter to support the editing of rules for character interactio n . The Travel to Adjacent
Area use case is explained in the case study accompanying this book. The Set Rules use case is not included in the
case study requi rements.

DESCRIBING MAIN FUNCTIONS AND USE CASES

Engage
foreign
character

Designer

Set rules

Figure 11.5 Use cases for Encounter-a UML use case diagram

Initialize

1 . System displays player's main character in the dressing room.
2. System displays a window for setting his character's qualities .
3 . Player allocates the qualities of his main character.
4. Player chooses an exit from the dressing room .
5 . System moves player's main character i nto the area on t h e other side of t h e exit.
Figure 1 1 .6 Initialize use case

Engage Foreign Character

1 . System displ ays the foreign character in the same area as the player's.
2. System exchanges quality values between the two characters.
3 . System displays the results of the engagement.
4 . System displays player's character i n a random area.
Figure 11.7 Engage Foreign Character use case

The actor need not be a human role-it can be another system that uses the application . For example, i f
the application under development i s a robot control system , then the actor could b e a factory automatio n
system that uses t h e robot control system.
Use cases can handle limited branchi ng, but i f there is more than one level o f branchi ng, the extension
idea, described above, can be tried. Otherwise the use case should probably be decomposed i nto other use
cases . Even a single branch in a use case leads to an awkward description. For example, the following could be
a use case for a personal budgeting applicatio n.
1 . User selects "add checks" or "reconcile account"

2. If "add checks" selected:

2 51

252

CHAPTER 11

ANALYZING HIGH-LEVEL REQUIREMENTS

3 . One action happens
4 . Another action happens
5.

. . . . (one or more steps)

6 . I f "reconcile account" selected:
7. One acti on happens
8. Another action happens
9.

This would be better decomposed into "select options," "add checks ," and "reconcile account" use cases .
Use cases are l ike stories and so they provide excellent i nsight into applications. They can be expressed
at differi ng levels of generality. The U n i fied Software Development Process [4J recommends using detai led
use cases to specify a large fraction of the requirements.
A use case that i s similar to an existing one yields l i ttle additional value . Use cases should be sequential,
or else orthogonal to each other. Two use cases are sequential i f one can fol l ow the other. Orthogonal is not a
precisely defined term , but orthogonal use cases take completely di fferent views or opti o n s . For exam ple,
i n a warehouse application, use cases based on a foreman actor and a financial analyst actor would typically
be orthogonal . I n the Encounter case study, Set Rules i s orthogonal to Engage Foreign Character. Chapter 1 4
shows how use cases are combined to produce new use cases; i t also i ntroduces inh eritance among use
cases .
Jacobson's [ 2 J inspiration for the i dea of use cases was that, despite the huge number of potential
executions, most applications are conceived of in terms of a relatively small number of typical interactions.
He suggests starti ng application design by writing use cases, then using them to drive class selecti o n . Th is
techn ique is demonstrated in Chapter 1 2 . Use cases are also the basis for syste m -level test plans.
Many established documentation standards, i ncluding the I EEE's, predate use cases and they must be
augmented to accommodate them . The Encounter case study describes them i n Section 2.2 "Product Functions"
of the SRS, as this is the section that describes the functional high-level requirements . Although use cases are
often identified with object-oriented methods, they can be used with any development methodology.
11.6 AGILE METHODS FOR HIGH-L EVEL REQUIREMENTS

High- level requirements for agile proj ects are collected and understood i n a manner similar to that for non-agile
methods except that the requirements process operates i n pieces and continues continuously through most of
the l i fe of the project. Non -agile processes require a time when requirements are frozen ( i . e . , beyond which the
customer has no right to change them ) . Agile processes, on the other hand, accept frequent changes in
requirements as a necessity. How can one of these be a vali d approach without the other being i nvalid? The
di fference l ies in the level of trust engendered by very close customer contact. If the customer's trusted
representative works continually as part of the development team, it is unl ikely that he will suddenly ask for
unreasonable requirements. In agile processes, selected high-level requirements are elaborated upon within
each iteration . Each is usually based on a user story or stories, each accompanied by an explicit acceptance test. A
user story is a high - level piece of required functionality as seen by the anticipated user. According to Beck and
West [5J a user story must be discrete, estimable , testable, and prioritized, as described in Figure 1 1 . 8 .
Compared with use cases, user stories are described less b y their form than b y these qual ities. Having to be
estimable is one di fference, and this is illustrated i n the example below. User stories can also be more extensive
than use cases.

AGILE METHODS FOR HIGH-LEVEL REQUIREMENTS

1 . From user's perspective
2 . Discrete
Single functionality, feature, or expectation .
Not necessarily precise.
3. Estimable
Developers can estimate required effort.
4 . Testable
5. Prioritized
By customer, in consultation.
6 . Can be fit in a single cycle .
•

•

•

•

Figure 1 1.8 Required qualities of a user story

Beck and West [5] give an example of how to gather user stories. The customer starts with the fol lowing
story.
0 . 0 Will outperform all other vending machines
This is fine except that i t's not estimable-there is no way to estimate the effort required to carry out this
job. Consequently, the developer probes for more specific stories to obtain estimable ones, a process known
as splitting.
1 . 0 Payment. Will accept all kinds of payments
2 . 0 Freshness . Will sell no stale or outdated merchandise
3 . 0 Restocking. Will automatically request restocking of items selling best in the area
4 . 0 Communication. Will communicate with the customer to prevent transaction errors
This is an improvement, but these are still not estimable, so further splitting is required. Recall that
prioritization is also called for. The agile programmer then requests more specifics concerning the h ighest
priority story. I f this were La Payment, the user might provide the following:
1 . 1 Accept coins
1 . 2 Accept currency
1 . 3 Accept debit card
1 .4 Accept credit card

1 . 5 Accept debit or credit card via Web transaction
1 . 6 Accept foreign coins and currency; at least euros for sales in Europe
1 . 7 Convert currencies
1 . 8 Ensure that payment meets or exceeds the cost of the selected product

1 .9 Make change

2 53

2 54

CHAPTER 1 1

ANALYZING HIGH-LEVEL REQUIREMENTS

0 . 0 Will
outperform all

"-..... Split
�

other vending
machines

1 .0 Payment. Accept
all kinds of payments

�

it

2 . 0 Freshness. Sell
Not estimable

no stale or outdated
merchandise

3 . 0 Restocking.
Automatically request
restocking of items
selling best in the
area

4.0 . . . .

1 . 1 Accept coins
1 .2 Accept currency
1 .3 Accept debit card
1 .4 Accept credit card
1 .5 Accept debit or credit
card via Web transaction

1 .6 Accept foreign coins

Not estimable
Needs prioritization
Figure 1 1.9 Splitting user stories

The splitting process is illustrated in Figure 1 1 . 9 .
11.7 SPECIFYING USER INTER FACES : HIGH LEVEL

The speci fication of a user interface at a high level is often i ncluded in the high - l evel requirements. Recall
from Section 1 0. 6 . 4 the following steps in specifying user interfaces.
Step 1 . Know your user
Step 2. Understand the business function in question
Step 3. Apply principles of good screen design
Step 4 .

W e will discuss Steps 1 a n d 2 i n this chapter a s they apply only to high- level requirements. The
remaining steps are described the next chapter, on detai led requirements.
11.7.1 Step 1: Know You r User

This step i nvolves understanding the nature of the appl ication's eventual users . Figure t t . t o outl i nes some of
the factors involved. The checklist is a way of ensuring that we know the basic characteristics of the
antici pated users , and that we document our assumptions. These characteristics determine the nature of the
user interface . In general, users with less education, training, ski l l , and motivation require greater simpl icity,
more explanation , and more help . This may have to be traded off against efficiency and speed. It is often
desirable to provide several levels of user interface , dependi ng on the level of the user.
11.7.2 Step 2: Understa nd the Busi ness Function

Th is step requires the designer to understand the purpose of the particular proposed user interface in terms of
the appl ication's overall purpose. For example, i f the business purpose is the stocking of a warehouse, we may

SPECIFYING USER INTERFACES: HIGH LEVEL

•

Level of knowledge and experience
•

•

•

•

•

•

•

Characteristics of the user's tasks and jobs
•

•

•

•

•

•

•

•

Type of use of this appl ication (mandatory; discretionary)
Frequency of use (continual; frequent; occasional; once - i n - a - l i fetime)
Turnover rate for employees (high; moderate; low)
I m portance of task ( high; moderate; low)
Repetitiveness of task (high; moderate; low)
Training anticipated (extensive; sel f- training through manuals; none)
Job category (executive; manager; professional; secretary; clerk, etc . )

Psychological characteristics of the user
•

•

•

•

Computer literacy (high ; moderate; low)
System experience (high; moderate; low)
Experience with similar applications (high ; moderate; low)
Education (high school; college; advanced degree)
Readi ng level (> ( 2 years school i ng; 5- ( 2; < 5)
Typ ing ski ll ( ( 3 5 wpm; 55 wpm; t o wpm)

Probable attitude toward job (positive; neutral; negative)
Probable motivation (high; moderate; low)
Cogni tive style (verbal vs . spatial; analytic vs. intuitive; concrete vs. abstract)

Physical characteristics of the user
•

•

•

•

Age (young; middle aged; elderly)
Cender (male; female)
Handedness (left; righ t; ambidextrous )
Physical handicaps (bl ind; defective vision; deaf; motor handicap)

Figure 11.10 Know your user when developing requirements
Source: Adapted from Gal itz, w., "The Essential Gu ide to User Interface Design: An Introduction to GUI principles and tech niques," John Wiley & Sons, 1996.

want the user interface to reflect the l ayout of the warehouse floor. The sequence of screens that appear
typically reflects the manner in which users normally carry out their tasks for the business at hand.
Sometimes the executio n of a program can be envisaged by displayi ng a series o f CUI images .
F o r example, one could provide a fair conception of Encounter b y displayi ng a sequence of screen shots.
Figures ( ( . ( ( and ( ( . 1 2 are exam ples of pre l i m i n ary CUI sketches for setti ng the qual ities of an Encounter
character.
Upon being shown C U Is, the customer typically realizes that he needs more or wants something
di fferent. I n the exam ple shown in Figure 1 1 . 1 1 , it could well occur to the customer that the CUI for changing

Qualities

Value chosen

Figure 11.11 prelimi nary sketch of user interface for setting game character qualities

255

2 56

CHAPTER 1 1

ANALYZING HIGH-LEVEL REQUIREMENTS

Name of
adjacent area

Name of
adjacent area

Name of
adjacent area
Name of
adjacent area
Figure 1 1.12 Preliminary EnCounter screen shot
Source: Graphics reprocuced with permission from Corel.

the value of qualities is awkward because the total number of poi nts may not change . The customer would also
probably observe that the CUI is not visually appealing. The process of finalizing the CUI is very interactive .
The detailed requirements provide precise CUI specification, as explained in Chapter 1 2 .
11. 7 .3 GUI T ransitions

App l ications typically involve multiple CUl s . The high- level requirements describe the required mouse
actions that take the user from one CUI to another. Figure 1 1 . 1 3 shows a useful way to represent the
transitions between CUls. When a particular CUI is present on the monitor, the appl ication can be
considered to be in a particular state. Changing from one CUI state to another is called a transition. States and
transitions are actually more general concepts, and are described further i n Section 1 1 . 9 . 2 .

I ndicates
start state

Selecting
_ Procedu re
GUI

Click
·stock O VOn

An event
(usually a
mouse action)

GUI
(a state)

Transition
Hit "commit"
button
Figure 1 1 . 1 3 G U I transitions for video store application-Introduction
Source: Copyright © E. J. Braude, John Wiley & Sons, 2003.

SPECIFYING USER INTERFACES: HIGH LEVEL

Select
"stock O VO"

Stocking DVD

Registering Customer

Select "register
customer"

Select
"check out'' __

--=::::::""'"""
:,, ""

::..

• Hit
"commit"
button

==:=::::;:::>r-----'

_
_

Select
"check in " _______

Checking In DVD

�=::::-;::;r--�

Figure 1 1 .14 GUI transitions for video store application
Source: copyright © E. J. Braude, John Wiley & Sons, 2003.

A typical GUI/transition diagram for the video store example is shown in Figure 1 1 . 1 4 .
While a particular G U I is being displayed, an appl ication is said t o b e in a particular state. W e explore
states further in Section 1 1 . 9 . 2 .
Figures 1 1 . 1 5- 1 1 . 1 9 show rough sketches of the GUts referenced i n Figure 1 1 . 1 4 . The detailed
requirements provide compete detail .
Select Proced u re
Stock DVD
Register customer
Check out DVD
Check in DVD

@
@
@
@

go

Figure 1 1 .15 Rough sketch of "Select Procedure GUI" referenced in Figure 1 1 .14

Stock DVD
Title

N u mber of copies

I

�I

Figure 1 1 . 1 6 Rough sketch of "Sketch of Stock DVD GUI" referenced in Figure 11.14

257

258

CHAPTER 1 1

ANALYZING H I G H-LEVEL REQUIREM ENTS

Register Customer
First name

Last name

I]

Commit and check out DVD

18

Figure 11.17 Rough sketch of "Register Customer GUI" referenced in Figure 1 1 . 1 4

Check Out DVD
DVD name

Customer

�

Register customer

I�

commit

I

Figure 11.18 Rough sketch of "Check out DVD GUI" referenced in Figure 1 1 . 1 4

Check In DVD
DVD name

Figure 11.19 Rough sketch of "Check in DVD GUI" referenced in Figure 11. 1 4

11.8 SECURITY REQUIREMENTS
Many security requirements can be effectively expressed at a high level because we can express security goals
without having to anticipate all of the specific breaches that can occur. Here is an example from the Ecl ipse
project.
The Eclipse Platform should provide the basic framework for a security mechanism that can be
used by all plug- ins, i ncluding a simple credentials store and user authentication. Additionally,

SECURITY REQUI REMENTS

•

Confidentiality "C"

•

Nonrepudiation

•

Integrity "I"

•

•

•
•

Abil i ty to validate not/altered in transit.
Abi l i ty to validate user's identity .

Authorization
•

•

Parties can prove the existence of agreements .

Authentication "A"
•

•

Data passed not visible to the unauthorized.

Permission to deal with the subject.

Availability
•

For exampl e , as compromised by denial - o f-service attacks.

Figure 11.20 Common securily requirements

key parts of the Platform itse l f should be secured, such as the ability to install plug- ins, which
might need to be restricted in certain products or for certai n users .'
Standard classifications for high - l evel security requirements are shown in Figure 1 1 . 20. They are
sometimes collected into the acronym "CIA," which stands for "Confidentiality, I n tegrity, and Authentica­
tio n . " Figure 1 1 . 20 adds nonrepudiation, which is the ability for parties to a contract to prove rel iably that the
contract was i ndeed made . It also adds authorization, which specifies who may access what particular
informatio n , and availability, which specifies reaction to denial-of-service attacks. Denial- o f-service attacks
are activities, such as flooding a Web site automatically with requests, that make is difficult for anyone else to
access it.
We ensure that these properties are satisfied by suitable corresponding requirements at the detailed l evel .
However, ill -meaning perpetrators devise ways to compromise systems by exploiting combinations of
properties that the system does not possess. To explain this, consider a (non-software) set of requirements
that were already devised to ensure that the funds in a prominent Irish bank were secure. These required that two
bank managers, each possessing a different key, were required to unlock a major safe. They also required
constant guards for the managers. Both procedures were faith fully observed. It is important to understand that
for perpetrators, existing security measures simply constitute a set of constraints within which they work, setting
them to seek opportunities that the constraints do not cover. I n the case of the bank example, there was no
requirement for guards on the famil ies of these two officials. Observing this combi nation of properties that the
system did not possess, criminals took hostage the families of both managers and by this means coerced the
officers i nto obtaining the bank's cash on their behalf.
Privacy is often l inked with or considered part of security. Th i s is because the purpose of many exploits is
to gain access to data to which the perpetrator is not entitled, thereby compromising i ts privacy.
One example of privacy regulations is the Health Insurance Portability and Accountabi l i ty Act of 1 996
( H I PAA) , which regulates health i n formation created or maintained by health care providers who engage in
designated electronic health care transactions. The Department of Health and Human Services is responsible
for implementing and enforcing H IPAA. The act took effect in April 200 3 .
The mai n thrust o f H I PAA i s to ensure that a n i ndividual's health i nformation i s used for heal th purposes
alone. 'The final rules for security protect the confidentiality, integrity, and availability of individual health
information and will provide a standard level of protection in an environment where health information
1

https:!/bugs.ecli pse .org/bugs/show_bug. c gi?id=3769 2 .

259

260

CHAPTER 1 1

•

•

ANALYZING HIGH-LEVEL REQUIREMENTS

The Health Insurance Portabi li ty and Accountab i l i ty Act passed
i n 2000 and 2002; 2003 compliance
Regulates health information created or maintained by health
care providers

•

•

U.s. Department of Health and Human Services responsible for
implementing and enforcing
Main thrust: Ensure that an individual's health information is used
only for health purposes
•
•

Ensures confidentiality, integrity, and availability
Mandates safeguards for physical storage , maintenance, trans­
mission, and access

Figure 11.21 Main poi nts of H I PAA
Source: HIPAA Act of 1 996.

pertaining to an individual is housed electron ically and/or is transmitted over telecommun ications systems!
networks. The standard mandates safeguards for physical storage and mai ntenance, transmission, and access to
individual health i n formation. Entities required to comply with the standard include any health care provi der,
health care clearinghouse, or health plan that electronically mai ntains or transmits health information pertaining
to an individual ." Figure 1 1 . 2 1 summarizes these poi nts.

11.9 USING DIAG RAMS FOR HIGH-LEVEL REQUIREMENTS
Accordi ng to Davi s [6] and Wiegers [7], no si ngle view of requirements gives a complete understanding, and
it is often helpful to represent high-level requirements using diagrams . What is often needed is a combination
of text and diagrams to convey a complete picture of the i ntended applicati o n . We i ntroduce two types of
diagrams used to describe high-level requirements: data flow and state transition diagrams. We are using them
here to express requirements. They are often used to express designs as well, and th is can be confusing. The
difference to watch for is not so much the form of expression as whether the attempt is to express "what"
(requirements) or "how" ( design ) .

11.9.1 Data Flow Diagrams
Some requirements are natural ly described as the flow of data among process ing elements . For example, imagine
that our customer is trying to explain what he wants from an ATM banking appl ication, starting with deposits
and affecting accounts at several locations. In a data flow diagram, the nodes, shown as circles or rectangles,
represent processi ng units. The arrows between nodes denote the flow o f data. The arrows are an notated with the
data's type . Data stores pl aces where data reside, such as databases-are denoted by a pair of horizontal lines
enclosi ng the name of the data store. External agencies such as the user and printers are represented by rectangles.
For the ATM appl icati o n , the deposit functionali ty might get the deposit from the user and check the
deposit transaction to ensure that it is legitimate. These functions are represented by circles in Figure 11.22.
Next, the type of data flowi ng between the functions is noted on the figure-the account number and the
deposit amount. The user is involved, too, and so is represented. A function to create a summary of accounts,
to give another example, requires i n put from a store , as shown.
A more complete data flow diagram for the ATM requirements would be as shown in Figure 11.23.
-

USING DIAG RAMS FOR HIGH-LEVEL REQUIREMENTS

Processing
element

Account no.
and deposit

Direction
of data flow

Data type

I
Balance
query

1

Data store

Account ___
database

Account
data

Figure 11 .22 Data flow diagram-explanation of symbols

The complete diagram of Figure 1 1 . 2 3 includes the "member banks" data store, which is a list of banks
allowing a deposit at this ATM . It also shows the data flow for the response to a query, in which details about
an account are displayed. Expressing these requirements in text form only would be more difficult than using a
data flow diagram to help describe them. Notice that data flow diagrams do not show control. For example,
the ATM appli cation does not indicate what function occurs first . Standards used for the symbols differ
among organizations (e.g., rectangles can be used for the processing elements rather than circles ) .
Whether or not data flow diagrams are helpful for expressing requirements depends upon the
application. For example, the ATM data flow diagram in Figure 1 1 .2 3 clarifies for many readers what
behavior the application is meant to exhibit, whereas video game requirements would probably not be

Member
banks

I

Bank
name

Error
Account #
& deposit

Account #

account
display

Account
data

Balance
query

":J

Deposit
transaction ___ Account

database -

Figure 11.23 Partial data flow diagram for ATM a pplication

Account
data

Error

261

262

CHAPTER 1 1

ANALYZING HIG H-LEVEL REQUIREM ENTS

described well using a data flow diagram. When using these diagrams for requirements specification, there is a
sign i ficant danger of slipping i nto performing design i nstead of analyzing requirements. For example, i f an
appl ication is required to track the flow of orders within a company, then a data flow diagram (DFD) showi ng
th is process at a h i gh level would be an appropri ate form for high-l evel requirements because the DFD is
needed to express the outcomes. On the other hand, consider an appl ication that is required to apply a
complex formula . A DFD explaining the calculation process would be part of the design, but not the
requirements-the formula would be sufficient for expressing the requirements. We will revisit data flow
di agrams in Part IV, the design section of the book.

11.9.2 State Transition Diagrams
Sometimes, an application, or part thereof, is best thought of as being in one of several states. The state of an
application is i ts situation or status. States are sometimes called "phases" or "stages." Although a state often
corresponds to a CUI and vice versa, the state concept is more general than CU ls. The i dea is to divide the
application into states so that the appl ication is always in one of these states. Note that the states we are
defining are based on the requirements of the application-not its software desi gn . For example, it might be
use ful to think of an online shopper at a bookselling site as being either in "browsing" state (looki ng at book
i n formation) or in "purchasing" state ( provi di ng credit card i n formation, etc.) . A diagram that depicts the
different states and the transitions between states is called a state transition diagram.
There are several possible Encounter states:
•

•

Setting up; the state during which the game is being set up
Preparing; equipping the player's character with qualities such as "strength" and "intell igence" can be
performed as long as no forei gn character is present

•

•

Waiting; nothing is happening in the game that is experienced by the user
Engaging; the state in which the player's character and the foreign character are exchanging quality values

These states are shown in a UML state transition diagram in Figure 1 1 .24. For event-driven appl ications,
diagrams like this can be an effective way for the customer and developer to obtain a shared concept of how
the application is meant to work.
After identifying the states, the transitions between states are added. Transitions, denoted by arrows, are
each labeled with the name of the event that causes the object to change from one state to another. Events are

Complete
setup

Player
clicks
qualities
menu
'
"

(f�nal state)
Foreign
character
tL--- enters
'--__--.J
area
Figure 11.24 partia l Encou nter state tra nsition d iagram

"

"
,

-( Engaging
.]

USING DIAGRAMS FOR HIG H-LEVEL REQUIREMENTS

Event

Player
moves to
adjacent �
area

[foreign
character
absent]
Condition

Condition

[foreign
character
present]

[J, ",

I

Figure 11 . 25 usi ng conditions in state tra nsition diagra ms

occurrences that can cause a change in the obj ect's state . A typical event on a CU[ is a mouse click. The sol id
circle denotes the starti ng state. The final state is depicted by the solid circle inside another circle.
States and transitions can apply to entities at many levels. For example, a shi p can be i n one of several
states, such as Sailing, Docking, or Docked. Parts of the ship can be in several states: For example, a cab i n can be
in Occupied or Unoccupied state.
Sometimes, when an object is in a given state and an event occurs, the object can transition to one of
several states, depending on a condition. For example, when the player decides to move her character to an
adjacent area, the game transitions from the Waiting state into one of two states. One possibility is to
transition back to Waiting state ( i f the foreign character is absent from the entered area); the other is to
transition to the Engaging state ( i f the forei gn character is present in the entered area) . [n UML, conditions are
denoted by square brackets, as shown in Figure 1 1 . 2 5 .
The complete state transition diagram for Encounter is shown i n Figure 1 1 .26. Once the player has fin ished
setting up the Encounter game, the l atter transitions from Setting Up state i nto Waiting state. If Encounter is in

[ �;;g"P I
Player
completes
setup

[foreign
character
absent}

[foreign character
present}

Figure 11 .26 Encou nter state transition d iagra m

2 63

264

CHAPTER 1 1

ANALYZING HIG H-LEVEL REQUIREM ENTS

Waiting state and a foreign character enters , then Encounter transitions i nto Engaging state. Figure 1 1 . 26 indicates
that the process of setting qual ity values and the process of reporting the results of an encounter can be
i nterrupted by the arrival of the foreign character. The latter causes a new encounter to commence immediately.
A state transition model is a good way to explain the concept of operations of E ncounter. State
transition models are commonly used as design tools as well (see Chapter 1 6 ) . Whether or not they should be
used to express high-level requirements, as we are doing here, depends on the application i n question and
how helpful doing so is for the customer. Thi s may require some education of the customer.
For many applications, each state corresponds to a CUI. However, there is a wide variety in what we may
define as a state . The state diagram i n Figure 1 1 . 26 corresponds roughly to the presence of visual artifacts on the
monitor, but these are not CUls. For example, when the foreign character Freddie appears on the monitor, the
applicati on transitions to Engaging state, but Freddie is just an additional graphical element, not a separate CUI.
11.10 CASE STUDY: HIGH-LEVEL SOFTWARE REQUIREMENTS SPECIFICATION (SRS) FOR
THE ENCOUNTER VIDEO GAM E

Note to the Student:
Using a standard to write the SRS helps one to
cover all of the aspects of requirements that
readers need to know about, and provides a
recognized structure. Several standards are avail­
able, but we will concentrate on the IEEE stan­
dard. The complete IEEE 8 30-1998 standard can
be found in [8]. Most organizations allow modi ­
fication of the standard to tailor it for their own
use. In fact, the template used below modi fies the
standard by omitting some less important sec­
tions and by adding sections on concept of
operations and use cases. The reader can com­
pare the case study headings with the standards
shown in Figures 8 and 9 of Chapter 10.
In the case study portion of this chapter,
Sections I and 2 cover the high-level require­
ments. The remainder of the document, Sections
3 and 4, contai ning the detailed requirements, is
provided in the case study at the end of Chapter
12. Recall that customer requirements are not
intended to be detailed enough to develop the
design and implementation-this is the purpose
of the detailed requirements.
History of versions of this document:
1 / 1 9/9 8 Hal Furness: Initial draft
1 /29/9 8 Karen Peters: Reviewed for technical
accuracy; changes made throughout

2/1/98 Hal Furness: Entire document reviewed
for small improvements
2/ 1 9/9 8 Karen Peters: Document reviewed and
suggestions made
2/29/98 Karen Peters: Moved use cases to
Section 2 . 2
3/ 1 /9 8 Hal Furness: Improved
throughout; sense not changed

wording

5/20/04 Eric Braun: Updated to 830 - 1 998
standard
1 4/20/08 Eric Brannen: Edited to improve as­
sorted c1ari fications

1. I ntroduction
1_1 Purpose
The purpose of th is entire document ( not the
purpose of the appl ication ) .

This document proVides all of the requirements
for the Encounter video game . Parts 1 and 2 are
i ntended primarily for customers of the application,
but will also be of interest to software engineers
building or maintaining the software. Part 3 is in­
tended primarily for software engineers, but wil l also
be of interest to customers.

CASE STUDY: HIGH-LEVEL SOFTWARE REQUIREMENTS SP ECIFICATION (SRS) FOR THE E NCOUNTER VIDEO GAME

1.2 Scope
(The aspects of the application this document
is intended to cover. )
This document covers the requirements for
release 0.0. 1 of Encounter. Mention will be made
through out this document of selected probable fea­
tures of future releases. The purpose of th is is to
guide developers i n selecting a design that will be
able to accommodate the full -scale application .

1.3 Definitions, Acronyms, and Abbreviations
See Table 3.3.

1.4 References
Software Con figuration Manageme n t Plan (SCM P )
for Encounter version 1 . 0
Software Design Description (SOD) for Encounter
version 1 . 2
So ftware Proj ect Management Plan (SPMP) for
Encounter version 1 . 2
So ftware Quali ty Assurance Plan (SQAP) for
Encounter version 1 . 0
Software User Documentation Plan (SUDP) for
Encounter version 1 . 0
Software Test Documentation ( STD) for Encounter
version 1 . 0

1.5 Overview
Intentionally omi tted.
The author of this document felt no need for
this sectio n , and intends to cover the overview
in Section 2.

2. Overall Description
Make this general enough so that it is unlikely
to change much in future versions. Avoid
statements that are repeated in later sections.

Encounter is to be a role-playing game that simu­
lates the l i fetime of the player's main character. It should
be of interest to both men and women. The measure of
"success" in playing Encounter is up to the player.
Typically, success will be measured by the "Iife points"
maximum attained by the player or by the ability of the
player to live as long a life as possible.
Some game characters are to be under the
control of the player. The rest, called "foreign"
characters, are to be under the application's contro l .
Came characters w i l l have a fixed total number o f
points allocated among qualities such a s strength ,
stamina, patience, and so on. Characters encounter
each other when they are i n the same area at the
same time, and m ay then engage each other. The
result of the engagement depends on the values of
their qualities and on the environment in which the
engagement takes place . Engagements are not nec­
essarily violent or adversarial. Players have restricted
opportunities to reallocate their qual ities . One of the
player-controlled characters will be referred to as the
"main" player character.
I n early versions of this game, there will be only
one player-controlled character and one foreign
character.
The eventual nature of the characters is to be
determi ned from insights gained from surveys and
focus groups. It is expected that initial releases will
not have animation . Encounter should eventually be
highly customizable, so that users can either start
with predefined games, substitute predesigned char­
acters and rules of engagement, or devise their own
characters and rules of engagement.
The design should support expansion into a
family of games, i ncluding I n ternet-based multiple­
player versions.

2.1 Product Perspective
In this section, Encounter is compared with
other related or competing products. Th is is a
useful way to provi de perspective on the ap­
plicati o n . Subheading 2.1.1 of this section has
been changed from the IEEE standard to ac­
commodate "concept of operations."

265

266

CHAPTER 1 1

ANALYZING HIG H-LEVEL REQUIREM ENTS

Encounter is i n tended to fulfill the need for
programmers to have a greater i nfluence over the
contents of video games with additional program ­
ming. It is also intended for a somewhat mature
clientele. Encounter is i n tended to appeal to both
gen ders. The design and documentation for Encoun­
ter will make i t convenient to expa nd and modi fy the
game. It is anticipated that Encounter will be used as
a legacy application for expansion i n to appl ications
such as office i n teraction simulations.

2. 1.1 Concept o f Operations
Th is section conveys the overall concept of
the application by whatever means are most
natural for doing so. In the case of Encoun ter,
the requirements developers decided that
state/transitions best convey the concept.

Encounter can be in one of the following states
(also shown in Figure 1 1 . 26):
•

•

Setting up. The state i n which the game is being
set up by the player
Reporting. The system is displaying a window

showin g the status of the player's character(s ) .
•

•

Setting qualities. Equipping t h e player's character
with quali ties. This process consumes arbitrary
amounts of time, and can be performed as long
as n o foreign character is present.
Engaging. The state that applies whenever a for­

eign character and the player's main character are
present i n an area at the same time.
•

Waiting. The player and the foreign character(s)
are not active .

This state/transition is tested by i n tegration test
<to be supplied> .

2 .1.2 User Interface Concepts
The following figures are prel imi nary sketches of
key user interfaces only, used to provide perspec­
tive on the product. All the user interfaces are
speci fied in detail in Section 3. We have modified

the standard IEEE headi ng "user interfaces" to
emphasize that these are not the detailed CUls.

2.1.2.1 Area User Interface Concept The areas
in which encounters take place shall have an appear­
ance very roughly like that shown in Figure 1 1 . 1 2.
2.1.2.2 User Interface Concept for Setting
Quality Values When setting the values of game
characters under his control, the player uses an interface
of the form sketched approximately in Figure 1 1 . 1 1 .
The scroll box is used to i dentify the qual ity to be set,
and the text box is used for setting the value.
2.1.3 Hardware Interfaces
None. Future releases will uti lize a j oystick.
2.1.4 Software Interfaces
None.
2.1.5 Communications Interfaces
None. Future releases will i nterface with the Internet
via a modem .
2.1.6 Memory Constraints
Encounter shall require no more than 1 6 ME of RAM
and 20 ME of secondary storage (see test plan <test
reference to be supplied».
2. 1.7 Operations
Normal and special operations required by the
user, sllch as modes of operation, data proc·
essing support functions, and backup and re ­
covery operation s .
I t shall be possible to save and retrieve a game.

2.1.8 Site Adaptation Requirements
Requirements for execution on a particular
instal lation; versions in various languages
(e.g. , French, Japanese, Span ish) .
None.

CASE STUDY: HIGH-LEVEL SOFTWARE REQUIREMENTS SPECIFICATION (SRS) FOR THE ENCOUNTER VIDEO GAME
t.

2.2 Product Functions
Summary of the major functi ons of the applica­
tion . Th is section is more deta iled than Section
1 . 5 , but does not attempt to supply all details, as
done in Section 3 . The wri ters of th is SRS
decided that use cases are an appropriate man­
ner i n which to specify the overall functionality
of Encounter.

This section speci fies the required overall func­
tionality of the application, but is not i n tended to
provide the complete specifications. Section 3 pro­
vides the requirements in complete detail.

2. 2. 1 Initialize Use Case
Actor: Player of Encounter
Use case: Figure 1 1 . 27 gives the text of the
Initialize use case. The use case is shown in context
with the Encounter foreign character use case and the Set
rules use case . Initial ize is the typical sequence users
execute at the begi n n i ng of a session.
This use case corresponds to test <test reference
to be suppl ied> in the Software Test Documentatio n .
2. 2. 2 Travel t o Adjacent Area Use Case
Actor: Player of E ncoun ter
Use case:

Encounter

Player h i ts hyperl ink connecting displayed area
to adj acen t area

2. System displays the i ndicated adj acent area
including player's character

2.2.3 Encounter Foreign Character Use Case
Actor: Player of E ncounter
Use case:
I.

System moves a foreign game character into the
area occupied by the player, or Player moves
i n to an area containing a foreign character

2. System causes the two characters to engage
3 . System displays the result of the engagement
4. If ei ther the player's character or the foreign
character has no points, the game termi nates
5. O therwise, System moves the player's character
to a ran dom area di fferent from that i n which the
encounter took place, and displays it there

2.3 User Characteristics
Indicate what kind of people the typical users
are likely to be . Examples: novice , software
professional , accountant with five years of
com puter usage, etc .

r---,--,---

Initialize

Usecase details

Usecase
- -- 1 . System d'ISPIays pIayer' s
Initialize
main character in the

Player

Travel to
adjacent
area

dressing room.

2. System displays a window
for setting his character's
qualities.

3. Player allocates the

qualities of his main
character.

4. Player chooses an exit

from the dressing room.

Designer

Set rules

Figure 11.27 Initialize use case for Encou nter

5. System moves player's
main character into the area
on the other side of the exit.

2 67

268

CHAPTER 1 1

ANALYZING HIGH-LEVEL REQUI REMENTS

The user is expected to be approximately 203 5 years of age .

the developers . It is anticipated that they will be part
o f a future release . "Optional" requirements wi ll be
implemented at the discretion of the developers .

2.4 Constraints
These are all conditions that may limit the
developer's options. They can originate from
many sources.
Encounter shall operate on pes running
Windows XP or later at a m i nimum speed of 500
MHz. Java shall be the implementation language .

2.5 Assumptions and Dependencies
(Any assum ptions being made-for example,
future hardware . )

11.11 CASE STU DY: HIG H-LEVEL
REQU IREMENTS FOR ECLI PSE
Note to the Student:
This section discusses published requirements for
Eclipse. There is no single requirements docu­
ment for Eclipse-the requirements are spread
over multiple documents. The authors have
reconstructed a partial requirements document
from these sources at a single poi nt in time, placing
them roughly in IEEE format for the sake of
comparison. The result is necessari ly incomplete,
and illustrates a shortcoming of many open source
projects. Most of the material below is quoted
directly (but selectively, of course) from the
Eclipse documentation online at the time.

None.

2.6 Apportioning of Requirements
( O rder i n which requirements are to be
im plemente d . )

The requirements described i n Sections 1 and 2
of thi s document are referred to as "customer require­
ments"; those i n Section 3 are referred to as "detailed
requirements." The primary audience for customer
requirements is the customer community, and the
secondary audience is the developer community.
The reverse is true for the detailed requirements.
These two levels o f requirements are i ntended to be
consistent. Inconsistencies are to be logged as de ­
fects. In the event that a requirement is stated withi n
both the customer requi rements a n d the detailed
requirements, the application shall be built from
the detailed requirement version since it is more
detai led.
"Essential" requirements ( referred to i n Section
3) are to be implemented for this version of Encoun­
ter. "Desirable" requirements are to be implemented
in this release if possible, but are not committed to by

'The Eclipse Project is an open source software
development project dedicated to providing a robust,
ful l - featured, commercial-quality, i ndustry platform for
the development of highly integrated tools. The mis­
sion of the Eclipse Project is to adapt and evolve the
eclipse technology to meet the needs of the eclipse tool
building community and its users, so that the vision of
eclipse as an industry platform is realized.',}
'The Eclipse workbench consists of windows. Each
window contains parts. Each part can be a view or an
editor. A perspective is a physical configuration of parts.
Figure t 1 . 2 8 shows a typical Eclipse screenshot.,,3 This
example is a Java perspective (as indicated in the
shortcut bar) . This perspective consists of a Windows
Explorer-type of view, an editor, and other parts,
i ncluding the console view.
Th is particular wi ndow is used merely as an
example, to make the spec ification more un­
derstandable-not as a detai led speci fication.

2
3

From h ttp://www . eclipse.org/projects/index . html.

Ibid.

ECLI PSE PLATFORM SUBPROJECT (FI RST OF THREE)

Short cut bar

Menu bar

Workbench window

Tool bar

Perspective

. r
8 IB (def..... pod<aQe)
8 [;1) ""'",Test.,...

41; tMle,*i#j

B��

.; moon(Stn"<iD
A edtltems
.A edltShortct.ts
Co f"6eJtems
.A f�Shortcuts

"_"'-0

�E System La."y [jd<.1 . 3 .

Editor

! i

• To change t,h�s generated. co ••ent �o to
.. \llnde.. Preferences>Java>Code Generatlon>Code and eo••ents
./

l..aport Jdva avt ..
l..aport Java avt event .;
i_port Javax sWlng ...
i.porl JdVdX sWlng border •.
i.port Jdvax swing event • �
class )(yHenuBar extends JHenuBar {
StrJ.ng[
Strl.ng[

cbar[
cbar[

) fl.lelteas • new Strlng(
] edltlteas • new Strlng(
] flleShortcuts • { ' N ' '0'
] echtShortcuts • { 'Z' ' X '

publl.c HyHenuBar(

) { -New·. -Open",
) { ·Undo·. "Cut"

'5'
'C'

'

X ' }.

'Y'

}

) {

Status line

Figure 11.28 Eclipse GUI
Source: Eclipse, http://WWW . eclipse.orgtarticles/Article-UI-Guidelines/lndex.html.

The following three sections are quoted from
Eclipse documen tation with some adaptation.

11.12 ECLIPSE PLATFORM SU BPROJECT
(FI RST OF THREE)

The Eclipse Platform provides the fundamental
building blocks of the Eclipse projects. Plan tasks are
new features of the Eclipse Platform or significant
reworking of existing features. Many of the changes
under consideration for the next release of the Eclipse
Platform address three major themes, as follows:
•

User experience theme. I mproving Eclipse from

the point of view of the end user.
Note to the Student:
Since Eclipse is organized around three sub­
projects, it is natural to organize the summary
requirements in the same way. Within each
project, summary requirements are organized
around several "themes . " This is a way to orga­
nize the (high-level) requirements and allow
latitude at the same time. The themes do pro­
vide content, but they avoid specifying details.

•

•

Responsive UI theme. Making it easier to write
Eclipse plug-ins that keep the UI responsive .
Rich client platform theme. Generalizing Eclipse
into a platform for bUilding non-IDE applications .

In addi tion, there are important Eclipse Platform
improvements that do not naturally fit into any of the
above themes. These are categorized as fol lows:
•

Other Eclipse Platform items

269

270

CHAPTER 1 1

ANALYZING HIG H-LEVEL REQUIREM ENTS

toolbars, and lengthy flat lists of preferences. This
problem is acute i n large Eclipse -based products. The
Platform should provide additional ways for control­
ling workbench clutter, such as further menu and
toolbar customizability, distinguishing between nov­
ice and advanced functions, supporting different de ­
veloper roles, and more speci fic object contributions
for particular file types . .
( 3 7929)"

Below are exam ples elaborating upon these .

User Experience Theme
This theme includes improving both the "out of the
box" experience so that new users are productive
faster, a n d finding better ways to scale up to large
numbers of plug- ins without overwhelm i n g the user.

The number given above in parentheses is a link
to the following bug entered in Eclipse's Bugzilla
bug database: https://bugs.eclipse. org/bugs/
show_bug.cgi?id= 37929 . This and other require­
ments are managed in the same way as defects.
The reason is that both define work to be done on
an existing application. Each Bugzilla location
contains extensive discussion about the require­
ment and the progress made im plementing it.
This amounts to the detailed specification-a
common way of specifying detailed requirements
in open source projects. The beginning of Bug­
zilla item 37929 is shown in Figure 1 1 .29 and
Figure 11. 30 . We will return to the subject of
requirements tools in Chapter 12.

Committed Items (Eclipse Platform subproject,
User Experience theme)
The requirements here are grouped by prior­
ity. "Committed" is the highest priority. The
others are "proposed" and "deferred." Comple ­
tion of a requirement is denoted with a green
check mark.

Improve VI scalability

"Despite efforts to ensure UI scalabil i ty with a large
base of available tools, the Ecli pse workbench still
i ntimidates many users with long menus, wide

Bupilla Duc 37929 [Plan Item) Improve Ul scalability
Show hn

Bue List: .Elm Lan (Thu: bug 15 not Dl yow bst)

Platform: �

�: :�

IPlattorm :::!1

: ::J
�: rP23
-"::'

Component: �
Product:

Status: RESOLVED

Assigned To:

vers

��i;;�� 1 ibmtom (Chru

URL,I

Severity:

Reporter:

::J

.
'
", --:- n, :::1
Ii-." h..-me

MJle��

Add

�;!:)rMetes@Ca ibm com {Tm des

��: lr,dOW-'7'CCiJ.-.o,-.. ".."...,.-:co.,-m-----,
om
••

�������!@;:�I:mc

9 wegenkned'tt®plenel-wegenknecht de
hudsonr@USlbmcom
..:J
rRe:movt se:le:cte:d CCs

] m= p:::
I
""Y::------­
',••=
=
,,
"
"u,c:
"
",c::7.
. =.m:;;
.::-;'
1i;;[PI;;:

Swnmary:

Keywords:

h)len

Create a New Attachment (proposed patch. \emasl!. etc) View All

Bua 37929 d

epend s on: 33&t8 36968 p3018. 36968

Bua 37929 blocks:

Votes: 1

Showvotesforthnbug

Show dtpen�nc.y tue

Voteforthlshug

Figure 11.29 using Bugzilla in Eclipse to track bugs and deta i led req u irements, 1 of 2

ECLIPSE PLATFORM SUBPROJECT (FIRST OF THREE)
(1) Leave as RESOLVED FIXED

Fonnat For Printing

View Bug Activity
Description:

Improve

U1

scalability.

Despite efforts to ensure

base of available tools,
with long menus,

the

additional ways for controlling workbench clutter,

�upporting different

scalability with a large

and lengthy flat lists of

problem is acute in large Eclipse-based products.

toolbar customizability,

U1

Eclipse workbench still intimidates many

wide toalbers,

The

preferences.

for particular file types.

[Platform

This

such as further menu and

distinguishing between novice and

developer roles,

users

Platform should provide

advanced functions,

and more specific object contributions
UI,

Platform Debug,

JDT U1]

[Theme:

User

experience]

------- Additional Comment !H From Jim des Rivieres 2003-05-21 11 :18 ------

B�g 369S� hS3 been marked as a duplicate of this bug. ���
------- Additional Comment til. From MorPheus 2003-06-08 14:40 -------

3.0

I

am

glad

that this

going

after reading the

to address this

cuatomization(i.e,
un"

l"'IrF>

;11C1t"

Eclipse

Project Draft

bug going to be addressed,
bug to

provide

allov us to remove

nrn17; n; TIN

,.h""

nnt'; nn

1""

but

3.0

plan that

I also want the people

spils to do the menu and

in

eclipse

who is

toolbar

unwanted menu items programmatically) .If

I""n"'lt"nmi �"" r-h ... m""nl1hl"'lr t"nn lhl"lr MRnl':t=l 11"

Figure 11.30 Using Bugzilla in Ecl i pse to track bugs and deta iled requirements, 2 of 2

Improve initial user experience

Users who are new to an Eclipse -based product can
find their first experiences with it overwhelming,
even daunting. The i nitial experience would be
improved i f a product could precon fi gure the work­
bench to show only the subset of function that a new
user really needs; welcome pages could be personal ­
ized for particular users roles or levels of experience.

Proposed Items (Eclipse Platform subproject,
User Experience theme)
The "proposed" category is the second most im ­
portant priority. Note that these requirements are
expressed in an exploratory, less specific, manner.
Requirements analysis still has to be perfonned to
transfonn these into committed items.

. (37664)
Improve UI affordances
... (37671)
'Work completed

The following work i tems are being actively
investigated, but we are not yet able to promise any
solution for this release .
Allow editors to open files outside workspace

This is a way of tracking the status of
requiremen ts.

A common request is to be able to use Eclipse to open a
file that is not part of the workspace, or perhaps even
one on a remote system. In addition, appl ications

271

272

CHAPTER 1 1

ANALYZING HIGH-LEVEL REQUIREM ENTS

woul d like to provide file extension associations so
that double-clicking on a file i n the OS desktop would
open the associated Eclipse editor. The operations
and capabil ities available on these "outsi de of the
workspace" files would need to be defined. ( 3 79 3 5 )

(� recently deferred item) Provide a general
purpose navigator (3 6 96 1 ) . ..

These are just a few examples that illustrate the
organi zation of these documents .

Improve workspace synchronization with file
system....

Other Eclipse Platform Items

Detai ls om itted

The following are examples from the Ecl i pse
Platform subproject with in this "theme."

content-type-based editor lookup....

Design Constraints: Compatibility of Release
3. 0 with 2.0 and 2.1

Details omitted

Deferred Items (Eclipse Platform subproject,
User Experience theme)
The Ecl i pse proj ect tracks requirements that
may never be implemented . This enables them
to be revived, provides history, and discour­
ages them from being proposed aga i n . It helps
to clari fy the project's direction .
These items are next in line for this release . As
committers complete their assigned tasks or addi­
tional help becomes available, some of these items
may be committed for this release:
Add table of contents support to wizards

(3 6 94 7 ) . ..
Details om itted
Add project templates (3 6 96 0) .

.

.J

(0 recently de-committed item) Aid ongoing
learning (3 7 6 6 6 )
More tracking the status of requirements . "De­
comm itted" means, effectively, "dropped."

This section is quoted from note4 It consists of
nonfunctional requirements , and one example
is expanded here. A "breaki ng" change is one
that prevents some applications from execut­
ing on the new version that did execute on the
old one. Note also that this paragraph contains
policy elements for requirements rather than
requirements themselves.
"Eclipse 3 . 0 will be compatible with Eclipse 2.0 and
2 . 1 to the greatest extent possible. The nature and scope
of some of the key plan items are such that the only
feasible solutions would break compatibility. Since
breaking changes are a disruption to the Eclipse com ­
munity, they cannot be taken lightly. We (the Eclipse
PMC) will have an open discussion with the community
before approving a proposed breaking change for inclu­
sion in 3 .0. In other regards, Eclipse 3.0 will be compati­
ble with 2 . 0 and 2. 1 . We also aim to minimize the effort
required to port an existing plug-in to the 3 . 0 APls. We
will provide a comprehensive Eclipse 3.0 Porting Guide that
covers all areas of breaking API changes and describes
how to port existing 2. 1 plug-ins to 3 . 0. Up-to-date drafts
of the Eclipse 3.0 Portinq Guide will be included with
milestone builds so that it's possible to climb aboard
the 3 . 0 release wagon at the early stages, or to estimate
the amount of effort that will be involved in eventually
porting existing plug-ins to 3.0."
4 http://www . ecli pse . org!eclipse/development/

eclipse_projecCplan_LO_20040 1 30. htm I.

CASE STUDY: HIGH-LEVEL REQU IREMENTS FOR OPENOFFICE

11.1 3 CASE STU DY: HIG H-LEVEL
REQU I REMENTS FOR OPENOFFICE
This section is i ntended to give the reader an i dea of
the OpenO ffice requirements.
Note to the Student:
The prose below has been adapted by the
authors from httpi/www.openoffice. org/prod­
uctl which was written with a partially market­
ing flavor. For example, we have replaced
"WRITER is a powerful tool . . . " with
"WRITER is a tool . . . " "You can easily inte ­
grate i mages" has been replaced by "It facilitates
integrati ng i m ages." OpenOffice requirements
are decomposed at this top level as shown next.

OpenOffice consists of the following:
o

o

o

o

o

WRITER is a tool for creating professional docu­
ments, reports, newsletters, and brochures. It fac i l ­
itates i ntegrating i mages a n d charts i n documents,
creating everythi n g from busi ness letters to com­
plete books with professional layouts, as well as
creating and publish Web content.
CALC is a spreadsheet that facilitates the absorption of
numerical information. It enables users to calculate,
analyze, and visually communicate data. Advanced
spreadsheet functions and decision making facilitate
sophisticated data analysis. Charting tools generate
2D and 3D charts.
IMPRESS is used for the creation of multimedia
presentations. It allows special effects, animation,
and drawing tools.
DRAW facilitates the production of everything
from simple diagrams to dynamic 3 D illustrations
and special effects .
The Database User Tools faci l itates day to day
database work in a simple spreadsheet-like form.
They support dBASE databases and ODBC or JDBe.

H igh-Level Requirements for WRITER
I t appears that the only high - l evel description
of WRITER is written in a style to attract users

rather than to specify its requirements. The
followi ng is found at httpi/www. openoffice.
org/productlwri ter. htm I .
"WRITER has everythi n g you would expect
from a modern, fully equipped word processor. I t's
simple enough for a quick memo, powerful enough
to create complete books with contents, diagrams ,
indexes, etc . You're free t o concentrate on your
message, while WRITER makes it look great.
The Auto-Pi/ot takes all the hassle out of producing
standard documents such as letters, faxes, agendas, min­
utes. You are of course free to create your own templates.
The Stylist puts the power of style sheets i n to
the hands of every user.
You're free to add words and phrases to the
AutoCorrect dictionary, which can check your spel l i n g
as y o u type .
AutoComp/ete suggests common words and
phrases to complete what you are typing.
AutoFormat takes care of the formatting as you
write, leaving you free to concentrate on your message .
Text frames and /inking mean you are free to lay
out newsletters , flyers, etc . exactly the way you want
them to be.
I ncrease the usefulness of your long, complex
documents by generating a table of contents or index­
ing terms, bibliographical references, i llustrations, ta­
bles, and other objects. You are free to choose your own
email software-WRITER offers direct connection to
email software. Make your documents freely available
with WRITER's HTML export to the Web, or publish
in Portable Document Format ( .pdf) to guarantee that
what you write is what your reader sees. Of course, you
are free to use old Microsoft Word documents, or save
your work in Word format for sending to people who
are still locked into Microsoft products."

We would express
followi ng.

these

more

like

the

WRITER shall be a full - featured word proces­
sor. [t shall allow the creation of simple documents
and complete books with contents, diagrams, i n ­
dexes, etc . A n example is shown i n Figure 1 1 . 3 1 .

273

274

CHAPTER 1 1

ANALYZING HIGH-LEVEL REQU IREMENTS

All e s timate d 6 million people
worl dwi de downloade d the

,0liwaIe, i n ,talled it from CD" or

just acq u i red it from rrie nds,
coUe ges, etc.
The OpenOffice. org

fJ!m.moY!tx

have listened to their feed b a ck ,
fixe d t h e i r b u g reports, an d are
proud to an n o u n ce versi o n 1 . l .

OpenOlice.or9 1.1 gNeS � aI tJe ofICe bois )IOU need in one
easy-to-use suie

O u r world d as s software package
has got even bel te r - and it's still
free!

Exports to

Th� �1f.Jn-one oKlee

sottW01re piKbl/e fot
beginners �nd potIN, users

:J!!!J formM. �nd i
In ,w

iI,."hlcs fles
(R.sh)
form., with no M1ditiOtl�1
soltware required

Mike.
Runs on Microsoft

",r.II,.,Hl DM�b�se Us.

Windows 'Sj!J8!2000/XP,

TooIs lllve you

I

I

I

Figure 11.31 Exa mple of document open in WRITER
Source: OpenOffice, http://www.openoffice.org/productlpixlwriter·big.png.

WRITER's Auto-Pilot feature shall facilitate the
creation of standard documents such as letters, faxes,
agendas, mi nutes. The Stylist feature shall allow the
user to easily vary the style of a document. The
AutoCorrect dictionary feature shall check spelling duro
ing or after test entry. The AutoComplete feature shall
suggests common words and phrases to complete a
partially typed sentence. The AutoFormat feature shall
handle formatti n g while the user enters text. The text
frames and linking features shall allow the user to
flexibly format newsletters, flyers, etc .
WRITER shall generate a table ofcontents, indexes,
bibliographical references, illustrations, and tables. It
shall provide direct connection to e-mail software, export
HTML to the Web, publish in Portable Document
Format, and save work in Microsoft Word format.

requ i rements i n an appl ication c a l l e d ( rather
un poetical ly) Issuezilla . I ssuez i l l a consi sts o f
"i ssues . " An i ssue c o u l d be a b u g b u t i t coul d
also be a task. Th is i s s i m i l ar to Ecli pse's
use of Bugzi l l a . Some O p e n O ffice proj ects
have created m o re careful require m e nts
documents. For exam ple, the OpenO ffice
PROJ ECT Management Toolset ( draft at 5 )
a n d the Open O ffice B i b l i ogra p h i c module
( draft at 6 ) .

5

http://oopm . openoffice. org/fl les/documen ts/ l 77/

1 8 4 3/0 0 PM_Requirements_Discussion_DrafcA 1 a . pdf as

We w i l l s k i p additional req u i rements for
O p e n O f fi c e . It carries many of its deta i l e d

of 2005.
6 http://www.geocities.com/manish_k_agrawaIlBibJio_

req .html as of 2005 .

EXERCISES

11.14 SUM MARY
This chapter has described the process whereby the high - l evel requirements for a product are obtained and
recorded in a man ner clear to the customer and developing organization. H igh -level requirements describe
the purpose of an applicati o n , its i n tended functionali ty, and i ts benefits. The high-level requirements are
documented in a form such as Sections 1 and 2 of IEEE 8 3 0- 1 99 3 Software Requirements Specifications.
Various techni ques for eliciting and recording high -level requirements are used. One way to gather
requirements is to i nterview stakeholders and potential customers .
A combination of text and diagrams is used to document the requirements. The following guidelines can
be used to choose the appropriate form .
•

•

•

•

If a requirement is simple and stands alone, express it in clear sentences with i n an appropriate section of
the SRS .
I f a requirement is an i nteraction between the user a n d the application, express it v i a a use case .
I f the requirement i nvolves process elements, each taking i nputs and produci n g outputs, use a data
flow diagram .
If a requirement i nvolves states that the application can be in (or parts can be i n ) , use a state transition
diagram. States often correspond to GUls.

Use cases are widely applicable for describing customer requirements because they capture user
applicati o n interactions. If a state transition diagram expresses what the customer wants and needs and the
customer understands the diagram, then its use is appropriate . The same holds for data flow diagrams .
User interfaces are specified a s part of t h e high-level requirements. Two important princi ples for
defining high - l evel user i n terfaces are to ( 1 ) know your user and ( 2 ) understand the business function i n
questio n .
High- level requirements for agile proj ects are collected continuously through most of t h e l i fe of the
project. Each requirement is expressed with a user story. A user story is a high - l evel piece of required
functionality as seen by the anticipated user.

11. 1 5 EXERCISES
1 . Describe i n your own words the di fference between customer wants and customer needs. Provide an
example that illustrates the difference .
2 . List four of what you consider to be the most important high-level requirements for an application
that tracks bar-coded i nvoices with i n a company.
3. Interview two separate people about their high - level requirements for the bar-code application
speci fied i n Exercise 2 . Compare the requirements gathered from each i nterviewee. H ow similar or
di fferent an appl ication did each of them envision? How did it compare with the high - level
requirements you generated? Write a paragraph summarizing the similarities and differences, the
importance of i nterviewi ng di fferent stakeholders for their vision of a software applicati o n , and
how you might reconcile the di fferences.

275

276

CHAPTER 1 1

ANALYZING HIGH-LEVEL REQUIREMENTS

4. What is a use case? Is the following a use case? Why or why not?

'The system shall provide advice for the begi nning Windows user on how to execute
Windows operations."
5 . Write a use case for one o f the high - l evel requirements l isted i n Exercise 2.
6 . Why is it important to show customers preliminary sketches o f CUls as early i n the development

cycle as possible? Cive what you consider to be one or two of the most important reason s .
7. Your customer needs t o spec i fy user interfaces. Discuss two or three of each of t h e pros and cons of
the following means for doing this i n the context of the application ( large or small) and the nature
of the CUI (complex or simple).
a . Sketching using hand drawi ngs , your own or drawn by a graphic artist
b . Sketching using graphics tools, such as Paint or PowerPoi n t
c . Using t h e C U I - building features o f t h e target language of t h e application
8. Draw a data flow diagram to express the high -level requirements of an application that tracks the
flow of orders within a company.
9. Consider an application that manages patients i n a doctor's office . Patients call for an appointment
and their i n formation is entered into the appl ication. Patients can call to reschedule or cancel
appoi ntments . After a patient is seen by a doctor, the patient may be referred to another doctor for
treatment if necessary. Draw a state -transition diagram to express the high-level requi rements for
this appl ication .

TEAM EXERCISES
T1 1 . 1 Write the high-level requirements for an application decided upon by the team. Follow the form of
IEEE8 3 0- 1 99 3 . Track the amount of time spent doing this exercise. Decide what fraction of the requirements
are understood by the team. Estimate how long it would take to obtain 95 percent of the requirements. State
how the process you used could have been improved. Be specific, and provide examples.

TI I .2
a. Identify an i ndividual outsi de the team who needs a m odest appl ication. You will be gathering high­
level requirements from this i n dividual, then showing them to him or her.
b . With your "customer," identify metrics for how he or she will evaluate your high-level
requirements. Also determine the time limit for an i n terview ( e . g . , a half hour) .
c. Interview the customer, and write the high- level requirements.
d. H ave the customer evaluate and comment on your high -level requirements in accordance with the
chosen metrics.

BI BLIOGRAPHY
1 . Dennis, Alan, Barbara Wixom , and David Tegarden , "Systems Analysis and Design with UML Version 2 . 0 , An Object-Oriented Approach, " John

Wiley & Sons, p . 1 39, 2005 .

BIBLIOGRAPHY
2 . Jacobson, Ivar, "Object Oriented Software Engineering, A Use Case Driven Approach, " (Addison -Wesley Object Technology Series), Addison­
Wesley, 1 994.
3. Fowler, Marti n , "UML Distilled Third Edition, A Brief Guide to the Standard Object Modeling Lang uage, "Add i son - Wesley, p . 99, 2004.
4. J acobson , Ivar, Crady Booch and James Rumbaugh , 'The Unified Software Development Process, " (Addiso n - Wesley Object Technol ogy
Series ) , Addison -Wesley, 1 999.
5 . Alexander, lan, and Neil Maiden (Editors ) , "Scenarios, Stories, Use Cases, Through the Systems Deoelopment Life-Cycle", John Wiley & Sons,
2004.
6. Davis, Alan, "2 0 / Principles of Software Engineering, " McCraw Hill, 1 99 5 .
7 . Wiegers, Karl , "Software Requirements, " Microsoft Press , p p . 1 9 3-4, 200 3 .
8 . "IEEE Recommended PractiC!! for Software Requirements Speci fications," IEEE Std 8 30- 1 998, June 1 998.

277

Ana lyzi ng Deta i l ed
Req u i re m e nts

�

Testing

Maintenance
The Software
Development
L ifecycle

Implementation

Planning

What ways are there to organize detailed
requirements?
How do you express user interfaces in

\

Requirements
analysis

� DeSign /

detail ?
H o w d o you express security requirements
in detail?
What kinds of error conditions can be
specified?
What is traceability and why is it important?
What ways are there to prioritize
requirements?
Why associate requirements with tests?
How do agile methods relate to detailed
requirements?
How do you use tools for requirements
analysis?

Figure

12 .1 The context and lea rning goa ls for this chapter

THE MEANING OF DETAILED REQUIREMENTS

After high - l evel requirements are specified, typically for an iteration, the next step in requirements
analysis is to define the detailed requirements. The purpose of detailed requirements is to provi de the reader
with absolutely all that's required of the applicati o n . With one exception, there is nowhere else for the team
to state exactly what this consists of. For example, if we do not state here that the title of a video must appear in
a 1 6-point font on the monitor, then we assume that this will not appear in the product.
The "exception" mentioned above refers to the possibility of either stating each detailed requirement as
a comment i n the source code or of expecting source code and its unit tests to effectively spec i fy the
requirement. This tends to be the approach o f agile projects, which we discussed previously. Agile projects do
not rule out the kind of documentation that we discuss in this chapter, but they value working code ahead of
such separate documentati o n .
This chapter concentrates on written detailed requirements. However, whether o n e writes down
detailed requirements in these ways or not, there is no choice but to eventually think them through . In fact,
they form a common currency of applications, as it were . Detailed requirements are usually divided into
sections, including functional requirements, nonfunctional requirements, and CUI details.

12.1 THE M EAN I N G OF DETAILED REQU IREMENTS
Detailed requirements provide software engineers with a basis for design and implementation . They are
sometimes called "specific requirements," "functional speci fications," or "developer requirements . " Detailed
requirements consist of a complete list of spec i fic properties and functional ity that the application must
possess , expressed in complete deta i l . Each of these requirements is labeled, and tracked through imple­
mentation. Detailed requirements are consistent with , and elaborate upon, the high -level requirements. They
are i ntended to be read primarily by developers-however, customers are interested in them as well , and
should be able to understand and comment on them with few exceptions. Recall that the primary audience for
the high - l evel requirements consists of customers .
As the case studies in this book demonstrate , when it comes to software engineering, "the devil is in the
details." For example, in 1 999 NASA lost a weather satell i te worth a reported I $ 1 25 million, reportedly
because control data they had assumed to be in metric form was not [ 1 ] .
. . . the root cause for the loss of the MCO spacecraft was the failure to use metric units in the
coding of a ground software file, "Small Forces," used i n trajectory models. Specifically, thruster
performance data in English units instead o f metric units was used i n the software application
code titled SM_FORCES (small forces ) . A file called Angular Momentum Desaturation (AMD)
contained the output data from the SMJORCES software . The data i n the AMD file was
required to be in metric units per existi ng software i nterface documen tation, and the trajectory
modelers assumed the data was provided in metric units per the requirements 2
This description implies that the requirements stated the need for metric units but the software did not
implement the requirements correctly. A fascinating fact is that this defect was identified within mere days after
the disaster. Thi s means that it may not be hard to locate a defect once we know it is present. The problem is often
our i gnorance of its presence. The detailed requirements form the first line of defense against the corruption or
omission of details. Far from being the mindless activity that it m ight first appear, getti ng all the requirements
down in complete detail involves the difficult tasks o f organizing people and their thought process . To
understand this challenge, imagine the task of organizing a 20-volume requirements document set so effective
I

http ://news .bbc . c o . ukl l /hi/sci/tech/5 1 476 3 . stm .

2

ftp :!lft p . h q . nasa. gov/pub/pao/reports/ 1 999/MCO_report. pdf.

279

280

CHAPTER 12

ANALYZING DETAILED REQUIREM ENTS

that a NASA engineer, for example, would know exactly where to add or look for a specific requirement. Stori ng
and mai ntai ning these requirements i n a searchable database helps a great deal , but the task remains difficult
i n deed.

12.2 ORGAN IZING DETAILED REQU IREMENTS
Requirements change constantly, and so wri tten requirements should be wel l - organized and easy to update.
To appreciate the value of carefully organizing detai led requirements, consider the following rather random
attempt at writing detailed requirements for the Encounter game. Note that these requirements are still raw
and are not inspected.
Every character in the Encounter video game shall have a name .
Every game character has the same set of qual ities, each with a floating point value .
Encounter shall take less than a second to compute the results of an engagement.
Each area has a specific set of "qualities needed." For exam ple, combat areas require strength and
stami na; l iving rooms require sensitivity and intellect.
When two Encounter game characters are in the same area at the same time they may either choose or
be obliged by the game to engage each other.
Every game character shall have an amount of l i fe points.
The sum of the values of qualities of a game character relevant to the area in question shall be re ferred to
as the character's area value . In an engagement, the system compares the area values of the characters
and com putes the result of the engagement.
The name of any character i n Encounter shall have no more than 15 letters .
As it grows, an unorganized list l ike the one above quickly becomes unmanageable.
•

•

Its very size makes it hard to understand as a unit even before it grows into the hundreds, i f not thousands.
The requirements are of m ixed types: performance requ i rements must be dealt with di fferently from
functional requirements, for example .

•

Some requirements naturally belong with related ones.

•

It is difficult to locate a specific requirement.

Functional detailed requirements can be organized according to several claSSifications, including by
feature, use case , C U I , state, and class. We describe each method in more detail in subsequent sections. Tools for
managing requirements can help a great deal . Nevertheless, the decision as to how to organize detailed
requirements i n the first place is important because teams refer to them continually i f the document is well done .
The IEEE standard 8 3 0- 1 998 provi des document templates for several ways to classify the detailed
requirements . Figure 1 2 . 2 shows the conventional and the object-oriented classification templates of the IEEE
8 3 0- 1 99 8 standard. The object-oriented classification uses classes/objects as a method of organizing the
functional requirements . The SRS is often tailored to corporate or team needs by adding or modifying
sections as appropri ate. For example, the 00 organization lacks a section equivalent to 3 . 4 i n the non-OO
organization "Iogical database requirements." The Encounter case study uses a modified form of the IEEE 0 0

ORGAN IZING DETAILED REQUIREMENTS

3.

Specific requirements (non-OO )

3. 1
3.2
3.3
3 .4
3.5

Performance requirements

3.6

Software system attributes

External interfaces
Functional requirements

Specific requirements (00)

3. 1

Logical database requirements

3.6. 1
3 .6.2
3.6.3
3 .6.4
3 .6.5

Standards compliance
Reliability
Availability
Security
Maintainab i lity
Portabi l i ty

External interface requirements

3. 1 . 1
3 . 1 .2
3. 1 .3
3 . 1 .4

Design constraints

3.5. 1

3.7

3.

3.2

User interfaces
Hardware interfaces
Software interfaces
Communications interfaces

Classes/Objects

3.2. 1

Class/Obj ect 1
3 . 2 . 1 . 1 Attributes
3 . 2 . 1 . 2 Functional requirements
3 . 2 . 1 . 3 Events . . .

Organizing specific requirements

3 . 7. 1 System mode - or
3 . 7 . 2 User class . - or
3 . 7. 3 Objects (see right) - or
3 . 7 . 4 Feature - or
3 . 7.5 Stimulus - or
3 . 7.6 Response or
3 . 7 . 7 Functional hierarchy - or

3.3
3.4
3.5
3.6

Performance requirements
Design constraints
Software system attributes
Other requirements

_.

3.8

Additional comments

Figure 12.2 IEEE 830- 1 998-specific req ui rements, 00 and non-OO organ izations
source: IEEE Std 830· 1 998.

style and includes a section for use cases. Figure 1 2 . 3 maps the detailed requirements sections of Section 3 to
the requirements category it describes.
It may be advisable to organize detailed requirements i nto a combination of classifications. For example, a
feature -based organization could be used within the configuring, executing, and backing up states of an accounting
applicati o n . The requirements for a factory automation system could be organized at the highest level by
function ( intake, part manufacturing, and assembly); they could then be organized by class with i n each.
This means the method of organizing detailed requirements is sometimes related to the probable
architecture or implementation of the application. For example, if the design is to be object-oriented, detailed
requirements organized by use case or class should be considered because they facilitate traceability. I f the
application lends itself to an obvious functional breakdown, then organizi ng the requirements by feature h ierarchy
may be appropriate.

12.2.1 Organizing Detailed Requirements by Feature
The oldest manner of organizing detailed requirements is by feature . Th is amounts to providing a simple list
of functional ity such as the followi ng, for the Encounter video game. Many features are defined by a stimulus­
and-response pair, as for requirement 1 2 7.

281

282

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS
3. Specific requirements
3. 1 . Extemal interface
requirements

-------ill nterface requirementsl

3 . 1 . 1 . User interfaces
3. 1 .2. Hardware interfaces
3. 1 . 3. Software interfaces
3. 1 .4. communication
Interfaces

3.2. Classes/Objects

�

Functional requirements

I

-see section tbd-

3.3.
3.4.
3.5.
3.6.

Performance requirements
Design constraints

Other nonfunctional

Software system attributes

requirements

Other requirements

Figure 12.3 IEEE 830-1 998-specific req uirements, 00 style interpreted as fu nctional and nonfunctiona l deta i led
req u i rements
Source: IEEE Std 830- 1 998.

1 2 5 . There shall be a set of hyperlinked locations at every exit to every area.
1 26 . The foreign character shall move from area to adj acent area at random times, with an average of
three seconds.
1 2 7. When the user clicks on the "Set qualities" button , the window in figure xx appears on the monitor.
Arranging requirements by feature has the advantage of simplicity but the di sadvantage of in­
accessibility; this is because it allows jumping from a feature in one part o f the application to a feature
in a completely di fferent part. For example, if we wanted to change the manner in which the foreign character
moves about, we would have to determine that the relevant requirement is number 1 26 . How would we know
what other requirements are affected? Search tools can help a great deal . Another disadvantage is the lack of
traceability. For example, what part(s) of the code does requirement 1 2 5 map to?
One way to impose order on functional feature l i sts is to arrange them i n a function hierarchy ( i . e . , by
decomposing the application into a set of high-level functions, and then these into subfunctions, etc . ) . For
example, the requirements for a home budget program could be decomposed into ( 1 ) checking functions, ( 2 )
savings functions, a n d ( 3 ) investment functions. The required checking functionality could b e further decomposed
into checkbook functions, reconciliation , and reporting, and so on.

12.2 .2 Organizing Detailed Requirements by Use Case

Use cases (introduced i n Chapter 1 1 ) exploit the observation that many requirements occur naturally in
operational sequences. For example, an individual requirement such as "a video store appl ication shall allow
entering the title o f a new video" typically takes place as part of a sequence of transactions. A use case diagram
showi ng a collection of use cases for a video store appl ication is illustrated in Figure 1 2 . 4 .
The authors advocate providing use cases for high - l evel requirements. One may have the option of
using this same organizing principle for detailed requirements. In this case we would group the detailed
requirements accordi ng to each use case, fleshing out the steps of each use case i n complete detai l . The
fol lowing is an example of how one such grouping of requirements would appear in the SRS .
3 . 7. 1 Checking in DVDs
Th is is a detailed version of section xx. (Note 1 ; see the "Note" explanations on the next page)

ORGANIZING DETAILED REQU IREMENTS

1. User hits any key
2. System displays main menu

-

1. User swipes bar code
2. System displays due data
3....
1.....
2.
1. User obtains "stock" screen
2. User enters name of DVD
3....

Figure 12.4 Organizing requirements by use case for the video store example

The application shall provide the following capability to interact with store clerks. These
requirements assume that the main screen is on the monitor. (Note 2 )
3 . 7. 1 . 1 Step 1 : Check In button (Note 3 )
The clerk shall be able to hit the Check In button, whereupon the Check In screen will appear
(described in section xx above) .
3 . 7. 1 . 2 Step 2 : Filling i n fields (Note 4)
The clerk shall be able to fill in the following text fields in the Check In screen
3 .7. 1 . 2. 1 Video name field
This field shall allow for 30 alphanumeric characters, including blanks.

Note 1 : This paragraph corresponds to the Checking in DVD use case described in the high-level
requirements.
Note 2: This section introduces the use case and states preconditions, if any. A precondition is a fact
assumed true at the inception of the use case.
Note 3 : This corresponds to the first step of the use case .
Note 4: Since these are the detailed requirements, they must specify the requirements completely. The
details will not be specified elsewhere.
The Unified Software Development Process favors organizing all requirements by use cases. Agile
methods de-emphasize detailed requirements in favor of working code, but they emphasize organization of
requirements by user story.

12.2.3 Organizing Detailed Requirement by GUI
Applications display GUls, and these are the means by which users think of them, so it can be natural to
provide requirements organized in this way. Using this style, the requirements for the Encounter video game
would be something like the following:

283

284

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

1 . Area CU[s
Area CUls shall have the appearance shown in figure xx. When the user clicks on the "Set qua[ities"
button, the window in figure xx appears on the monitor. When the user clicks on
2 . Dungeon CU[ .
3. Living Room CU[
4. Set Quality CU[ .

5. View Qualities Window
The advantage of organizing requirements by CU[ is its direct connection with the use of the application.
Another advantage is traceability: we have a good chance of tracking the requirements associated with a given
CU[ class. One disadvantage of this means of organization is that it often fails to cover all of the requirements. [n
the Encounter example, we need to describe the requirements for the interaction of the player's character and
the foreign character. No CU[ paragraph is a natural container for this. Perhaps the closest is "Area CU[s."
However, this is not a suitable place for specifying the manner in which characters exchange points. Another
disadvantage is that given functionality is often associated with several CUls.
As an example, Figure 1 2 . 5 illustrates an organization of the video store requirements by CU I.
Specification of individual CU[s is discussed further in Section 1 2 . 3 .

3.1 Selecting Procedures

Stock DVD

The GUI for selecting procedures shall be as shown in
Figure 1. It shall be possible to select from the
following procedures by clicking on a radio button,
followed by the "go" button....
Select Procedure
SlockDVD
Register customer
Check oul DVD
Check inDVD

@
@
@
@

Title

Figure 2
Number of copies

c::;]

II com... I

3.3 Checking out DVDs

Figure 1

The GUI for checking out DVDs shall be as
shown in Figure 3. It shall be possible to ...
Check Out DVD
DVD name

�

'---_____....

Figure 3

3.2 Stocking DVDs

The GUI for stocking DVDs shall be as shown in
Figure 2. It shall be possible to enter a DVD into the
system using the GUI in figure... The application
shall save the title-expressed in up to 30
alphanumeric characters-and the number of copies.
The latter shall range between 1 and 100, inclusive.

3.4 Registering Customers

Register Customer
First name

last name

IICommit and - out ovo l S
Figure 12.5 Organizing requirements by GUI, for the video store example

Figure 4

ORGANIZING DETAILED REQUIREMENTS

12.2.4 Organizing Detailed Requirements by State
This style consists of collecting in one place the detailed requirements that apply to each state. For example,
the requirements for an application that controls a chemical process might be best classi fied by the states in
which the process can find itself (starting up, reacting, cooling, etc. ). Within each state classification, the events that
affect the application while in that state are listed. Classification by state can be appropriate when the
requirements for each state are quite distinct. For example, an accounting system may be required to behave
entirely differently depending on whether it is in the confi guring, executing, or backing up state. Although the
Encounter case study requirements could be organized by state, we decided that there are more advantages to
organizing them by class, which we describe next.

12.2.5 Organizing Requirements by Class
In the object-oriented (or "class") style for organizing requirements, a categorization is first performed
equivalent to selecting classes; then the individual requirements are placed into the resulting classes. Classes
used to categorize the requirements are known as domain classes. Domain classes represent real-world objects
or concepts in the application. For example, a banking application would have domain classes such as bank
customer, checking account, and savings balance. A common first step in identifying domain classes is to gather the
nouns or their equivalent used in the high-level requirements. We then make each functional detailed
requirement correspond to a function in the target language. This promotes one-to-one traceability from
detailed requirements to methods. Agile methods use a similar approach in that detailed requirements are
organized by tests of classes.
One disadvantage of organizing requirements by classes is the risk that we later change the classes,
thereby breaking the correspondence between requirements and design. This is discussed by Jordan, Smilan,
and Wilkinson in [2]. In fact, some developers use classes for organizing the requirements but do not seriously
aim to use these classes for the design. In this case, traceability is compromised, but there is less pressure to
identify lasting classes very early in the process. Another disadvantage of this classification is that it requires
us to select classes very early in the development cycle, and many argue that we are effectively performing
design in doing so. Let's look at the Encounter game case study as an example. Picking classes such as
PlayerCharacter and Area at requirements time is harmless since the implementation is very likely to use these
classes. On the other hand, it can be reasonably argued that having the AreaConnection objects reference the
Area obj ects that they connect is a design decision.
The great advantage to organizing requirements by classes that will be used in the design is that it
promotes tight correspondence between requirements, design, and implementation. This is a key benefit for
using the 00 paradigm in any case. In addition, classes that correspond to real-world concepts are much
more likely to be reused than those that do not. For many applications, the benefits of using a class-oriented
classification method outweigh its drawbacks in the authors' opinions.
A typical sequence for obtaining functional detailed requirements using the 00 style is as follows:
1 . List the concepts mentioned in the use cases and other high-level requirements (usually, many of the
nouns).
2 . The resulting collection of classes is typically incomplete. Try to uncover remaining "domain" classes.
This process is explained below. Inspect this collection of classes.
3. For each of the classes obtained, write down all of the required functionality of the application primarily
pertaining to that class, as shown in the Encounter case study. This is done in the form of attributes and
functions. For example, "every customer shall have a name" (an attribute listed under paragraph Customers)

285

286

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

1. Obtain domain classes and objects from use cases and high-level
requirements diagrams
2. Add additional essential domain classes
Inspect the resulting collection of classes

3. For each class,
specify the required attributes
specify the required functionality
specify how its objects react to events
draft test plans for each
inspect the results
Inspect against high-level requirements

5. Verify with customer where possible
When complete:

16.

Release

1

Figure 12.6 Road map for detailed requirements using the 00 style

and "the application shall be able to compute the total assets of each customer" (a function listed under
Customers). In the (requirements) document that you are writing, avoid using the term "c1ass." Use
ordinary, nontechnical English. Specify the events that the objects of the class are required to handle.
4.

Inspect the detailed requirements as the process progresses.

5. Ideally, test plans for each detailed requirement should be devised at the same time, as explained below.
6. Inspected the detailed requirements against the high-level requirements.
7. Verify the detailed requirements with the customer.
8. Release the requi rements, or return to Step I for more requirements.
Recall that the primary audience for detailed requirements consists of developers. However, customers
are vitally interested in the details, too. Figure 1 2 . 6 summarizes these steps.
It is a common error when classifying requirements by class to use the language of design instead of
plain English. For example, the following language is acceptable .
It shall be possible to obtain the number of days delinquent on any account.
The following is not acceptable in a requirements document.

getDelim1uentDays() returns the number of days delinquent on the account.
In other words, object-orientation is used here only as an organizing principle for the requirements. The
use of 00 for design and implementation is performed later.

ORGANIZING DETAILED REQUIREMENTS

I Encounter Area Connection I
[ncounter Character I
I Engagement Display I
[ngagement I I Passageway I
I Foreign Character I
�ayer I I Area I (1) list every
reasonable
I Game Character I
� I Combat I candidate class
you can think of
I Player Window I
[Encounter I
(this list). then
�� I Result I (2) drastically cut I Exit Choice Window I
down to a few
[§:oom I � essential classes. I Quality I
@:core I I Connection Hyperlink I
Figure 1 2.7 Candidate domain classes for the Encounter video game

We i dentify the classifying classes carefully and conservatively, identifying the domain classes of the
application. As an additional example, the domain of an application simulating a bank might contain classes
Bank Customer (the corresponding class name in Java or C+ + can have no blanks, of course ) and Teller but not
File or Database-not even Customer or Transaction. The latter are not special to the application in question. Our
goal is to identify a minimum but sufficient set of domain classes that include all of the specific requirements.
Each GU I usually results in a domain class.
As another example of domain class selection, consider an application that manages visits to a Web site .
Some candidate domain classes are Site Visitor, Site Visit, and Site Mission. Requirements pertaining to the visitor
(e.g. , data about visitors, and functionality such as displaying visitor profiles) would be collected with the Site
Visitor classification. If the application requires us to track the reasons for each visit, then a domain class Site
Mission would be appropriate. The corresponding requirements would be collected within Site Mission. For
example, the requirement on the application could be that visitors submit a form stating their goals in visiting
the site.
After identifying classes from the use cases and other high-level requirements, an effective way to
complete the identification of key domain classes is to use a "list and cut" process. This consists of (Step 1 )
listing every reasonable candidate class you can think of, and then (Step 2 ) aggressively paring down the list
to a few essential classes. We elaborate on these steps next.
(Step 1 ) Figure 1 2. 7 shows candidate classes for the Encounter game selected from the text of the high­
level requirements. The Unified Modeling Language (UML) notation for a class is a rectangle containing the
class name .
(Step 2 ) We now filter the classes identified. Note first that it is far easier to add a class later than to
remove one that has become embedded in the design and implementation, so that i f there is doubt about the
usefulness of a candidate class we eliminate it. The rationale used for the final selection of domain classes for
the case study is given next.

Encounter: Change to EncounterGame to make its purpose clearer (we may also need the plain "encounter"
concept as well).

Game: Not a domain class-too general (we may reintroduce this later when seeking useful
generalizations) .
Game Character: Too general to be in the domain (we may reintroduce this later when seeking useful
generalizations) .

287

288

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

Player: Player Character is a preferable name (more specific to the domain) .

Foreign Character: OK (foreign characters act in ways that are different from player characters).
Encounter Character: OK (generalization of PlayerCharacter, ForeignCharacter, etc., is still within the domain
of the application).

Quality: Omit-try to handle as simple attribute of EncounterCharacter.
Room: Omit-n ot sure if we need this; already have Area.
Door: Omit-not sure we'll need it.
Exit: Not sure if we need this; leads to neighboring area. Try as simple attribute of Area-omit for now
Rule: Omit-not sure we'll need it.
Area: OK (The astute reader will note that this decision is defective . )
Engagement: OK
Passageway. We do need to connect areas, but we do not yet know what form these connections will
take. Use EncounterAreaConnection instead.

Result: Omit-it's vague.
Combat: Omit-not sure we'll need it-already have Engagement.
Score: Omit-try as attribute of other classes.
Player Quality Window: This is needed to express the Initialize use case.
Exit Choice Window: Omit-not needed-click on exit hyperlinks.
Map: Omit-not required at this stage (maybe in a future version).
Engagemen t Display: OK-needed by use case though will try to postpone by substituting a command line
interface.
The resulting classes are shown in Figure 1 2. 8. The figure includes the inheritance relationships present
among these classes denoted with a triangle. UML notation is covered in detail in Chapter 1 6.
EncounterAreaConnection
ConnectionHyperlink
(1) list every

I PlayerQualityWindow I
I Engagement I

I EncounterGame I

I EngagementDisplay I
Key:

reasonable
candidate class
you can think of

then (2) drasti­
cally cut down to
a few essential
classes (this list).

A class in design and code, blanks eliminated

Figure 12.8 Classes for the Encounter video game, showing only inheritance relationships

ORGANIZING DETAILED REQUIREMENTS

The classes in Figure 1 2. 8 may relate in ways besides inheritance. For example, Encounter Area Connection
will probably aggregate two Area objects. However, our concern here is only with the core application classes,
using them to organize the requirements. Relationships among classes are shown where necessary. Using
inheritance enables some degree of leverage. For example, after stating the requirements for Encounter Character
we do not need to repeat these requirements in describing Player Character and Foreign Character. The Encounter
Character class is shown in italics in Figure 1 2. 8 because it is abstract-this declares that there will be no actual
characters besides player-controlled and foreign characters.
The IEEE 8 3 0- 1 998 SRS standard designates a place where the purpose of each class is stated,
together with its key attributes and functions. The standard calls for using the decimal numbering system
from each class (e.g., 3 . 2. 5 ) to each of its attribute requirements (e .g., 3 . 2 . 5. 1 ) and each of its function
requirements (e.g., 3 . 2 . 5. 2 ). Instead, we will arrange classes alphabetically to make it easier to add and
remove classes. Such insertions are necessary as the application grows. It is important to number
requirements, however, in order to be able to manage them, so we do this within each class as shown
in the case study.
Sometimes, only "essential" requirements are numbered since only they must be traced for now. A good
reference for this style of organizing specific requirements is Jordan, Smilan, and Wilkinson [2]. To assist in
tracing detailed requirements it can help to give a name to each one, as in the case study. For example:
3 .2.A. 7 Preferred qualities
[essential] Each area shall favor a set of qualities.
Including "desirable" and "optional" detailed requirements is beneficial for several reasons. First, the
scope of the application can be controlled by implementing the requirements in a planned order. Second,
stating future requirements provides direction to designers, helping them to create designs that can
accommodate future features. One technique for indicating which requirements have actually been designed
for and implemented is to start by including a disclaimer with each, as in the following example.
When organizing detailed requirements by class, it's sometimes a challenging issue to decide under
what class to state the requirement. Consider the following requirement example.
Every Encounter character shall have a name . . .
This requirement should be classified with "Encounter Characters." We will explain below the relation
of this with a CUI requirement. The following requirement requires more consideration.
Whenever the player's main character enters an area, that area and all the characters in it shall be
displayed on the monitor.
Class candidates to classify this function are Player Character and Area. The requirement effectively calls
for an event handler. A natural triggering class for handling the entry event would be the area entered because
it is aware of which characters inhabit it. The area entered could display itself and the characters it contains,
so the requirement stated above could reasonably be classified under Area.
We often find it necessary to deal with individuals, aggregations, and CUls centered on a single theme. For
example, for a video store management application, we need to deal with the following.

•

What are the required properties of individual DVDs? For example, what are the length limitations of their
titles?

289

290

CHAPTER 12

•

•

ANALYZING DETAILED REQUIREMENTS

What are the required properties of the collection of DVDs? For example, what is the requirement for
stocking new CUls?
What are the specifications of a CUI that displays information about DVDs? For example, what are the
limitations on the text shown? (CUI specifications often change frequently. )

Thinking ahead, we recognize that these will be separate classes when we corne to design time, so we
organize the requirements document paragraphs to anticipate this. It is usually best to begin with the
paragraph that describes the requirements on the individuals: in this case, DVD. This specifies the required
degree of detail that the application is required to store. It is referenced by other paragraphs.
3.2.oV DVDs

3.2.oV.l Attributes of DVDs
3.2.oV.l.x Director's Name The application shall retain the name of the director of
each DVD. This shall consist of the director's last name, in a form of between 1 and
30 characters, which can consist of a-z, A-Z, and a hyphen. In the case of multiple
directors, only the first-alphabetically-shall be retained.

3.2.oC DVD CUI

The CUI displaying a DVD shall have the appearance of figure xx.

3.2.oC.l Attributes of DVDs
3.2.oC.l.x Director's Name Appearance The director's name shall be displayed in
the location shown in figure xx, in accordance with requirement 3.2.oV. I .X, but
limited to the first 20 characters.

3.2.oC.3 Events Pertaining to the DVD CUI

3.2.oC.3.x OK Button When the "OK" button is pressed

3.2.01 DVD Inventory

3.2.01.2 Functionality of DVD Inventory

3.2.o1.2.x Stocking a DVD The application shall allow new DVDs to be added to
the inventory, up to a maximum of one million .. . .

USER INTERFACES: DETAILED REQUIREMENTS

Organizing
principle

Advantages

Disadvantages

® Does not map well to 00 code

By Use Case

© Maps well to why we are
building the application
© Easy to understand
© Easy to understand

By CUI

© Easy to understand

By State

© Easy to understand
© Design thinking begins early

By Class

© Easy to trace to code
© Easy to locate random
requirement
© Design thinking begins early

By Feature

® Hard to locate random requirement
® Use cases may overlap
® Hard to trace to design and code
® Coverage is limited
® Not every function appears in a CUI
® Functionality of CUls overlap
® Hard to trace to design and code
® Classification can be unclear to the
customer
® Hard to allocate requirements to state
® Classification can be unclear to the
customer

Figure 12.9 Ways to organize detailed requirements-advantages and disadvantages

12.2.6 Classification Methods: Advantages and Disadvantages
Figure 1 2 . 9 summarizes the different ways to organize functional detailed requirements that we discussed in
the previous sections, along with their relative advantages and disadvantages.

12.3 USER INTERFACES: DETAILED REQUIREMENTS
Recall the following steps in specifying user interfaces.
Step 1 : Know your user
Step 2: Understand the business function in question
Step 3: Apply principles of good screen design
Step 4: Select the appropriate kind of windows
Step 5: Develop system menus
Step 6: Select the appropriate device-based controls
Step 7: Choose the appropriate screen-based controls
Step 8 : Organize and lay out windows
Step 9: Choose appropriate colors
Step 1 0: Create meaningful icons
Step 1 I: Provide effective message, feedback, and guidance

291

292

CHAPTER 12

•

ANALYZING DETAILED REQUIREMENTS

Ensure consistency among the screens of designated applications, and among screens within each
conventions; procedures; look-and-feel; locations
Anticipate where the user will usually start
frequently upper left-place "first" element there
Make navigation as simple as possible
align like elements
group like elements
consider borders around like elements
Apply a hierarchy to emphasize order of importance
Apply principles of pleasing visuals-usually:
balance; symmetry; regularity; predictability
simplicity; unity; proportion; economy
Provide captions
•

•

•

•

•

•

•

•

•

•

•

•

Figure 12. 10 principles of good screen design
Source: Galitz, W., "The Essential Guide to User Interface Design: An Introduction to GUI Principles and Techniques," John Wiley & Sons, 1996.

Steps 1 and 2 were described in the previous Chapter 1 1 since they apply primari ly to high-level
requirements. We now describe the remaining steps for specifying detailed user interface requirements,
which are essentially a detailed description of each CUI screen.
Step 3: Apply the principles of good screen design

Figure 1 2. 1 0 lists some major elements of good screen design. The figure includes several factors that often
apply to making an interface pleasing. Although these serve only to introduce the subject of visual effects,
they are nevertheless usable by the average software engineer.
As an example, we apply some of these principles to an example of a screen used to input information about
customers and their accounts. An initial attempt at a CUI is shown in Figure 1 2. 1 1 . To improve the interface, we
start at the top left, placing the most important elements first, and grouping like elements. Figure 1 2. 1 2 illustrates
Type:

checking 0

Branch:

Main S!. 0

Privileges

savings 0
Elm S!. 0

newsletter 0

mmfo

COO

High S!.O

discounts 0 quick loans 0

First name
Middle name
Last name
Street
City
State/county

lOKI

c=J

II Apply I

i cancel l

� Help I

Figure 12. 1 1 Applying principles of good screen design-"Before"
Source: Galitz, W., "The Essential Guide to User Interface Design: An Introduction to GUI Principles and Techniques," John Wiley & Sons, 1996.

USER INTERFACES: DETAILED REQUIREMENTS

New Customers
Name--------,

A ddress --------,

First

Street

Middle

City

11..._____--'
State/county c:=J

Last

- Branch

A ccount

ype

r

0 checking

0 Main St.

0 newsletter

0 savings

0 Elm St.

0 discounts

0 mmf

0 High St.

0 quick loans

0 CD

� I

' '1
pnVleges

Apply

I I Cancel I

Figure 12. 12 Applying principles of good screen design-"After"

the improvement that the application of these principles can bring. Figure 12.13 shows where some of the
principles of good screen design were applied.
Step 4: Select the appropriate kind of windows
Each user interface purpose can be served most effectively by one or two particular types of windows. Figures 12.14
and 12. Islist five common CUI purposes and a window type that satisfies each of them. The window types employ
Windows™ terminology, but are typical.

'New Customers

.------

....

r Name

"""'\

- AntjQjpgJ§J.§!p!1

- - - - :-J!.Ocfress .=-=...-,..-J��'\->------.,,
---,

M Align like elements - -

City

1 ...."". State/co

Last

a

--4
�sJ.![e....kP�tfmC$

. ..... Street

: :: �
-

1

:=J

m=e=nt=s�
o e a=ro=u= n=d=li=ke== el=e=

�___�B= =rd= =r=

se caPtions Account type ----, r Privileges -----,

in s

o ElmSt.
o HighSt.
Y(QJ.!{l

Help

'-

First

[

Expected position

like elements

J

o checking
o

f-"'--'

fu.,mm@Y

o r....,, --

D newsletter
D disc.

Balanc�

D quick loans

o CD
'-------' '-------'

Figure 1 2.13 How principles of good screen design were applied

293

294

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

1. Purpose: display properties of an entity
-- property window
Properties of automobile 189
Property

Value

Brand

Toyota

Model

Camry

10

893-8913-789014

2. Purpose: obtain additional information so as to carry
out a particular task or command
-- dialog window

Figure 12.14 Types of windows, 1 of 2

step 5: Develop system menus

Some rules for the creation of main menus, provided by Calitz [ 3 ], are shown in Figure 1 2. 1 6.
Users require a stable, comprehensible anchor for applications, hence the need for a constant main
menu. The number of items on this menu should usually be between five and nine, because most of us feel
comfortable with choices of this size. For example, the word processor with which this book is being typed
has nine main menu items: File, Edit, View, Insert, Format, Tools, Table, Window, and Help. The number of items
could have been far higher, since there is plenty of space for more. However, we would probably have to
3. Purpose:
provide information
message window
-

4. Purpose:

present a set of controls
palette window
-

ABC controls
File Edit View Fonnat Tools Help

� .. ��
monitor

I-I
5. Purpose:
amplify information
pop-up window
-

disk

keyboard

This is a pop-up
window, designed to
provide on-the-fly
amplification

Figure 12.15 Types of windows, 2 of 2

•

•

•

•

Provide a main menu
Display all relevant alternatives (only)
Match the menu structure to the structure of the application's task
Minimize the number of menu levels

Figure 12.16 Developing system windows

modem

USER INTERFACES: DETAILED REQUIREMENTS

continually search the list for the option we require, and this outweighs the benefit of increasing the choices.
The main menu items are determined by the business at hand-in this case the processing of text. Thus, for
example, graphics commands are placed on a secondary menu.
Step 6: Select the appropriate device-based controls

"Device-based controls" are the physical means by which users communicate their desires to the application.
They include joysticks, trackballs, graphics tablets, touch screens, mice, microphones, and keyboards.
Step 7: Select the appropriate screen-based controls

"Screen-based controls" are symbols that appear on the monitor, by means of which the user notifies the
application of his or her input and intentions. These include icons, buttons, text boxes, selections, and radio
buttons. The rules for arranging screen-based controls in a window are virtually the same as those for screen
design in general (see Figure 1 2. 1 0. Their number is, again, typically between five and nine. This number can
be increased, however, when a hierarchy is used. For example, in Figure 1 2. 1 3 there are twenty options to
select from, but the interface is manageable because these twenty items are organized into six groups.
Step 8: Organize and lay out windows

The rules for laying out multiple windows are similar to those for individual screen design (involving
symmetry, proportion, etc. ) as in Figure 1 2. 1 0, but they involve arrangements such as tiling and cascading.
The latter terms are illustrated in Figure 1 2. 1 7.
Step 9: Choose appropriate colors

When used with skill and taste, color can enhance displays. Colors do not automatically make a user interface
more useful or more attractive, however, and they can easily worsen it. According to renowned designer Paul

,Cascading windows

I-

Tiled

Icon
---

I
\

New Customer

r-- windows -

Text box

- Name
-4
First I
Last

- -

I

Figure 12.17 Common G UI terms

I

-.;]

a

forward

back

,. Privileges -

-.0 checking

o newsletter

o mmf

Source: Graphics reproduced with permission from Corel.

I

- Account type
0 savings
Button --- -

Screen
�

� discounts
-

"'"

- - - � Cancel I I Apply I Checkbox

295

296

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

Rand, "color is complexity personified" [4]. Software engineers who do not have a professional designer with
whom to work should be very sparing and conservative about the use of color. Try black and white first. If
there is a clear purpose to it, introduce one color. Make sure that this helps the user. Think seriously before
adding more colors.
Taking note of well-established applications, such as widely used word processors, can suggest how to
use colors well. You can be assured that experienced professionals designed these interfaces, and the
untrained software engineer can benefit from imitating them. The color blue is common in real-world screens
of all kinds. Symmetry of colors is often recommended, and this symmetry can be of several varieties. For
example, the author's word processor uses mainly three different shades of blue, which occur in a symmetrical
pattern on the standard color palette . The other two colors used are yellow and, to a lesser extent, green.
These are used in small quantities, accenting additional functionality only, and they do not compete with the
major items, which are in black and gray.

12.4 DETAILED SECURITY REQUIREMENTS
Writing the detailed requirements for security measures is a matter of being entirely specific about the needed
security measures. Some of these are shown in Figures 1 2. 1 8 and 1 2. 1 9. When it comes to security logoffs, for
example, we may want to require that if there is no keystroke on the application for ten minutes, it logs off
automatically. Audit trails for security breaches are important. Some of these requirements are easy enough to
specify but difficult to implement. For example, how would an application know that it has experienced a
security breach?

12.5 ERROR CONDITIONS
For each requirement, we ask what would happen if it were to take place under erroneous circumstances. As an
example, let's take a requirement example put forward by Myers [5], as shown in Figure 1 2. 20.

1 . User identification capabilities
Rules on IDs, name clashes, restrictions, etc.
2. Person or entity authentication capabilities
Exact requirements permitting access to resources
3 . Security logoff
Measures to prevent unattended or unusual usage
4. Audit traits of security-related events
Type, outcome, state at the time, date and time, source
•

•

•

•

Figure 12. 18 Detailed security requirements, 1 of 2

5.

Password specifications

6.
7.
8.

Length, composition, allows characters, etc.
Controls t o ensure data integrity
Retrievable record of encryption methods
Information on security attributes of the system
•

Figure 12.19 Detailed security requirements, 2 of 2

TRACEABILITY OF DETAILED REQUIREMENTS

Afunction that tells whether three numbers produce an equilateral triangle (all sides equal), an isosceles triangle (exactly
two sides equal), or a scalene triangle (all sides different).
Figure 12.20 Requirement example, without necessary errors

A function that tells whether a triplet of numbers produces:
1 . an equilateral triangle (whose sides are all greater than zero and equal). in which case it outputs 'E' at the prompt, or
2. an isosceles triangle (whose sides are greater than zero, exactly two of which are equal, and thatform a triangle). in which
case it outputs T at the system, or
3. a scalene triangle (whose sides are all greater than zero, which form a triangle, and that is n either equilateral nor isosceles). in
which case it outputs '5' at the prompt, or
4. no triangle, in which case it outputs 'N' at the prompt.
Figure 12.21 A more complete version, accounting for errors

This requirements specification is not complete because it does not account for error conditions. The
version in Figure 1 2.2 1 is more complete. A lack of error conditions in requirements specifications becomes
especially glaring when the function is tested, since the tester forces error conditions and needs to know what
the required output is.
Sound requirements analysis does not turn a blind eye to "illegal" input: it deals with them directly. For
example, it is tempting to assume that a CUI for the triangle requirement does not permit the input of negative
numbers, and so the function does not have to deal with erroneous data. Such an assumption is unwise because it
transfers the "legality" part of the triangle requirement to requirements on code clients of our triangle function.
This increases the dependence among parts of the application, whereas we always try to obtain independent
parts. Although it is good practice to trap invalid user input at the CUI level and to oblige the user to enter only
legal values, this does not substitute for good requirements and error recognition elsewhere. The authors
recommend requiring the trapping of incorrect data at many, if not all, possible points. This is equivalent to a
long-established engineering practice of practicing redundancy to promote safety.

12.6 TRACEABILITY OF DETAILED REQUIREMENTS
Chapter 1 3 discusses the qualities that we want requirements to possess, and metrics for measuring them.
We will call out one property here because it is fundamental to how we think about requirements:

traceability.
Imagine an application with 1,000 specific requirements. Without a clean trace from each requirement
through the design of the application to the actual code that implements it, it is very difficult to ensure that
such an application remains in compliance with the requirements. When the requirements change, which is
safe to assume, this becomes even more difficult. The capacity to map each detailed requirement to its
relevant part(s) of the design and implementation is called traceability. We first discuss the traceability of
functional requirements, then nonfunctional requirements.
One way to help accomplish traceability is to map each functional detailed requirement to a specific
function of the target language. This technique is used in the Encounter case study. Figure 1 2. 22 shows parts

297

298

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

My-D-Requirement**
Requirement inspection report incorporating My-D-Requirement

Design inspection report incorporating My-D-Requirement
*

Code implementing My-D-Requirement
Code inspection report incorporating My-D-Requirement
Test plan incorporating My-D-Requirement
Test plan inspection report incorporating My-D-Requirement
Test report incorporating My-D-Requirement

* key traces
** 0- detailed
=

Figure 12.22 A thorough trace of an invidivual detailed requirement

of the project that we would like to keep linked to have complete traceability. Achieving and maintaining this
degree of traceability during development is a major challenge.
As an example, consider the following functional requirement for the Encounter video game case study.
When a foreign game character enters an area containing the player's main character, or vice
versa, they engage each other.
The meaning of this statement is clear. What remains to be seen, however, is what part or parts of the
design and code will be responsible for implementing this requirement. When using the 00 paradigm we
can link this requirement to a specific function of a specific class. The issue of what class is responsible for a
function is not trivial, and it arises repeatedly when using the 00 style. For the above example, Area
objects would be able to recognize that an engagement is to take place since they would presumably be
aware of their inhabitants. In particular, this requirement will be traceable to specific event-handling code
for the Area class.
As the project proceeds, the requirements document should be kept consistent with the design and the
implementation. When requirements are hard to trace through design and code, however, developers tend to
avoid updating the requirements document when making changes to the source code because of the extensive
effort required. Ultimately, such a deterioration of documents results in escalating development and
maintenance expenses. This phenomenon is illustrated by the following example.

Developer Bill is asked to make changes to the implementation. Bill finds it difficult to connect the code he is modifying
to the corresponding parts of the requirements document; consequently, he fails to update the documentation.
Developer Carmen is tasked to make new modifications. She implements new code, tests it, and begins updating the
requirements document. However, everyone tells her not to bother, pointing out that the requirements document is out of
date in several places and no one trusts it very much. They tell her it makes no sense to take the time to perfect her part
when no one will read the document anyway. So Carmen moves on to do other programming. The discrepancies
between the requirements document and the code continue to widen.

TRACEABILITY OF DETAILED REQUIREMENTS

Requirement
1783
1784

Module 1

Module 2

Module 3

getinterestO
showAccountO

computeBalO
showAddressO

showNameO
showNameO

Figure 12.23 Example of a requirements traceability matrix

When a requirements document as a whole is untrustworthy, even the most conscientious developer
balks at properly updating his or her particular part. On the other hand, when the documents are clearly
cross-referenced, and management makes documentation a job performance requirement, engineers do keep
them in very good professional shape. In other words, the system used to match detailed requirements with
the designs, and code that implement them, must be very clear and concrete.
When the code implementing a requirement needs to exist in several parts of the implementation,
tracing is achieved by means of a requirements traceability matrix of which Figure 12.23 is an example. Here,
requirement 1783 is implemented by the action of functions getlnterest() in module 1, computeBal() in module 2,
and showName() in module 3. A change in this requirement necessitates a change in one or more of these
functions. This must be carefully managed because these functions may participate in satisfying other
requirements (e.g., showName() is used to implement requirement 1784 as well). As a result, changes made to
satisfy one requirement may compromise another. Since many-to-many relationships are difficult to manage,
we try to make the mapping between requirement and function one-to-one.
We want each detailed requirement to be traceable forward and backward. The preceding discussion
concerns forward traceability of functional requirements from detailed requirement to implementation.
Backward traceability of a detailed requirement means that the requirement is a clear consequence of one
or more high-level requirements. For example, the detailed requirement
Foreign characters should move from area to area at intervals averaging 5 seconds
can be traced back to the following high-level requirement, which was part of Section 2.0 in the SRS.
The rest [of the characters], called "foreign" characters, are to be under the application's control.
This backward traceability is a basis for the inspection of detailed requirements. Complete traceability is
obtained when each detailed requirement is linked to a specific element of deSign, and to a unit test, as suggested
by Figure 12.22. It indicates the advantage of a tight trace (correspondence) between each individual functional
requirement, the part of the design intended to handle the requirement, and the part of the code that implements
it. These are coupled with the focused test for the requirement, called a unit test. Unit tests are the subject of
Chapter 26.
The preceding discussion concerned functional requirements, but how do we trace nonfunctional
requirements? This can be difficult because more than one part of the design and implementation may
contribute to satisfying a nonfunctional requirement. For example, a requirement that every Encounter
engagement complete in less than one second could involve code in an Engagement class, and/or a GameCharacter
class, and/or an Area class. Our objective at requirements time is to specify nonfunctional requirements as
clearly as possible. In order to clarify nonfunctional requirements, we will also touch on design and
implementation issues.

299

300

CHAPTER 1 2

ANALYZING DETAILED REQUIREMENTS

I nspect

----..
�/'

-

/

R e l evant
compone nts

/1

./

./

./

./

./

'"

./

./

./

./

./

I m p l e m e ntatio

./

Implemented by
whole application

t

tests . . .

Nonfu nctional Req u i rement · - - - tested by - - - - .. System Test

Figure 12.24 Tracing and testing functional VS. nonfunctional requirements

One goal of the design phase is to isolate each nonfunctional requirement in a separate design element.
In the case of performance requirements, an attempt is made to isolate time-critical processing units.
Appropriate, inspectable, nonfunctional comments accompany each function that is affected by performance
requirements. Preferably, these are quantitative, as in "must complete in less than one millisecond in the worst
case." Similarly, in cases where storage constraints are specified, we identify functions that generate the most
storage.
Experience shows that a relatively small percentage of functions in an application account for most of
the processing, so searching for a few principal time-consuming ones can be fruitful. Let's return to the "one­
second" performance requirement example for Encounter engagements mentioned above. At design and
implementation time, we seek typical time-consuming components in the computation of engagements.
These components include loops, graphics displays, and network communication. Loops and communication
are not involved in computing engagements, and a test is implemented to ensure that the graphics and CUls
required for an engagement execute fast enough. Probably, the function that consumes most of the time is
either the function to "engage a foreign character" of the Engagement class, or the function to display
engagement results.
To validate nonfunctional requirements we therefore tie each of them to a test plan, preferably at the time of
writing the requirement. Figure 1 2 . 24 illustrates the typical relationship of functional and nonfunctional
requirements to implementation and testing, discussed above. It illustrates the fact that several elements
may contribute to nonfunctional requirements, and that system or integration testing is typically required to
validate nonfunctional requirements because verifying them (i.e. , prior to execution) can be difficult.

12.7 USING DETAILED REQUIREMENTS TO MANAGE PROJECTS
Detailed requirements can be considered the "currency" of a project because they track the amount that's been
accomplished. For example, a project manager can track the project as in Table 1 2. 1 . Recall that it's important
for developers to quickly find relevant requirements sections to enable them to easily keep a requirements
document up-to-date. In the IEEE requirements format, functional requirements are in Section 3. 2. If we were
to number the paragraphs 3 . 2. 1 , 3 . 2 . 2 , . . . , it would be time-consuming to locate the paragraph pertaining
to a Customer class, for example. For this reason, the authors use an alphanumeric labeling such as 3. 2.CU for
Customers, 3. 2.DV for DVDs, etc.

PRIORITIZING REQUIREMENTS

Table 12.1 Example of a table that facilitates the tracing of a requirement
3.2.CU This section concerns the regu irements for dealirlR with video store customers.

Priority ( 1 , 2, or 3)
Im plemented yet? (Y or N )

Attributes
Functions

3.2.CU.1 .1
3.2.CU.1 .2
3.2.CU.2.1
3.2.CU.2.2
3.2.CU.3.1
3.2.CU.3.2

1
2
1
1
1
2

N
Y
N
Y
Y
N

I Events
I I

A required attribute
A required attribute
A required function
A required function
I A required event
I A required event

1 2 . 8 PRIORITIZING REQUIREMENTS
It is usually difficult-if not impossible-to implement all desired functionality of an application on schedule
and within budget. As discussed in Chapter 8, one may trade off capability, schedule, quality level, and cost. Thus, if
the schedule, budget, and quality level cannot be changed, the only alternative is to vary capability-that is,
to reduce the requirements that are implemented. This reduction process is performed in a planned manner.
One technique is to prioritize the specific requirements. Ranking all requirements is usually a waste of time.
Instead, many organizations classify requirements into three (sometimes four) categories. We will call them
"essentiaI." "desirable," and "optional." The use of three categories is an application of triage described in
Chapter 5 . We first implement all of the essential requirements. The desirable and optional requirements
indicate the direction in which the application is headed and thus influence the design. Figure 1 2 . 2 5 gives an
example of requirements prioritization.
Some speculate that as much as 80 percent of the real benefits of many applications accrue from as few as
20 percent of the requirements. Thus, if prioritization is performed well (e.g., calling roughly 20 percent-no
more-"essential'') . one can possibly achieve most of an application's benefit with only a fraction of the work.
This is a useful point to keep in mind if the project begins to run out of time.
The preliminary draft of an SRS shown in Figure 1 2 .26 contains some prioritized detailed requirements for
the first release of Encounter. They are provided here, "warts" and all, to give the reader a feel for issues that must
be dealt with. Some of the "desirables" will become "essentials" in future releases. The requirements are in draft
form and are clearly in need of reorganization. They are improved upon later in this chapter and in the case study.
The prioritization of requirements usually relates to the iteration that will implement them . For
example, if we are not able to implement the "optional" requirement "Encounter shall take less than a second

[essential] Every game character has the same set of qualities.
[desirable] Each area has a set of preferred qualities .
[optional ] The player's character shall age with every encounter. The age rate can be set at setup time. Its default is one year per

encounter.
Figure 1 2.25 Example of prioritization of detailed requirements

301

302

CHAPTER 1 2

ANALYZING D ETAILED REQUIREMENTS

PRELIMINARY DRAFT of Encounter detailed requirements
(These are not yet organized: see the case study for an improved form . )
[not inspected][essential] Every game character in the Encounter video game shall have a name .
[not inspected][essential] Every game character has the same set o f qualities, each having a floating point
value.
[not inspected][essential] Encounter takes place in areas, each of which is connected to other areas by exits.
[not inspected][essential] Whenever an Encounter game character enters an area containing another game
character and one of them is player-controlled, the characters may either choose, or be obliged by the
game, to engage each other.
[not inspected] [essential] Whenever a player-controlled game character is alone, the player can change
the values of its qualities.
[not inspected][desirable] The name of every character in Encounter shall have no more than 1 5 characters.
[not inspected][desirable] At any given time, every game character shall possess a number of living points.
These are the sum of the values of its qualities.
[not inspected ][desirable] Each area has a set of preferred qualities.
[not inspected] [desirable] Combat areas require strength and stamina; living room areas require listening
ability and inte llect.
[not inspected][desirable] The sum of the values of qualities of a game character relevant to the area in
question shall be referred to as the character's area value . In an engagement, the system compares the area
values of the characters and transfers to the stronger half the points of the weaker. For example, suppose
the player engages a foreign character in an area requiring stamina and attention to detail, and ps is the
value of the player's stamina. Assuming Ps + P a > fs + fo. we would have ps' Ps + £/2, Po' Pa + f.l2, fs ' =
£/2, fa' = f/2 where x' denotes the value of x after the transaction.
=

=

[not inspected] [optional] Encounter shall take less than a second to compute the results of an engagement.
[not inspected] [optional] The player's character shall age with every engagement. The age rate can be set
at setup time. Its default is one year per engagement.
[not inspected][optional] Player-controlled characters lose or gain the values of their characters at the end
of every engagement at the rate of + 2 % when under 30 and - 2 % when over 3 0.
Figure 12.26 Preliminary SRS fragment showing prio ritization and status of detailed requirements

to compute the results of an engagement" in the second iteration, it could appear with higher priority in a
subsequent iteration. The requirements for an iteration are maintained in an identi fiable manner. This helps in
understanding subsequent requirements.

1 2 . 9 ASSOCIATING REQUIREMENTS WITH TESTS
As each detailed requirement is written, tests for the requirement should be developed . There are several
advantages to writing tests simultaneously with the requirement. First, doing so helps to clarify the specific
requirement. Second, it shifts some work from the testing phase of the project to the requirements phase. Th is
reli eves some of the pressure on the latter half of the project when there is less flexibility in the use of time.
Agil e processes go one step further, and specify each detailed requirement by means of a test.

AG ILE METHODS FOR DETA ILE D REQU IREMENTS

Test input for Requirement NNN

Expected output

Harry
X
" " (blank)
1 2 34567890 1 2 345
1 2 34567890 1 2 3456

Harry
X
"" (blank)
1 2 34567890 1 2 3 45
1 2 34 567890 1 2 345

Figure 12.27 Example o f association between detailed requirements and their tests

To take an example, one of our requirements is as follows:
Requirement NNN . Every game character in the Encounter video game shall have a unique name
containing between 1 and 1 5 characters.
Requirements of the attribute type like this really specify get- and set- functions, so that Figure t 2 . 27
constitutes the beginnings of a test plan for this requirement. Part VII covers these tests in detail.

1 2 . 1 0 AGILE METHODS FOR DETAILED REQUI REMENTS
In an agile project, the detailed requirements are usually expressed in terms of in-code comments and unit
tests rather than being written explicitly in a separate document. For example, consider a traditional
requirement such as the following.
Customers shall be able to enter the name of a DVD in the text box, up to 20 alphanumeric
characters. The application shall check this, with punctuation marks replaced by blanks, with the
DVD inventory, and display accordingly "Sorry, we don't stock this DVD" or "Added to your list."
This is replaced with one or more tests as shown in Listing t , augmented by code comments and equivalent
data entry in the corresponding CUI. Assume that the setup code in the unit test contains the following:

Listing 1:

Example of J Unit testing, typically used in agile methods

DVD S e a r c h dVD S e a r c h = n e w DVD S e a r c h ( ) ;
p u b l i c v o i d t e s t L o o k up ( )

{
// " G o n e W i t h The Wind '

,

s h o u l d b e p r e s e nt

dVD S e a r c h . d o S e a r c h ( " G o n e W i t h T h e W i n d "

) ;

a s s e r t E qu a l s ( dVD S e a r c h . s e a r c h R e s u l t , t r u e ) ;
a s s e r t E qu a l s ( dVD S e a r c h . o u t p u t M e s s a g e , " A d d e d t o y o u r l i s t ' ' ) ;
,
s h o u l d b e ab s e n t

// " Wa r and P e a c e '

dVD S e a r c h . d o S e a r c h ( " W a r a n d P e a c e "

) ;

a s s e r t E qu a l s ( dVD S e a r c h . s e a r c hR e s u l t , f a l s e ) ;

303

304

CHAPTE R 12

ANALYZING DETAILED REQUI REMENTS

a s s e r t E qu a l s (

dVD S e a r c h . o u t p u t M e s s a g e ,

" Sorry ,

we

don ' t

st o ck

t h i s DVD ' ' ) ;

}

Figure 1 2 . 2 8 summarizes this discussion.
The advantage of using tests as a requirement is that this is concrete; the disadvantage is that it is not
complete . There is nothing to stop us from including thorough detailed requirements with the unit test,
however, thereby gaining agile and, to some extent, non-agile advantages. This is shown in Figure 1 2 . 2 9 .

�
'So
<

§

Z

Customers shall be able to enter the name of a DVD in the text box, up to 20 alphanumeric
characters. The application shall check this, with punctuation marks replaced by blanks, with
the DVD inventory, and display accordingly "Sorry, we don't stock this DVD" or "Added to
your list." (Excerpt from requirements document. )
p ub l i c v o i d t e s t L o o k up ( )

{

II ' ' G o n e W i t h The W i n d "

shou ld b e p r e s ent

dVD S e a r c h . d o S e a r c h ( "

G o n e W i t h Th e W i n d "

II ' ' War and P e a c e '

,

) ;

s h o u l d b e ab s e n t

dVD S e a r c h . d o S e a r c h ( "

War and P e a c e "

) ;

Figure 12.28 Unit tests and code comments as detailed requirements in agile processes

1* R e qu i r e m e n t 3 . 4 . 2 : C u s t o me r s s h a l l b e ab l e t o e n t e r t h e n am e o f a DVD i n
t h e t e x t b o x , up t o 2 0 a lp h anume r i c c h a r a c t e r s . T h e ap p l i c a t i o n s h a l l
c h e c k t h i s , w i t h p un c t u a t i o n ma r k s r e p l a c e d b y b l ank s , w i t h t h e DVD i n ­
v e n t o r y , a n d d i sp l ay a c c o r d i n g l y ' ' S o r r y , w e d o n ' t s t o c k t h i s DVD ' , o r
,
, ' Ad d e d t o y o u r l i s t . '
*1
p ub l i c v o i d t e s t L o o kup ( )

{

,
II ' , Gone With The Wind ' sho u l d b e p r e s ent
dVD S e a r c h . d o S e a r c h ( "

II ' ' Wa r and P e a c e '

G o n e W i t h The Wind "

) ;

, s h o u l d b e ab s e n t

dVD S e a r c h . d o S e a r c h ( "

War and P e ac e '

,

) ;

Figure 12.29 Combining agile and non-agile methods in handling detailed requirements

USING TOOLS AND THE WEB FOR REQUIREMENTS ANALYSIS

1 . Understand next

requirement

o. Understand

high-level
requirements

2. Refactor
code base to

5. Refactor
code-to clean
up, etc.

necessary

4. Modify code

base to pass
the test

3. Write tests

validating the
requirement'

Figure 12.30 The agile programming cycle

When unit tests are used as detailed requirements, they are sometimes written before the code is written.
This style is known as test-driven development. It builds upon the existing code base, and is carried out in the
following sequence.
1 . Understand the required new or modified functionality.
2 . If needed, refactor the code to prepare it for the new functionality. Refactoring preselVes the code's
functionality, neither increasing nor decreasing its actual functionality. It is discussed in detail in Chapter 24.
3. Write test code that would test this functionality if it existed. This is usually done with a tool such as
]Unit. This test will fail initially because the functionality it tests does not yet exist.
4. Add to the code base until the test passes.
5. If necessary, refactor the code base to make it clear and coherent.
Test-driven development is described further in Chapter 27.
Recall that agile development consists of the cycle shown in Figure 1 2. 3 0. Refactoring, described in
Chapter 24, is essential to the process in two ways. It is used to change the form (not the functionality) of the
code base to prepare for the addition of new functionality. It is also used to make the resulting addition fit
smoothly within the application as a whole.

12. 1 1 USING TOOLS AND THE WEB FOR REQUIREMENTS ANALYSIS
Tools can help the process of capturing and managing requirements-for example, by sorting, categorizing,
prioritizing, assigning, and tracking them . One benefit of such tools is to know who is working on what
requirement at what time. Tools can also help to control "feature creep"-the process by which features that
are not really necessary are added to the application. With the appropriate tools, a project leader can more
easily assess the status of requirements analysis. For example, the leader can easily determine the percentage

305

306

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

Status
Reguirement
number

Not

Priority
Optional

Essential

started

Designed
for

Fraction complete Ready for
I nspection
2/3
1 /3
I nspected

Desirable

I ntegration
Unit
tested

tested

ResRonsible
enginee r

Figure 12 . 31 Example spreadsheet for tracking requirements

of essential detailed requirements implemented and fully tested by QA. Bugzilla (sometimes in a version with
the unappealing name "Issuezilla"), an open source tool for managing requirements, was described in the
Eclipse high -level requirements case study. This section also discusses the management of requirements for
simple projects, as well as IBM's commercial Requisite Pro tool.

1 2 . 1 1 . 1 Simple projects
For simple projects, much of this can be performed using a simple Web- based spreadsheet, as illustrated in
Figure 1 2. 3 1 . However, for most reasonably sized projects a requirements tool is essential. The "designed for"
designation in Figure 1 2 . 3 1 indicates that the requirement is accounted for in the design. "Unit tested" means
that the code implementing the requirement has undergone testing in stand-alone fashion. "Integration
testing" means that the application has been tested to verify that it implements the requirement. A table such
as that in Figure 1 2. 3 1 is maintained as part of a project status document that can be attached to the SPMP.
The cells in this matrix could be hyperlinked to relevant parts of the project's documents, thereby
preserving single-source documentation for detailed requirements (i.e. , eliminating duplication). For example ,
.. - - - - - HYRerlink from Java Sou rce
to CorresRonding D-Reguirement Using javadoc
I

I

f**

�

t

<a h ref= " RequAn al\# Engag i n g Fo re i g n C h a racte r " >

Engagement Requirement 1
( " E ngag i n g a fore i g n c haracte r")
<fa>
. . . . I m pl em entation comments . . . .
*f

I

The purpose of this method is stated in SRS.
The purpose is not repeated with the source code.

I
I

p u b l i c engageFore i g n C h a racte r( . . . )

{

Figure 12 .32 Hyperlink from Java source to corresponding detailed requirement using Javadoc

USING TOOLS AND THE WEB FOR REQUIREMENTS ANALYSIS

hyperlinks from the source code to the corresponding detailed requirement can be accomplished with tools such
as}avadoc. }avadoc converts certain}ava source code comments into an HTML document describing the classes
and their methods (see, for example, [6J). By inserting hyperlinks to the SRS within these comments, the HTML
document produced by }avadoc hyperlinks to the SRS. This is illustrated in Figure 1 2 . 3 2 , where the detailed
requirement corresponding to the method engageForeign Character() is hyperlinked from the document that
}avadoc produces from the source code. The use of doclets make this process increasingly convenient.
The trend is for continual improvements in the process by which programmers will be able to more
easily go back and forth between the SRS, the design, the graphical user interfaces, and the source code .

1 2 . 1 1 .2 IBM's Requisitepro™
For substantial projects, professional tools are needed to track requirements. The sheer number of detailed
requirements usually make this necessary. One example is IBM's RequisitePro™ product. The following figures,
describing it, are taken from http://www. ibm.com/developerworks/rational!1 ibrary/5 347.html. Figure 1 2. 3 3
shows a window for setting the properties o f an individual detailed requirement.
RequisitePro allows various views of the requirements as a whole . This helps project managers and
software engineers to manage and track their progress. Figure 1 2. 3 4 is one example.

it

RequIrement 1'ropertIM : RFT24
\ienorII

I

�

�..

I I� 1

ftpdly

l �

Jarb.A..

In_db
ITecIncaI

--.

T)pO:

IV..
lC·u.o
IDmcI HanoI;>

Cmc>Ionce
we Ref"","",, ·

�

- --.

-

-

-

-- - --

-

�

::J j

-

cn:.. 1

:.:1
::J

::J ..:J

I

� I

Figure 12.33 Setting properties of a requirement in IBM's Requisitepro™
Source: IBM, http://www.ibm.com/developerworks/rationalllibrary/5247. html.

ftf1l 1loo T_ _ _ ,., _ � d
lIfT} 1Ioo _ .'••'.n ..... ..._ 10
AFT< 1Ioo T_ _ _ ",, _ iNl o
AFTS 1Ioo T_ _ _ tl_
'II
AFT, 1Ioo SOE _ _ "'�_
RFT7 1Ioo SOE _ _ ... _ _ ... _
IIFTI
SOE _ _ _ "' _ '
RfTt 1100 SOE Ih>Jd bo hViY __ _ '"
�
RfTlO 1loo SOE Ih>Jd _ ... _ -..,. ,
RfTl ' 1Ioo SOE _ _
......
AFT IZ _ .., _ " "-I><I
.... .... _
- 'IfT I ) 1100 _ _ _
,_ "- '"
II<TIl ' 000p0 1)Oot ..-

..

..

..

..

.!l-

-..,
HgHy _

..
..
..

'1'..
-..,.
'1'..
......"
-..,
HgHy _ V..
-..,
'1'..
-..,

..
..

�

r' 1Ioo - ---Figure 1 2.34 A view of a collection of requirements in Requisitepro™
Source: IBM, http://www.ibm.co m/developerworks/rationalllibrary/5247.html.

CUl l
,un
CU ' J
c cu
CU'5
C.. "
CHI
,H'7
CUll
'00"

..

_ _ ""
_ _ 10
0...;., _
- - ,..
-'1'..
00""' _
-00"" _
- _ Y.
0.... _ 1
0.... _
-"" OM _

:

,,.=1

307

308

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

Revision HIstory

10007

10006

1910112002
1010112002

1�

2OIJ2I2OO1

10003
10002

1&11212001
1&11212001

RoIIonaI T... "'""- .._eo wi!> _ ReqUoI.Pro «1d RoIIonaI Rose ,. fadil...
A
... develol>m«t «1d ptOYide ItOCeObIIy botweM _. «1d det9I ....... «1d teo! t""
. O>onges '0 -" """ "",,"obIiy Irla 10 be mori<ed tonpe<i fadillUlg I... V

Figure 12.35 History of a req u irement in Req uisitepro™
Source: IBM, http://WWW.ibm.com/developerworks/rational/library/5247. h tml.

It is possi ble to query this requirements database-i n other words, to obtai n all requirements satisfying a
desired criterion, such as those pertaining to security. As i ndivi dual requirements are worked on by software
engineers, tools l ike RequisitePro ™ allow the "history" to be tracked, as shown in Figure t 2 . 3 5 . History refers
to an account of the work performed to satisfy the requirement at various points in time.
12.12 THE EFFECTS ON PROJECTS OF THE DETAILED REQUIREMENTS PROCESS
Once detailed requirements have been collected, the project documents can be updated to reflect the
improved project knowledge. We will take as an example the required updates to the SPMP, which can be
updated as shown i n Figure 1 2 . 36 .
Detailed requirements are placed under configuration contro l . One issue to be addressed is what level o f
detail should b e counted a s a software con fi guration item ( C I ) . Certainly, Section 3 as a whole ("Specific
requirements") of the SRS (using the IEEE standard) coul d be a CI . Each class could be a CI . Individual
requirements are typically too fine·grai ned to be Cis.
When the list of requirements grows i n to the hundreds, inconsistencies can easily arise. Class i fyi ng
requirements by classes, classes by packages, and packages by subpackages, and the l ike becomes a necessity.
The packages typically correspond to subsystems in the overall organization of the applicatio n .
Although completeness is a goal for which w e strive i n collecting requirements, i t is usually an elusive goal .
For substantial applications, there is seldom a natural "last" requirement-just the last one before requirements
freeze . For this reason, we strive for self-completeness: ensuri n g that all of the requirements necessary to
accompany each requirement are present.
Large -scale projects require i ncreasing organizational formality ( not to be confused with formal methods).
The SRS may have to be divided i nto separate volumes. A single section in our (ti ny!) case study could expand
i nto a 700-page volume. Extensive management work is requi red to schedule the development and inspection o f
detailed requirements. Projects with hundreds o f specific requirements need requirements management tools .
The successful widespread usage of the Java packages has shown, however, that large collections of requirements
are manageable when the functional ity is organized by well-defined packages, subpackages, and classes.
The rewards o f good requirements analysis are substantial . Conversely, the penalties for poor
requirements are substantial too. For example, Faulk [7], reports on a Covernment Accounting Office study
of the Cheye nne Mountain U pgrade project on which "requirements - related problems" resulted in a $600

STUDENT PROJECT GUIDE: REQUIREMENTS FOR THE ENCOUNTER CASE STUDY

Status after
i n i tial draft

Result of updating
after high-level
requirements

Result of updati ng after detailed
requirements

Milestones

I n i tial

More detailed

More detailed

Risks

Identify

Retire risks iden­
tified previously;
seek more risks

Schedule

Very high
level

Preliminary proj­
ect schedule

More detailed: shows class and method
development tasking

Personnel

Designate C­
requirements
engi neers

Engineers desig­
nated for D­
requirements
analysis

Designate software architects

Cost

Crude
estimates

First estimates
based on job
content

Improved estimate using more speci fic
functio n points and/or past experience
with similar requirements

Estimation

I

Retire risks identi fied; identify more risks

l

Figure 12.36 Updating a project upon completion of deta i l ed requirements a n a lysis

million cost overrun, an eight-year delay, and diminished capabil ity. Debates conti nue about the percentage
of l arge projects that turn out badly versus the percentage that turn out wel l . Many large projects do a fine job
of requirements analys is . The author can attest to this from personal experience .
12.1 3 STUDENT PROJECT GUIDE: REQUIREMENTS FOR THE ENCOUNTER CASE STUDY
This section illustrates how the requirements principles covered in this book are translated into practice, by using
the video game case study as an example. It uses the object-oriented style of expressing requirements. Recall that
this organizing style has the advantage of improved traceability and the disadvantage of dim i nished readability
compared with other organizations such as by use case. The case study is continued in subsequent chapters.
1. Preparing

Hal Furness, having been elected the requirements leader, was responsible for organizing the analysis of the
requirements. As per the project organizati o n , Hal was backed up by Karen Peters . They deci ded to gather
requirements in two stages. The first would be primarily from the customer's perspective (high-level
requirements ) , and the second primarily for developers ( detailed requirements ) .
Hal a n d Karen prepared t o gather metrics on the requi rements process . They classi fied the stages of the
process by preparation , interview, write-up, and review. The metrics they chose were dictated mostly by
company policy, and were as fol l ows:
•

Time taken

•

Pages of high-level requirements written

309

310

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

•

Self-assessment of the artifacts on a scale of 1- 10 (not mandated by company policy)

•

Defects found during inspecti ons, as applicable

The reader is referred to Section 4 o f this guide to see these metrics arranged in tabul ar form .
Karen made sure that the system for logging and trackin g defects was in place, and that Hal was
equipped with the documentation of how to use it.
The company's i nvestors considered video games a promising area, and were willing to provide seed money
for requirements analysis and a prototype. It was now Hal and Karen's task to determine with whom to speak to
get high-level requirements. Hal understood that none of the team knew much about video games. He decided to
i nterview people who frequently play games and are i nterested in giving their time for a modest fee . He made
contact with Betty Sims, President of Amateur Garners I nternational , an enthusiastic game player who saw a
bright future for video games as vehicles for fun , community i nvolvement, and education. Betty also knew many
garners. Hal and Karen decided to wri te up requi rements specifications based on Betty's i nput and then show the
specifications to others. The rest o f the team was to i nvestigate other avenues for i nput at the same time.
At a weekly meeting, Hal presented a plan for requirements analysis, as fol lows:
Week 1:

Hal and Kare n : I n terview Betty; begi n drafti ng h i gh-level requirements.
Fern and AI: Seek other candi dates for requirements i nput.
Week 2:

Fern and AI: Report candidates to weekly meeting.
Tea m : Select one or two additional people to supply requirements.
Hal and Kare n : Complete draft of h i gh-level requirements, e-mail to Betty for comments; arrange to
interview the design ated additional people; e-mail existing speci fication to them; create a complete
requireme nts document for i teration 1 ; place under configuration contro l .
Week 3:

Team : Approve the SRS for iteration 1 .
Hal and Kare n : I nterview designated people; edit and expand the speci fication; e-mail to all
i nterviewees; collate responses; edit document, leaving selected issues for team resolution; plan detailed
requirements analysis (see the Part V of this book) .
Week 4:

Team: Provide input on the draft SRS; approve plan for detailed requirements analysis (see Part V ofthis book) .
Hal and Kare n : Write up SRS and e-mail to all interviewees .
Week 5:

Hal and Karen: Resolve issues raised by i n terviewees; write up results; e-mail to team; begi n
implementing detailed requirements process (see Chapter 13).
Team : Inspect high-level requirements.

STUDENT PROJECT GUIDE: REQUIREMENTS FOR THE ENCOUNTER CASE STUDY

Despite the expense, Hal fel t i t i mportant t o have the entire team i nspect the h i gh-level requirements
because of the docume nt's importance. I n general, the team planned to use three-person i nspection team s .
Hal scheduled t h e first i nterview w i t h Betty i n Room 1 428 o f t h e Stewart Building from 1 0 :00 a.m. to
1 1 : 3 0 a . m . He e-mailed her a brief write -up of the project's history, and created the following very simple
agenda.
1 0 : 00 a . m . -IO: 15 a . m . Hal : motives for the project
1 0 : 1 5 a.m . -I 1 : 3 0 a . m . I n terview of Betty: customer requirements
Hal decided not to i ntroduce more details because he wanted Betty's requirements to influence the rest
of the meeting.
2. Interviewing the Customer

Hal and Karen arrived at the interview with Betty, equipped with good sound recording equipment. Betty could
not understand why anyone would want to build a video game unless i t competed with the best availabl e . Hal
explained that this was j ust a first step, to provide the team with experience in this kind of programm ing, to get an
idea of the scope of work required, and to show the i nvestors what coul d be accomplished with a given amount
of fundi ng. Other m otives were to determ ine whether there was any merit to the i deas that video games have
potentially wide appeal, and are applicable to educatio n . After this, the meeting became more focused. The tape
recorder was turned on and Hal and Karen began to take detailed notes .
Betty's contention was that role-playing games ( n ot actio n games) held the most promise for broadening
the player community. She discussed the m i n i mum capabil i ty that a prototype would need. Th is i ncluded
areas where the game characters would engage , ways to get from one area to the other, ways to cause
interactions among characters, and what would happen when the characters engaged. Hal and Karen tried to
separate the issues and features as they arose , into "cruci al for the first iteration," "can be postponed," and
"other" ( i . e . , they used a triage method) . The importance o f the requirements l i sted i n "other" would be
determ i ned l ater.
Given the script-l ike nature of the requirements Betty described, Hal focused on obtaining use cases
from her. He asked her to describe typical scenarios for the gam e . Betty described what happens when two
characters i nteract. Karen took notes and expressed this as a use case-a sequence of actions taken by the
player and/or the game-and then read it back to Betty.
Betty couldn't thi nk of any other scenarios. Hal felt that there must be more, and asked how the game gets
started. This resul ted in a second use case. The third use case that they recognized explained how the player
m oves his character from one area to another. These three use cases seemed to be a satisfactory begi nning. Hal
and Karen felt that there m ight be additional essential use cases, but they would have to gather them later.
Betty, Karen, and Hal sketched a few screens together. One showed a typical e ncounter, and another
showed a screen for entering the qual ities of game characters . There was considerable discussion of the
perspective that the player would have . Betty wanted a player perspective where the view shown on the monitor
is the view seen by the player. Karen felt that the required complexity for that view would take the project well
beyond thei r modest i nitial budget. I t was agreed that a modified from -above view would be adequate for the
prototype . The screen sketches reflected this. They agreed that considerable refinement of the user i nterface
would be required.
Because o f the i nterfaces that they sketched, Karen felt that the game coul d really be understood only by
means of states . Betty was not familiar with this term , but she was comfortable describing what she called the
"modes" of a typical role-playing game, which turned out to be the same concept. Karen and Hal then sketched
out the required states of the game, and reviewed with Karen how the game gets from one state to another.

311

312

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

Hal brieRy considered clari fyi ng the game further by analyzing the Row of data, but soon real i zed that
the data Row perspective added li ttle value.
Karen reviewed her notes with the others . A few poi nts needed correcting, but there was general
agreement on the descri pti o n .
3 . Writing U p the Software Requirements Specification

Hal and Karen divided the task of writing up the SRS by sections. They used the IEEE SRS standard, Sections 1
and 2 (Section 3 consists of the detailed requirements, the process for which is discussed in the Student Project
Guide for Chapter 4). To avoid conRicting write-ups, they made sure that their sections were as independent as
possible. Hal remembered his previous project, where the team spent so much time reconciling pieces written by
different people that it would have been quicker for one person to perform the entire task alone.
They discussed how to prioritize the requirements, because it was becoming clear that otherwise the list
of requirements would become far larger than the team could handl e . Hal wanted to rank them all, but Karen
pointed out that the effort i nvolved would be largel y wasted-most of the top-ranking requirements would
get done anyway, so thei r exact order would not be important. Almost none of the bottom ones woul d get
done, so the time spent ranking them also would be wasted. They deci de d to use a triage method to rank
requirements i n to essential at one extreme, optional at the other, and desirable for the m iddle category
(which simply means neither essential nor optional ) . They felt that it m ight be necessary to rank the desirable
requirements later. This saved a great deal of useless debating time. They described their classification
scheme i n Secti on 2 . 6 of the S RS ( "Apportioning of requirements" ) .
Section 2 . 1 . 1 (concept o f operations, containing the state diagram for the game) took Hal the longest time to
write because he had to translate Betty's informal comments into a concrete form . They tried to cross-reference
appropriate sections of the SRS with corresponding tests even though the tests were still sketchy. This helped to
clarify the requirements themselves, however. When Betty l ooked at the test for Section 2 . ( . (, she recognized that
Hal and Karen did not understand some of the issues. In particular, when the game is in Reporting state and the
foreign character enters the area containing the player's character, the test did not expect anything to happen.
Betty saw this as detrimental and as a way for the player to effectively halt the game. The defect was added to the
l ist of defects with a "major" categorization.
Karen sketched the user i n terfaces using PowerPoint ™ as a drawing tool, rather than building them
with J ava, the target language . She considered PowerPo i n t adequate because the Uls i n this part of the SRS
are meant to be sketches-the detailed Uls are specified i n Section 3 -and, in any case , they were li able to be
changed a great deal. Th is helped Hal and Karen to show the sketches to Betty and the others, obtai n
feedback, and then specify the Uls exactly for the detai led requirements.
4. Following Up

The SRS Sections 1 and 2 were e-mailed to Betty. She realized that Hal and Kare n had i ncluded only two of
the three use cases, and the third use case describing movement of the player's character was absent. Th is
defect was logged with a high priority.
Betty was surprised to see that the SRS di d not reRect several issues that she thought she had made clear
were important, and was humbled to see that the SRS reRected "requirements" that she h ad offhandedly
mentioned but now realized would be a waste of time. The latter i ncluded the ability of the player to change
outfits while an engagement is progressing. She had numerous comments, most of which Hal and Kare n
responded to, and some of which were added to the list of defects. Hal e-mailed the SRS Sections ( and 2 to
the team to enab l e them to prepare for an i nspectio n .
Team leader E d h a d learned about Arl an Howard, a marketing executive who was very fam iliar with the
video game industry. The financial backers were willing to fund further requirements analysis at the customer
leve l , and Hal and Karen prepared to meet with Howard. The latter was not able to grant them more than h al f

STUDENT PROJECT GUIDE: REQUIREMENTS FOR THE ENCOUNTER CASE STUDY

Th is project II
norm

Preparation

Interview

Write-up
( results of
i nspectio n )

Time spent
( m i nutes)

200 mi nutes

170 mi nutes

2 70 mi nutes

250 mi nutes

% Time spent

250/8 90 =
2 8 %1120%

1 70/890 =
1 9%1/23%

2 70/890 =
30%1127%

200/890 =
2 2%1129%

organization

Quantity
produced

15 pages

Productivity
( Timel
quantity)

1 5/ 1 4. 8 =
1 . 0 1 pgs/hrll
0.95

=

Sel f-assessed
qual ity
( 1 - 1 0)

9

5

Total
14. 8 hours

2

1 . 3 per pagell
t .01 per page

Defect rate

Process
i mprovement

9

Review

Spend ",20%
less time
prepari ng

Spread interview time
more evenly
among people

Check material more thoroughly prior to
inspection

Spend ±30%
more time
reviewing

Figure 12.37 Example of postmortem data a n d a n a lysis

an hour si nce he was very busy. Karen developed a prioritized l ist of questions and topics and mailed them
and the existi ng draft of SRS Chapters 1 and 2 to Howard. They plan ned to wrap up the high-level
requirements with Howard. The team also planned the process of developing the detailed requirements.
5. Metrics and Postmortem for High-Level Requirements

The high - l evel requirements were subjected to an i nspectio n by the entire team and the defects were
recorded. For the next weekly meeting, Hal and Karen summarized the metrics as shown in Figure 1 2 . 3 7. The
team agreed on the postmortem observations shown.
6. preparing for Detailed Requirements
Hal and Karen had completed their write-up of the h i gh-level requirements, based on discussions and
i n terviews with Betty Sims and Arlan Howard. They used the I EEE standard, whose headings prompted them
for the nonfuncti onal requirements such as GUls , performance, and hardware platforms. Now they had to
identify the manner in which they would organize the functional Detailed Requirements. They anticipated
having to revisit and update the SRS many times, coordinating the design and code with it: they wanted this
process to be as simple as possible. As a result, their major criterion was the abi l i ty to easily maintai n
consistency between the SRS, the design, and the code.

313

3 14

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

They first discussed organizing the detailed requirements by states and actions, based on the state ­
transition diagram described i n the h i gh -level requirements. This organ ization method would consist of a list
of the actions that a player would take, such as clicki ng an exit hyperl ink on an area, followed by the effects of
this actio n . They both agreed that this would be an understandable organization, but decided that it would
not trace to the implementation as well as they wanted. They began searching for other ways in which to
organize the detailed requirements.
Hal was i n favor of organizing the functional detai led requirements by use case, especially si nce he
wanted to follow the Unified Software Development Process. He said that, at this stage, the video game could
most easily be thought of i n terms of the setting up use case, the moving among the game areas use case, and the
engaging the foreign character use case. He pointed out how convenient i t would be to use just these three use cases
as the total extent of the functional requirements. He was also excited about the prospect of perhaps bei n g
able t o reuse these u s e cases for spec i fying future games.
Karen agreed that the requirements would be quite easy to understand i f organized by use case, but she
had several objecti ons. The first was that some requirements would be part of more than one use case. An
example is what happens when an exi t from a room is clicked. This could be part of all of the three use cases
they had identified, and so i t would not be clear where to look for it. Karen's other obj ection was the fact that
mapping from the use cases to the code would not be as clean as the organization she had i n mind. Finally, she
pointed out that the organization was not yet equipped to properly archive use cases for future reuse.
Karen wanted to organize functional use cases by class, which, she said, facili tated traceability from
requirements to implementatio n . She wanted to pick them carefully enough to ensure that they would be used as
part of the design (and implementatio n ) . Hal poi n ted out a disadvantage of this approach: the fact that it forced
them to deci de very early on some of the classes that they would use i n implementing the applicatio n . He was
worried about the possibili ty that they may later change their m inds about the selectio n . After further
discussion, they decided that organizing the detailed requirements by class had more benefits than drawbacks,
and they committed to this method. They decided to be very conservative about class selection, however.
7. Classifying the Detailed Requirements
Hal and Karen first took each use case, and identified what object of what class ini tiated the action and what
object has the responsibili ty for carrying out the actio n . This process prompted them to create and/or identi fy
classes. They found it necessary to call Betty and Arlan several times to clarify use case steps they thought
they had understood but really didn't.
Hal listed the classes and obj ects mentioned i n the use cases . They then brainstormed, scouring every
aspect of Encounter they could reasonable imagi ne for addi tional possible classes . As a final step in the class
selection process, they drastically cut the list down to an essential few, but taking care to preserve all of the
classes referred to i n the use cases . The final list consi sted of Area, EncounterCharacter, EncounterGame, Engagement,
EngagementDisplay, ConnectionHyperlink, Foreign Character, PlayerCharacter, and PlayerQualityWindow.
They now finalized the headings of the SRS in Section 3 . 2 ("Specific requirements") . They collected the
detailed requirements related to areas in Subsection 3 .2.A, corresponding to the Area class. They ordered these
subsections alphabetically because they antici pated adding classes later. They surmised that if they were to have
ordered topics by number ( e . g. , PlayerCharacter being 3 . 2. 14) , then locating an individual requirement would
have been more difficult, because the user of the SRS would have to search many of the 3 .2.N subsections be fore
finding the one applicable . The next class being EncounterAreaConnection , they numbered the next subsection 3 . 2.
EAC, and so on. Within each classification, they created subsections for attributes, entities, junctionality, and events.
8. Writing the Detailed Requirements
Karen and Hal wrote Section 3 . 1 on user interfaces by fill i ng in details on the sketches they had made for the high­
level requirements, then asking Betty, as well as the human factors department, to review them. Knowing that this
would be the final document from which these were to be built, they had the customer agree on every detail.

CASE STUDY: DETAILED REQUIREMENTS FOR THE ENCOUNTER VIDEO GAME

They checked their i n terview notes with Betty and Arl an as to the properties ( "attributes") of each
classi ficati o n (class). For example, they asked what properties were required for the connections between
two E n counter areas. ( O n e property o f such connections was "the first area" connected, and another was
"the seco n d area.") For each class, they asked themselves what enti ties ( i n stances of the class) were
requi red for the gam e . For exam p l e , there would have to be a dressing room area and a courtyard are a . They
then asked what functio nal i ty the cl ass had to posses s . For exam p l e , a functi o n a l i ty o f each Encounter
character i s the abi l i ty to c o n fi gure the values o f i ts qualities ( requirement 3 .2 . E C3.2 ) . F i n al ly, they l isted
all o f the eve n ts that i ns tances o f the c lass were req u i red to respond to ( for example, clicking o n an exit
from a n area) .
One aspect that disturbed them was the time required for new values to take e ffect. They realized that
this was a key aspect to the game: if no time were to elapse, the player would simply set the qualities
pertaining to the current area to a maximum , and l i ttle skil l would be required to play the game. The delay
made the game i n teresting, but the problem was, how much delay should there be? They considered stating
"to be decided" for the duratio n , but fi nally concluded that thi s would not help . They deci ded to spec i fy four
seconds, feeling that changing this amount should be straightforward.
Karen was concerned about the i mprecision of some of the requirements, especially those concerni n g
t h e manner in which quali ty points should be exchanged when two characters engage each other. She felt
that programmers could easily misunderstand the requirements. This would waste time on defects and
produce a defective game. She suggested using Z-speci fications. Hal made the point that n o one except Karen
would understand them well enough , since the rest of the team did not have the required educatio n .
They compromised by agreeing t o use appropriate mathematics i n spec i fying this requirement, b u t n o t the
Z-spec i fication format. Karen made a mental note that if she ever taught software engineering, she would
insist that all students to be completely comfortable with Z-speci ficati ons.
Prompted by the section headi ngs in the IEEE SRS standard, Karen and Hal made sure to cover all of the
performance requirements and checked them with Betty and Arla n , mostly pertaining to the speed that the
game would have to possess to be i n teresting. They also thought through the memory requirements (RAM
and disk) . They then completed the document.
9. Following Up: Metrics and Postmortem on Detailed Requirements
The requirements analysis team asked Betty, Arlan, and the rest of the team to i nspect the detailed requirements .
They performed this i nspection primarily against the high-level requirements b y ensuri n g that every part of the
h i gh-level requirements were elaborated upon by detailed requirements. They also employed a checklist l ike the
one described in Table 1 3 . 3 of Chapter 1 3 . Several defects were found, which Hal and Karen recorded and
repaired. The results of this process were similar to those described i n Figure 1 2.37.
12.14 CASE STUDY: DETAILED REQUIREMENTS FOR THE ENCOUNTER VIDEO GAME
This section completes the requirements specification of the Encounter video game i n IEEE format.

3.1 External Interface Requirements
3. 1. 1 User Interfaces

3. Detailed Requirements
Note to the Student:
The IEEE term used in this headi ng is "speci fic"
requirements . We have substi tuted the term
"detailed" to be consistent with the text.

Section 2 .1. 2 in the SRS for the Encounter video
game showed only sketches of user interfaces in
order to provide product perspective. It lacked
detai Is and should not be regarded as the last word.
If user interfaces are not completely speci·
fied later in this document, then all details should

3 15

316

CHAPTER 1 2

ANALYZING DETAILED REQUIREMENTS

kitchen

L

COURTYARD

Note: Each part
of this figure is
specified
separately in
Section 3.

L

Current life
points: 56.38

i

Get status

lEnd

game

I
I

Kitchen
living

Value

Dressing I---+-,....,j

16.18

Dungeon

Study

Figure 12.38 Deta iled req u i rement for Encou nter cou rtyard GUI
Source: Graphics reproduced with permission from Corel.

be given in this section. Since we are usi ng the
object style of speci fication in this case study, the
details of each window are packaged with their
classes in Section 3 .2 . 2 in the SRS. In any case,
this section should explain the physical relation­
ships among graphical elements (e.g. , cascading,
tiled, superimposed) .

same user i n terface i s used to show the status
of the player's character.
An i n terface of type a above will always be present on
the monitor. When called for by these requirements,
i n terfaces of type b or c will be superim posed.
This requirement is tested in Software Test Docu­
mentation (STD ). <test reference goes here>.
3. 1. 2 Hardware Interfaces

Encounter takes place i n areas. Figure 1 2 . 3 8
shows a typical screen shot o f the courtyard area,
with a player-controlled character, a foreign charac­
ter, and the results of an engagement. This i n terface
takes up the entire monitor screen . Areas have
connections to adjacent areas, labeled by hyperli nks.
Clicking on one of these hyperli nks moves the
player's character i nto the corresponding area.
The entire set of i nterfaces i s as follows:
a. One user i nterface for each area, speci fied i n
Section 3 . 2AR below.
b. A user interface for setting the quality values of the
player's character, speci fied i n Section 3 .2 . PQ.
c . A user i nterface for displaying the results of an
engagement, speci fied i n Section 3 . 2 . ED. The

The hardware that Encounter (which is a
software applicatio n ) deals with

None
(In a future release, Encounter will be control ­
lable b y a j oystick . )
3. 1. 3 Software Interfaces

Other software with which Encounter must
i nterface: an example would be a pri n ter driver
None

CASE STUDY: DETAILED REQUIREMENTS FOR THE ENCOUNTER VIDEO GAME

(In a u
f ture release, Encounter will b e playable
from Intergalactic Internet Gaming Site.)

referred to elsewhere in the project, could not
be disturbed. The requirements would not be
alphabetically ordered. As a result, one would

3.1. 4 Communication Interfaces

have to go through the requirements one by

None

one to locate a particular one.
(In a future release, Encounter shall interface

with the Internet via a modem with at least 56 Kb/s.)

3. 2.AR Areas

3.2 Detailed Requirements by Category
First, we describe what the class
The IEEE uses the heading "Classes/objects" for

(i.e., this

classification of requirements) refers to.

Section 3.2. This assumes an audience that
knows object orientation. It is necessary to

An area is a place viewable on the monitor. All

understand 00to create this section but it is

activities of Encounter (including engagements)take

not necessary in order to read and understand it.

place in areas. Rooms, gardens, and courtyards are
examples of areas.

Since we are classifying the detailed require­

3.2.AR.1 Attributes of Areas

ments by class, we first list the classes that we
have (very carefully!)chosen. These are not all

Here we tell what properties each object

of the classes that will be used by the applica­

(specific entity) of the class must possess.

tion-merely the core classes pertaining to the
domain of the application, which are adequate
for organizing all of the requirements.In this
case, for example, all of them are aspects of the

3.2.AR.1.1 Area
implemented)

Name

(essential;

not

yet

Encounter video game.
The statement above in parentheses indicates
Categories for the Encounter video game suffi­

the priority and the status of the requirement.

Area,

Once the requirement is coded and tested, the

EncounterCharacter, EncounterGame, Engagement,

statement "not yet implemented" is either de­

cient for expressing the requirements are

EngagementDisplay, ForeignCharacter, PlayerChar­

leted or changed to "implemented." "Essential"

acter, and PlayerQualityWindow.

requirements are implemented first. Once a
requirement has been designed for and imple­
mented, "essential" can be removed. This is

The numbering "3.2.Area.N.N ...," etc.used

one technique for tracking the state of the

in Section 3.2 makes it easier for us to insert,

application and its relationship with this SRS.

remove, and locate requirements by organiz­

Another technique is to specifythe iteration to

ing alphabetically the classes that contain

which the requirement applies.

them. Think in terms of hundreds of require­
ments.If we were to number the classes using
"3.2. 1 ...", "3.2.2 ...," etc., then inserting
new classes would have to be done at the end
of the list, since existing numbering, already

Every Encounter area will have a unique name
consisting of

1 to 1 5characters. Acceptable charac­

ters shall consist of blanks, 0through 9, a through
and A through Zonly.

z,

317

318

CHAPTER 1 2

ANALYZING DETAILED REQUIREMENTS

Test plan < reference to test goes here>.

Each attribute-type requirement maps to a pair of
get- and set- functions. This document suggests
how each requirement can be hyperlinked to a
unit test in the Software Test Documentation.

3.2.AR.1 .2 Area Image (essential; not yet
implemented) There shall be an image to display
each Area object on the entire monitor. The i mage
shall fill the entire monitor.
3.2.AR.1 .3 Area-Specific Qualities (essential;
not yet implemented) Only some game character
qualities shall be applicable in each area. The specific
qualities required for each area are specified i n Section
3 . 2.AR. 2.

al ternative would have been to express these
requirements as functions: for exam ple,
"Encounter shall be capable of displaying
XYZ area with the fol lowing characteristics."

3.2.AR.2.1 Courtyard Area (essential; not yet
implemented) There shall be an Area object
with the name "courtyard" requiring the qual ities
stamina and strength . The prel iminary courtyard
image shown in Figure 1 2 . 3 9 includes a map of
nearby areas .
3.2.AR.2.2 Dressing Room Area (essential; not
yet implemented) There shall be an area with
name "dressing room" requiri ng no qual ities. I ts
prel i m i n ary i mage, shown in Figure 12 . 40, includes
a map of nearby areas.

3.2.AR.2 Area Entities

We designate specific area objects that must
exist within the application . Th is section has
been added to the IEEE standard . The

3.2.AR.2.3 Dungeon Area (essential; not yet
implemented) There shall be an area with name
"dungeon" requiring the quali ties stamina and pa­
tience. I ts preli m i nary image shown in Figure 1 2.4 1
includes a map of nearby areas.

kitchen

COURTYARD

dressing
room

r---

I Get status I

Kitchen

Courtyard

lEnd game I
Figure 12.39 Encou nter cou rtyard i mage

Dressing

LIving
room

room
Dungeon

Study

CASE STUDY: DETAILED REQUIREMENTS FOR THE ENCOUNTER VIDEO GAME

DRESSING ROOM

courtyard

dungeon

I Get status I

Kitchen

Courtyard
Dressing

lEnd game I

Living
room

room
Dungeon

Study

Figure 1 2 .40 Encounter d ressing room image
Source: Copyright © E. J. Braude. John Wiley & Sons. 2001.

3.2.AR.2.4 Kitchen Area (essential; not yet
implemented) There shall be an area with name
"kitchen" requiring the quality concentration . The
preliminary kitchen image shown in Figure 1 2 . 42
includes a map of nearby areas.

3.2.AR.2.5 Living Room Area (essential; not yet
implemented) There shall be an area with name
"living room" requiring the qualities concentration and
stamina. I ts preliminary image shown in Figure 1 2 .43
includes a map o f nearby areas .

DUNGEON

dressing
room

I Get status I

-..II�
Courtyard

'::,r::;

Dungeon

Study

L---__
-

lEnd game I
Figure 12.4 1 Encou nter d u ngeon i m age

Dressing

319

320

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

KITCHEN

,---,---­

I Get status I

Kitchen

Court¥.ard

I Set qualities
lEnd game I

Courtyard

Dressing

Living
room

1----+---.--1

room
Dungeon

Study

Figure 1 2 .42 Encounter kitchen image
Source: Copyright !j';) E. J. Braude, John wiley & Sons, 2001.

3.2,AR.2,6 Study Area (essential; not yet imple­
mented) There shall be an area with the name
"study" requiring the quality concentrat i o n . Its pre­
l i m i nary i mage shown in Figure 1 2 . 44 includes a map
of nearby areas.

3.2.AR.3 Area Functionality
Thi s is the required functionality that pertains
specihcaIIy to areas. Every functional

LIVING ROOM

courtyard

I
I
lEnd

Get status

I

Set qualities
game

I

,---Kitchen

I

Figure 12.43 Encounter l iving room i m age

Courtyard

DreSSing

Living
r

I----I--....-j
Dungeon

Study

CASE STUDY: DETAILED REQUIREMENTS FOR THE ENCOUNTER VIDEO GAME

Living
room

STUDY

Dungeon

tstatus

l

t qualities
d game

I

.--Kitchen

I

Courtyard
Dressing

living
room

room
Dungeon

Study

Figure 12 .44 Encou nter study i mage

capab i l i ty of the application should belong to
one of these sections.

None

3.2.AR.4 Events Pertaining to Areas
We separate the events that perta i n to areas
from the attributes, objects, and m ethods. An
event is an action that occurs to the appl ica­
tion and is i nstigated from outside o f the
appl icatio n .

3.2.AR.4.1 Display on Entry o f Player Character
(essential; not yet implemented) Whenever the
player's main character enters an area, that area and
the characters i n i t shall be displayed on the monitor,
fi l l i n g the monitor.
3.2.AR.4.2 Handling Engagements (essential;
not yet implemented) When a foreign game
character enters an area containing the player's
main character, or vice versa, they engage each other.

(op­
Engagements
3.2.AR.4.3 Interrupting
tional; not yet implemented) Players are able
to i n terrupt engagements o n a random basis. On
average, the player can stop one o f every ten engage ­
ments by executing the procedure to set qualities.
The user tries to i n terrupt an engagement by at­
tempting to set the player's qualities. If the game does
not allow this, no i ndication is given: the game
proceeds as if the attempt had not been made .
3.2.AR.4.4 Pressing the Set qualities Button
(essential; not yet implemented) When the
user presses the Set qualities button , a window for setting
the values o f qualities appears superimposed on the
area, provided that there is no fore i gn character in the
area. See 3 . 2 . PQ for the specifications o f this wi ndow.
3.2.AR.4.S Pressing the End game Button (op­
tional; not yet implemented) When the user
presses the End game button , the game termi n ates .
No additional screens appear.
The previous sentence , an i nverse require·
ment, was fel t to be necessary because games
often do display a summary of a session.

321

322

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

3.2.AR.4.6 Pressing the Get status Button (op­
tional; not yet implemented) When the user
presses the Get status button , an engagement display
window appears showing the status of the player's
character before and after the last engagement.
3. 2. CH Connection Hyperlinks

Between Areas Con nection hyperl i nks are hyperl i nks
placed at each area exit, showing the area to which i t
is connected.

Kitchen

Courtyard
Dressing
room
Dungeon

Key:

Living
room

Study

I ; connection

Figure 12.45 Encounter a rea configuration req u i rement

3.2.CH.1 Attributes of Connections Hyperlinks
3.2.CH.1 .1 Connection (essential; not yet
implemented) Each connection hyperl ink corre­
sponds to an area connecti o n .
3.2.CH.2 Connection Hyperlink Entities (essen­
tial; not yet implemented) There are two con­
nection hyperli nks corresponding to each area
con nection, one in each area of the connecti o n .
3.2.CH.3 Functionality o f Connection
Hyperlinks None
3.2.CH.4 Events Pertaining to Connection
Hyperlinks
3.2.CH.4.1 User Clicks on a Connection Hyper­
link The effect of cl icki ng a connection hyperl ink
is that the player's character i s displayed i n the area
on the other side of the area connecti o n .
3. 2. CO Connections between Areas

Characters travel from area to adjacent area by means of
connections. Each of these connects two areas. Fig­
ure 12.45 shows the required connections among the
areas.

3.2.CO.1 Attributes of Connections between
Areas
3.2.CO.1 .1 First and Second Areas (essential;
not yet implemented) Each connection shall
connect a pair o f areas, which we will call the "first"
and "secon d" areas.

3.2.CO.2 Connections Entities
3.2.CO.2.1 Dressing Room-Courtyard (essen­
tial; not yet implemented) There shall be a con­
nection between the dressi ng room and the courtyard.
3.2.CO.2.2 Dungeon-Study (essential; not yet
implemented) There shall be a connection be­
tween the dungeon and the study.
3.2.CO.2.3 Study-Living Room (essential; not
yet implemented) There shall be a connection
between the study and the l iving room .
3.2.CO.2.4 Courtyard-Living Room (essential;
not yet implemented) There shall be a connec­
tion between the courtyard and the l iving roo m .
3.2.CO.2.5 Dressing Room-Dungeon (essen­
tial; not yet implemented) There shall be a con­
nection between the dressing room and the dungeon.
3.2.CO.2.6 Courtyard-Kitchen (essential; not
yet implemented) There shall be a connection
between the courtyard and the ki tchen .
3.2.CO.3 Functionality of Area
Connections None
3.2.CO.4 Events pertaining to Area
Connections
3.2.CO.4.1 Moving a Character through a Con­
nection (essential; not yet implemented) Con­
nections are displayed as hyperl i nks at the borders of

CASE STUDY: DETAILED REQUIREMENTS FOR THE ENCOUNTER VIDEO GAME

areas whenever the player's character is i n the area.
When the user clicks such a hyperlink, the l inked
area is displayed with the character in this area.
3. 2.EC Encounter Characters

Elena

Strength

3.2.EC.1 Attributes of Encounter Characters

Endurance

3.2.EC.1.2 Qualities of Encounter Characters
(essential; not yet implemented) Every game
character has the same set of qual ities. Each quality
shall be a nonnegative floating point number with at
least one decimal of precision. These are all i n i tial­
ized equally so that the sum of thei r values is 1 00 .
The value of a qual ity cannot be both greater than a
and less than 0 . 5 .
For the first release the qualities shall b e concen­
tration, i ntell igence, patience, stamina, and strength.
3.2.EC.1.2 Image of Encounter
(essential; not yet implemented)
character shall have an image .

Characters
Every game

Value

16.18

Intelligence
Patience

3.2.EC.1.1 Names of Encounter Characters
(essential; not yet implemented) Every game
character in the Encounter video game shall have a
unique name . The speci fications for names shall be
the same as those for Area names, specified i n 3 . 2 .
AR.l.

1;�

Current life
points: 56.68

"

Figure 1 2 .46 Req uired user i nterface for status
Source: Graphics reproduced with permission from Corel.

equal to the sum of the quali ty values. The values of
the remaining qualities are automatically adj usted so
as to maintain their mutual proportions, except for
resulting quantities less than one, which are replaced
by quali ty values of zero .
3. 2.ED Engagement Displays (essential; not
yet implemented)

There shall be a window displayin g the result of
engagements. The format is shown i n Figure 12. 46.

3.2.ED.4 Engagement Display Events
3.2.ED.4.1 Dismissing the Display (essential;
not yet implemented) Whe n the user h i ts O K,
the display disappears .
3. 2.EG The Encounter Game

3.2.EC.2 Encounter Character Entities The
characters of the game are described among the
types of Encounter characters .
3.2.EC.3 Functionality of Encounter
Characters
3.2.EC.3.1 Living Points (essential; not yet
implemented) The Encounter game shall be
able to produce the sum of the values of any charac­
ter's qual ities, called its l iving points.
3.2.EC.3.2 Configurability of Encounter Char­
acter Quality Values (essential; not yet imple­
mented) Whenever an Encounter character is
alone i n an area, the value of any of its qualities
may be set. The value chosen must be less than or

The requirements in this sectio n perta i n to the game
as a whole.

3.2.EG.1 Attributes of the Encounter Game
3.2.EG.1.1 Duration (optional; not yet imple­
mented) A record shall be kept of the duration of
each game, timed from when the player begins the game.
3.2.EG.2 Entities of the Encounter Game
3.2.EG.2.1 Single Game (essential; not yet
implemented) There shall be a singl e game.
Future releases will allow several versions of
the game to run at the same time.

323

324

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

3. 2.EN Engagements

An engagement is the interaction between a game
ch aracter controlled by the player and a foreign
character.

3.2.EN.1 Attributes of Engagements

None

3.2.EN.2 Engagement Entities There are no
permanent engagement entities.
3.2.EN.3 Functionality of Engagements
3.2.EN .3.1 Engaging a Foreign Character
(essential; not yet implemented)
Th is particular requirement is mathematical in
nature and so there is no attempt to replace the
mathematics with natural language, which
would risk comprom ising its precision. The
use of natural language to explain the mathe­
matics is a good practice, however.
When an engagement takes place, the "stronger"
of the two characters is the one whose values of area­
spec i fic qual ities sum to the greater amount. The
system transfers half the values of each area-specific
quality of the weaker to the stronger. No transfer of
poi nts takes place i f neither character is stronger.
If either character has no poin ts after the value
reallocations are m ade , the game ends. If the game
does not end, the player's character is moved to a
random area and the results of the engagement are
displayed.
As an example of the value reallocations, suppose
that the player engages a foreign character in an area
preferring stami na and concentration . If Ps is the value
of the player's stamina, and assuming Ps + Pc > Is + In
we would have Ps' Ps + 1,/2, P: Pc + Ii2,} s' 1,/2, andI:
fa/2 .
=

=

To take a numerical example of an engagement
in this area: I f the player's stam ina value is 7 and
concentration value is 1 9, and Freddie the foreigner's
stamina is 1 1 and concentration 0 . 6, then the player
i s stronger. The result of the engagement would be:
Player: stamina 7 + 1 1 /2
1 9 + (0. 6)12
1 9 . 3 [OJ

=

1 2 . 5 ; concentration

=

Freddie: stami n a
1 1 /2 5 . 5 ; concentration 0 because (0. 6)/2 is
less than 0 . 5
=

3.2. FC Foreign Characters

A foreign character is an Encounter character not
under the player's control .

3.2.FC.1 Attributes of Foreign Characters See
Encounter character requirements. These are i n itial­
ized to be equal .
In future releases, foreign characters may mu­
tate into new forms.

3.2.FC.2 Foreign Character Entities
Th is section tel ls that there is only one foreign
character.

3.2.FC.2_1 Freddie Foreign Character (essen­
tial; not yet implemented) There shall be a
foreign ch aracter named "Freddie," whose image is
shown i n Figure 1 2.47. This character shall initially
have a total of 1 00 points that are distributed equally
among i ts qual ities .

=

=

The reader will recognize the defect in the last
equatio n , which should be J: 1/2 . We will
leave the defect intact as an exam ple.
=

3.2.FC.3 Functionality of Foreign Characters
3.2.FC.3.1 Foreign
Character
Movement
(essential; not yet implemented) As long as it
is alive, a foreign character should move from area to
adj acent area at random intervals averaging two
seconds. After being present in an area for a random

CASE STUDY: DETAILED REQUIREMENTS FOR THE ENCOUNTER VIDEO GAME

called the "main" character. The nature of this con­
trol is subject to the restrictions speci fied i n the
remaining requirements. This character shall initially
have a total of 1 00 points that are distri buted equally
among its qual ities.

3.2.PC.2.2 Additional Characters under the
Control of the Player (optional; not yet imple­
mented) The player shall be able to introduce
characters other than the main character that the
player controls. Details are to be decided.
3.2. PC.3 Player Character Functionality

Figure 1 2 .4 7 Foreign character Fredd i e i mage
req u i rement
Source: Graphics reproduced with permission from Corel.

amount of time averagi ng one second, all of the
character's l i fe points are divided among the qualities
relevan t to the area, such that the values of each
quali ty are as close to equal as possible.
3.2. PC Player Characters

These are Encounter characters under the control of
the player.

3.2.PC.3.1 Configurability of the Player Char­
acter Quality Values (essential; not yet imple­
mented) Whenever all foreign players are absent
from the area containing the player's main character,
the player may set the value of any qual ity of the
main character using the Player Quality window
shown in Figure 1 2.49 . The value chosen must be
less than or equal to the sum of the qual ity values.
The values of the remai n i n g qualities are automati ­
cally adjusted so as to maintain their mutual propor­
tions, except for resulting quantities less than 0 . 5 ,
which are replaced b y quali ty values of zero .
3.2.PC.3.2 Configurability of the Player Char­
acter Images (desirable; not yet imple­
mented) The player shall have the option to
choose the image representing his or her main
character from at least two images. These options
are shown i n Figure 1 2.48.
3.2.PC.3.3 Aging of the Player Character Im­
ages (optional; not yet implemented) The main
player character shall automatically increase each
qual ity by a percentage for the first half of his or her
l i fe, then decrease each quali ty by the same percent­
age for the secon d half. Detai ls are to be deci ded.

3.2.PC.1 Attributes of Player Characters See
Encounter character attributes. Player character images
can be selected from one of the images in Figure 1 2.48 .

3.2. PQ The Player Quality Window

3.2.PC.2 Player Character Entities

Thi s is a window from which the player may allocate
the values of his or her characters .

3.2.PC.2.1 Player's Main Character The player
shall have control over a particular game character

3.2.PQ.1 Attributes of the Player Quality
Window The window for setting the quali ties of

325

326

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

Elena

Sean

Boris

Figure 1 2 .48 Player cha racter i mage options
Source: Graphics reproduced with permission from Corel.

a player character in Encounter is shown by means o f
a typical example i n Figure 1 2 .49. The game charac­
ter icon appears in the center, and i ts name appears at
the left top of the screen . The character's l i fe poi nts
appear in the center. On the left center is a list box

displaying four of the qual i ties at a time . Clicking on
one of these qualities allows the player to select a
value for it i n the text box on the right. An explan­
ation of how the arithmetic is performed is shown in
a pale yellow box i n the lower part of the screen.

Current life points: 1 00 . 0

Shawn

Choose the quality

Choose t h e value of

you wish to set

the qual ity selected

J��.�gt'� " " ' H "
Endurance
Inte l l i gence
Patience

.

".
..:.J

Explanation _---.,.:::-_-,--

-:
_-,::-----",---.,--___,...----:
______-,

The values of the q u alities not specifically chosen re m a i n in the same
proportion to each other. Values less than 1 . 0 a re counted as zero. E . g . ,

before:

stre n gth = 1 0 . 0 , e n d u rance = 6 0 . 0 , i ntel l i gence = 3 0 . 0 , patience = 0 . 0
(cu rrent l ife p O i n t s 1 0 .0 + 60.0 + 3 0 . 0 + 0 = 1 00 . 0 )

change: stre n gth from 1 0 . 0 to 2 0 . 0
after:

stre n gth = 20, e n d u rance = 53.33, i ntel l i gence = 26.66

Figure 1 2 .49 User interface req u i red GUI for setti ng q u a l ity va l u es
Source: Graphics reproduced with permission from Corel.

OK

CASE STUDY: DETAILED REQUIREMENTS FOR THE ENCOUNTER VIDEO GAME

Color backgrounds for the name, l i fe points, and
value boxes are to be pale turquoise.

3.2.PQ.2 Player Quality Window Entity
3.2.PQ.2.1 Window for Allocating Qualities
(essential; not yet implemented) A window
shall be available under the conditions described
above to allocate the values of the player character.
The window shall have the appearance of the CUI
shown i n Sectio n 3 . 1 . 1 . 2 of this specification .
3.2.PQ.3 Player Quality Functionality
3.2.PQ.3.1 Initiating the Display (essential; not
yet implemented) The player quality menu shall
be able to display i tsel f.
3.2.PQ.4 Player Quality Window Events
3.2.PQ.4.1 Displaying the Value of a Quality
(essential; not yet implemented) When the
player clicks on a quality in the list box on the
left, the value of that quali ty shall be displayed i n
the text box on the right.
3.2.PQ.4.2 Setting the value of a Quality
(essential; not yet implemented) When the
user enters a legitimate value for a quali ty and hits
the "enter" button, the value of that quality is set to
the amount entered. If the value is invalid, an error
window shall appear stating "invalid value : try again . "
3.2.PQ.4.3 Dismissing the Window (essential;
not yet implemented) When the user h i ts the
OK butto n , a time of four seconds elapses, after
which the window disappears . At the end of this time
period ( i . e . , i f there are no i nterruptions) the value
allocations are made .

3.3 Performance Requirements
Performance requi rements i nclude requi red
speeds and/or time to complete . U nless docu­
mented i n a di fferent section of the SRS, they
may also i nclude memory usage ( RAM and/or
disk), noted either statically or dynamically
( i . e . , memory required at runtime ) .
The appl ication shall load a n d display the
i nitial i mage i n less than a m inute .
Engagements should execute i n less than one
second.
These requirements are tested i n STO < refer­
ence to test goes here > .

3.4 Design Constraints

Th is section speci fies restrictions on design . I f
there is no material i n this section, designers
are free to create any (good) design that
satisfies the requirements. For example, we
can add the design constraint "one-story" to
the following: "A house with four bedrooms,
all of which are less than a th irty-second walk
from the family room . "

Encounter shal l be designed usin g U M L and
object-oriented design. I t shall be implemented in
Java. The software shall run as a Java application on
Windows 95 . It shall be designed i n a way that makes it
relatively easy to change the rules under which the
game operates so that others can customize the game.

3.5 Software System Attributes
3. 5. 1 Reliability

3.2.PQ.4.4 Interruption (essential; not yet
implemented) Upon i nterruption of the display
of the quali ty value wi ndow, the window van ishes.
Note that interruptions shall be caused by a
foreign character entering the area. Note also i n this
case that the quality values are not changed and that
an engagement takes place.

Encounter shall fail not more than once i n every
1 ,000 encounters . Test documentation < reference
to test goes here > .
3. 5. 2 Availability

Encounter shall be available for play on any PC
runn i n g Windows 95 only ( i . e . , n o other applications

327

328

CHAPTER 12

ANALYZING DETAILED REQUIREM ENTS

simultaneously) . Test documentation < reference to
test goes here > .

4. Supporting Information

3. 5. 3 Security

4.1 Table of Contents and Index

None

Not included.
Future rel eases w i l l a l l ow access to saved
games only with a password .

4.2 Appendixes
Not i ncluded.

3. 5. 4 Maintainability

Appendices may i nclude

3.5.4.1 Changing
Characters
and Areas
(essential) It shall be straightforward to change
characters and areas .
3.5.4.2 Globally Altering Styles (desirable) It
shall be straightforward to globally alter the style of
the areas and connections. (Style changes reflect dif­
ferent levels of game play i n the same environment.)

(a) Sample I/O formats, descri ptions of
cost analysis studies, or results of
user surveys
(b) Supporting or background i n forma­
tion that can help the readers of the
SRS
(c) A descri ption of the problem to be
solved by the software

3.5.4.3 Altering Rules of Engagement (op­
tional) Rules of engagement should be rel atively
easy to change .
3.6 Other Requirements

(d) Special packagi n g instructions for
the code and the media to meet
securi ty , export, i n i tial l oading, or
other requirements
State explici tly whether or not each appendix
is to be an official part of the SRS.

None

12.1 5 SUMMARY
Detailed requirements ("developer" or "detai led" requirements) are written primarily with designers and
developers i n mind. They are created from high - l evel requirements, as wel l as from conti nued customer
interactio n . Detai led requirements must be testable , traceable, and consistent. S i nce they become numerous,
they must be classi fied systematical ly. There are several ways to organize detailed requirements i ncluding by
feature, use case, CU I , state , and domain class.
Agile projects tend not to create documents-separate from the code and tests-with detailed requirements.
Detailed requirements must be traceable to the design and impleme ntation that realize them and to the
tests that vali date them. Without a clean trace from each requirement through the design of the appl ication to
the actual code that im plements it, it is very di fficul t to ensure that such an application remains in compli ance
with the requirements. When the requirements change, which is safe to assume, this becomes even more
di fficul t. Detailed requirements must also be traceable in the other directi o n , to the high - l evel requirements
they are derived from, to ensure that all are ful l y speci fied.
Since i t is difficult to implement all desired functional i ty, requirements are often prioritized. Categories
such as essential, desirable, and optional are used to designate pri orities. Organ izations commit to deliveri ng
essential functionality, and i f there is time they impl ement desirable and then optional features.

EXERCISES

Once detailed requirements have been collected, the project documents are updated to reflect the
improved project knowledge . For example, schedules are updated with more accurate dates and risks are
retired and more i n formation is learned.

12.16 EXERCISES
1. To what audience are detailed requirements primarily targeted?
2 . Name five ways of organizing detailed requirements.
3. What is wrong with the followi ng Detailed requirements? Explain how you would fix the m .
a . HomeBudget shall display a convenient i n terface for enteri ng personal data.
b. SatControl shall compute the predicted time it takes to circle the Earth on the current orbit,
and the actual time taken to circle the Earth on the previous orbit.
c. InvestKing shall determine the best i nvestment strategy.
4. What are three advantages and three disadvantages of organizing detailed requirements by class
rather than by feature?
5. Suppose that you are de fining the requirements for an application that simulates the movement of
customers in a bank. List five classes that can be used to organize the requirements.
6 . Provide detailed requirements for each class i dentified i n Exercise 3 by describing one attribute and
one function correspondi n g to each class.
7. When identifying doma i n classes (as i n Figure 1 2 . 8 ) , why is it useful to denote the relationship
between them ( i . e . , inheritance, aggregation)?
8 . Applyi n g the principle of good screen design outl ined i n Step 3 of Section 1 2 . 3 sketch good CUI
screens for a home finance application that:
a . displays a summary of a user's fi nancial holdings, organi zed by type of holding, and
b. allows a user to i nput the details for a new holding
9 . For each detailed requirement l isted i n Exercise 6, assign a priority ( e . g . , essential , desirable ,
optional) a n d explain why you chose them .
1 0 . Create a chart similar to Figure 1 2 . 2 7 that speci fies test i n put and output for one of the attributes
identified in Exercise 6 .

TEAM EXERCISE
SRS

Write the SRS for your appl icati o n . Use or modify the IEEE standard. If you are using an i terative
approach, try to indicate what requirements are to be implemented i n each i teratio n .

329

330

CHAPTER 12

ANALYZING DETAILED REQUIREMENTS

Track the time spent on this by i n dividuals and by the group . Break this time into appropriate
activities. Measure the effectiveness of your effort. (Feel free to develop your own metrics; see also
team exercises i n previous chapters . ) Indicate how the process you used to develop the SRS could
have been improved.
Evaluation criteria :
( 1 ) Degree of clari ty
( 2 ) Extent to which the plan includes all relevant details and excludes irrelevant material
( 3 ) Effectiveness of your self- measurement and process improvement description

BIBLIOGRAPHY
l . Booch, Grady, "Object-Oriented Analysis and Design with Applications , "Addison - Wesley, 1 994.

2. Jorda n , Richard, Ruth S m i l a n , and Alex Wilkinso n , "Stream l i n i ng the Proj ect Cyc le with Object-Oriented Requirements," OOPSLA
Conference Proceedings ( 1 994), p p . 2 8 7-300.
3 . Galitz, W . , 'The Essen tial Guide to User Interface Design, An Introduction to GUI Principles and Techniques, " John Wiley & Sons, 1 99 6 .
4 . R a n d , Paul, " A Designer's Art, " Y a l e U n iversity Press, 1 9 8 5 .
5 . Myers , Glenford. J . . "The Art of Software Testing, " J o h n Wi ley & Sons. , 1 979.
™
6 . Java
SE 6 Platform Documentation, 2006 .
7. F a u l k , Stuart,"So ftware Re q u i re m e n t s , A Tutori a l , " 1 9 97, h t t p )/www . c s . u m d . edu/c i ass/s p r i n g2 004/c m sc 8 3 8 p/Re q u i r e m e n tsl
FauILReq_Tut.pdf [ accessed November 29, 2009 ] .
8 . Mars Cl i m ate Orbiter Mishap I nvestigation Board Phase t Report, November 1 999, ftp)/ftp .hq. nasa. gov/pub/pao/reports/ 1 999/
MCO_report.pdf [accessed November 29, 2009 ] .

Q u a l ity a n d M etri cs
i n Req u i re m e nts Ana lys i s

[..---"

Testing

Planning

Maintenance
The Software
Development
L ifecycle

Implementation

What is meant by the access i b i l ity
of req u i rements?
Comprehensiveness?

\

Requirements
analysis

� DeSign /

U n derstandability?
How do you assess the deg ree of
ambigu ity of req u i rements?
Cons istency?
P rioritization?
What i s meant by the degree of secu rity
in req u i re m ents?
In what sense can req u i re m e nts be complete?
Testable?
Traceable?
What m etrics are suitable for these q ual ities?

Figure 13. 1 The context and learning goa l s for this chapter

Th is chapter describes measures of qual ity in requirements. The more a requirements document
expresses what the customer wants and needs, the higher its qual ity. We usually think of details as being far
less i mportant than the "bi g picture," but a missing requirements detail can seriously affect projects, as
numerous case studies show. Recal l , for example, the overlooked detail of metric-to-nonmetric distance
conversion that dispatched a $ 1 25 million spacecraft to oblivion .

332

CHAPTER 13

How .

QUALITY AND METRICS IN REQUIREMENTS ANALYSIS

. accessible is each requirement?
comprehensive is the SRS?
. . . understandable is each requirement?
. . unambiguous is each requirement?
. . consistent is the SRS?
effectively prioritized are the requirements?
secure is the requirement?
self-complete is the SRS?
testable is each requirement?
traceable is each requirement?
.

·

.

·

·
·

·
·

Figure 1 3 . 2 Attributes of req u i rements ana lysis that promote q u a l ity

To help ensure that the requirements are i n deed covered, we focus on qualities that requirements should
possess. They should be complete and consistent; each one should be capable of being traced through to the
design and implementation, tested for vali dity, and implemented accordi ng to a rational priority. Figure \ 3 . 2
l ists these attributes a n d tells what w e should l o o k for i n good requirements. W e c a n systematically review
and i nspect requirements based on this l i st. For example, a set of consistent requirements is far more likely to
express what stakeholders want and need than a set with contradicti ons.
This chapter discusses how each of these qualities can be measured. "Target values" refers to the numerical
goals set in the project relative to various metrics. Metrics are most useful when their target values are specified in
advance. For example, we could state in advance that, based on experience on past proj ects, requirements will be
considered "complete" when the rate of modification and addition is less than 1 percent per week.
Projects are greatly improved when the QA organization is i nvolved i n the requirements analysis stage .
In particular, QA veri fies that the intended development process is being executed in accordance with plans.
QA should participate i n inspections of requirements documents. They tend to have a healthy perspective
because they understand that they will have to vali date the product based on the requirements. In poorly
organized projects, QA may be handed an appl ication with l ittle or no requirements documentation and
asked to test it. This begs the question, "what is the application supposed to do?"
13.1 QUALITY OF REQUIREMENTS FOR AGILE PROJECTS
Before discussing the attributes of requirements analysis quality l isted above , let us discuss the quality of
requirements for agile processes. The primary process for requirements here consists of eliciting user stories
from the customer, along with acceptance tests, and then subjecti ng the implementati on to those tests upon
completio n . I n addition, the customer must feel satisfied with the result. This may or may not be supported by
significant documentatio n . Quality has to be assessed, i f not measured accordi ng to thi s standard. Thi s entai ls
computi ng the fraction of acceptance tests passed and making an assessment of the customer's reactio n ,
possible v i a a questionnaire. Si nce t h e customer-usually i n the form of a team member representative-is
part of the development effort, requirements assessment includes the performance of the customer. Given the
nature of requirements analysis, this is all to the good.
1 3 .2 ACCESSIBI LITY OF REQUIREMENTS
To deal with a set of requirements, we should be able to access the ones we want, when we want them . This is the
qual ity of accessibility. The first property we need in this respect is a means of identifying the detailed requirements .

COMPREHENSIVEN ESS OF REQUIREMENTS

•

Ease of getting to statement of detailed requirements.

•

Metric:
0:
1 0:

extremely long average access time (compared with the organization's norm)
average access time as fast as can be expected

Figure 1 3 . 3 The accessibi lity of requirements

We do this by numbering them in some way. A good numbering system allows us to know whether the
requirement has been implemented, for example, and to trace it to the code that actually carries it out.
A project's requirements change continually throughout its life cycle. For example, when a programmer tries
without success to implement a requirement and explains this to the customer, the latter frequently finds missing
parts in the requirement. The SRS must then be accessed to ascertain whether these miSSing requirements were
present, and included if they were not. Taking an example from the video store case study, the customer (in this
case, the video store) may question why a DVD's play time does not appear on the monitor. The developers and
the customer will want to know whether this was specified in the SRS. Where in that document should they look to
determine this? Rummaging through poorly organized documents is time-consuming and therefore expensive.
Here is a checklist for improving the accessibility of requirements:
•

Do you know where the high-level requirements are stated?

•

Do you know where the detailed requirements are listed?

•

Are the detailed requirements organized in groups, preferably with each group corresponding to a highlevel requirement?

•

Are all of the detailed requirements organized into a list, or a clearly understood list of lists?

•

Can you look up requirements by keyword? By subject matter? By use case? By CUI? By user type?

•

Can you look up requirements by other criteria relevant to the particular application or project?

One accessibility metric is the average time taken to access a detailed requirement. To measure this, a sample
would be taken of existing and missing requirements, and several people would be timed finding these or
ascertaining that they are absent. Statistically speaking, 150 is a good sample size. Smaller sample sizes are
unreliable but are probably better than nothing. In selecting a sample, one uses a process that is as random as
time allows. For example, one could ask each of a group of people familiar with the proposed application to
contribute ten potential detailed requirements, then pick at random from the combined list to obtain samples
to seek. Accessibility is summarized in Figure 13 . 3.
13.3 COMPREHENSIVENESS OF REQUIREMENTS

A quality SRS expresses all of the requirements for a product. By comprehensiveness, we mean the extent to which
the customer's wants and needs are included. An appropriate metric would thus be percentage of the customer's
requirements appearing in the SRS. An obvious way to ensure this is to have the customer validate it, but this is not a
simple matter, as the points in Figure 13.4 suggest.
The comprehensiveness of requirements forms an elusive and vague goal, and yet the completeness of
requirements is key to the successful completion of a project and the tracking of progress. Each iteration

333

334

CHAPTER 13

•

QUALITY AND M ETRICS IN REQUIREM ENTS ANALYSIS

Not enough resources to satisfy every customer wish
Prioritize so that comprehensive within each batch of requirements
Customer can't/won't read entire SRS
Make SRS easy to follow
Use a standard
"Read" SRS to customer
•

•

•

•

•

•

Limitations of self-inspections

•

Contradictory stakeholder requirements need to be satisfied

•

•

Subject to peer inspection
Apply diplomatic skills and expect compromise

Figure 1 3.4 Issues in atta i n i ng comprehensive req u i rements

makes the requirements more comprehensive. One way to deal with the evolving set of requirements is to
include requirements of future iterations and of all priorities in measuring completeness. An example is shown
in Table 1 3 . 1 . This perspective helps us to assess how close our plans are to satisfying the customer's wants
and needs .
A more tractable measure i s self-completeness , i n which the requirements contain all materials that its parts
reference. However, this is somewhat different, and is discussed below.
Here is a checklist for improving the comprehensiveness of requirements:
•

•

•

Summarize, or give a very short preliminary description of needed requirements that have not been
included yet .
Is the customer satisfied that the requirements reflect all of his or her needs and wishes?
What fraction of the listed requirements are slated for implementation in the current release? Future
releases?

Figure 13.5 shows two useful comprehensiveness metrics.
The IEEE defines a rather complex measure of completeness in 982.2- 1988 A 3 5 . 1. This is a formula
involving 18 observed quantities (e .g., "number of condition options without processing") and 10 weights
(e .g., the relative importance of "defined functions used") . It measures the degree to which there are loose
ends within a set of detailed requirements.

Table 1 3.1 Including future requirements
Requirement
priority Iteration

No.

Description

780

Every DVD record shall contai n the title, up to 60 alpha n umeric characters

2

3

781

Every customer record shall include the customer's credit card n u m ber, consisting of

1

2

782

16 digits.
.

.

.

UNAMBIGUITY OF REQUIREMENTS

Let T
total number of documented detailed requirements
(all priorities; all iterations)
=

METRIC: % Requirements implemented

=

100 * [no. of requirements implemented]
T

METRIC: % Requirements Currently Targeted
100 * [( no. of requirements implemented ) +
(no. of top priority requirements in current iteration )]
=

T
Figure 13.5 Two useful comprehensiveness metrics

13.4 UNDERSTANDABILITY OF REQUIREMENTS

Understandability appears to be a highly subjective quality because it depends on peoples' opinion.
However, it can be measured . For example, a random set of people from an appropriate population can be
asked to express on a form their opinion of a requirements document. Table 1 3.2 is an example of an
opinion form-in this case applied to a user interface. Here is a checklist for improving the comprehen ­
siveness of requirements .
•

Are the requirements written in language that its typical reader would understand?

•

Do they use the vocabulary of the client problem domain?

•

•

Do the requirements describe only external behavior-that is, as seen from the user's point of view? ("User"
can include external systems rather than just people.)
Do the requirements avoid stating how the problem is to be solved, what techniques are to be used, or how the
application is to be designed? (The exceptions to this are when such specification are indeed required up front.)

13.5 UNAMBIGUITY OF REQUIREMENTS

Unless a detailed requirement is written clearly and unambiguously, we won't be able to determine whether it
has been properly implemented. Figure 13.6 illustrates an example of an ambiguous requirement, followed by
an improved version. The original requirement seems to allow the player to change the qualities of a game
character at any time during the game. This would take the fun out of the game, because the player would
simply set quality values to their largest possible relevant values and there would be little room for trying
various strategies.
Here is a checklist for improving the nonambiguity of requirements:
•

For each requirement, is there only one way that a typical reader would interpret it?

•

For each requirement, are terms avoided that could be understood in more than one way?

Figure 1 3.7 shows a metric for ambiguity that depends on a triage measurement: decide whether the
detailed requirement has exactly one clear meaning (score of 2); or many meanings (score 0); otherwise give it
a score of 1.

335

336

CHAPTER 13

QUALITY AND M ETRICS IN REQUIREM ENTS ANALYSIS

The player can decide the qualities of Encounter characters .

X

At any time? Probably not. Would have to test under all
circumstances, many not intended, incurring unnecessary
expense and producing a wrong result.

,J

Better version:

Whenever all foreign players are absent from the area
containing the player's main character, the player may
change the quality values of this character, keeping the
sum total of the quality values unchanged. The
PlayerQualityWindow, (see Section tbd) is used
for this purpose. Changes take effect four seconds after the
"OK" button is pressed.
Figure 1 3.6 An exa mple of a m biguity in req u i rements

A metric (range: 0 to 1 00)
t 00* I: [unambiguity of each detailed requirement (0-2)]

2*[number of detailed requirements]
o

=

could have many meanings; 2

=

clearly one meaning

Figure 1 3.7 A metric for unam bigu ity

13.6 CONSISTENCY OF REQUIREMENTS

A set of detailed requirements is consistent if there are no contradictions among them. As the number of detailed
requirements grows, inconsistency tends to become difflcult to detect. Inconsistency is illustrated by the
three requirements in Figure 1 3 . 8.

Requirement 14. Only basic food staples shall be
carried by game characters.

Requirement 223. Every game character shall

carry water.

Requirement 497. Flour, butter, milk, and salt shall be
considered the only basic food staples.

Figure 1 3 .8 Exa m p l e of inconsistency in req u i rements

PRIORITIZATION OF REQUIREM ENTS

Means: No contradiction, in whole or in part
I

Example:.,.....

�

. . ...

DVDs shall b e classified
alphabetically as drama.
comedy. horror ..

..... The DVD
classification order
shall be the order of
preference of the
customer. .

Metric: Percentage of contradicted requirements
Figure 1 3 . 9 Consistency in requirements

The object-oriented style of organization of requirements helps to avoid inconsistencies by classifying
detailed requirements by class and by decomposing them into a simple form. This is not a guarantee of
consistency, however, and so requirements inspections include a check for consistency. Here is a checklist for
improving the consistency of requirements:
•

For each requirement, are there other requirements that could lead to contradicting or annulling it?

•

For each requirement, are there other requirements that are very similar and so can create inconsistencies?

•

Does each requirement avoid a chain of consequences that can't be readily followed?

A consistency metric is the percentage of detailed requirements partly or wholly contradicted elsewhere . To obtain such
a metric, one would consider a sample of detailed requirements- t 50 would be appropriate-and investigate
each one in turn to determine whether it is contradicted elsewhere in the document. This entails comparing it
to all of the remaining detailed requirements. Figure 13.9 proVides another example.
This measure is imperfect because it accounts only for pairs of inconsistent requirements. As Figure 13.8
illustrates, inconsistency can result from a set of requirements.
13.7 PRIORITIZATION OF REQUIREMENTS

Since quality is ultimately defined by customer satisfaction, the requirements analysis process is continually
directed toward the customer's concept of satisfaction . Teams typically show stakeholders interim accom­
plishments, and stakeholders then influence the course of the work accordingly. Because of this, the priority
of requirements-and thus the order in which requirements are implemented, as described in Chapter 12makes a significant difference in the customer's satisfaction. In mathematical language, this is a non­
commutative operation since the SRS sequence

implement requirement A then plan to implement requirement B
may well produce a different product from

implement requirement B then plan 10 implement requirement A

337

338

CHAPTER 13

QUALITY AND M ETRICS IN REQUI REM ENTS ANALYSIS

Assume three prioritizations: high, medium, and low
Metric: Variation from # high
# medium
# low
Let T
total number of detailed requirements
=

=

=

1 00 * [T - I T/ 3 - high l - I T/ 3 - medium l - I T/ 3 - low l]
T
o

=

worst; 1 00

=

best

Figure 1 3 . 1 0 A metric for measuring the q u a l ity of prioritization

There are effective and jneffective prioritizations. For example, giving most requirements the highest
priority indicates poor planning. Ranking low-priority requirements is usually a waste of time because they are
unlikely to be all implemented. As mentioned, when stakeholders see the implementation of requirements, they
tend to change subsequent requirements. An effective prioritization tri es to account for these factors.
Here is a checklist for improving the prioritization of requirements:
•

Is it clear what requirement should be worked on first? Second?

•

Are the priorities at a high level consistent with those at the detailed level?

•

Is there a prioritization process in place such that it will remain clear what is the next important requirement
that should be worked on?

•

Is the prioritization appropriately matched with customer expectations?

•

Is the prioritization appropriately matched with project risks?

Assume that each requirement is in one of three priorities. How would we measure the quality of the
prioritization? A good quality prioritization categorizes requirements into equal parts, indicating that no
category has been neglected. Figure 1 3 . 10 shows a metric for this.
For example, jf 900 requirements are very well prioritized, each category would contain 300 requirements,
and the formula would give 1 00 * [900 - 0 - 0 - 0 ]/900 1 00%. On the other hand, if 700 were classified as
high priority, 1 00 as medium and 1 00 as low, the metric would yield
=

1 00 * [900 - 1 300 - 700 1 - 1 300 - 100 1 - 1 300 - 1 00 /l/900

=

1 00 * 1 00/ 900

=

1 1. 1 %

The low percentage indicates poor prioritization.
13.8 SECURITY AND HIGH-LEVEL REQUIREMENTS

Security can be dealt with as an actual (explicit) requirement or as an attribute of requirements. For example,
"All passwords shall be unavailable except to the system admin istrator" is an explicit requirement of an
appl ication . On the other hand, 'The requirements in our SRS will cause fewer than 1 0 security breaches of
level 1 or greater (defined elsewhere) in a century of continuous operation under the threat environment of
2009" is not a requirement i n the ordinary sense. It is an attribute of the requirements.
Security in requirements is a special case in that it deals with deliberate exploits on the part of others to
misuse it. Traditional requirements, after all, are i ntended to specify what an application should do, and have not

S ELF-CO M PLETENESS OF REQUIREMENTS

addressed misuse. This is changing. To an increasing extent, requirements documents are addressing the security
issue by including such content as misuse cases. These are similar to the idea, mentioned earlier, of inverse
requirements. The following are examples of misuse cases--use cases that the system is required to disallow :
An automated user of the application enters a known user 10 and more than 10 passwords per second.
A user accesses more than 30 customer records in a single sitting and transmits these to another
address within 1 0 seconds of accessing them.
Here is a checklist for improving the security aspects of requirements:
•

Consider the places in the proposed application where intrusion appears to be possible. Are concrete
security requirements stated for those places?

•

Has the confidentiality of data, where applicable, been speci fically required?

•

Has the security of user identity been specified?

•

Has the security of passwords been explicitly called for?

•

Has the ownership of files or access been specified?

•

Has encryption been called for when appropriate?

•

Have specific, known security exploits ("hacks") been specified against? An example is "SQL injection shall
be prevented ." (SQL injection is a means of unauthorized database access.)
Have speci fic and potential exploits been specified against via misuse cases?

13.9 SELF-COMPLETENESS OF REQUIREMENTS

Typically, a requirement depends on other requirements. A set of requirements is self-complete if it contains
every part whose inclusion is necessitated by parts already present. Figure 13. 11 illustrates an incomplete set
of requirements. Without the specification of how a video is to be "displayed," this set of requirements is
incomplete as a unit.
As another example, suppose that the SRS for a calendar application contains the following requirement.

The application shall retain all information entered by the user for each appointment.

REQUIREMENTS
1. The application shall display a D VD in stock when a

title is entered at the prompt; otherwise it shall display
"OUT OF STOCK"
2. The application shall display all of the store's D VDs

by any director whose last name is entered at the prompt.
These shall be displayed one by one. Advancing through the
D VDs shall be controlled by the forward arrow key.
Incomplete: Lacks speCi fication on how to display a video!
Figure 1 3. 1 1 An exa mple of self-incompleteness in requ irements

339

340

CHAPTER 13

QUALITY AND M ETRICS IN REQUIREMENTS ANALYSIS

When a requirement is present, so must all those
necessitated by its presence .
A metric (0

=

best; 1 poor; no theoretical upper limit):

[number of missing necessary associated requirements]
[number of detailed requirements present]

Figure 1 3 . 1 2 A metric for self-completeness

The presence of this requirement necessitates a requirement describing means for entering appointment
information. It also necessitates a requirement explaining means for displaying this information. This is the
meaning of "self-completion." Here is a checklist for improving the self-completeness of requirements:
•

For each requirement stated, are all the requirements present that it refers to?

•

For each requirement stated, are all the requirements present that it depends on?

To measure self-completeness, we look at each detailed requirement and note any necessary associated
requirement that is missing. An appropriate metric is shown in Figure 13.12.
The number of missing requirements is determined by sampling.
13. 10 TESTABILITY OF REQUIREMENTS

Each detailed requirement must be testable; that is, it must be possible to definitely validate that the
requirement is operative in the finished application by testing for it. Figure 1 3.1 3 provides an example
of a nontestable requirement, and shows what it would take to make the requirement testable.

The system shall display the difference in salary
between the client and the worldwide average for the
same trade.

X

-can't be tested because the average mentioned
cannot be determined (even though it exists).

�

Better:

The system shall display the difference in salary
between the client and the estimated worldwide average
for the same trade as published by the United Nations
on its Web site www .tbd at the time of the display.
Figure 1 3 . 1 3 An exa m ple of testa bil ity

TESTABILITY OF REQUIREMENTS

Table 1 3.2 Exa m ple of a user satisfaction q u estion naire
user Satisfaction
0= of no value; 5

=

average satisfaction; 10= a pleasure to use

Score

Quality
1. Overa l l a ppearance
2. Layout of text areas
3. Layout of buttons
4. Readability
5. Ease of entering data
6. Degree to which erroneous data entry is prevented
.

.

.

.

.

.

Requirements that are not testable are of negligible value. It would be impossible to assess whether such a
requirement has been attained. This is an all-or-nothing property. There is little value in the "degree of
testability" of a requirement.
Testability can sometimes be used to specify a detailed CUI requirement. For example, instead of
specifying a CUI in complete detail we may prefer to provide a test such as the following:
The CUI for entering DVDs shall have the fields and buttons listed in figure xx, and its design
shall score an average of at least 8.5 out of 10 on the user satisfaction questionnaire in Table 1 3.2.
An effective way to ensure testability and to ensure the clarity of a requirement at the same time is to
include tests with the requirement. Figures 13.14 and 1 3. 1 5 illustrate an example .
Agile programming applies this test orientation but short-circuit's the prose by encoding the test up
front, using it as a requirement, in effect. A reasonable testability metric is the following:

The percentage of detailed requirements that are accompanied by a test.
Even when a requirement is testable, executing a test may be difficult or time -consuming. To be
complete, we sometimes need to consider the cost of testing as part of the consideration. A very high cost

The video store application shall implement a discount program as follows:
•

•

•

•

One DVD: no discount
Two DVDs: 20% discount for the second DVD

Three DVDs: 40% discount for the second and third DVD
All videos beyond the third are discounted at 40%.

Figure 13. 1 4 Including tests with req u irements, 1 of 2-the req u i rement

341

342

CHAPTER 13

QUALITY AND M ETRICS IN REQUIREMENTS ANALYSIS

1. Customer Owen Jones rents one DVD. He is charged the regular rental of $5.00.
2. Customer Teresa Edwards rents two DVDs. She is charged the regular rental of $5.00 for the first and
$4.00 (20% discount) for the second.
3. Customer Theodore List rents three DVDs. He is charged the regular rental of $5.00 for the first, $4.00
(20% discount) for the second, and $3.00 (40% discount) for the third.
4. Customer Fred Harari rents five DVDs. He is charged the regular rental of $5.00 for the first, $4.00
(20% discount) for the second, and $ 3 .00 (40% discount) for the third. The fourth and fifth DVDs are
charged at $3.00 (40% discount).
Figure 13.15 Including tests with requirements 2 of 2-the tests

inAuences our choice and priority of requirements. For example, suppose that we consider adding to our
online video service the following requirement:
For each movie entered by the customer, the application shall display a number from 0 to 5 that
provides the system's estimate of how much he will like the movie. This estimate is based on the
customer's past viewing ratings.
This can be tested, but the expense of doing so properly may dissuade us from making it a high priority.
Recommendation algorithms have become a competitive activity among providers, with large rewards
provided for the creators of the most (measurably) effective ones. Like this one, many requirements are
strongly associated with business decisions.
Here is a checklist for improving the testability of requirements:
•

•

•

Is the requirement clear enough to devise input/output data samples that exercise it? Specify the tests.
Is there a set of tests that, if passed, provides significant confidence that the requirement will have been
satisfied?
If one reasonable person in the customer community proposed a set of tests for the requirement, would
another probably agree that it tests the requirement?

13. 1 1 TRACEABILITY OF REQUIREMENTS

Traceability was defined in Chapter to. Our concern here is how to measure a set of requirements in this
respect . A requirement is traceable if it maps in a completely clear manner to the design element that
accommodates it, the code that implements it, and the tests that test it. When the 00 (or "class")
organization of requirement writing is used, the mapping to the class within the design and to the code
can be completely clear. It requires work and clear thinking to maintain such clarity, however. For example, a
Customer paragraph that specifies the rentals that each customer can have could compromise traceability. The
design would probably have the classes Customer, D VD, D VDRental, and D VDRentals. The requirements
organization should reAect this.
Organizing classes by functionality, CUls, use cases, and so on has various advantages, as discussed in
Chapter 12, but traceability is not a strength for most of them. One would have to peruse each detailed
requirement and ask whether it will clearly map to a class.

M ETRICS FOR REQUIREM ENTS ANALYSIS

(Range: 0 to 1 00)
1 00 * L [traceability of each detailed requirement ( 0 - 2 )]
2 * [number of detailed requirements]
o

=

untraceable; 2

=

clearly traceable to a speci fic class

Figure 1 3 . 1 6 A tracea b i l ity metric

Here is a checklist for improving the traceability of requirements:
•

•

For each detailed requirement, is it clearly conceivable that an identifiable part of the code base will
implement it? (It's ideal when a single method implements a single detailed requirement.)
Is it clearly conceivable that a single, identifiable part of a software design and implementation could contain
it? (A detailed requirement that must be spread over several probable main modules is not easily traceable.

Traceability can be measured as in Figure 1 3 . 1 6. Using 2 as a measure allows the application of triage for
a give requirement, where 0
untraceable; 2 fully traceable; j otherwise.
=

=

13. 12 METRICS FOR REQUIREMENTS ANALYSIS

The previous sections of this chapter described metrics for a number of requirements qualities: accessibility,
comprehensiveness, understandability, unambiguousness, consistency, degree of prioritization, security, self­
completeness, testability, and traceability. Additional metrics can be considered.
The following list of quality assurance metrics includes requirements analysis metrics in IEEE Standard
982.2- 1 98 8 ("IEEE Guide for the Use of IEEE Standard Dictionary of Measures to Produce Reliable
Software"). Some measure the qualities we have already discussed in a different manner.
•

Percentage of unambiguous specific requirements (IEEE metric 6)

•

Degree of completeness (IEEE metrics 23 and 3 5)

•

Percentage of misclassified detailed requirements (in the object-oriented style, this measures the percent­
age allocated to the wrong class)

•

Traceability (IEEE metric 7)

•

Degree of atomicity (indivisible into smaller parts)

•

Consistent with the remaining requirements (IEEE metrics 1 2 and 23)

•

Measures of the effectiveness of requirements inspection

•

Percentage of missing or defective requirements found per hour of inspection

•

Measures of the effectiveness of the requirements analysis process

•

Cost per detailed requirement

•

On a gross basis (total time spent/number of detailed requirements)

343

344

CHAPTER 13

•

•

QUALITY AN D M ETRICS IN REQUIREMENTS ANALYSIS

On a marginal basis (cost to get one more)

Rate at which specific requirements are
- modified
- eliminated
- added

•

Measure of the degree of completeness of the requirements. This can be estimated from the rate, after the
official end of detailed requirements collection, at which specific requirements are .
- modified
- added

13. 13 INSPECTING DETAILED REQUIREMENTS

The reader is referred to Chapter 5 for a description of the inspection process in general.
Detailed requirements are the first software process documents that can be inspected against prior
documentation (the high-level requirements). Inspectors prepare for the inspection by reading over the high­
level requirements and comparing the detailed requirements with them. It can be very productive to inspect
requirements against each of the qualities and metrics listed above.
The rest of this section provides an example of a detailed requirements inspection. Here is an uninspected
version of detailed requirements for the Encounter video game case study on which we will perform an example
inspection, entering the results in a table (see Table 1 3. 3 ) . We employ the technique of automatically adding the
"not inspected yet" comment to each. It is removed when the inspection takes place. The final version of these
requirements, resulting from the inspection, is shown in the accompanying Encounter case study.

Area Requirement 1 ("Area name"). (Not inspected yet) Every area shall have a name of up to 1 5 characters.
Area Requirement 2 ("Area image"). (Not inspected yet) There shall be an image in gif form to display each
Area object.
Area Requirement 3 ("Display area method"). (Not inspected yet) Whenever a player character enters an
area, that area and the characters in it shall be displayed.

Area Requirement 4 ("Courtyard object"). (Not inspected yet) There shall be an Area object with name
"courtyard." Its image shall be that shown in Figure xx on page xx.

Area Requirement 5 ("Dressing room object"). (Not inspected yet) There shall be an Area object with name
"dressing room" and blank background image. The dressing room shall be adjacent to the courtyard area.

Encounter Requirement 1 ("Engaging a foreign character"). (Not inspected yet) When an engagement takes
place, the following computation is performed: The sum of the values of qualities of a game character
relevant to the area in question shall be referred to as the character's area value. (In this release, all qualities
will count as equal.) In an engagement, the system compares the area values of the characters and transfers
to the stronger, half of the points of the weaker. For example, suppose the player engages a foreign character
in an area requiring stamina and attention span, and ps is the value of the player's stamina, etc. Assuming Ps
'
+ P. > fs + fa, we would have ps'
p s + f/2, Pa
Pa + f.!2, fs'
fj2, fa' f/2 where x' is the value of x after
the transaction.
=

=

=

=

1015

1014

1013

1012

1011

1010

1009

1008

1007

Requirement 3

Player Character

Requirement 2

Player Character

Requirement 1

Player Character

Requirement 1

Foreign Character

Requirement 1

EncounterGame

Requirement 4

Encountercharacter

Requirement 3

Encountercharacter

Requirement 2

EncounterCharacter

Requirement 1

EncounterCharacter

Requirement 1

Yes

Engagement

1005

Area Requirement 4

1006

Note 3

Yes
Yes

Note 9
Yes
Yes
Yes
Yes
Yes

Yes
Yes
Yes
Yes
Yes
Yes

No6
Note 3
No7
Note 13
Yes

Yes
Yes
Note 12
Yes

Note
8

Yes

Yes
Note 10

Yes
Yes

Yes

Yes

Yes

Yes

Yes

No12
Note 3

No12
Note
10

No
12
No12
Yes
Yes

Yes

Yes

Note 15
Yes

No
10
Yes
Yes

Yes

Yes

Yes

No8,9
Yes
Yes

Yes

Yes

Yes

Note 11

Yes

Yes

Yes

Note
12

Yes

Yes
No1, 2
No2

Yes

Yes

Yes
Yes

Yes

Yes

Yes

Yes
Yes

No1, 2

Note 14

forward

No1

Yes

Yes

Yes

Note 3

Yes

Note 6

No5

Note 3

No2

Modifiable Testable

Yes

Yes

Yes

Yes

No3

No3

No1

Yes
Yes

Precise

Clear

Yes

Yes

Yes

Yes

No1

Yes

Yes

Yes

No3

No3

No1

unambiguous

Yes

Yes

Yes

Yes

Yes

Yes

Yes

Yes

Yes

Yes

Feasible

Traceable

Yes

Yes

Yes

Note 11

Yes

Yes

Yes

Yes

Yes

Yes

Note 5

Yes

Yes

Consistent

Yes

Yes

No11

Note 1

Yes

Note 7

Yes

Note 5

Yes

Yes

Yes

Note 2

Yes

Yes

Area Requirement 6

Area Requirement 3

1003

1004

Note 1

Yes

Note 2

Yes

Area Requirement 1

Area Requirement 2

Comprehensive

backward

Traceable

Description

1002

1001

No.

Requirement

Table 1 3.3 Example of a form used for the inspection of detailed requirements

W
.1>0
c.n

m
.0
c
;:0
m
s:
m
Z
--I
Ul

0
;;0

r=
m

�

m

0

G)

Z

(')
--I

Z
Ul
"0
m

346

CHAPTER 13

QUALITY AND M ETRICS IN REQUIREM ENTS ANALYSIS

EncounterCharacter Requirement i ("Name of game character"), (Not inspected yet) Every game character in
the Encounter video game shall have a unique name of up to 15 characters.
EncounterCharacter Requirement 2 ("Qualities of game characters"). (Not inspected yet) Every game
character has the same set of qualities, each having a floating point value. These are initialized to
IODin, where n is the number of qualities. The qualities are attention span, endurance, intelligence,
patience, and strength.

EncounterCharacter Requirement 3 ("Image of game character"). (Not inspected yet) Every game character
will be shown using an image that takes up no more than 1 /8 of the monitor screen.
EncounterCharacter Requirement 4 ("Engagement with foreign character"). (Not inspected yet) Whenever an
Encounter game character enters an area containing another game character and one of them is player­
controlled, the player character may either choose or be obliged by the game to engage the other
character. Whether there is a choice or not is controlled by the game in a random way on a 50% basis.

EncounterGame Requirement i ("Encounter game object"). (Not inspected yet) There shall be a single
EncounterGame object.

ForeignCharacter Requirement i ("Freddie foreign character object"). (Not inspected yet) There shall be a
foreign character named "Freddie," all of whose qualities have equal values and whose image is shown in
Figure 4. 57.

PlayerCharacter Requirement i ("Configurability"). (Not inspected yet) Whenever all foreign players are
absent from an area, the player may set the values of his or her qualities using the PlayerQuality­
Window, as long as the sum of the quality values remains the same.
PlayerCharacter Requirement 2 ("Main player character"). (Not inspected yet) The player shall have
complete control over a particular game character called the main character.

PlayerCharacter Requirement 3 ("Living points") (Not inspected yet). Encounter shall produce the sum of the
values of the character's qualities, called its living points.
We will show typical results of an inspection of these requirements. One inspection comment about this
set as a whole is that the requirements do not support enough expansion of the game into a competitive
product. A more particular defect is that the requirements do not properly specify the delay involved in
setting a player's quality values; during the delay the player is subjected to an engagement in an unprepared
state. (If the delay is too small, the player simply sets the qualities required for the area as high as possible and
the game is not much of a challenge.) Let's inspect the list of proposed detailed requirements one at a time.
Table 1 3. 3 is an example of a form that can be used for the inspection of detailed requirements, applied
to the above list. Most of the metrics previously described in this chapter can be computed from this table.
The table contains "Notes" and "No" notes.
Here are the "No" notes:
1 . Can a game character or area have a name with no characters?
2. The number 15 is rigid.
3 . Only one?
4. If the player controls several characters, are all of their areas to be displayed or does this have to do only
with the main player character?

SUMMARY

5. Filling the entire monitor screen?
6. It should be easier to add new qualities or remove them.
7. When is there a Freddie? When does he appear?
8. In future releases, characters may mutate.
9. Clarify what stays the same .
1 0 . Can the value of a quality be negative?
1 1 . Ambiguous, because the player can't control everything that happens to the main character at all times.
1 2. Refine "complete control."
The "Notes" are as follows:
1 . Is any keyboard character acceptable?
2. Check validity with the customer.
3. It is unclear how modifiable this should be.
4. It is hard to answer "complete" because it is unclear. See the note referenced in the "Clear" column for the issue.
5. We assume that the customer has some leeway in exactly what the "courtyard" will look like.
6. Are there dressing room exits to any other area?
7. This is somewhat clumsily written: could lead to misunderstanding.
8. It is usually preferable to have a single requirement match each attribute. This does not appear necessary,
as the qualities will be treated alike .
9. Produce at any time? On request? Show at all times?
to.

These details are not mentioned in the high-level requirements: check with customer.

1 1 . Clarify "50% basis," if possible.
1 2. For Internet versions, it may become necessary to have more than one instance of an EncounterGame
object. We will not exclude this possibility in future iterations.
1 3. It is not clear in what directions this could be modified.
1 4. Is the requirement written in such a way that it will be possible to trace it through to the code that
impleme nts it?
13. 14 SUMMARY

The quality of a requirements document is reflected in how well it expresses customer wants and needs. To
help ensure that requirements are of high quality, we focus on attributes they should possess. They include
the following:
•

Accessible

•

Comprehensive

347

348

C HAPTER 13

QUALITY AND METRICS IN REQUIREMENTS ANALYSIS

•

Understandable

•

Unambiguous

•

Consistent

•

Prioritized

•

Secure

•

Self-complete

•

Testable

•

Traceable

Requirements are inspected after they are written. They are the first software process documents that
can be inspected against prior documentation (the customer requirements). It can be very productive to
inspect requirements against each of the attributes listed above.

13. 15 EXERCISES
1.

(This is intended to be a closed book exercise.) list the qualities that requirements should possess
(one example: precise). In your own words, describe the meaning of each.

2. Explain why the following requirement for a book sales site is ambiguous. Modify the requirement
to make it unambiguous.
"Orders that include special edition books and overnight delivery or exceed $100 must be
processed over the phone."
3. Provide an example of three requirements for an order entry system that are inconsistent. How
would you modify them to make them consistent?
4. For the order entry system in Exercise 3, provide three requirements that are not testable, and
explain why each is not testable. Provide a modified version of each requirement to make it
testable.
5. Your instructor will pair up student project teams. Conduct an inspection of the other team's
detailed requirements. Evaluate the requirements against the list of metrics described in this
chapter. Prepare a table such as Table 1 3. 3 to summarize your results.

Formal and Emerging Methods
in Requirements Analysis: An
Introduction (Online Chapter)

14. 1 PROVABLE REQUIREMENTS METHODS
14.2 INTRODUCTION TO FORMAL METHODS
14.3 MATHEMATICAL PRELIMINARIES
14.4 THE Z-SPECIFICATION LANGUAGE
14.5 THE B LANGUAGE SYSTEM
14.6 TRADE-OFFS FOR USING A B-L1KE SYSTEM
14.7 SUMMARY
14.8 EXERCISES

To access this online chapter please visit waveland.com/Extra_Material/32306/.

Principles of Software Design

�nlen.nco
Testing

The Software
Development
Lifecycle

What are the goals of software

Planning

design?
How do you use various design

\

models for a single application?
What are use case model,
class models, data flow models,

Requianalrements
ysis

Implementation
�DeSign /

and state models?
How are frameworks used in design?
What are the IEEE standards for

expressing designs?

How does a team prepare for design
in practice?

Figure 1 5 . 1 The context and learning goals for this chapter

A "software design" is a representation, or model, of the software to be built. Its purpose is to enable
programmers to implement the requirements by designating the projected parts of the implementation. It is a set
of documents containing text and diagrams to serve as the base on which an application can be fully programmed.
A complete software design should be so explicit that a programmer could code the application from it without
the need for any other documents. Software designs are like the blueprints of a building that are sufficient for a
contractor to build the required building. They can be understood in two parts: high-level design, often referred
to as "software architecture," which is generally indispensable, and all other design, referred to as "detailed
design." It can be beneficial to make designs very detailed, short of being actual code. This is because engineers
can examine a detailed design for defects and improvements prior to the creation of code rather than examining

THE GOALS OF SOFTWARE DESIGN

only the code. The benefits of a fully detailed design are balanced against the time required to document and
maintain detailed designs. For large efforts, levels in between high level and detailed design may be identified.
This chapter introduces the concepts, needs, and terminology of software design . It sets the stage for
the remaining chapters in this part of the book, which include various concrete examples.
15. 1 THE GOALS OF SOFTWARE DESIGN

The first goal of a software design is to be sufficient for satisfying the requirements. Usually, software designs must
also anticipate changes in the requirements, and so a second goal is flexibility. Another goal of software design is
robustness: the ability of the product to anticipate a broad variety of input. These and other goals are summarized in
Figure 15. 2.
These goals sometimes oppose one another. For example, to make a design efficient it may be necessary
to combine modules in ways that limit flexibility. In fact, we trade off goals against each other in ways that
depend on the project's priorities.
A software design is sufficient if it provides the components for an implementation that satisfies the
requirements. To assess such sufficiency, one needs to be able to understand it . This fact is obvious, but it has
profound consequences. It can be difficult to create an understandable design for applications due to the large
number of options that are typically available. OpenOffice, for example, is a very complex application when
viewed in complete detail. Yet OpenOffice is simple when viewed at a high level, as consisting of a few
subapplications: word processing, spreadsheet, presentations, and database.
Modularity is thus a key to understandability. Software is modular when it is divided into separately named
and addressable components. Modular software is much easier to understand than monolithic software, and
parts can be replaced without affecting other parts. It is easier to plan, develop, modify, document, and test.
When software is modular you can more easily assign different people to work on different parts.
A design is a form of communication. In its most elementary form, it documents the result of a designer's
thought process, and is used to communicate back to himself thereafter when he needs to know what he
designed. This is fine if the designer is to be the only person who has this need, but a project usually involves
several people throughout its lifetime. If a design is not understandable for them, it is of limited value, and the
project's health is at risk . Design simplification, in particular, frequently results in a better design.
Understandability is usually achieved by organizing the design as a progression from a high level with a
manageable number of parts, then increasing the detail on the parts.
A good software architect and designer forms a clear mental model of how the application will work at
an overall level, then develops a decomposition to match this mental model. She first asks the key modularity

•

Sufficiency: handles the requirements

•

Understandability: can be understood by intended audience

•

Modularity: divided into well-defined parts

•

Cohesion: organized so like-minded elements are grouped together

•

Coupling: organized to minimize dependence between elements

•

Robustness: can deal with wide variety of input

•

Flexibility: can be readily modified to handle changes in requirements

•

Reusability: can use parts of the design and implementation in other applications

•

Information hiding: module internals are hidden from others

•

Efficiency: executes within acceptable time and space limits

•

Reliability: executes with acceptable failure rate

Figure 15.2 Principal goals of software design

351

352

CHAPTER 15

PRINCI PLES OF SOFTWARE DESIGN

Component
2

{l
:r���ponent

4

3

::::::::

I

I

/
(parts belong together) (mi n imal contact)
High cohesion

Low coupling

Figure 1 5. 3 H igh cohesion and low coup l i ng-bridge example

question such as: What five or six modules should we use to decompose a personal finance application? What
four or five modules neatly encompass a word processing application? After deciding this, she turns to
decomposing the components, and so on. This process is sometimes called "recursive design" because it
repeats the design process on design components at successively fine scales. Software decomposition itself
involves consideration of cohesion and coupling .
Cohesion within a module is the degree to which the module's elements belong together. In other
words, it is a measure of how focused a module is. The idea is not just to divide software into arbitrary parts
(i.e., modularity) , but to keep related issues in the same part. Coupling describes the degree to which modules
communicate with other modules. The higher the degree of coupling, the harder it is to understand and
change the system. To modularize effectively, we maximize cohesion and minimize coupling . This principle helps to
decompose complex tasks into simpler ones.
Software engineering uses Unified Modeling Language (UML) as a principal means of explaining
design. Understanding software design concepts by means of analogous physical artifacts is helpful to some,
and we will employ this means on occasion . Figure t 5 . 3, for example, suggests coupling/cohesion goals by
showing an architecture for a bridge, in which each of the six components has a great deal of cohesion and
where the coupling between them is low. The parts of each bridge component belong together (e.g., the
concrete and the embedded metal reinforcing it)-this is high cohesion. On the other hand, each component
depends on just a few other components-two or three, in fact. This is low coupling.
The "Steel truss" in Figure t 5.4, on the other hand, shows many components depending on each other at
one place. We would question this high degree of coupling.

High coupling

Figure 1 5.4 A q uestionable arch itecture-h igh cou p l i ng in a truss

X

THE GOALS OF SOFTWARE DESIGN

•

Obtaining more or less of what's already present
Example: handle more kinds of accounts without needing to change the existing design or code

•

•

Adding new kinds of functionality
Example : add withdraw to existing deposit function
Changing functionality
Example : allow withdrawals to create an overdraft

Figure 15.5 Aspects of flexibil ity: ways in which an application may be requ i red to cha nge

Low coupling and high cohesion are particularly important for software design because we typically
need to modify applications on an ongoing basis. Compare the life cycle of a typical software application with
that of the bridge in Figure 1 5 . 3: the likelihood that the software will require modification is many times
greater. Low coupledlhigh cohesion architectures are far easier to modify, since they tend to minimize the
effects of changes.
The number of top-level packages in an architecture should be small so that people can comprehend the
result. A range of "7 ± }" is a useful guideline, although specific projects can vary greatly from this range for
special reasons. As an example, OpenOffice would be hard to understand if we decomposed it into 1 00 parts
instead of four as follows: "word processing, spreadsheet, presentations, and database." The mind has much
trouble thinking of 1 00 separate things at more or less the same time. The difference between small- and
large-scale projects (such as OpenOffice) is the amount of nesting of modules or packages. Projects typically
decompose each top -level package into subpackages, these into subsubpackages, and so on. The "7 ± }"
guideline applies to each of these decompositions.
A design or implementation is robust if it is able to handle miscellaneous and unusual conditions. These
include bad data, user error, programmer error, and environmental conditions. A design for the video store
application is robust if it deals with attempts to enter DVDs with wrong or inconsistent information, or
customers who don't exist or who have unusually long names, or if it handles late rental situations of all kinds.
Robustness is an important consideration for applications that must handle communication.
The requirements of an application can change in many ways, and as a result a design must be flexible to
accommodate these changes. Figure 1 5 . 5 illustrates ways in which an application may change.
A set of previously used design patterns is a useful resource for flexible designs. Design patterns are
discussed in Chapter 1 7. We design so that parts of our own applications can be reused by others and ourselves.
Figure 1 5.6 lists the types of artifacts that often can be reused.

We can reuse
•

•

Object code (or equivalent)
Example : sharing dlls between word processor and spreadsheet
Cla s s es in source code form
Example: Customer class used by several applications
Thus, we write generic code whenever possible
-

•

Assemblies of related classes

•

Patterns of class assemblies

Example : the java.awt package

Figure 1 5 . 6 Types of reuse

353

354

CHAPTER 1 5

PRINCIPLES OF SOFTWARE DESIGN

As an example of class reuse, consider the class D VDRental that associates the DVD and the customer
renting it. Such a class is reusable only in another application dealing with the rental of DVDs, which is
limited. If, however, we design a Rental class dealing with the rental of an Item to a Customer, and if D VDRental
inherits from Rental, then we would be able to reuse the Rental portion for other applications due to its
generality. Design patterns facilitate the reuse of assemblies of related classes rather than individual ones.
Information hiding is a design principle in which the internals of a module are deliberately not usable by
code that does not need to know the details. This is supported in object-oriented languages by declaring a
public interface through which user code accesses the objects of a class. Private methods and attributes are
only accessible to the objects of the class itself. Information hiding allows the internals of a module to be
modi fied without the users of the module having to change. It also reduces complexity because the module
interface is fixed and well defined; using code need not be concerned with internal details.
Efficiency refers to the use of available machine cycles and memory. We create designs and implementa­
tions that are as fast as required, and that make use of no more than the required amount of RAM and disk.
Efficient designs are often achieved in stages as follows. First, a design is conceived without regard to
efficiency; efficiency bottlenecks are then identified, and finally the original design is modified. As an
example, consider the use of maps on the Web. When the user browses a map and wants to move to an
adjacent area, early algorithms required a separate page fetch. Algorithms were introduced, however, to
automatically fetch appropriate adjacent maps after the initial fetch, improving efficiency and, with it, the
user's experience. It is ideal if efficiency is considered at the time of initial design, however.
It is unrealistic to expect that a real-world application be t OO percent defect-free. An application is
reliable if it falls within a predetermined standard of fault occurrence . Metrics make this precise, such as the
average time between failures. Reliability is related to but different from robustness. Robustness is mostly a
design issue because one must specifically accommodate erroneous data in advance-accommodating it does
not happen by accident or experience. On the other hand, reliability is mostly a process issue, requiring
thorough inspection and testing of artifacts. Design affects reliability in that clean designs make it easier for
developers to produce error-free applications. However, a wide range of other factors make for rel iability,
because an application can fail for a wide variety of reasons.
15.2 INTEGRATING DESIGN MODELS

The architectural drawings of an office building comprise the front elevation, the side elevation, the electrical
plan, the plumbing plan, and so on. In other words, several different views are required to express a building's
architecture. Similarly, several different views are required to express a software design. They are called models.
Four important models are shown in Figure 1 5. 7, and they are explained next. Several ideas here are
taken from the Unified Software Development method of Booch, Jacobson, and Rumbaugh. Figure 15.7
includes an example from the Encounter video game case study to illustrate the four models and how they fit
together.
The subsequent sections of this chapter elaborate on these models so that they can be contrasted and
combined with each other. Subsequent chapters in this part of the book provide detailed examples of each.
1 5.2. 1 Use Case Model

This section describes several levels of use cases and related concepts. The use case model consists of the
following four parts:
1. The business use cases: a narrative form, suitable for developer-to-customer communication, describing the
required basic sequences of actions

INTEG RATING DESIGN MODELS

To express requ i rements, arch itecture, and deta i led design

Class model

Use case model

"with objects of these classes . . "

"Do this . . . "

.

e . g : , engage foreign character

e . g . , with Engagement . . . classes

Target
Application

Data flow model

State model

"in this way . . .

"reacting to these events . "

"

e.g. , character scores flow

..

e.g. , when foreign character enters

from . . . to . . .
•

Video game example

Figure 1 5 . 7 Models to express designs (and parts of req U i rements)

2. Their refinement into regular use cases , described in Chapter I I
3 . Their transformation into sequence diagrams (covered in Chapter 16) , which in turn can be in two successive
stages of refinement:
(a) With informal functionality descriptions, at first lacking all details
(b) With speci fic function names and showing all details
4. Scenarios : instances of use cases that contain speci fics, and that can be used for testing. For example, a
scenario of the use case step

Customer chooses account
would be something like

John Q. Smith chooses checking account 1 2 3 4 5 .
The use case model expresses what the application is supposed to do, as suggested in Figure 1 5. 8.
15.2.2 Class Models

Classes are the building blocks-more precisely, the types of building blocks-of designs. Class models
consist of packages (a grouping of classes) that decompose into smaller packages, and so on, which decompose
into classes, and these, in turn, decompose primarily into methods. This is shown in Figure 1 5 .9. We cover
classes in more detail in Chapter 16.
15.2.3 Data Flow Models

The class model describes the kinds of objects involved; it does not show actual objects. The data flow model, on
the other hand, shows speci fic objects and the types of data flowing between them. It is related to the class

355

356

CHAPTER 1 5

PRINCI PLES OF SOFTWARE DESIGN

Use case model :

- - - - - - - - - - - -

1

-

-

Use case
-

elaborated by . . .

- - - - - - - - - - -

-1

Scenarios

I

Target
Appl ication

Data flow model

Figure 1 5 .8 The role of use case models i n design

model, because the objects involved must belong to the classes in the class model. We discuss data flow
diagrams in Chapter 1 6 . Figure 1 5 . 10 shows the parts of a data flow model.
15.2 .4 state Models

State models reflect reactions to events. Events i nclude mouse actions and changes i n variable values. Events
are not described in class models or component models, but they do occur in the state model. We introduced
states in Chapter 1 1 as one way to describe the requirements of an application. The states in that context
describe the external behavior of the application . The states we are referring to here reflect the state of

Class model

Package

Consists
of . . .

Methods

Figure 1 5 . 9 The role of class models i n design
Source: Jacobson, Ivar, "Object Oriented Software Engineering: A Use Case Driven Approach," Addison-Wesley, 1 992.

FRAM EWORKS

Data flow model

I

;

proceSSi n
or g a n ized
by . . .

element

'

�;-

---

.....

"
"

:

.....

.....

-1

D_a_t_
L_
a_
ty
__--,
pe

..... � _D
r
_a_t_
a_s_t__
o e---'
1L

""'
'---------- ------------'
S u b p ro c e s i n g e I e m e n t

I

Figure 1 5 . 1 0 The role of component models in design
Source: Jacobson, Ivar, "Object Oriented SOftware Engineering: A Use Case Driven Approach," Addison-wesley, 1 992.

Target
Appl ication

State model : "reacting to these events"

I

States

�--------1

Substates

decompose
i nto . . .

Transitions

Figure 1 5 . 1 1 The role of state models in design
Source: Jacobson, Ivar, "Object Oriented Software Engineering: A Use Case Driven Approach," Addison-Wesley, 1 992.

elements in a software design. The role of state models is shown in Figure 1 5 . I t . They are described in more
detail in Chapter 16.
15.3 FRAMEWORKS

As we have seen, the reuse of components is a major goal in software development. If an organization can't
leverage its investments in the skill of its designers and programmers by using their work several times over,
competitors who do so will be faster to market with superior products. The parts of an application that are
particular to it and are not reused are often called its business logic . Business classes are essentially the domain
classes discussed in Chapter 1 2.
Where do we keep the classes slated for reuse? How do we organize them? Should we build in relationships
among these classes? Do they control the application or does the application control them? The computing

357

358

CHAPTER 15

PRINCIPLES OF SOFTWARE DESIGN

Rentalltems

I

I
RentalCustomers

l

r

II
I

j

Figure 15 . 1 2 A framework for rental applications

community has learned from exper ience that merely making a l ist of avai lable functionality does not necessarily
result i n reuse. We have learned , however, that arrangements l ike the Java A PI (coherent sets of classes) do
i n deed lend themselves to highly successful reuse . The J ava APls (3D, 2D, Swing, etc. ) are frameworks.
A framework, sometimes called a library, is a collection of so ftware artifacts usable by several di fferent
app l ications. These arti facts are typically implemented as classes, together wi th the so ftware required to
uti l ize them. A framework is a kind o f common denomi nator for a family of app l ications. Progress ive
development organizations designate selected cl asses as belonging to their framework . Typ ical ly, a
framework begi ns to emerge by the time a development orga n i zation develops its second to four th
appl ication. As an example, consider the Rental framework shown in Fi gure 15.12 that our video store
appl ication could use . Thi s architecture divides the elements i n to the items tha t can b e rented (b ooks, DVDs,
etc. ), the people who can rent them, and the rental records that associ ate members from the first two parts.
The individual classes in the framework wi ll be supplied later . Frameworks l ike these are usually
obtained in a comb i ned bottom-up and top -down manner: bottom-up by exam ining the structure of actual
appl ication archi tectures such as the video store appl ication, seeking more general forms; and top -down by
conceptualizing about the needs o f a particular family of appl ications such as rentals.
Classes within a framework may be related. They may be abstr act or concrete. Appl ications may use
them by means of i nher itance, aggregation, or depe ndency. Alter natively, as we will see below, a framework
may feel like a gener i c appl ication that we customize by inserting our own parts.
Figure 15. t 3 shows the relationship between fra mework classes, domain classes, and the remaining
design classes. The design for an appl ication consists of (I) the doma i n classes (tha t are special to the
Frameworkclasses

1----------1

The architecture

The detailed design

The Class Model ./

I
I
I
I
I
I

Design classes

I
I
I
I
I

Domain classes

/�

/

I
I
I

I Rentalltem I

�

I
I
I
I
I

I
I
I
I
I

� :

L _________ ..."

Figure 15.13 Class model VS. architecture and detailed design

SUMMARY

1. Introduction
1.1

1.2
1.3

Purpose
Architecture
....
Scope
. ....
... .
Definitions, acronyms, !
and abbreviations

2. References

3. Decomposition description

3.1 Module decomposition
3.1.1 Module 1 description
3.1.1 Module 2 description
3.2 Concurrent process
decomposition
3.2.1 Process 1 description
3.2.2 Process 2 description
3.3 Data decomposition
3.3.1 Data entry 1 description
3.3.2 Data entry 2 description

4. Dependency description

4.1 Intermodule dependencies

4.2 Interprocess dependencies
4.3 Data dependencies

5. Interface description

5.1 Module interface
5.1.1 Module 1 description
5.1 .2 Module 2 description
5.2 Process interface
5.2.1 Process 1 description
5.2.2 Process 2 description

6. Detailed design

6.1 Module detailed design
6.1.1 Module 1 detail
6.2.2 Module 2 detail
6.2 Data detailed design
6.2.1 Data entity 1 detail
6.2.2 Data entity 2 detail

Figure 15.14 IEEE 1016-1998 SOD example table of contents

appl icati o n ), (2) some of the framework classes ( generally speaki ng, not all are needed) , and ( 3 ) the remaining
classes needed to comp lete the desi gn, which we are cal l i n g simply "design" classes. The design classes consist
o f those required for the architecture and those that are not. The l atter are e ffectively the detai l design classes,
required to complete the design . These three constitute the class model for the appl icati o n . All o f the domain
cl asses are i n the detai led design because they are very speci fi c . The framewor k classes used are part o f the
application's architecture.
The framework classes used in the design are part of an application's architecture, as shown in the figure.
The domain classes are usually part of the detailed design since they are speci fic to the application and are not
architectural i n nature.
1 5.4 IEEE STANDARDS FOR EXPRESSING DESIGNS

The IEEE So ftware Des ign Document ( SOD) standard 1016- 1998 provi des guideli nes for the documentation
o f desi gn. The table o f contents is shown in Figure 15.14. IEEE guidel i nes explain how the SOD could be
organized for var i ous architectural styl es, most of which are descr ibed above . The case study uses the IEEE
standard, with a few modi fi cations, to account for an emphasis on the obj ect-or i ented perspective . As shown
i n Figure 15.14, Sections 1 through 5 can be considered so ftware architecture, and Section 6 can be
considered the detailed design, to be covered in the next chap ter.
1 5.5 SUMMARY

So ftware design is a model of the intended software application, as spec i fied by its requirements. A software
design is analogous to the bluepri nts of a house .
Good so ftware desi gns should ex hibit the following characteristics: sufficiency, understandability, modular­
ity, high cohes ion, low coupling, robustness, Aexibility, reusability, information hiding, e fficiency, and reliabi lity.
When expressing a software design, it is help ful to use several di fferent con nected views, or models. A
use case m odel descr i bes wha t the appl ication is i n tended to do from the point of view of the user. Sequence

359

360

CHAPTER 15

PRINCIPLES OF SOFTWARE DESIGN

d iagrams are derived from use cases and describe obj ects and the sequence of methods calls between them.
Class models are a static representation of the classes of the design and the relationship between them . A data
flow m odel shows specific obj ects and the types o f data flowing between the m . A state model shows design
elements and their reaction to events.
Frameworks are collecti ons o f reusable software that implements a general solutio n to a general
problem . For example, CUls are often desi gned via frameworks so that new applications do not have to
rewri te code to implement a CUI. They can instead leverage the existing CUI code and j ust add their own
customization.

1 5.6 EXERCISES
1. Write a paragraph describing what a "software design" is, and why i t is important.

2 . In your own words, define the goals of so ftware design and explain why each goal is important.
3 . I n your own words, define the followi ng terms: modularity, cohesion, and coupling. Why is each a
desirable property of so ftware designs?
4.

Can a design be cohesive and exhibit a h igh degree o f coupli ng? Explain your answer and prov ide
an example.

5 . How migh t coupling and reusability be related? How might cohesion and reusability be related?
Explain your answer and provide one example for each.
6. In your own words, ex plain what is meant by robustness. Below is code for a method divide(). Make
the method more robust in at least two ways .

public double divide ( Double aNumerator, Double aDenominator )

{
}

7.
8.

return aNumerator. doubleValue ( ) / aDenominator. doubleValue ( ) ;

Using the I nternet, research one of the many J ava API frameworks ( e . g., Swing,JMF,20, 30 ) . In a
few paragraphs, describe the design of the framework and how it accommodates reuse .
Provide a modularization for an application that advises clients on stock picks, and enables them to
transfer funds among various stocks and sav i ngs accounts. Explain your soluti o n . Hint: One
reason able soluti on employs four packages.

The Unified Modeling
Language

�n
Testing

Planning

How does UML represent class
relationships such as inheritance,
aggregation, and dependency?

ton.nc.

The Software
Development
Lifecycle

\

What is a sequence diagram?
Requirements
analysis

Implementation

What is the UML notation for classes
and packages of classes?

How do UML activity diagrams
relate to flow charts?

/

�DeSign

Figure 16.1 The context and learning goa ls for this chapter

Recall that a "software design" is a representation, or model, of the software to be built. For many years,
so ftware engineers rel i ed on a m iscell any of somewhat unrelated graph ical means for getti ng across the point
o f their designs. Their pri nci pal means were data flow diagrams, flowcharts , and ways to picture the location
o f physical Illes. These were never very sati s factory. With the advent and wide acceptance o f obj ect-oriented
methods, leaders in the so ftware engineering community began to pool and relate their ideas for notatio n and
graphical representation of software designs. Classes, for exam ple, now needed to be represented in design
figures. The U nified Modeling Language ( UML ) i s the result.
I n this chapter we i ntroduce the UML, which is now a widely accepted, largely graphical notation for
expressi ng object-oriented designs. The UML standard is managed by the nonprofi t Object Management

362

CHAPTER 16

THE UN IFIED MODELING LANGUAGE

Canister

�

+:Visible
from without

+ numCanisters: int
numWafers: int
•

• size: float
+ displayO

I+----- Class name
I+----- Attribute: type

I+----� + getNumOpenSlotsO
setStatusO
•

Responsibilities:
describes each
canister undergoing
fabrication
••

Operations

Place for

I--- comments

Figure 1 6.2 Class details in UML
Group consortium of companies (www. omg. org), and takes hundreds of pages to formally spec i fy . As a resul t,
UML tends to be inclusive (some say too much so), incorporati ng data flow and, in effect, flowcharts; but it
contains much more that we do not have space i n thi s book to include. The parts that we do cover, however,
are adequate for most of our needs . UML is an excellent step i n the direction of improv i n g so ftware
engi neeri ng, but wil l probably be improved upon as the discipl i n e evolves.
The chapter describes class relationships in UML, including i nheritance ( Class Models, Section 16.2) a
way to represent control among functions (Sequence D i agrams, Section 16 .5 ) , di agrams of state, even ts, and
transitions ( Sectio n 16.6 ) , its modernization o f flow charts (Activi ty Di agrams , Section 16.7 ), and finally data
flow diagrams ( Section 16. 8 ). Section 16. 9 shows an example that combines these .
1 6. 1 CLASSES IN U M L

Classes in UML are represented b y rectangles containing the class name a t a minimum. The detailed version
includes attribute and operation names, signatures, visibility, return types, and so on. Figure 16.2 shows a class from
the detailed design of an application that controls the flow in a chip manufacturing plant of canisters holding wafers.
Not all of the attributes need be speci fied in the class model. We show as much detail as needed,neither more
nor less. Showing more detail clutters a diagram and can make it harder to understand. Some required attributes
may be left to the discretion of the implementers . It is also common to omit accessor functions from class models
(e. g., getSize() and setSize()) since these can be i nferred from the presence of the corresponding attributes (size).
As an example of a class , consider an application that assists the user in drawing a simple figure of a
person using geometric shapes. We'd probably want a Rectangle class for this with attributes such as length and
breadth. S ince the applicatio n i s supposed to be smart, we'd want it to use the concept of a foot ( e . g., to know
where feet belong) , so we'd probably want a Foot class. By i ntroducing these classes, we are improv i ng the
cohesion of related parts, such as the attributes of a foot, the understandab i l i ty of the design, and its
modularity . We are also h i ding information until it's needed. This example will be explored as we go through
this chapter, and will be described as a whole in Section 16. 9.
1 6.2 C LASS RELATIONSH I PS IN U M L

Thi s sectio n d iscusses the way i n which UML collects classes a n d such i n packages. It also in troduces
relationships called associations .

CLASS RELATIONSHIPS IN UML

UML Notation...

Typical Implementation

and

package of classes

..�

myPackage

package myPackage;
class MyFirstClass { .. . }

mySubPackage
MyClass

... �

I

package myPackage.mySubPackage;
class MyClass { ... }

subpackage

"hidden»

MyFirstClass

.

. ..
.
..
..

..

acccessibility of classes
from outside package

public package
myPackage;
class MySecondClass { ...

}

..
..•

"visible»

MySecondClass

Figure 1 6.3 UML notation for packages and Java implementation

1 6.2. 1 packages

The Uni fied M odeling Language uses the term package for collecting design elements such as classes. UML
packages can contain subpackages, or any materials associated with an application, i ncluding source code,
designs, documentation, and so o n . Figure 16. 3 shows the UML notation for packages and subpackages.
Classes with i n a package can be specified as access ible or as inaccessible from code external to the package.
"Package" also happens to be the name of collections of J ava classes. Java packages translate i n to file
d i rectories; their subpackages decompose into subdirectories, and so o n . The J ava i mplementation o f thi s i s
shown i n Figure 16. 3 .
1 6.2.2 Associations

Attributes are one way of showi ng the p roperties of a class, and are generally used to denote simple types such
as integers or Booleans. Association is an add i ti onal method o f i ndicating class properties, and is commonly
used to denote that obj ects o f two classes depend on each other in a structural way. Associations are drawn
with a solid line between two classes. We can annotate the rel ationship, which may be one- or two-way. Two­
way associations are problematical because we need to be sure that both ends of the i mplied i n formatio n are
kep t consistent. Thi s is illustrated in Figure 16.4.
Consider an application that assists the user in drawing a simple figure of a person. We m ay want a
FootShape class i f the shape of a foot needs to be descri bed (promoting the "sufficiency" of the design ) . There
would be an association between FootShape and Foot, i nd icati ng coupling between the two. Thi s example is
descri bed as a whole i n Secti on 16. 9 .

363

364

CHAPTER 16

THE UN IFIED MODELING LANGUAGE

employs

<III is employed by

class Employer
{
Employee[ 1 employees;

class Employee
(
Employer[ 1 employers;

Figure 1 6.4 UML notation for associations
1 6.3 M U LTI PLICITY

The ends of an association l i ne can be annotated with multiplicity, which describes the numerical rel ationship,
or the number of i nstances, of each class. For example, consider the Employer/Employee relati onship as shown i n
Figure 16. 5. The " 1 . . 3" next t o Employer i nd icates that each instance ( object) of an Employee c a n b e associated
with 1-3 instances of an Employer. Conversely, the "1 .. *" next to Employee means that each i nstance o f an
Employer can be associated with a m i n i mum o f one Employer (with no maximum ) . In other words, the
multiplicity next to a class i nd icates how many i nstances of that class are associ ated with one instance of the
class at the other end of the association l i n e . A single value can be used to i ndicate an exact number o f objects .
I f a multiplicity is n o t prese nt next t o a class, the assumed value is 1 . Th is is also illustrated in Figure 16. 5,
which shows that one Employee is associated with exactly one PersonalInfo instance, and vice versa.
1 6.4 INHE RITANCE

In UML, inheritance describes a relationship between classes in which one class assumes the attributes and
operations of another. It is often thought of as an "is-a" rel ati onship. For example, since an Employee "is-a" Person,
we can express thei r relationship with i nheritance by saying that an Empl oyee i nherits from a Person. UML
1 ..3

employs �

<III is employed by

1 ..•

Personallnfo

Figure 1 6.5 Multiplicity of associations in UML

INHERITANCE

UML Inheritance

MyPackage

l

... Typical I mple mentation

package MyPackage;
abstract cl¥s MyAbstractClass ....

..
.. .
r ... . ..package
MyPackage;

abstract class

I

... and

,

.. ..

MyAbstractClass

... .

....... . .... .. .............

.

·

class MyDerivedClass exte2ds MyAbstractClass

D . . . . . . .. ..........f

inheritance
. .. . ..

. .. .. ..

......·.... · ....
·....·..·......·....·....·............·....................'

. .. .

. . �int att;

.. · . ...... .

,

I

My DerivedClass
att: int

void myFunction( ReferencedClass r )
{ .}
..

t

,

. ......... attribute

.. ....

myFunctionO

oper.ation

I

Figure 1 6. 6 Inheritance in UML and Java implementation

i ndicates i nheritance with an open triangle. We refer to the class being i nherited from (e . g. , Person) as a base
class; the class doing the i n heriting ( e. g., Employee) is a derived cl ass.
Figure 16.6 sh ows an example of a package consisting of two classes: MyAbstractClass and MyDerivedClass,
with MyDerivedClass i nheriting from MyAbstractClass.
Abstract classes-that is, those classes that cannot be instantiated into objects-are denoted with italics. Interfaces
are collections of method prototypes ( name, parameter types, return types, and exceptions thrown) . Classes realize
interfaces by implementing the methods that the interface promises. The UML notation is shown in Figu re 16.7 .
It is customary to arrange cl ass models so that base classes are physically above derived cl asses.
However, thi s positi oning is not necessary in any technical sense .

UML Notation...... Typical Java Implementation

interface
1----------------1

:

Mvlnterface

interface MyAbstractClass ....

:

f'ass MyClass imPle1ents Mylnterface
i ��� ��� � i
�-------------�����----------�
realization
e

__

!

__

I

I
I

MyClass
myMethodO
Figure 1 6 .7 Interfaces in UML and Java implementation

365

366

CHAPTER 16

THE UN IFIED MODELING LANGUAGE

Consider again the appl ication that assists the user in drawing a simple figure of a person. Si nce it deals
with various geometric shapes, we may introduce a GeometricShape class from which Rectangle and such inherit.
Th is saves us from hav i ng to repeat code common to Rectangle, Circle, Triangle, and so on, thereby promoting
modul ari ty, flexibil ity, and reusabi l i ty in the design. This example is described as a whole in Section 16 . 9.
1 6.4. 1 Aggregation

Aggregation is a type of association that can be thought of as a whole- part rel ationsh i p . It is denoted with an
open d i amond next to the aggregator (whole ). Aggregation i n dicates the structural i nclusion o f objects o f
one c l a s s b y another, and is usually i m p lemente d b y m e a n s o f a c l a s s (whole) hav i ng an attribute whose
type i s the i n cluded class ( p art). Aggregation i s shown i n Figure 16. 8, with both Company and Employ­
eeDirectory each considered a "whole," and each consisting of multiple Employees, the "parts. " The label "emp"
next to the diamond den otes the re ference i n Company and Employer to the aggregated Employee. The use of
aggregation i m pl ies that i f a particular Employee is both a part o f the Company a n d part of the Employ­
eeDirectory, then the two aggregators "share" the Employee instance that is part of both. That i s, if "Jane
Doe" i s an Employee, then one instance o f her Employee record i s created, and both Company and
EmployeeD i rectory re ference that instance.
Return ing to the application that assists the user i n dr awi ng a simple figure o f a person, the association
between Foot and FootShape probably turns out, more specifical ly, to be an aggregation o f FootShape by Foot.
This example is described as a whole i n Section 16.9.
1 6.4.2 Composition

Composition is a stronger form of aggregation in which the aggregated obj ect ex ists only duri ng the lifetime
(and for the benefit of) the composing obj ect- no other object m ay reference it. The composed obj ect is
created and destroyed whe never the composing obj ect i s created and destroyed. Composition im plies that
the composed i nstance is not shared. For examp l e , Figure 16.9 shows that Employee i nstances are structurally
part o f Company and EmployeeDirectory. For any given employee such as "Jane Doe," a separate in stance of her
Employee obj ect is created as part o f Company and EmployeeDirectory.

Company

aU: int

aggregation
*

myFunctionO
aggregation

class Company
{
Employee emp;
int aU;

class
EmployeeOirectory
{
Employee emp;
int att;

emp

EmployeeDirectory
att: int
myFunctionO

Figure 1 6 . 8 UML representation of aggregation and Java implementation

IN HERITANCE

composition

Company
att: int

joI--�-:-:-----�
�-:------. *-----�.I
--

myFunctionO

�

�
��
��
�
��

emp

� -/

�

T

Employee

{.. }

att: int

class Employee emp;

{.

.

.

.

emp

EmployeeDirectory

class EmployeeOirectory

{

class Employee emp;

*

I

composition

�.

class Company

{

,

myFunctionO

}

Figure 1 6.9 UML representation of composition and Java implementation
1 6.4.3 Dependency

Dependency, denoted with a dotted l i n e arrow, means that one class depends upon another i n the sense that i f
the class a t arrow's end were t o change, then this would affect the dependent class. Strictly speaking,
dependency includes associati o n , aggregation , composition, and i nheritance. However, these relationships
have thei r own notation, and we usually reserve dependency to i nd icate that a method o f one class utilizes
another class, and to relate packages. This is shown in Fi gure 16.10.

De p end ence: UML Notation ... and ...Typicallmple mentation
MyDependentClass
att: int

+

myFunctionO

class MyDependentClass

{

MyReferencedClass

dependence
(reference to a class)

void myFunction1 ( MyReferencedClass r)
t. . . .
{ .}
.

........ ..... ... .....................................

.

parameter

MyReferencedClass myFunction2( ... )

{ . }
.

.

t.

..............................................................................................................

void myFunction3( ... )

{

}

or return type

�

MyReferen edClass m ...
t..................................................................................... or loc l v

a

ariable type

Figure 1 6. 1 0 UML representation and Java implementation of dependence (excluding inheritance and aggregation)

367

368

CHAPTER 16

THE UNIFIED MODELING LANGUAGE

CustomerMaiiApp lication
customer

generateMailO
getCustomerTypeFromUser()
mainO

""""
'"�-.......

-

-

-

-

-

�----�----�

-

-

­
-

-

-

�--��----�

RegularCustomer
createMailO

CustomerMailApplication
generateMailO

customer

getCustomerTypeFromUserO
mainO
Figure 1 6 . 1 1 Example of a class diagram (class model) for a customer mail application

1 6.4.4 Class Diagrams

Class diagrams help us to visualize the design of applications. They describe the types of objects in the application,
their attributes and operations, and the static relationships between them [I] . Consider an application producing e­
mail text for various kinds of customers. A possible UML class diagram is shown i n Figure 16. II . It says that the class
CustomerMailApplication has a variable named customer, which is of type Customer. Since Customer is abstract, the customer
variable is either a DelinquentCustomer, MountainCustomer, or RegularCustomer. When customer.createMailC) is called, one of
the three versions of createMailC) is called, depending on the class that customer belongs to.
The strength of class diagrams is that they help us to envisage the building blocks of an appl icati o n .
Note, however, that they d o not indicate t h e way i n which t h e application executes . In t h e Customer M a i l
Appl ication class model, for example, there i s no way to tell what method executes after main(). Sequence
diagrams, discussed in Secti on 16. 5, prov i de this capab i l i ty.
1 6.4.5 Object Diagrams

An obj ect diagram shows objects and their rel ationships. An object is a particular real i zatio n of a class, so
obj ect models are derived from class models. There are many possible obj ect models der iving from a class
model . For example, let's return to the class model i n Figure 16.4. F i gure 16. 12 shows one object model that
derives from i t. Whereas class models are com pile-time relationshi ps, obj ect models are usually runtime
relationships. Figure 16. 12 shows that the obj ect ajaxCorp:Compal1Y employs the objects sue:Employee and joe:
Employee. It also shows that the obj ect abcCorp:Company employs the obj ect joe:Employee.
1 6.5 S EQUENCE DIAG RAM S

Use cases are a good complement to classes because they de fine steps through which a user and an appl ication
transitio n . To use them i n design , however, we refine them i nto a more tech nical form so that class and
methods that enable them can be identi fied. I n addition, there are many sequences of actions that appl ications

SEQUENCE DIAGRAMS

Class Model

[ EmPloyer 1r- 1_.. 3
_

1

1 . .n
_ -i Employee

__________

I

One Particular Derived Object Model
,-------3>1 sue: Employee

ajaxCorp:Employer

abcCorp:Employer
Figure 1 6. 1 2 Example of a class model and a particular object model in UML derived from it

need to be designed for but are not use cases . The number of possible sequences of functio n calls-even
common ones-is very l arge , whereas the number o f use cases is kept relat ively small (4-20 for small jobs and
at most hundreds for extremely large ones). Sequence diagrams are graphical representations o f control flow,
and are particularly useful for describing executions that i nvolve several objects, as found in the scenario o f a use
case . Sequence diagrams require us to thi nk in terms of obj ects and functions. The l i fetime of each object
i nvolved is shown as a sol id vertical line, with the name o f the obj ect and its class at the top. Each i n teraction
between obj ects is shown by means o f a horizontal arrow from the obj ect i n i tiating the service to the obj ect
supplying the service. As an example we develop a sequence diagram for the Check Out use case for the video
store appl icati o n . Figure 16. 13 shows a beginning sequence diagram for the use case.

erk

I

:MainScreen

doCheckoutO

II

:BarCodeReader

Originates from use case'

I

1. User swipes bar code

..

3. User enters duration ...

�lJ
readO

�{

Step 20f
use case

order

2. Application prompts
for rental duration

..

}

I

:CheckoutOptionDispl

Step 1 of use case

initiateO

8

I

:Checkout

..
...

I
I

I

I

showO

J

....

I
I
I
I
I
I
I
I
I

Figure 1 6. 1 3 Beginning of a sequence diagram for Check Out use case in video store design

369

370

CHAPTER 16

THE UN IFIED MODELING LANGUAGE

The following notes explain the correspondi ng features of the diagram:
Note 1: In a sequence diagram, time goes in a downward directio n . In this example, doCheckout()
occurs first, followed by read() and then initiate(), and so o n .
N ote 2: U s e cases are i n i ti ated e i ther b y t h e user, as this one i s , or b y an obj ect. I n i tiation
begi ns at the top l e ft o f the diagra m , and a solid vertical l i ne beneath this symbol is drawn to
i ndicate that the entity already exists. We can supply preconditions to spec i fy assumptions
that apply at the i n ception o f the sequence.
Note 3: Sequence di agrams show the i n i tiation and execution of a sequence of functions. The
obj ect at the beginning o f each arrow initiates work; the obj ect at the end o f the arrow carries out the
work of the method i n dicated. E ach elongated rectangle denotes the execution o f a method of
the correspondi n g object.
I n our Check Out seque nce di agram, the clerk init i ates the second functi on by swi p i n g the bar cod e
reader over the vi deo . We the n determ i n e who or what should execute the responding functi o n . S i nce a
bar code reader recogni zes a swipe, we may dec i de that a BarCodeReader obj ect would be appropri ate for
dealing with actions relating to the physical reader, and that the required functi on of BarCodeReader will be
n amed reade). There will be only one BarCodeReader obj ect for the ent i re appl icati o n , so the notati on
":BarCodeReader" to represent this obj ect is sufficient. There is no need to name a BarCodeReader obj ect; we
may dec i de later to make the read() method of BarCodeReader static , in which case no actual BarCodeReader
obj ect would be i nvo lved.
Note 4: We can capture the checkout process with a Checkout cl ass. The BarCodeReader object then
creates a Checkout obj ect. We have used a factory method initiate() here to create and initialize the

User

I

:MainScreen

doCheckoutO

I

I

:BarCodeReader

I

:CheckoutOptionDisplay

..

"-lJ

1. readO

..
...

2.1 initiateO

I

:Checkout
..
....

II

:Account

I

2.2 createO
..

... � 2.3 showO ..

...

3. setDurationO

..

...

This sequence diagram originates from Use case:
1. User swipes bar code

2. Application prompts for rental duration
3. User enters duration

4. Application stores record

Is. printO ...
...

5. Application prints customer's account status
Figure 1 6 . 1 4 sequence diagram for Check Out use case in video store design

I

"-l

....

4. storeO

SEQUENCE DIAGRAMS

I Player

I

Encounter
Game

I

main PlayerCharacter:
PlayerCharacter

I

freddie:
ForeignCharacter
I
I
I
I
I

I
I

create and display
�

I

move

create and display

I
I
I
I

move

U
Figure 1 6. 1 5 A sequence diagram showing concurrence

Checkout obj ect. The method initiate() then creates a displ ay for choosing checkout options and
shows i t on the console. A complete sequence diagram for the use case is given i n Figure 16. 14.
In the previous sequence diagr ams, the solid arrow head i ndicates synchronous method calls, meaning that
the caller receives control back when an operation is complete . Sequence di agrams show asynchronous
messages using either stick arrow heads or half-arrows. An asynchronous message means that the caller does
not wait for an operation to complete. Instead, control returns immedi ately back to the caller and the result, i f
any, is processed at a later time. The called method executes i n a separate thread, either b y spawn ing a new
thread or executing within an exi sting thread. The elongated rectangle at the end o f the arrow represents a
thread that executes in parallel. As an example, we migh t want the game char acters of Encounter to move
i ndependently from area to area during the action. This is shown in Figure 16. 1 5 with both a PlayerCharacter
and ForeignCharacter running in separ ate threads.
Figures 16.16 and 16. 17 summar i ze the steps needed to create a sequence di agram.
When the i n i tiator is the user , a simple label at the top suffices, r ather than a rectangle. Note that the
object responsible for executing the method named on the arrow is at the end (not the begi nning) of the arrow.
1. Identify the use case whose sequence diagram you
will build (if applicable)
2. Identify which entity initiates the use case
- the user, or

name the class
name the object, if possible

- an object of a class

-r
:� � i���:t�� �b1���a� 1������ . �. � �������. . ... .. . . J):
I
•

•

3.

o

e

91 t

nt

-use UML object:Class notation"

!

4. Draw an elongated rectangle beneath this to represent i

the execution of the operation initiating the process

5. Draw an arrow pointing right from it
Figure 1 6. 1 6 Steps for building a sequence diagram, 1 of 2

I

:

371

372

CHAPTER 16

THE UNIFIED MODELING LANGUAGE

6. Identify which entity handles the

operation initiated
-

an object of a class
•
•

name the class
name the object

7. Label the arrow with the name of

operationO

the operation

8. Show a process beginning, using
9 .
.

an elongated rectangle

. Continue with each new
statement of the use case
. . .

Figure 1 6. 1 7 Steps for building a sequence diagram, 2 of 2

1 6.6 STATE DIAG RAM S

We i ntroduced the concep t of state and tra n s i t i on s in Chapter 1 1 as a way to sometimes express
requirements. A state diagram shows the states o f the obj ects o f a class, the events to which the obj ect are
sensit ive, and the result i n g tr ansitions between them . State diagrams are also k nown as state-transition
diagrams or statecharts.
1 6.6.1 States and Substates

In UML , substates of a state are simply shown as nested rounded rectangles . Figure 16. 1 8 shows the states and
substates that may be present i n an OnlineShopper class. It shows that while a shopper is check i n g out , she can
be havi ng her credit val idated.
The state Incomplete indicates that the shopper has signaled a readi ness to check out but has not yet submitted
credit card information . The black dot and arrow i ndicate that OnlineShopper objects are initially in the Browsing state.
1 6.6.2 Events

In the con text of state models, an event is something whose occurrence affects obj ects of the class in quest i o n .
Examples o f events are a button click on a Button obj ect o r a change i n the value o f an object's variable.

[ ItemsChosen 1
CheckingOut

[ CreditUnderValidation 1

[ CreditDenied 1

Figure 1 6 . 1 8 States and substates for OnlineShopper class

[ Incomplete 1
[ comPlete 1

STATE DIAGRAMS

[credit card
data
incomplete]

)

Hit Submit
button

[credit card
data
complete]

--1 CreditUnderValidation 1

Figure 1 6.1 9 Conditions on events in UML and the resulting difference in transitions

1 6.6.3 Transitions

An event may cause an object to transition from i ts current state to another state. We den ote a transition with an
arrow, labeled with the name o f the event causing the transition . For example, when a Shopper obj ect in Incomplete
state submi ts valid credi t card i n formati on, it transitions from Incomplete state to CreditUnderValidation state.
Sometimes, when an obj ect is in a given state and an event occurs, the object can transition to one o f
several states , dependi ng on a condition. F o r example, when a shopper submits credit card i n formation (by
click i n g the mouse or h i tting enter), the result i n g transition depends on whether or not the data are complete.
As shown i n Figure 16. 19, conditions are denoted by square brackets in UML.
1 6.6.4 OnlineShopperState Diagram Example

A complete state - transition diagram for the OnlineShopper is shown in Figure 16.20. When the Shopper object
enters the CheckingOut state, i t automatically enters the substate Incomplete ( more precisely, CheckingOut.

Incomplete) .

select item

put back
last item

[credit card
data

f--- select item

hit
Quit

�

)I

hit OK

[credit card
data
complete]

/
��

validation
received

Figure 1 6.20 State-transition diagram for OnlineShopper class

hit OK

373

374

CHAPTER 16

THE UNIFIED MODELING LANGUAGE

1 6.6.5 The Relationship between States and GUls

When an applicatio n is displaying a GUI, one can think of it as being in a particular state. Mouse or keyboard
act ions are events t hat affect this state. Although we may well want to defi ne states that do not correspond to
GUls , and vice versa, a State ...... GUI correspondence can be made for m any applications.

1 6.7 ACTIVITY DIAG RAM S

Flowch arts are among t h e oldest graphical metho ds for depicting t h e flow o f contro l o f algorithms. T h e UML
uses an extended form of flowcharts called Activity Diagrams. The notatio n for activity di agrams is shown in
Figure 16.21 . This example i ncludes paral lelism, showing the activities Do a Task andDo Another Task operating
i n parallel . Control is not passed to Do Even More until both have completed.
Figure 16.22 co ntains an activity di agram for a setName () method, showing the most commo n ly used
flowchart constructs: decisions ( diamon ds) and processes (ovals) .
T h e fo l lowi n g exam ple shows an activity diagram i nvo l v i n g two c l asses . I t de scribes the backward
c h a i n i n g a l go r i t h m for expert syst e m s , a n d i l lustrates how flowchart i n g can be h e l p ful i n exp l a i n i n g
co m p l e x a l go r i t h m s. Expert systems a re usually based o n knowledge i n t h e form o f rul e s , w h i c h t a k e t h e
fo rm

antecedent AND antecedent AND . . . AND antecedent =? consequent
where antecedents and consequents are facts.
For example,

animal is mammal AND animal is striped =? animal is zebra
Our facts will simply be strings such as "animal is mammal . "

else

[condition true)

}
Figure 1 6.21 UML activity chart notation

In
parallel

ACTIVITY DIAGRAMS

else

Parameter and settings make sense

Nominal path

Output notification to console

else

Parameter
name too long

protected final void setName( StringaName )

(

II Check legitimacy of parameter and settings

iff (aName == nUll ) II (maxNumCharslnName() <= 0) II
(maxNumCharslnName() >allti meLimitOfNameLength() ) )

( name = new String( "defaultName" );
System.out.printin

( "defaultName selected byGameCharacter. setName() ");
else

/1 Truncate ifaName too long

if(aName.length() >maxNumCharslnName() )
name = new String

( aName.getBytes(), 0, maxNumCharslnName() );

else 1/ assign the parameter name
name = new String(aName );

Figure 1 6 .22 Activity diagram example

The problem is to build a program that, given the following:
•

•

a list of facts, such as A, �, g, and
a list o f rul es, such as A&R='?b., A&B='?�, and B&C='?E.

determ i nes whether or not a given fact, such as L , can be deduced. The answer is "yes" for this example,
because

A(known)&B(known) ='? C;
B(known)&C(just deduced) ='? R;
A (known)&R(just deduced) ='? L.
We will store the current l ist of k nown facts as a static Vector of Fact calledfactList , and the list of k n own
rules as a static Vector o f Rule called ruleBase. We will simpl i fy the setup o f these lists by h ard coding the
example given above in the Fact and Rule classes. This is shown i n Figure 16.23.
Our emphasis is on the harder part: the "backchaini ng" algorithm proveBackCJ for establishing whether or
not a give n fact, which we will name soughtFact, can be deduced from the given facts and rules. A flowchart for
this algorithm is shown in F i gure 1 6.24 .
This activity di agram helps to s i m p l i fy an otherwise complex algorit h m . An inspection of the activity
diagram m i gh t uncover the fact that i t fai l s t o term i nate if there is a circular chain i n the rule base such as
X ='? Y and Y ='? X.

3 75

376

CHAPTER 16

THE UNIFIED MODELING LANGUAGE

static ruleBase

static factList
Fact

content
addFactO
proveBackO

Rule

consequent
1 n
..

antecedents

addRuleO
proveAntecedentsO
forwardChainO

_____________________

J

Set Fact.factList to the known facts
and a Rule.ruleBase to the known rules.
Create Fact object soughtFact
Execute soughtFact.proveBack( ruleBase );
Figure 1 6 .23 A class model for chaining rules in expert systems

else

soughtFact
in factList

Another rule R exists with
soughtFact as its consequent

proof succeeded

else

else
Prove that every
antecedent fact is true

*

Figure 1 6.24 Activity for soughtFact.proveBackO involving two classes

16.8 DATA FLOW MODELS

Data flow models were introduced in Chapter 1 1 when we discussed requirements. Reca l l that they consist of

actions, each of which takes place at a node. The UML notation for this is exemplified i n Figure 16.25. Each
node has i n put and output pins i ndicating the corresponding data type. Data stores are shown with rectangles
and a datastore stereotype .

A DESIGN EXAMPLE WITH UML

Ship
part
order
Part order
Price list

Charge
credit
card

Charge
amount

Figure 1 6. 25 Data flow models in UML-an example
Source: Adapted from Jacobson, Ivar, Grady Booch and James Rumbaugh, "The Unified Software Development Process," (Addison-Wesley Object Technology
Series), Addison-Wesley, 1999.

1 6.9 A DESIGN EXAM PLE WITH U M L

A s an example that il lustrates several parts o f the UML notation i n this chapter, consider a graphics studio
specializing in drawing stick people. A CUI for this is i llustrated i n Figure 16.26.
We will focus only on the "foot" requirements. Certainly, there is a need for Rectangle and Ellipse classes.
The first question is whether we need a Foot cl ass. When we drag a rectangle near the end of a leg, the
application has to know that we want it to be placed at the end o f that leg in a standard position. Although it
may well be possible to do this without the appl icatio n "knowi ng" about legs and feet, i t is much easier to

o

Facilitate drawing stick
figures

o

Drag to vicinity to
auto-complete

o

Feet can be rectangles
or ellipses

o

(Rest to be specified)

Releasing dragged figure anywhere in this area
causes it to appear in position at end of left leg
Figure 1 6 .26 Specifications for figure-drawing example application

377

378

CHAPTER 16 THE UNIFIED MODELING LANGUAGE

Figure 1 6 .27 Bad attempt at class model for " A foot is either an ellipse of a rectangle"

Figure 1 6 .28 Better attempt at class model for " A foot is either an ellipse of a rectangle"

carry out if Leg and Foot classes are used . (For exam ple, a Leg object would aggregate a Foot object) . The next
question is how to rel ate the classes Foot, Rectangle, and Ellipse. Consi der the possib ility shown in Figure 16.27 .
This class model says that a Foot object is both an ellipse and a rectangle, which is not correct. A better
option is the class model in Figure 16.2 8 .
This model i s a t least not i ncorrect a s the first attem pt was . It i s a little clumsy, however , i n that i t
proli ferates cl asses (EllipseFoot, RectangleFoot, etc . ) . This i s not tenable ( do we need ReactangleEar, etc. ?). It also
uses multiple inheritance, which is problematical in general, and not available in Java. N ow consider the
option shown in Fi gure 16.2 9.
Th is is a reasonable solution except for one very awkward issue: it makes every Ellipse in our appl ication a
k i n d of FootShape, and l ikewise for every Rectangle. For one thing, this certainly l i m i ts the reusability of the
Ellipse class . For another , it is rather strange to thi nk of ellipses as FootShapes in any case. Finally, i f we conti nue
with this, Ellipse may also have to be a HandShape obj ect etc. One way to deal with these problems is for
FootShape to depend only "lightly" on Ellipse and Rectangle as shown in Fi gure 16. 30.

Figure 1 6 .29 Another attempt at class model for " A foot i s either an ellipse o f a rectangle"

FootShape

>-----3>1 , drawAsEllipseO

, drawAsRectangle(h
\
\

Figure 1 6 .30 Best attempt so far at class model for "A foot is either an elli pse of a rectangle"

A DESIGN EXAMPLE WITH UML

Area
releaseCursorO
\

\
\

� - - - - - - - - - - - - - - - - - - - - GeometricFigure

" "

\

l�g l
/

/

FootShape
drawAsEllipseO
drawAsRectangleO
"

---

.......

- - -�......
......

......

--......

--

'»4=

/

/

;

/

'

,

"
"

:::: ::: - ----------1 Position f---------'
_

-

-

-

......

/

"

Figure 1 6 . 3 1 A class model showing all dependencies in drawing application class model

This class model shows that the restrictions on the shape of Foot obj ects are reflected in the methods of
FootShape. They reference only Ellipse and Rectangle at this point, but can readily be augmented to accept other
geometric shapes . We can now fill i n more detai ls, as shown in Figure 16. 3 1 .
The Area's releaseCursor() method handles the auto - p l acement ( at the end o f legs i n the cases shown ) ,
a n d this i n formation i s passed along t o the anatomical obj ect (Foot i n this case ) ; otherwise the draw()
of Ellipse and Rectangle are used to do actual drawing. The class Position could be avo i ded. I t contai n s the
x - and y-coordi nates. For example, drawAsEllipse(Position aPosition) in FootShape could have the fol lowi ng
form .

void d r awA s E l lips e ( p o siti o n aP o siti o n )

{

E l lips e e l lip s e

=

n e w E l lips e ( ) ;

e l lips e . d r aw ( aP o siti o n ) ;

/ / t h e d e p e n d e nc y s h own in th e
c las s m o d e l
/ / th e ac tual wo r k d r awin g th e
e l lips e

}

Showing all of the dependencies in a class m odel can make for a complicated diagram, and for this
reason dependencies are often omitted. (This is perhaps like sweeping things under the rug ! ) The sequence
diagram i n Figure 16. 32 specifies how the classes and methods work together, and shows details about
parameters .
The sequence di agram spec i fies that when a geometric figure is dragged to an area and the cursor i t
released, t h e releaseCursor() method of Area executes with the GeometricFigure as parameter. The Area object
deduces which anatomical object is i nvolved (Foot i n th i s case ) , so i t calls upon that object to draw itsel f; i t also
knows what geometric form i s required.

379

380

CHAPTER 16

THE UN IFIED MODELING LANGUAGE

: FootS hape

I : Ell iPse l
l

releaseCursor
( GeometricFigure
draw
aGeometricFigure) Y------_,-L,
( Leg aLeg ,
GeometricFigure
aGeometricFigure)

drawAsEllipse*
( Position aPosition)

draw( aPosition)

I
I
I
I
I

* or drawAsRectangle() . . .

Figure 1 6 .32 Sequence diagram for figure drawing application

16. 10 S U M MARY

The U n ified Modeling Language ( UML) is a widely accepted graphical n otation for expressing object­
oriented designs. UML de fines several ways classes can be related. These are summarized in Figure 16. 3 3 .
UML models are di agrams that show either the classes of a software design and how they are related, or
the flow o f con trol of a design . Fi gure 16. 34 summarizes the UML m odels covered i n this chapter.

•

Package

•

Inheritance

•

•

Group of related classes
Take on attributes and operations from other classes
"is-a" relati onship
For example, an Empl oyee "is-a" Person
•

•

•

Association

•

Aggregation

•

•

Structural relationship between classes
Structural inclusion o f obj ect on one class by another
"whole- part" relationsh i p

•

•

Composition
•

•

•

Stronger form o f aggregation
Included object is created and destroyed when i ncludi ng obj ect is created and destroyed

Dependency
•

•

One class depends on another
Changes to depended-on class affect dependent c l ass

Figure 1 6 .33 Various relationships between classes that can be shown in UML class diagrams

EXERCISES

•

Class Models

•

Object Model

•

Sequence Diagrams

classes of a design and their relationship

•

objects of a design and their relationship

•

sequence of method calls among objects
usually corresponds to a use case

•

•

•

S tate Diagrams

states of a design element
transitions among states caused by events

•

•

•

Activity Diagrams
•

•

•

flow of control
simi lar to flow charts

Data Flow Model
•

show processi n g elements and the data that flow between them

Figure 1 6. 34 UML models

1 6. 1 1 EXERCISES
1.

Name three maj o r relationships that could exist between classes A and B. Describe them i n your
own words . Express each in UML and in a typical J ava implementati o n .

2 . Explain t h e di fference between aggregation a n d composition . Give an example t o support your
answer.
3. Which of the following classes i nherit from which? Explain your reasoning.

Worm, Ellipse, Animal, 2DFigure, Circle

4 . Draw the class di agram for the following code . Explain the correspondence between the code and
the di agram .
abs t rac t c la s s A ( )
c la s s B

(

B (

) ( )

c la s s C ex tend s A

(

5.

B b

=

new B ( ) ;

A l ibrary has a collecti on of items (books and magazines) available to loan patrons . For each i tem i n
the collection, the system mai ntai ns data about i ts title, author, a n d uni que i d. I n addition, the

381

382

CHAPTER 16

THE UNIFIED MODELING LANGUAGE

copyright year is maintained for books, and the edition number is maintained for magazines. Draw
a UML class di agram representing the l ibrary i tems . Be sure to i n clude the required attributes. Hint:
Use i n heritance in your model.
6. Show a class diagram for an application that displays automobiles. Depending on the user's request, it
displays a typical Ford, Toyota, or Chevy, together with i n teractive pages of i n formation about each .
We want to be able to easily add new automobi le brands to the application in the future and to reuse
parts of the desi gn where possible .
7.

Suppose that your car has a built- i n appl i cation that displays the status of the engine parts at all
times. Draw a UML state diagram for the Starter class that describes the automobile's starter only.
Explain your reasoni ng.
Note that the starter i s sometimes connected to and sometimes disengaged from the car's
motor. The starter reacts to actions i nvolving the car key. The key can be in one of three positions:
vertical, 90° , a n d 1 80° .

8 . Consi der an appl ication used at a doctor's office . The application schedules patient appoi n tments
and mai ntains patient medical histories. Suppose the appl ication design contains an Appointment
class to track appoi n tments, a n d a Medica/History class for each patient. How would you draw the
UML class relationship between these two classes?
9 . Consider the followi ng use case for a web e - commerce applicatio n :
Use Case Name: "Select I tem"
Actor: Shopper
Preconditi o n : Actor has requested product list
Scenari o :
I . Appl icati on displays product list
2. User selects i tem o n product l ist
3 . User clicks "add i tem to shopping cart" button
4. System acknowledges i tem placed in shopping cart

D raw a UML sequence diagram for thi s use case. Expla i n your reasoning.
1 0 . Draw a UML activity diagram for the "Select I tem" use case in Exercise 9. Explain your reason i ng.

BIBLIOGRAPHY
1 . Fowler, Mart i n , "UML Distil/ed, A Brief Guide to the Standard Object Modeling Language, " 3 rd ed. Addison-Wesley, p . 99, 200 4 .

2 . Jacobso n, Ivar, Grady Booch and James Rumbaugh, "The Unified Software Development Process, " (Addiso n - Wesley Object Technology

Seri es), Addison -Wesley, 1 99 9 .

Software Design Patterns

�

Testing

Maintenance
The Software
Development
Lifecycle

Planning
\

Requianalrements
ysis

Implementation
�DeSign /

What are examples of a recurring design
purpose?
What are "creational" design patterns?
What are "structural" design patterns?
What are "behavioral" design patterns?
Can design pattems be thought of in
terms of roles and basic forms?

Figure 17.1 The context and learning goa ls for this cha pter

Design patterns concern class combinations and accompanying algorithms that fulfill common
design purposes. Each design pattern expresses a design concept rather than an inflexible class
combination. The accompanying algorithms express the pattern's basic operation. This chapter is
intended to familiarize the reader with the purposes of design patterns, probing their overall forms
and usage, summarizing the major ones, and examining several in some depth. These are taken from
Gamma et al. [ 1], the classic reference for the subject. Chapter 15 described typical software design goals
and purposes. We will start here with an example design purpose and follow it with a desi gn pattern
satisfying that purpose.

384

CHAPTER 17

SOFTWARE DESIGN PATIERNS

17. 1 EXAMPLES OF A RECURRING DESIGN PURPOSE
17.1. 1 A Simple Example
There are many applications in which we define a class but for which only one instance will be needed. As an
example, householders are forever contemplating the modernization of their kitchens, often using software to
visualize the possibilities. Using a Kitchen class would be natural. Now suppose that a requirement is that the
application does not allow more than one kitchen to be under consideration. It is always a good idea for an
application to enforce what it intends, so the pattern needed here is the enforcement of the one-instance-only
requirement. The Singleton design pattern, described in Section 1 7.5 . 1 , fits this bill.

17. 1.2 A More Complex Example
Let's continue with the kitchen application, which we will call Kitchen Viewer. It enables the user to first lay out
the parts of a kitchen without committing to a style. The overall interface is shown in Figure 1 7. 2.
Here is a use case.
Layout a Kitchen
Preconditions: None

1 . User clicks on the "wall cabinet" icon.
2. Application displays a wall cabinet in the center of the work area.
3 . User resizes the wall cabinet.
4. User drags the wall cabinet to a position in the upper half of the work area.

D

Wall
cabinet

/�

menu

-

Counter
display area

D

styles

Floor
cabinet

�

Modern

I�

/

Classic

I�

Antique

Figure 17.2 Graphical interface to the KitchenViewer exa m ple application

I�

Arts & Crafts

I

EXAMPLES OF A RECURRING DESIGN PURPOSE

5 . User releases the cursor.
6. Application places the wall cabinet in the nearest conforming position.
7. User clicks on the "floor cabinet" icon.
8. Application displays a floor cabinet in the center of the work area.
9.

. . .

.. .

Once the layout process is complete, the kitchen appears as in the example shown in Figure 17. 3 .
After a kitchen has been sketched in the above manner, Kitchen Viewer allows the user to try various
styles for the wall cabinets, floor cabinets, and countertops. When the user selects "Antique," for example, the
design appears as in Figure 1 7. 4 .

Countertop

Mode r n

i�

Classic

H

Antique

!� Arts & Crafts I

Figure 17.3 An exa m ple of a kitchen being designed with KitchenViewer

_
-

-

J

ib= M Od e rn dl [111==�C=la�ss�ic=dl[u.1 """",""
A ""
n ti a
qu ;;.:e;"""d
" l[l Arts & Crafts
=
==
==

Figure 17.4 Selecting an a ntique style using KitchenViewer

385

386

CHAPTER 17

SOFTWARE DESIGN PATIERNS

What are our specific design purposes for KitchenViewer? The procedure of rendering the various styles
is basically the same, regardless of the style, and we should not have more than one copy of this procedure in
our application. In particular, we should avoid code such as the following.

Counter counter
draw( counter) i

=

new Counter ( ) i

This is because no amount of added code will enable this to draw variable types of counters at runtime.
Better design thinking than this is required, and it is usually set up to allow polymorphism: a single block of code
that executes in several possible ways, depending on the context. One approach is to design the kitchen
application so as to provide a method such as renderKitchen(myStyle), somehow parameterizing the rendering
procedure with a required style. We would need to figure out what kind of a thing myStyle should be, and how

renderKitchen() uses it. This kind of design purpose recurs, and we can describe it as follows.
An application must construct a family of objects at runtime: The design must enable choice among several families of styles.
This purpose can be approached with the Abstract Factory design pattern, which is discussed in
Section 17.5.2.

17.2 AN INTRODUCTION TO DESIGN PATTERNS
To illustrate how patterns express ideas, think about how you might describe your housing preferences to a
realtor. The term "ranch style," for example, denotes a useful house pattern. It conveys an idea rather than a
completely specific design.

17.2.1 Example Application: Without Applying Design Patterns
As an example of a software design pattern, let's return to the KitchenViewer example. Recall that we want
to be able to provide a method such as renderKitchen(myStyle). Now we need to elaborate on what myStyle
means.
The method renderKitchen() uses the classes Kitchen, WallCabinet, and so on, and we will make it a member
of a class called

(lient. If we temporarily forget our purpose of parameterizing the style, the method
renderKitchen() would look something like Listing 1 7. 1 .
This code would have to be repeated for every style, resulting in more error-prone and far less

maintainable code. (Sooner or later, code that is supposed to be duplicated becomes different in different
places.) A class diagram for this would look like Figure 1 7. 5 .
The result i s repetitive and complicated. A s a result, i t i s inAexible, hard t o prove correct, and hard to reuse.

17.2.2 Example Application: Applying a Design Pattern
Now let's fulfill our KitchenViewer design purpose by applying the Abstract Factory design pattern. We'll
assume that some object will have the responsibility for creating the kitchen. Here is the key: Instead of that
object directly creating AntiqueWallCabinet objects, for example, a parameterized version of renderKitchen()

AN INTRODUCTION TO DESIGN PATIERNS

Listing 17.1:

The method renderKitchenO in KitchenViewer

II VERSION IGNORING OUR DESIGN PURPOSES
II Dete r mine the style

II case statement?

II A s s ume that the antique style wa s sele c ted.
II C r eate the antique wall c abinets

AntiqueWallCabinet antiqueWallCabinetl

=

new AntiqueWallCabinet ( );

AntiqueWallCabinet antiqueWallCabinet2

=

new AntiqueWallCabinet ( );

II C r eate the antique f l o o r c abinets

AntiqueFl o o r Cabinet antiqueFl o o r Cabinetl

=

new AntiqueFl o o r Cabinet

Ant iqueF l o o r Cabinet ant iqueF l o o r Cabinet2

=

new Ant iqueF l o o r Cabinet

();

();

II C r eate the kit c hen o bj e c t, a s s umin g the exi sten c e o f add() meth o d s
Kit c hen antiqueKit c hen

=

new Kit c hen ( );

antiqueKit c hen.a d d ( antiqueWallCabinetl,

. . .

); II r e s t o f

pa r amete r s s pe c i f y l o c ati o n antiqueKit c hen.a d d
( antiqueWallCabinet2,

. . .

);

antiqueKit c hen.a d d ( antiqueFl o o r Cabinetl,

);

antiqueKit c hen.a d d ( antiqueFl o o r Cabinet2,

);

II Ren de r antiqueKitchen

delegates their creation, replacing phrases such as the following:

new AntiqueWallCabinet ();

myStyle. getWallCabinet ();

//applies only to antique style: Replace! with the following.
//applies to the style chosen at runtime

At runtime, the class of myStyle determines the version of getWallCabinet() executed, thereby producing
the appropriate kind of wall cabinet. To carry out this delegation of responsibility, we introduce a new class,
which we'll call KitchenStyle, supporting methods getWallCabinet(), getFloorCabinet(), and so on. KitchenStyle will

387

388

CHAPTER 17

SOFTWARE DESIGN PATIERNS

----

/

/

/

/

/

/

/

/

/

/

/

/

/

ModernFloorCabinet

AntiqueFloorCabinet

Figure 17.5 A design for KitchenViewer without design patterns

have subclasses, which we'll name ModernKStyle, An tiqueKStyle, and so on, each supporting separate imple­
mentations of getWallCabinet(), getFloorCabinet(), and so on. This is shown in Figure 17.6 .
Recall that, due to polymorphism, executing myStyle.getFloorCabinet() has different effects when myStyle is an
object of ModernKStyle versus an object of AntiqueKStyle. The class model in Figure 17.7 is a more complete version.
Notice that the client code references Kitchen, KitchenStyle, WallCabinet, and FloorCabinet, but does not
reference specific wall cabinet styles or floor cabinet styles. For example, the class AntiqueWallCabinet does not
appear in the client code. To see how this works, let's assume that at runtime, myStyle is an object of the class
ModernStyle. In this case, when the method renderKitchen() executes a statement such as

WallCabinet wallCabinet7

=

myStyle. getWallCabinet ( ) i

KitchenStyle
getWaliCabinetO
getFloorCabinetO

I
I

ModernKStyle
getWaliCabinetO
getFloorCabinetO

AntiqueKStyle /
getWaliCabinetO
getFloorCabinetO

'----'----"'

FloorCabinet getFloorCabinetO
{ return new ModernFloorCabinetO; }

I

--

--

---

--

--

--

---

--

__

--

__

--

--

---

--

FloorCabinet getFloorCabinetO
{ return new AntiqueFloorCabinetO; }

Figure 17.6 The idea behind the Abstract Factory design pattern

AN INTRODUCTION TO DESIGN PATTERNS

,

- - - - - - - - - - - -

1

Client
renderKitchen( KitchenStyle)

- -

,, ,,
"

Kitchen

getWallCabinet()
( return new ModemCabinet();
}

ModemKStyle
getWaliCabinetO
getFloorCabinetO

AntigueKStyle
getWaliCabinetO
getFloorCabinetO

ModemFloorCabinet
- - - _

AntiqueFloorCabinet

Figure 17.7 The Abstract Factory design pattern a pplied to KitchenViewer

the method getWallCabinet() is the version defined in the class ModernStyle, and so it actually returns a
Modern Wall object.
The method renderKitchen(KitchenStyle myStyle) looks like Listing 1 7. 2 .
This version of renderKitchen() is much more versatile than the previous version since it is not written for
any particular style. Figure 17.8 describes the Abstract Factory design pattern in general.

Listing 17.2:

The method renderKitchen(Kitchenstyle myStyle) in KitchenViewer

/ / Create the wall cabinets: Type determined by the class of myStyle
WallCabinet wallCabinetl = myStyle.getWallCabinet( );
WallCabinet wallCabinet2 = myStyle.getWallCabinet( );

/ / Create the floor cabinets: Type determined by the class of myStyle
/ / Create the kitchen object ( in the style required)
FloorCabinet floorCabinetl =,myStyle.getFloorCabinet( );
FloorCabinet floorCabinet2 = myStyle.getFloorCabinet( ) ;

Kitchen kitchen = new Kitchen( );
kitchen.add( wallCabinetl,

);

kitchen.add( wallCabinet2,

);

kitchen.add( floorCabinetl,

);

kitchen.add( floorCabinet2,

);

389

390

CHAPTER 17

SOFTWARE DESIGN PATIERNS

-

-

-

--

-

-

--

Style
getComponentA()
getComponentBO

/'

/'

/'

/'

-

/'

-

/'

-;:..

/'

/

/

/

/

\

\

\

\

\

\

\

\

�

Style1
,

getComponentAO
getComponentBO

,

Style2
getComponentAO
getComponentBO

,

"

Style2ComponentA
'------'

;/-------­
,

Style1 ComponentB

, ,'
--- ---- - -- --- --- -- -- -- ---

Style2ComponentB

Figure 17.8 The Abstract Factory design pattern

The client method doOperation(Style myStyle) builds an instance of Collection in the style indicated by
myStyle by calling myStyle.getComponentA() and myStyle.getComponentB(). If myStyle is a Style1 object, for example,
these two operations produce Style1ComponentA and Style1ComponentB objects, respectively. The pattern thus
ensures a consistent style throughout.
We have mentioned that design patterns should not be regarded in a literal manner. For example, the
design in the above figure could also appear as shown in Figure 1 7. 9 .
I n this alternative, Collection aggregates Style, Client does not reference Style directly, doOperation()
takes no parameters, and Collection has methods for getting the various components. Collection's aggregated

Style

object

is instantiated

at runtime,

perhaps with

separate

setup

code.

When

doOperationO

calls getComponentA() in Collection , control is delegated to getComponentAO in the aggregated Style object.
This is still the Abstract Factory pattern. The Abstract Factory pattern is described in more detail in
Section 17 .5. 2 .

17.3 SUMMARY OF DESIGN PATIERNS BY TYPE: CREATIONAL,
STRUCTURAL, AND BEHAVIORAL

Gamma et at. [ 1 ] classified design patterns in one of three categories, depending upon whether it has to do
with one of the follOWing:

•

Creating a collection of objects in flexible ways (creational patterns)

•

Representing a collection of related objects (structural patterns)

•

Capturing behavior among a collection of objects (behavioral patterns)

SUMMARY OF DESIGN PATTERNS BY TYPE: CREATIONAL, STRUCTURAL, AND BEHAVIORAL

-

"'

Collection

Style

<> getComponentAO

getComponentA()
getComponentB()

getComponentBO

�

I

i/.

.§Mtl

getComponentAO

,

,,

,,

,

getCompone ntAO
getComponentBO

�

/

,

,

,

,

�

l'

,

,

,

'�

ComponentB

�

Style 1 ComponentA

getComponentBO - ---- -Style2

/

/

/

//

ComponentA

I
�

p

/

/

,

--

,

,,

,

,

,

,

Style2ComponentA

-; !.. -------- -- -,

I

Style 1 ComponentB

-------------------------

I

Style2ComponentB

I

Figure 17.9 The Abstract Factory design pattern a lternative

These categories are useful for recognizing when a pattern may be needed and as the beginning of a
guide to selecting which one may be appropriate. Next, we will elaborate on each using example applications.

17.3.1 Creational Design Patterns
Creational design patterns help us to Aexibly set up collections of objects for subsequent processing. They
allow the creation of several possible collections from a single block of code, but with properties such as:

•

Creating many versions of the collection at runtime

•

Constraining the objects created: for example, ensuring that there is only instance of its class
Table 1 7. 1 summarizes the use and nature of key creational design patterns. The abstract factory and

Singleton patterns are described in more detail in subsequent sections.

17.3.2 Structural Design Patterns
Structural design patterns help us to arrange collections of objects in forms such as linked lists or trees. They
are useful when we want to manage complex data consisting of associated objects. Table 17.2 summarizes the
use and nature of key structural design patterns. The Adapter and Facade patterns are described in more detail
in subsequent sections as representative examples of structural design patterns.

391

392

CHAPTER 17

SOFTWARE DESIGN PATTERNS

Table 17.1 A summary of key creational design patterns
Example Application Purpose
Satisfied by This Pattern
Design
Pattern Name

Approximate Design
purpose Satisfied by
ThisPattem

Factory

Abstract
Factory (see

Section 17.5.2)

prototype

Singleton (see

Section 17.5.1)

Create objects at
runtime with flexibility
that constructors alone
cannot provide.
Create coordinated
families of objects at
runtime, chosen from a
set of styles.
Create an aggregate
object in which selected
parts are essentially
copies.
Ensure that a class has
at most one
instantiation, accessible
throughout the
application.

Outline of the Design

Design for the following
requirements without repeating
code unnecessarily. Make the
design easy to change.

Pattern

From a si ngle version of control

Create desired objects by
using methods that return
the objects.

code, generate mail messages
ta ilored to va rious customers.

Display a kitchen layout, allowing
the user to select a style at runti me.
(See Section 17.2.2.)

Display a kitchen layout, allowing
the user to select at runtime a type

Encapsulate each family in a
class whose methods return
objects in that style.

Create the objects of the type
by cloning a prototype.

of wa l l cabi net, or a type of floor
cabinet, etc.
Build an application to evaluate the
results of a lab experiment. Ensure
that there is exactly one Experiment
object at runtime, and ensure that it

Make the constructor private
and obtain the unique object
by means of a public method
that returns it.

can be accessed by any method in

the application. (See Section 17.5.1.4.)

Table 17.2 A summary of key structural design patterns
Example of Design Purposes
Satisfied by This Pattern
Design
Pattern Name

Summary of the Design

Approximate Design
purposes Satisfied by
ThisPattern

Represent a tree of
objects.

Design for the following
requirements without repeating
code unnecessarily. Make the
design easy to change.

Pattern

Represent the orga nization chart of

Have composite objects
aggregate other composite
objects.

a company. Allow client code to call

printOrganizationO o n a ny Employee
composite

Allow client code to
access uniform
fun ctionality d istri buted
in the subtree rooted by

object, printing the names of the

em ployee and all subordinates, if
a ny. Allow the addition and removal
of subtrees at runtime.

any node.
Decorator

Allow objects and
functionality to be added
to an object at runtime.

Allow the user of an o n l i n e cloth ing
store to see his or her i mage

Link the objects using
aggregation.

dressed in a variety of clothes.

(continued)

SUMMARY OF DESIGN PATIERNS BY TYPE: CREATJONAL, STRUCTURAL, AND BEHAVIORAL

Table 17.2 (continued)
Ada pter (see

Section 17.6.2)

Allow an application to
make use of external (e.
g., legacy) functionality.

Design a loan a p plication from
scratch, but allow it to use any
vendor's classes that com pute
monthly payment calculations.

Facade (see

Section 17.6. 1)

Manage software
architectures involving
large numbers of
classes.

Design the a rchitecture of a student
loan software appl ication so that
one group of developers can
concentrate on the loan option

Introduce an inherited
intermediary class relating
the application and the class
with desired functionality.
For each package, introduce
an object that is the sole
access to objects within the
package.

database, a nother on the user
interface (si multa neously), and a
third on payment calculations.
M i n i m ize coord i nation problems.

Flyweight

Obtain the benefits of
having a large number of
individual objects
without excessive
runtime space
requirements.

We want to be a ble to visualize a
room with stenciling. There a re five
stencil patterns but thousands of
potential stencil ma rks on the wa lls.

Share objects by
parameterizing the methods
with variables expressing the
context.

This might be easy to do if each
m a rk were a sepa rate object, but
we ca n't afford the memory
requi red, and it's i m practical to
name all of these sepa rate objects.

Proxy

Some methods are
remote, or require lots of
resources to execute
(time or space). Ensure
that they can be
executed, but no more
often than necessary.

Assume that rendering an image
consumes a sign ificant a mount of
time and space because the image

Introduce a class standing
between the requesting
methods and the resource.

data has to be read from a fi le, fill a
buffer, a n d then be rendered. If the
buffer is a l ready filled by a previous
invocation of the method, then
invoking the function should not
repeat this step.

17.3.3 Behavioral Design Patterns
When an application runs, much behavior generally occurs among the objects. An example is when a method in
one object calls several methods in an object of a different class. Sometimes we want to control and label behavior
in order to parameterize it or reuse it. Each behavioral pattern captures a kind of behavior among a collection of
objects. Let's consider the following example of mutual behavior among ShiP and Tughoat objects. Let's say that we
want to estimate the amount of time required to bring ships into and out of a harbor and transport them to dry
dock for maintenance, based on their size, and so on. Imagine that this is a complex calculation that requires a
systematic simulation of the transportation process. Figure 17.10 suggests a configuration.
The classes ShiP and Tugboat are natural class choices, but objects of these classes play different roles,
depending on whether the ship is entering, leaving, or heading for dry dock. Since there are many potential
applications in which we can use Ship and Tughoat, we do not want these classes to depend on each other, as
suggested by Figure 17.11 .
We have a behavioral design purpose here because we want to separate the interdependent behavior of
these objects from the objects themselves. The Mediator design pattern does this. Figure 17.12 shows the
core idea of Mediator.

393

394

CHAPTER 17

SOFTWARE D ESIGN PATIERNS

�.A
�.A

obstacles

Algorithms express mutual behavior

( ".... -

-: � \

""

\..-,

,

to dry dock -7

Figure 17.10 Example of behavioral design goal-tugboat a n d s h i p port entry

Harbor application

�r--

><-A

___

..

n

1 _-l

____

1

Tugboat

I

Customs application: reuse Ship alone

I

Longshoreman

I

Figure 17.11 Avoiding design dependency in port entry example

In this design, Ship and Tugboat classes do not refer to each other. Instead, the LeavingPort class controls
how objects of Ship and Tugboat behave to estimate the time for that maneuver.
The full Mediator pattern allows for the fact that the mediated classes may need to communicate (e.g.,
to respond to events on either of them). To accomplish this, the mediated classes can be made to subclass a
base class that aggregates a generic mediator class (PortMission). This is shown in Figure 17. 13.
Note that in Figure 17. 13 the Ship class does depend on the class Vessel, which depends on PortMission, so we
cannot use the ShiP class without these two. These dependencies are much more acceptable, however, than

r----'i>l Ship
LeavingPort
estimateTimeO

Figure 17.12 The Mediator design pattern concept applied to the port entry example

SUMMARY OF DESIG N PATTERNS BY TYPE: CREATIONAL, STRUCTURAL, A N D BEHAVIORAL

Mediator base class

�ngMaintained K�>-------'--'
�timateTimeo
Figure 17.13 Applyi ng the Mediator design pattern to the port entry exam ple

having Ship depend for all time on Tugboat. Ships are always vessels, and they usually have missions, but they are
only sometimes associated with tugboats. Table 1 7.3 summarizes the use and nature of key behavioral design
patterns. The Interpreter, Observer, and State patterns are described in more detail in subsequent sections as
examples of structural design patterns.

Table 17.3 A summary of key behavioral deSign patterns
Example of Design purposes
Satisfied by This Pattern
Approximate
Design
Pattern Name

Chain of
Responsi bility

Command

I nterpreter
(see Section

17.7.1)

Summary of the Design

Design purposes
satisfied by This
Pattern

We want a collection of
objects to exhibit
functionality. At design
time we want to be able
to easily add or delete
objects that handle all or
part of the responsibility.

Design for the following
requirements without repeating
code unnecessarily. Make the
design easy to change.

Pattern

Design a GUI for a Web a pplication

Link objects to each other via
aggregation. Each performs
some of the work, and then
calls on the next object in the
chain to continue the work.

to view a utomobiles with requested
color, etc. The d isplay is dynam ic,
depending on the model, etc.
chosen. Reuse the GUI parts among
the displays.

Make the execution of
operations more flexible.
For example, enable
"undoing."

Allow users of an a pplication to

Parse an expression.

Design an application that takes as
inp ut a n order for a network of pcs,

retract their last fou r decisions at

Capture each command in a
class of its own.

any time (the "und o" problem).

expressed in a standard syntax. The
output consists of instructions for
assembling the network. (See
Section 17.7.1.5.)

Introduce a class to capture
expressions, and allow
expression classes to
aggregate expression
classes.

(continued)

395

396

C HAPTER 17

SOFlWARE DESIGN PATTERNS

Table 17.3 (continued)
Example of Design Purposes
Satisfied by This Pattern
Approximate
Design
Pattern Name

Mediator (see
above)

Design purposes
Satisfied by This
Pattern

Capture the interaction
between objects without
having them reference
each other (thus
permitting their reuse).

Summary of the Design

Design for the following
requirements without repeating
code unnecessarily. Make the
design easy to change.

Pattern

Build an a p p l i cation that estimates

Capture each interaction in a
separate class, which
aggregates the objects
involved.

the amount of time required to
bring ships i nto and out of a harbor,
a n d to transport them to d ry dock
for mai ntena nce, but ensure that
the Ship and Tugboat classes can be
reused sepa rately.

Observer (see

Section 17.7.2)

State (see

Section 17.7.3)

Tem plate

A set of objects depends
on the data in a single
object. Design a way in
which they can be
updated when that
single object changes
attribute values.
At runtime, vary the
effect of invoking an
object's methods
depends upon the
object's state.

Allow an algorithm to
execute partial variants
at runtime.

Keep m a nagement, m arketi ng, a n d
operations departments up to date
on sales data. Each of these
departments has d ifferent

Capture the data source as a
class. Allow it to loop through
the observer objects, calling
an update() method.

requirements for the data.

Customers fill out a n order form on
a web site, a n d then hit the "enter"
button. The result m ust depend
upon the state of the form data:

"Product Information Complete,"
"Personal Information Incomplete,"
"Credit Check In Progress," etc.
Orga n ize the huge n u m ber of traffic
l ight algorithms i n a city by
a rranging them i nto a few basic
forms, with variants tailored to
specific locations.

Aggregate a class
representing the state with
operative method doAction().
Subclasses effect the
required actions of substates
with their own versions of
doAction().
Have a base class contain an
overall method, but with
function calls where
variability is needed. Have
subclasses implement these
function calls to capture the
required variability.

17.4 CHARACTERISTICS OF DESIGN PATTERNS: VIEWPOINTS, ROLES, AND LEVELS
Design patterns are partially described by class diagrams, but they also can be thought about in two ways: the

static and dynamic viewpoints of the pattern. This section explains these two viewpoints. It also describes the
abstract and non-abstract (concrete) levels of design patterns. Finally, it covers the ways in which design patterns
are embedded in applications. The static vs. dynamic viewpoints, abstract vs. concrete levels, and embedding
issues are actually characteristic of most deSigns, and are not limited to design patterns. These characteristics

are summarized in Figures t 7. t 4 and t 7. t 5 .

CHARACTERISTICS OF DESIGN PATTERNS: VIEWPOI NTS, ROLES, AND LEVELS

•

Viewpoints-ways to describe patterns

1. Static: class model (building blocks)

2.
•

Levels-decomposition of patterns
1.

2.
•

Dynamic: sequence or state diagram (operation)

Abstract level describes the core of the pattern
Concrete (

=

nonabstract) level describes the particulars of this case

Roles-the "players" in pattern usage
1. Application of the design pattern itself
2.

Clients of the design pattern application

3. Setup code initializes and controls

Figure 17.14 Some characteristics of design patterns, 1 of 2

(class or classes)

l_C.!!�!..r.Qlg '"
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I

_

-.,.

3.

Role: Application of the design pattern
B. Dynamic viewpoint
A. Static viewpoint
r--------,

�-iA-=---=--�B_=_�
I

I

��____ �_ J

DOD

(i) Abstract level
(ii) Concrete level

(class model)

state diagram)

g._S�\.!.!I2..(QI� ---

(class or classes)

�

(sequence or

- - - ->

: Reference direction

Figure 17.15 Some characteristics of design patterns, 2 of 2

17.4.1 TWo Viewpoints for Describing a Pattern: Static and Dynamic
Design patterns are illustrated with class models, showing the classes involved and their mutual relationships;
this is a static viewpoint of the pattern. The functions of these classes execute in particular sequences, however,
which class models do not illustrate. This is the dynamic viewpoint of the pattern, and requires appropriate
means of expression.
We'll use the KitchenViewer example to illustrate the static and dynamic viewpoints. The static viewpoint
was shown in Figure 17.7. This viewpoint does not specify how the design actually works at runtime: what
happens first, second, and so on. Figure 1 7.6 lists the code for getFloorCabinet() and getDoorCabinet(), and although
this code contributes to the dynamic viewpoint of the design pattern application, it is hard to see the
whole execution picture. To express the dynamic viewpoint, we often use sequence diagrams, as illustrated in

397

398

CHAPTER 17

SOFTWARE DESIGN PATIERNS

:

myStyle KitchenStyfe
"' y'-'S"'ty'-le'-:.,.--:-,.---,--..
0-_-.:.mgetWaliCabinelO
,- -,

-- I FmyStyfe

renderKilchen
(myStyle)

BELONGS TO ModemKStyfe-waliCabinel1 :
ModernWaliCabinel

gelWaliCabinelO
ModernWallCabinelO
-- IFmyStyfe

BELONGS TO AntiqueKStyfe-myStyle:
AnliqueKStyle

,

waliCabinel1 :
AnliqueWaliCabinel

getWaliCabinelO

: :f------_.,..L,

AnliqueWallCabinelO

Y----'-------"---..r,

'1'
I

Figure 17.16 Abstract F actory sequence d i agram for KitchenVi ewer

Figure 17.16. It shows the dynamic viewpoint of the KitchenViewer application of the Abstract Factory design
pattern.

17.4. 2 TWo Layers of a Pattern: Abstract and Concrete
Notice that within the Kitchen Viewer Abstract Factory pattern application, some of the classes are
abstract. In conformance with Gamma et at. [1] we will call non-abstract classes "concrete." Figure 17. 17

-

,

-----

---

I KitchenStyfe r----

�

---

Abstract level

,

,

,

,

:'
,

:�

,,

'JI

Wa/fCabinet

L).

I"",

',.\

1

FfoorCabinet

t,::,.

Concrete level

L-.ol Kitchen I·
,,;

I ModernKStyle

I ModernWaliCabinet I I. AntiqueWaliCabinet J
- ---

---

---

-----

---- -

I AntiqueKStyle

-

---

-

-

-

--

-

----

-

:;.,<....,

---

-

-

-

-

-

-

-

-

-

-

-

-

/'7

I

ModernFloorCabinet

-------

Figure 17.17 Concrete a n d a bstract layers in design patterns

-

----

----

I

AntiqueFloorCabinet

1

CHARACTERISTICS OF DES I G N PATIERNS: VI EWPOI NTS, ROLES, AND LEVELS

rearranges the physical placement of classes in Figure 1 7 . 7 to emphasize the abstract and concrete
groupings called layers.
The interface of clients with a design pattern application usually needs to be at the abstract layer. This
can be seen in the code for renderKitchen(), which is written in terms of KitchenStyle (and doesn't reference

ModernKStyle or AntiqueKStyle), WallCabinet (not ModernWallCabinet or AntiqueWallCabinet), and so on.
A division into abstract and concrete layers is a often a good design practice, regardless of whether
design patterns are being applied, because client code can be written in terms of the more general classes of
the abstract layer, making it more versatile.

17.4.3 Three Roles Involved in Pattern Usage: Pattern Application, Client, and Setup
This section explains the three parts-or roles-involved in the usage of a design pattern in a design. This discussion
is designed to help the student surmount common problems using design patterns. The three roles are as follows:

•

The application of the design pattern itself

•

The code that utilizes this application (the "client role")

•

The code, if required, that initializes or changes the design pattern application (the "setup role")
These three roles are shown in Figure 17.18, and are explained next.

1 7. 4 . 3 . 1 The Design Pattern Application Role
A design pattern-the design pattern application-involves a specific class model. For example, KitchenViewer,
described in this chapter, contains an application of the Abstract Factory design pattern. This is the substance of
the design pattern.

1 7.4.3.2 The Client Role
Many parts of a program can potentially use a design pattern application. We usually refer to these parts as clients
of the pattern application. Each client is typically a method, but we often regard the method's class as the client. In

!

i Interacts with
i

I

I
I
I

the deSign
pattern only
through ItS
mterface

r··_··_··_··_·_···_··· __··_·__··_·__..._··__··_·_·_··_......--"'-"---'''-'''-"1

! I 1. Design Pattern Application
II

I 2. Client Role

i-"'�"-"-"'-'-'-"-'-"'-"-"-"--"'-"-"-"--''-"-1

ii

I I

I DPClient r-11--1
DPlnterface I (frequently
abstract;
!
bly
possi
II
:
/'/'
clseveral
asses)
;l\

,

, �.:-, ,-

.

I

/

I i --------------------l>

';;:;:;,;.;;;:;,;; ;;;;; ---:l------------.
No limitations

i

I

I

�:: :��:: =: :=::=:::::::�,::::::=,: 1.�.:::=.://::::;:4t""
[} ii
I
i 3. Setup Role

Interface to
the pattern

I

D D D D D I!I

L....._....._ ......_........ _........_.........._ ........_.........__........__.J

L..._.....__......_.........._

Figure 17.18 The th ree roles i nvolved in design pattern usage

Rest

����

d

pattern
application
....._ ...... _........_........__...

I
i
i

J

399

400

CHAPTER 1 7

SOFTWARE DESIGN PATIERNS

the KitchenViewer design, for example, the renderKitchen() method is a client of the design pattern application. We
will use the term client role for the community of clients. Typically, the client utilizes the design pattern application
only through speCified methods of speCified classes of the design pattern application. These methods and classes
constitute the interface of the pattern application. In the case of the KitchenViewer design, for example, the
interface consists of the classes KitchenStyle, Kitchen, WallCabinet, and FloorCabinet. Clients may not refer to any other
parts of this pattern application, and they generally do not overlap the design pattern application.

1 7. 4 . 3 . 3 The Setup Role
The third role involved in the usage of design patterns is not terribly significant, but one can get confused if
one does not recognize its presence and necessity. It consists of the code that initializes or changes the design
pattern application code at runtime. You can think of this as a janitorial-or housekeeping-role. In the
Kitchen Viewer design, for example, clients specifically do not reference particular styles, such as Modern­
KStyle. Recall that renderKitchen() takes a KitchenStyle object as parameter, and deliberately does not reference
any subclass of KitchenStyle. How are these specific style objects selected and instantiated? This is the task of
what we will call the setup role. In the KitchenViewer design, it is the code that responds to cl icks on the "Style"
buttons in Figure 1 7. 4 by instantiating a KitchenStyle object and calling renderKitchen() with this parameter value .
Setup code needs access to many parts of the application, is normally runtime intensive, and is typical ly
not intended for reuse. This is because it tends to be special to the application and because it depends on too
many other classes. One can think of the setup role as not overlapping either the client or the design pattern
application, although both are possible.

17.5 SELECTED CREATIONAL DESIGN PATTERNS
This section describes the Singleton and Abstract Factory design patterns as examples of creational design patterns.

1 7 . 5 . 1 Singleton
1 7 . 5 . 1 . 1 Design purpose of Singleton
Although a typical class allows the creation of many instances at runtime, we often want a class to have exactly
one instance throughout the application, and no more. For example, many applications maintain a profile of the
user. Often, there is no need for more than one User instance at runtime. In fact, the existence of more than
one instance could lead to problems where one part of the application changes the user's profile in one way on one
instance, and another part in another way on another instance. This leads to an incorrect implementation. We
want a guarantee of one and only one User instance at runtime. Figure 1 7. 1 9 summarizes the purpose of Singleton.

Design P urpose
Ensure that there is exactly one instance of a class S. Be able to obtain the
instance from anywhere in the application.
Design Pattern S ummary
Make the constructor of 5 private; define a private static attribute for 5 of type 5;
define a public accessor for it.
Figure 17.19 Design pu rpose of Si ngleton

SELECTED CREATIONAL DESIGN PATIERNS

We refer to the desired unique instantiation as the singleton o f the class, and the class as a Singleton class.

1 7. 5 . 1 . 2 The Singleton Interface for Clients
As an example, if an application has a User class as described above, client methods such as verifyAccess() and

sendEmailToUser() would require a reference to the singleton of User. To get the singleton, they would contain a
statement such as the following:

User user

=

U s e r . getTheU s e r (

) i

This requires that getTheUser() is a static method of User. Notice again that a statement such as the
following:

User user

=

new U s e r ( ) i

would create a truly new User object, failing to guarantee the requirement that there be only one User
instance.

1 7 . 5 . 1 . 3 The Singleton Class Model
The first issue is: where do we put the single instance of our class? We will name the class in question S. A
good place is within S itself, as a static variable. So far so good- but the problem is, what's to stop another
part of the application from including the following statement?

S myVe r yOwn l n stan c eO f S

=

new S (

) i

We prevent this by making the constructor S() private. The only remaining issue is a way to obtain the
singleton; to do this we include in S a public static accessor method.
The Singleton design pattern is actually a special case of Factory in which the object returned is the one and
only instance of the class with the Factory method. Singleton is thus in the Delegation form: the method getting
the singleton delegates its creation to the constructor. The class model for Singleton is shown in Figure 17. 20.
Let's sum up this discussion. Suppose that S is a class for which we require one and only one instance.
The Singleton design pattern consists of the steps shown in Figure 17. 2 1 .
Making the constructor o f the class MyClass private prevents the creation o f MyClass objects except by
methods of MyClass itself. MyClass is given a static data member of type MyClass that will be the singleton.
Let's name this object singletonOfMyClass. A public static factory method of MyClass, getSingletonOfMyClass(), is
defined that returns singletonOfMyClass. Thus, to get this one and only element of MyClass, we merely invoke

MyClass.getSingleton OfMyClass() .
Our discussion on Singleton does not automatically extend to clients operating in parallel threads,
needing access to a singleton object.

401

402

CHAPTER 17

SOFlWARE DESIGN PATTERNS

I Cli�nt I
I
I

Singleton Design Pattern

singletonOtMyClass
MyClass
>--------,
getSingletonOfMyClassO : MyClass �
«static»

t

T

1 L-

-J

__
__
__
__
__
__
__
__
__
__
__
__
__
__
__

Figure 1 7 .20 Singleton class model

1 . Define a private static member variable of MyClass of type MyClass
p r i v a t e s t a t i c M yC l a s s s i n g l e t o n O fMy C l a s s

=

new My C l a s s ( ) ;

2 . Make the constr uctor of MyClass private
p r i v a t e MyC l a s s ( )

( /*

. . .

.

c o n s t r u c t o r c o de

. . . */ ) ;

3. Define a p ublic static method to access the member
p ub l i c s t a t i c MyC l a s s g e t S i n g l e t o n O fMyC l a s s ( )

r e t u r n s i n g l e t o n O fMyC l a s s ;

Figure 1 7 . 2 1 The si ngleton design pattern, appl ied to MyClass

1 7 . 5 . 1 . 4 EXample singleton Application : " Experiment"
Let's look at the following example:
An application evaluates the results of lab experiments. The application for this phase does no
substantive evaluation, takes no input, and always prints the following message to the console:

The analysis shows that the experiment was a resounding success
There is to be exactly one Experimmt object at runtime, and it can be accessed by any method in the
application. Each time the method is called, it displays the following message on the console to verify it was
called:

Noting that the Experimmt singleton referenced n times so far
The output would have the appearance shown in Figure 1 7. 2 2 .
The simple class model for this experiment example is shown in Figure 1 7. 2 0 .

SELECTED CREATIONAL DESIGN PATIERNS

O utp ut
Noting that the Experiment singleton referenced 1 times so far
The analysis shows that the experiment was a resounding success.
Figure 1 7 .22 Output for s i ngleton Experiment exa m ple

Experiment
the Experiment: Experiment

�

�----

ana/yze()
getTheExperiment(): Experiment

<::

the Expe riment
« static»

reportResu/ts()

1t
Figure 1 7 . 2 3 Application of Si ngleton to Experiment example

17.5.2 Abstract F actory
Now we turn our attention to the creation of families of objects. This kind of problem was discussed in Section

1 7. 1 using the KitchenMaster example.

1 7 . 5 . 2 . 1 Design Purpose of Abstract Factory
Our design purpose here is to create a family of related objects, chosen at runtime from several possible
families. You can often think of a "family" here as a "style" choice. We want to be able to write code that
applies to these families without committing to one particular family.
As an example, consider a word processor requirement that allows the user to view a document in several
styles. Modern word processors allow users to view documents in a variety of ways: for example, in outline
form, showing only the headings. We will Simplify this for illustration. Typical input to our primitive word
processor is shown in Figure 1 7. 2 4 .

---; Enter title :

---; Enter text:

My Life

I grew up playing in the woods

---; Enter Heading or "-done":

---; Enter Heading or "-done":

Birth

Adulthood

---; Enter text:
I was born in a small mountain hut

---; Enter Heading or "-done":
-done

---; Enter Heading or "-done":
Youth
Figure 1 7 .24 Word processor i nteraction, 1 of 2-i n put

(continued)

403

404

CHAPTER 1 7

SOFTWARE DESIGN PATTERNS

»

Enter the style you want d isplayed:

big

:=::============ Option 1
----- Title : MY LIFE - - -- -

»

E nter the style you want d isplayed:

small

-

�====== Option 2
My Life

-

Birth

Section 1 . --- B I RTH ---

I was born in a mou ntain hut . . . .

I was born i n a mou ntain hut . . . .
Youth

Section 2 . -- - YOUTH - - ­

I grew up stu rdy . . .

I grew u p stu rdy . . .

Section 3. -- - ADULTHOOD ---

Adulthood

Figure 1 7. 2 5 Word processor interaction, 2 of 2-output options

The application prints the document in a variety of styles. For simplicity, we will use small and big styles.
In small style output, all headings are in left-justified lowercase and end with a colon. In big style they are
capitalized with section numbering, and so on. The title and the various subheadings appear differently in
these two styles. We can assume that more styles will be required in the future. The output for "small" and
"big" styles is shown in Figure 1 7 . 2 5 .
We want a design with a clean separation into the word manipulation part and the style choice part. We
capture the various kinds of headings with classes. In general, a "style" involves a family of classes. For
example, CapitalStyle involves the classes CapitalTitle, CapitalLevel l Heading, CapitalLeve12Heading, and so on, so
the problem is to be able to change the family at run time. The purpose of Abstract Factory, as expressed by
Gamma et aI. , is as shown in Figure 1 7. 2 6 .
The rest of this section explains the pattern that fulfills this purpose.

Design P urpose
"Provide an interface for creating families of
related or dependent objects without speci fying
their concrete classes. '"
Design Pattern
Capture family creation in a class containing a
factory method for each class in the family.
Figure 1 7 .26 Design pu rpose of Abstract Factory
I Erich Gamma et aI . , "Design Patterns , Elements o f Renseable Obj ect- Oriented Software ," Addison -Wesley, 1 99 5 .

SELECTED CREATIONAL DESIGN PATTERNS

Ensemble

setAbstractF actoryO Ic.

"

"

"

"

"

"

"

doAFunction O

Abstract Factory*

I

v:

/

/

"

/

/

,, /

/

/

/
/

StyleAFactory

'

\ "- "-,,,- '

/
/

I I
•

\
"- ,,-, " ' .::::. AbstractFactorv
\
"\
getAPart1 0bjectO
"\
"getAPart20bjectO
\
"\
""\
"\
"\
"-

�

StyleB Factory

"-

I I �

Sty e · . .

·1

relationships within pattern application not shown

Figure 1 7 . 2 7 The i nterface to Abstract Factory

1 7 . 5 . 2 . 2 The Abstract Factory Interface for Clients
Client code has access to the entity to be constructed with the families. We will name this class Ensemble in
general. The class AbstractFactory encapsulates the style of the Ensemble parts. The interface for the client has
the appearance of Figure 1 7. 2 7 .
For a discussion o n a narrower interface alternative using the Facade design pattern, see Section

1 7. 6 . t . 1 . For our word processor example, the role of Ensemble would be held by a class such as Document, which
supports methods dependent upon Style (our Abstract Factory). First the client-or setup code-has to
determine the required style, typically depending on user input as in the following.
Style c u r r entStyle i
. . .

/ / inte r a c t with the u se r

c u r r entStyle
. . .

=

new SmallStyle (

) ;

=

new Lar geStyle (

) i

or

c u r r entStyle

d o c ument. setStyle ( c u r r entStyle

) i

Once the style has been set, the client makes calls to Document such document.display(). A class model for
this would have the appearance of Figure 1 7. 2 8 .
But what does a "style" class look like, and how does it achieve our purposes?

1 7 . 5 . 2 . 3 The Abstract Factory Class Model
The Abstract Factory design pattern uses a class to collect coordinated factory methods in one place , one
class per "style. " In the standard pattern, the base class for these style classes is named AbstractFactory. The
idea is that each AbstractFactory subclass interprets its factory methods to produce objects of a singl e style.
Abstract Factory is in the delegation form, delegating the "getters" of obj ects to constructors all in the
desired style.

405

406

CHAPTER 1 7

SOFlWARE DESIG N PATIERNS

/

/

/

/
/

/ /
/ /
-::
/ /
,/

......

/

/

/

/

­

-::.::

--

?' �� -

I Client r�

...-- " /

,

--

/

/

--

-

-

-

--

--

Application of Abstract Factory

Figure 1 7 .28 The i nterface of Abstract Factory appl ied to word processor exa m ple

For the sake of simplicity we will illustrate this with just one style to begin with. Let's call the class whose
complex objects are to be constructed, Ensemble. Figure 1 7. 2 9 shows how Ensemble objects are constructed in a
style encapsulated as StyleA. Ensemble consists of parts: Part l objects, Part2 objects, and so on . The attribute

abstractFactory of Ensemble is instantiated with a StyleAFactory object in this case. When a Part ! object is required,
abstractFactory is called. The virtual function property implies that the
getAPartl 0bject() method of StyleAFactory is actually called, and it returns a Part 1 5tyleA object. Similarly, when
getPart20bject() of Ensemble is called, it returns a Part2StyleA object. Thus, all of the parts obtained are in the
the getAPartt Object() method of

same style. The partial class model is shown in Figure 1 7. 2 9 .
The full Abstract Factory class model, with two styles (AbstractFactory subclasses) i s shown i n Figure 1 7. 3 0 .
A s discussed i n the section above o n client interfaces, the client may interface with the AbstractFactory
and PartX classes but specifically not with the subclasses of Part J , Part2, and so on.

Ensemble

AbstractFactory
abstractFactory
K:>------=-------� getAPart1 0bjectO
getAPart20bjectO

setAbstractFactoryO
doAFunctionO

,... ,...

.... .... ..«create»
.. .... .... .... .... .... ....... .......

I

StyleAFactory
0bjectO
.... .... .... etAPart1
etAPart20bjectO

I

:- --------------------------------1Cli�nt� --Figure 1 7 .29 The idea of the Factory design pattern

-

SELECTED CREATIONAL DESIGN PATIERNS

11

I

I

Part1 StyleA
�,

,

,

,

«create» "

.. n

I Part2 1

L(I

L(I

I I

Part1 StyleB
,,
,,

,

I

11

.. n

I Part I
1

,

,"

V'

AbstractFactoCL.
getAPart1 0bjectO IE
getAPart20bjectO

1

abstractFactory

Ensemble
-I) doAFunctionO y
C

Part2StyieA

,"
,
, ,,
, "
,,
,
,
,,
,

I

StyleAFactory
....- - - -

I

I
I I
/

- - - - - - - - - - - - - - - - - - - - - - - -

�

I

/

;1

/

' .... //
StyleBFactory

':'
---�

I

Part2StyieB
/

/

Part. . .

-

�

I
-

I ; ·1

Sty e· ..
---

- - - - - - - - - - -

Figure 1 7 . 30 Abstract Factory

1 7 . 5 . 2 .4 The Abstract Factory Seq uence D iagram
A sequence diagram for Abstract Factory, including the setting up of the particular "style" (the Abstract Factory
object), is shown in Figure 17. 3 1 .

1 7 . 5 . 2 . 5 Example Abstract Factory Application : Word Processor
We now show the design of our Word Processor example using the Abstract Factory design pattern. The
following use cases describe the application:
View a Doc ument
Preconditions: none
1. Application requests the title of the document

2 . User provides the title
3. The "Heading/Text" use case ( see below) is executed until the user enters "done"

4. Application requests a style from a list
5 . User enters a style from the list
6. Application outputs the document to the monitor in the style requested
The following is the "Heading/Text" use case referenced above.

407

408

CHAPTER 17

SOFTWARE DESIGN PATIERNS

I
I :Client I abstractFactory I :Ensemble
--

1

'T

:StyleXFactory

I
U

StyleXFacto�)!

a style

I

doAFunctionO

.

requires a

..

.
. /
.
..

..

.

.
.
.. . . . . .
.

I

lJ

(abstractFactory)

this method

abstractFactory
:AbstractFactory

Selecting

setAbstractFactory

Assume that

- ------,
----;:=--

..

•

ParUobject.

:ParCiStyleX

getAParUO

I

Creating a Part_i

getAParUO
ParUStyleXO

object in

..T.

required style

...·····1

Virtual
function
property
Figure 17.31 Sequence diagram for Abstract Factory

Provide Headingrrext

Preconditions: user has provided the title
1. Application requests a header
2. User provides header text
3. Application requests text
4. User provides text to fit with the header
The class model is shown in Figure 17.32.
Typical output is shown in Figure 17.33.

17.6 SELECTED STRUCTURAL DESIGN PATIERNS
This section describes the Facade and Adapter design patterns as examples of structural design patterns.

17.6.1 Facade: Interfacing with a Collection of Classes
17.6.1.1 The Design Purpose of Facade
In building applications we parcel out sets of classes to separate developers. This requires the clear
modularization of the design. Developers typically require the services of classes that others are responsible

S ELECTED STRUCTURAL D ESIG N PATIERNS

Style

Document
getAHeadingO
getATilleO
grtDocumentFromUserO

style
--3>I gelAHeadni gO
p'>--.----...----r------,
gelATit e
l O
Displayable
: d�Pla�) :
__

. r:-----------:i

� O .. n

.. 'smaIiHeadinq.
,�;;:; dispiavt):':'::
,,-_

__

O .. n

Text L-1\�----1 Heading
'--'
value
value I
L--Displayable
.. ,

I

I

L------';01 Title

value

Q

LargeHeading
displayO

displayO

- /- ---.-..:=:: -7
".--__....:;;...:.....:
:; -:--_ �
,;
-_=_ -_
-_
I

«create»

_-

J)m�l!st¥M:�

:

�if.rNa?\;,g():

".

Tg�rArij'�OT ::

LargeStyle
getAHeadingO
getATilleO

Client

- -- -- - - - - - - - -- L-----<O getStyleFromUserO -

displayDocumentO

Figure 17.32 Abstract Factory applied to word processor

---> Enter the title of your document:
MY LIFE
---> Enter heading or '-done':
Birth
---> Enter the text:
I was born in a mountain hut . . . .
---> Enter heading or '-done':
Youth
---> Enter the text:
I grew up sturdy . . . .
---> Enter heading or '-done':
-done
---> Enter the style you want displayed ('small' or 'large'):
large

--Title: MY LIFE-­
Section 1. --BIRTH-I was born in a mountain hut . . . .
Section 2. --Youth-I grew up sturdy . . . .
Figure 17.33 I nteraction for word processor application

­

409

410

CHAPTER 17

SOFTWARE DESIG N PATTERNS

Design Purpose

Provide an interface to a package of classes.
Design Pattern Summary

Define a singleton that is the sole means for
obtaining functionality from the package.

Note: The classes need not be organized as a package;
more than one class may be used for the facade.
Figure 17.34 Design purpose of Facade

for developing, so that classes and packages often relate to each other as client and server. The client and server
portions are developed relatively independently-the problem is that services are typically in various states of
completion as the project progresses. Complexity is greatly reduced when there is just one object providing
access to the functionality of a collection of classes.
A component acts effectively as a server when its interface is narrow. "Narrow" means that the interface
(i.e., a collection of functions) contains no unnecessary parts, is collected in one place, and is clearly defined.
The Facade design pattern establishes just such an interface to a package of classes. Facade regulates
communication with the objects in its package by exposing only one object of the package to client code of
the package, hiding all of the other classes. This helps organize development because the programmers
responsible for a package can publicize the services offered by a Facade object and stub them while the
package is under development. (" Stubbing" is temporarily substituting the real content with very simplistic
content, or perhaps with none at all.)
Clients of the package have a concrete representation of the package's functionality to use during
development. This advantage extends to maintenance. If maintainers can upgrade the way in which
functionality is coded without disturbing the fac;:ade, they can be assured that all clients of the package
are not affected. The Facade object is a typically a singleton. Figure 17.34 summarizes the design purpose and
technique of Facade.

17.6.1.2 Interface for Clients of Facade
Suppose that a package contains a collection of classes and that the client code, external to the package, requires
a service myCMethod() provided by a class C in the package. The client may interface only with the Facade
object, which we will call theFacadeObject. Thus, the client code calls a method such as cMethodOJFacade()
of theFacadeObject in order to accomplish this purpose.

17.6.1.3 The Facade Class Model
The Facade class model shows clients interfacing with a single class of a package, but with no others. Actually,
there is nothing to stop us from designating more than one class as a Facade class. The non-Facade classes are
not accessible to code external to the package. The Facade structure is in the Delegation form since the Facade
object delegates commands to classes internal to its package.This is illustrated in Figure 17.3 5.

S ELECTED STRUCTURAL DESIGN PATTERNS

I

��

Facade
«_e�xp_o_s_e_d_»

�r-

Clien

____

�

____

«not exposed»

cMethodOfFacade()

"

I

"

I

"

Th is cal/
rep/aced
by 1 and 2.

10

"
"

I

"

"

C/e
i nt can't
reference C

«not exposed»

myCMethod()

Figure 17.35 Facade design pattern structure

A call that would otherwise refer to an object of a class within the package is replaced by a call to a
method of the Facade object. This method can then reference the object in question. The sequence diagram is
shown in Figure 17.36.

I :Client I

:C

singleton
: Facade

cMethodOfFacadeO
myCMethodO

(return if any)
1..0 .
....----.
--

(return if any)

14--------------

Figure 17.36 Sequence d iagra m for Facade

----

411

412

CHAPTER 17

SOFTWARE DESIGN PATIERN S

MyGameEngine

I

MyGame
MyGameCharacters

«facade»

I

MyGameCast
«facade»

MyGameEnvironment

I

MyGameEnvironment
«facade»

Figure 17.37 Using Facade for the a rch itecture of the Encounter video game

17.6.1.4 Examples of Facade Applications
17. 6. 1.4. 1 Using Facade for a Videogame Architecture
The use of Facade in the architecture of a video game is shown in Figure 17.37.The game's classes are divided
into three packages. One pertains to the characters that move about, the second contains the classes that
describe the maze, and the third contains the control of the game.
Communication with game characters must occur via the single MyGameCast object. Reference to parts
of the game's environment must occur through the MyGameEnvironment object, and references to the game
engine must occur through the MyGame object.
17.6.2 Adapter: Interfacing in a Flexible Manner
17.6.2.1 The Design Purpose of Adapter
Suppose that a preexisting application, or even just a preexisting object, provides functionality that
our application requires. For example, the existing application could compute the principal
Design Purpose

Allow an application to use external
functionality in a retargetable manner.
Design Pattern Summary

Write the application against an abstract
version of the external class; introduce
a subclass that aggregates the external class.
Figure 17 .38 Design purpose and sum m a ry for the Adapter design pattern

S ELECTED STRUCTURAL DESIGN PATIERNS

obtained from investing a given amount for a given number of years in a special type of investment, and
we want to use this functionality. In using this functionality, however, we want to modify our own
application as little as possible. We also want to be able to easily switch to alternative
implementations of the required functionality. Figure 17. 38 summarizes these purposes and the basic
Adapter technique.

17.6.2.2 Interface for Clients of Adapter
The "client" is the application that must use the existing functionality.We create a design in which the client
does not directly interface with the existing functionality, however. Instead, it interfaces with an abstract
method of an appropriately named abstract class.The latter must be instantiated at runtime with an object of a
concrete subclass, as explained next.
Let's call the abstract class AbstractClass, and its relevant method we need standinForRequiredMethod().
Client code would be something like the following.

AbstractClass anAbstractClassObject;
..... // setup code instantiates anAbstractClassObject
anAbstractClassObject.clientNameForRequiredMethod();

//usetheexternalfunctionality

Setup code, typically executed at initialization, must instantiate anAbstractClassObject at runtime in
something like the following manner.

if(

. )//e.g.,froma setupfile

{

anAbstractClassObj ect

=

new ConcreteSubclassOfAbstractClass( );

17.6.2.3 The Adapter Class Model
The class model for Adapter is based on the delegation form because an Adapter object delegates the command
to the targeted command, as shown in Figure 17.39.

17.6.2.4 The Adapter Sequence Diagram
Adapter works by handing off function calls to clientNameForRequiredMethod() as shown in Figure 17.40.

413

�

,,

414

CHAPTER 17

�

SOFTWARE DESIGN PATTERNS

________

/
/

/

L-

______

AbstractClass

ReguiredClass
requiredMethodO

I Cli�nt I
Adapter
clientNameForR.�u;redMethod()
{ adaptee.requiredMethodO;}
Figure 17.39 The Adapter class model

:AbstractClass

I

:Adapter

I

I

adaptee
:RequiredClass

I

clientNameForRequiredMethod()
RequiredMethodO

Figure 17 .40 Sequence d iagram for Adapter

17.6.2.5 Example Applications of Adapter
Let's consider a financial application that needs to use the method

computeValue ( float years, float interest, float amount)

of a legacy class Principle. We want to be able to easily switch to other implementations of this functionality if
necessary. We write our application by giving our own names to the function of interest, and the class/object
that owns the function. For example, we can name a method as follows:

amount ( float originalAmount, float numYears, float intRate)

in the class Financial. This class is made abstract, as illustrated in Figure 17.4 1.

SELECTED STRUCTURAL DESIG N PATIERNS

Adal2tation

Al2l2lication

I

Financial
amount()

1T
I
I
I

I Cli�nt I

Legacy system

I
I

I

I

FinancialAdapte r
amountO ""

f:::::

Pri nciple
computeValueO

I

legacyAdaptee

......

legacyAdaptee.computeValueO; }

Figure 17.41 An application of the Adapter design pattern

The Adapter design pattern in this case consists of a class, which we will name FinancialAdapter here,
which inherits from the application's class (Financial in our case), and which aggregates the legacy class
Principal. This could be implemented as follows.
class FinancialAdapter extends Financial
{
Principal legacyAdaptee

=

null;

/ / Constructors go here . . .
/** This method uses the legacy computeValue () method * /
float amount ( float originalAmount, float numYears, float intRate)
{
return legacyAdaptee. computeValue
( originalAmount, numYears, intRate) ;
}
}

The new application is written against the class Financial, but executed at runtime with a FinancialAdapter
object. Setup code instantiates the Financial object as a FinancialAdaper instance. For example, the client could
be written with a method parameterizing Financial, such as the following:
void executeFinanceApplication ( Financial aFinancial) ;

It could then be executed with the following setup statement that utilizes the appropriate adapter object.
executeFinanceApplication ( new FinancialAdapter () ) i

415

4 16

CHAPTER 17

SOFTWARE DESIGN PATIERN S

actionListener

ActionListener

�

I

<)

I

MyButton
addActionListenerO

I
Result of button I1ress

Adal1tation

I

MyListener
actionPerformedO

I

I

MyClass
myMethodO

I

Figure 17.42 Adapter and the Java API

All calls to the amount() method of Financial are passed to the legacy method computeValue().
It is easy to adapt the application to an implementation of amount() in a new class. We would only have to
change the code in FinancialAdapter. The rest of the application would not be affected. Being able to retarget
code by making localized changes like this is valuable for development and maintenance. The alternative is
making changes in multiple locations, which is error-prone.

17.6.2.6 Adapter and the Java API
Java Listeners are adapters for the following reason. Suppose that we want myMethod() in MyClass to execute
whenever myButton is pressed. To do this, we introduce a class MyListener that implements the ACLionListener
interface. The class model is shown in Figure 17.42.
The class MyListener is the adapter class in this case. At runtime we can instantiate actionListener with an
ActionListener subclass instance such as MyListener, according to the effect we require when the button is clicked.
The code in MyBulton references only ActionListener, not any particular subclass.

17.6.2.7 Comments on Adapter
•

�

Instead of aggregating RequiredClass in Figure 17.39, we could inherit from it, as long as the language allows
multiple inheritance. This is shown in Figure-------17. 43. �
__

__

/
/

/
/
/

____

L-

I Cli�nt I

{
Figure 17.43 Adapter example-inherita nce version

requiredMethod();}

S ELECTED BEHAVIORAL DESIG N PATIERNS

We may be satisfied to make AbstractClass an Interface if the language does not support multiple
inheritance (e.g., Java).
•

•

Adapter is often used when we create an application using library classes, but where we want to retain the
flexibility to select other library classes. For example, we might use Vector in a Java application to store a
collection, but find that it is somewhat awkward for the purpose in question. We could then design and code
the application so that it uses an ideal class of our invention to store a collection (e.g., Automobiles with methods
storeAuto () etc.): Then we would incorporate an adapter to fit this to Vector. When a more suitable collection
management class appears, we could then easily retarget to it, needing to change only the adapter.
Returning to the financial example, to preserve the option to retarget at runtime, we could retain

FinancialAdapter, but introduce a new Adapter class FinancialAdapter2, inheriting from Financial. Whenever
we want to target the application to the second legacy system, we would execute the application with the
following.

executeFinanceApplication ( new FinancialAdapter2 () ) i

17.7 SELECTED BEHAVIORAL DESIGN PATIERNS
This section describes the Interpreter and Observer design patterns as examples of particular behavioral
design patterns.

17.7.1 Interpreter: parsing Expressions
17.7.1. 1 Interpreter Design Purposes and Examples
Applications must sometimes deal with expressions written in a grammar. A compiler, for example, must deal with
expressions written in the grammar of a programming language. Compilers are the most common example,
but there are many other needs for the interpretation of grammars. The following XML, for example, is an
expression, and the grammar (called a schema, not explicitly given here) specifies the permissible form for the
XML used in this context.

« engineer»
« name»
John Q. Doe
«/name»
« task»
Universal payroll Application
«/task»
« task»
Interglactic Web Site Analyzer
«/task»
« task»

417

418

CHAPTER 17

SOFTWARE DESIGN PATIERNS

Financial Forecaster
«/task»
«/engineer»

Our purpose is to design an interpreter for grammars. [n the XML example, our interpreter should be
able to interpret the following expression as well.

« engineer»
« name»
Sue W. Smith
«/name»
« task»
Friendly Server Application
«/task»
« task»
Intergalactic Web Site Analyzer
«/task»
«/engineer»

There are two parts relating to the Interpreter design pattern: parsing and interpreting. Parsing is the
process of converting an input-usually a string-into a tree of objects consistent with the class model. [n the
XML example, this would include picking out individual pieces such as the engineer's name. Interpreting
consists of performing useful functionality with the result of the parsing phase. The purpose and basic
technique of Interpreter are summarized in Figure 17.44.

17.7.1.2 Interpreter Interfaces for Clients
Once an expression has been parsed and represented using the Interpreter class model, clients interface with an
AhstractExpression object that is the root of the parse tree.The client typically calls an interpret() method on this

Design Purpose

Interpret expressions written in a formal grammar.
Design Pattern Summary

Represent the grammar using a
recursive design pattern form:
Pass the interpretation to
aggregated objects.
Figure 17.44 Design purpose and summary of Interpreter

S ELECTED BEHAVIORAL DESIGN PATTERNS

I Client � - - - - - - - AbstractExpression
interpret()
-

Figure 17.45 I nterface to Interp reter design pattern

object. In the above XML example, suppose that the two expressions formed by parsing the two inputs are

johnDoeXML and sueSmithXML. Suppose that the application is intended to convert XML to conversational
prose. When the client executes johnDoeXML.interpret(), the following might be output.
Engineer John Q. Doe is working on the following three projects: Universal Payroll Application, Intergalactic Web
Site Analyzer, and Financial Forecaster.
The class model for the client/design pattern interface looks like Figure 17.45.

17.7.1.3 The Interpreter Class Model
The Interpreter design pattern has the Recursive form because expressions can contain further expressions.
The class model is shown in Figure 17.46.
AbstractExpression objects are either TerminalExpression objects, on which the interpretation function is
simple, or NonTerminalExpression objects. The latter aggregate AbstractExpression objects in turn. The interpret()
function on aNonTerminalExpression object operates by performing required work on the object itself, then
essentially commanding each of its aggregated AbstractExpression objects to execute its interpret() method. This
has much in common with the dynamic viewpoint of the Composite design pattern.

17.7.1.4 The Interpreter Sequence Diagram
The sequence diagram in Figure 17.47 captures the interpretation process.

17.7.1.5 Example Interpreter Application: Network Assembly
As an example of Interpreter, consider an application that handles orders from customers for networked computer
systems, and generates installation instructions. Forexample, considertheorder for a network shown in Figure 17.48.

I Client �-

AbstractExe.ression

-----

interpret()

I

T

l
I

1 n
..

I

TerminalExQression

NonTerminalExQression

interpretO

interpretO

Figure 17.46 The I nterpreter design pattern

1<>-

419

420

CHAPTER 17

SOFTWARE DESIGN PATIERNS

I :Client II AbstractExpression I
I
:Nonte r m i n alExpression II Nonte r m i n alExpression
I
interpretO
..
.

..

.

create and
interpretO

I TerminalExpression I
create and
interpretO

.

..

�

Figure 17 .47 The I nterpreter sequence d iagram

It consists of a 700 Mhz system with 512 MB of RAM connected to a system that consists of the following two
connected computers:
a 800Mhz system with 768MB of RAM
a 500Mhz system with 5 12MB of RAM
This is illustrated in Figure 17.48.
This order can be expressed using the following expression.
{ ( 700512 ) } {{ (800768) } { (500512 ) }}

assemble ....

800 Mhz and 768 MB

700 Mhz and 512 MB

500 Mhz and 512 MB
Figure 17.48 Example of a virtual machine "program"
Source: Graphics reproduced with permission from Corel.

SELECTED BEHAVIORAL DESIGN PATTERNS

The output produced by the application would be instructions to the technician, describing how to
perform the assembly.
The main use case for this example is as follows. All I/O is to the console.
I. The application prompts the user to enter an order.
2. The application displays the grammar to be used.
3. The application displays an example.
4. The user enters an order.

5. The application echoes the order.
Figure 17.49 specifies the grammar for the orders and shows typical input.
The order example in Figure 17.49 is indeed a legitimate expression in the grammar specified, as the
following verifies.
component-+ net system -+
{
component
} {component}-+
component
} {component}} {computer }-+
{{
{{{component} {component }} {computer }} {(cpu ram) }-+
}-+
{{{computer } {computer }} {(cpu ram) }} {(444 44 )
}} {(444 44 )
}-+
{{{(cpu ram) } {(cpu ram) }} {(333 33 )
{{{(III I!)
}H(333 33)
}H(444 44 )
H(222 22)
}
The output of the interpretation process-instructions on how to assemble this networking order-are
as shown in Figures 17.50, 17.5 1, and 17.52. In this case, the user selected the example provided by the
application.
Our first task is to parse the input and create the corresponding set of aggregated objects. After that, the
output is generated in response to a client calling aNetworkOrder.assemble(). The method assemble() takes the
place of interpret() in this example. The interpretation of a primitive element alone (e.g., a CPU in the example) is

Please describe a network on one line using the following grammar for 'component.'
Blank paces are ignored.
component ::
net system I computer
net system::
( component) ( component) I ( component)
computer::
(cpu ram)
cpu::
integer
ram::
integer
Example: ( ( ((400 4))( (900 3)) } ((600 3)) } ( (750 10) }
An input with a syntactic error will be ignored without comment.
=

=

=

=

=

( ( ((III 1 1)}( (222 22)
) } ((333 33)) } ( (444 44) }
You chose ( ( ((III I!)}( (222 22)) } {(333 33)
) } ( (444 44) }
Figure 17.49 I nput for network assembly example

421

422

CHAPTER 17

SOFTWARE DESIGN PATTERNS

Please describe a network on one line using the following grammar for 'component.' Blank paces are
ignored. Inputs with syntactic errors will be ignored without comment.
component ::
net system I computer
net system : :
(component) (component) I {component }
computer ::
(cpu ram) 1
cpu ::
integer
ram ::
integer
=

=

=

=

=

Example: ({{(400 4)]( (900 3))) {(600 3))) {(750 10)) ({{(400 4))( (900 3))) {(600 3))) {(750 10))
. .. Do some work with the order. ...
Assemble a network from either one or two parts as follows:
=> First Part: Assemble a network, which we will name 'componentl', as follows:

Assemble a network, which we will name 'cornponent2', from either one or two parts as follows:
-+

Assemble a network, which we will name 'component3', from either one or two parts as follows:
-+

Build computer component3, from the following parts:
CPU with specifications . .. . ..400
and
Figure 17.50 Output for network assembly example, 1 of 3

simple (see the CPU class in the listing). What remains is to execute an interpret() function when applied to a
more complex expression.
Applying the Interpreter design pattern to the network order example, we obtain the class diagram
shown in Figure 17.53.
For simplicity, we assume that every network consists of just two components, so that each System object
aggregates two Component objects.This can be easily extended to more than two. The source code for the
implementation is contained in the accompanying textbook Web site.

17.7.2 Observer
17.7.2.1 The Design Purposes of Observer
Software requirements and design frequently involve a source of data, together with a number of clients that
must be updated whenever the data changes.As an example, suppose that the headquarters of International
Hamburger Corporation maintains data on its server about hamburger sales throughout the country.
Distributed clients for this data include Senior Management, Marketing, and Operations.The data change

S ELECTED BEHAVIORAL DESI G N PATTERNS

RAM with specifications..... 4
second part: -t
Assemble a network, which we will name component4, as follows:
Assemble a network, which we will name 'component5', from either one or two parts as follows:
Build computer component5, from the following parts:
CPU with specifications..... 900
and
RAM with specifications.. .. . 3
-Now connect cornponent3 with component4 to complete cornponent2second part: -t
Assemble a network, which we will name component6, as follows:
Assemble a network, which we will name 'cornponent?', from either one or two parts as follows:
Build computer component7, from the following parts:
CPU with specifications.. . . . 600
and
RAM with specifications.... 3
- Now connect cornponent2 with component6 to complete componentl.

Figure 17.51 Output for network assembly example, 2 of 3

continually, and each of headquarters' clients needs to update its display according to their various
requirements. Let's say, for example, that Senior Management's bar chart must be updated after a 5 percent
change has taken place, Marketing displays a new pie chart when a change of at least 1 percent has taken place,
and Operations requires tables to be updated when every change takes place.

=? Second part: Now assemble a network, which we will name 'component8', as follows:

Assemble a network, which we will name 'component9', from either one or two parts as follows:
Build computer component9, from the following parts:
CPU with specifications... . . 7 50
and
RAM with specifications..... 10
====Now connect component! with component8 to get the resulting network.====
... Do more work with the order. ...
Figure 17.52 Output for network assembly example, 3 of 3

423

424

CHAPTER 17

SOFTWARE DESIGN PATIERNS

0 1
..

�

1

----

I
I
I

component1

�

NetSystem �
assembleO

�

,

�
,
,

:

cpu

CPU

Computer r----assembleO

component2

v----.

r

describeO

RAM

,
,

Setup
getinputFromUserO

describeO

ram

\
\
\

parseO

Figure 17.53 Application of I nterpreter design pattern

The Observer design pattern is intended to address these requirements. Its purposes and basic technique
are summarized in Figure 17.54.
1 7.7.2.2 Observer Interfaces for Clients

Suppose that the abstract class Source is aware of the data source. Whenever a client wants all observers to
take notice (typically, of a change in the data)' it calls a designated method of Source. In the model below,
this method is named l1ot;fy(). The client is shielded from the manner in which Observer carries out this
process.
1 7.7.2.3 The Observer Class Model

The parties in the Observer design pattern requiring updating are known as observers, and are subclasses of a
single abstract class, which we will call Observer. This pattern is in the Delegation form since Source delegates
the updating process to the Observer objects.The pattern is shown in Figure 17.55.

Design Purpose

Arrange for a set of objects to
be affected by a single object.
Design Pattern Summary

The single object aggregates the set, calling
a method with a fixed name on each member.
Figure 17.54 The design purpose and summary of the O bserver pattern

SELECTED BEHAVIORAL DESIG N PATIERNS

Client part

Server part

,---------------------------------,

'----><----'

·· ·····0

..

1 .. n
..
..
•.
.

...

for all Observer's 0:
o.updateO;
ConcreteObserver

ConcreteSource
state

observerState
.

L-________________�

....

.. ···updateO ---'
•. ..----. L3 ... ..
.

Figure 17.55 The Observer design pattern

We will follow a sequence of steps to show how Observer operates.
Step 1 The client references a known interface object, requesting that the observers be notified. For
example, the client could be a process programmed to notice that the data has changed, or it could
be a clock-driven task. In the model, this is shown as a Client object telling the Source object to
execute its notify() function.
Step 2 The notify() method calls the updateD function on each of Observer object that it aggregates.
Step 3 The implementation of update() depends on the particular ConcreteObserver to which it belongs.
Usually, update() compares the ConcreteObserver object's state (variable values) with that of the
central data source on the server, then decides whether or not to change its variable values
accordingly. [t probably performs other actions such as creating a new display.
The class model tells us that every Observer references a Source object. [n fact, the ConcreteObservers will
reference the ConcreteSource object at runtime. How do the ConcreteOberver objects know to reference the
ConcreteSource object? We could pass a reference to it in the parameters of updateO, as is done in the Java API
(see Section 17.7.2.5).

1 7.7.2.4 Example Observer Applications

17.7.2.4. 1 "Hamburgers" Observer Example
Applying Observer to our [nternational Hamburger Corporation problem, we obtain a model such as that
shown in Figure t 7.56.

17.7.2.4.2 Mutual Funds Observer Example
We will take as another example application of Observer the updating of mutual fund portfolios. Mutual funds
invest in multiple stocks, so that when a particular stock's price changes, it affects the values of all the mutual
funds that invest in it. Normally, such changes in a stock's price are transmitted electronically.In our example,

425

426

CHAPTER 17

SOFTWARE DESIGN PATIERNS

Server part

1------------------------

Client part

1 .. n

SeniorManaqement
forecast
Headquarters

update()

demand

r---L---L_--,

Marketing

marketingDemand
/updateO

if( abs( hq.demand - marketingDemand) > 0.01

{

marketingDemand

=

doDisplayO

hq.getDemand();

doDisplayO;

Figure 17.56 Observer applied to I nternational Hamburger Corporation

we will make the change to Awesome Inc.'s stock by hand. The application will then display the resulting
changes in the mutual funds carrying Awesome stock.We will use the Observer/Observable Java API to carry out
this design and implementation.
The main use case is as follows:
1. The application reports the status of mutual funds that invest in Awesome Inc.
2.The following repeats until the user signifies quitting.
2.1. The application prompts the user to supply a price for Awesome stock.
2.2. The user enters a price in decimal form.
2.3. The application reports the status of mutual funds that invest in Awesome Inc.
Figure 17.57 shows a typical scenario.
The class model is shown in Figure 17.58.
This class model uses Observer classes in the Java API, which are discussed next.

17.7.2.5 Observer in the Java API
Many of the design patterns discussed in this book are present in the Java API.However, one recognizes them
by their form rather than by name. Observer is one of the few patterns explicitly called out by name in the
Java API. The Java API Observer class model is shown in Figure 17. 59.
The Java API uses virtually the same terms as Gamma et al. Notice that update(. .) is a callback
method in the sense that it provides Observer objects a reference to its source, thereby enabling them to
compare their data and so on with the Observable object in executing updateCJ. Because update is
implemented as a callback, there is this no need for concrete Observer classes to maintain references
to the Observable object.

SELECTED BEHAVIORAL DESIGN PATTERNS

Note: HiGrowthMutualFund starts with 3 shares of Awesome, assumes price of 1.0, and has non-Awesome
holdings totalling 400.0
Note: MedGrowthMutualFund starts with 2 shares of Awesome, assumes price of 1.0, and has non­
Awesome holdings totalling 300.0
Note: LoGrowthMutualFund starts with 1 shares of Awesome, assumes price of 1.0, and has non-Awesome
holdings totalling 200.0
Enter 'quit': Any other input to continue.
go on

Enter the current price of Awesome Inc. in decimal form.
32.1

Value of La Growth Mutual Fund changed from 20 1.0 to 232. 1
Value of Med Growth Mutual Fund changed from 302.0 to 364.2
Value of Hi Growth Mutual Fund changed from 403.0 to 496.3
Enter 'quit': Any other input to continue.
go on

Enter the current price of Awesome Inc.in decimal form.
21.0

Value of La Growth Mutual Fund changed from 232. 1 to 22 1.0
Value of Med Growth Mutual Fund changed from 364.2 to 342.0
Value of Hi Growth Mutual Fund changed from 496.3 to 463.0
Enter 'quit': Any other input to continue.
Figure 17.57 I/O example for mutual fund application

------------------1
1

r--------L-------,
I

Observer

I

update( Observable, Object)

L _______

MutualFund
value
numAwesomeShares

't
Awesomelnc
price

I Java
Key: .
I

API Class

I

.

Developer Class

1
I
1
1
1
I
1
1

i

I
LongTermMutualFund

-------

I

�--------:

I

MediumTermMutualFund
HiGrowthMutualFund

I

'-

Figure 17.58 Observer example c lass d iagram-mutual funds example

.. . .
update( ...)

427

428

CHAPTER 17

SOFTWARE DESIGN PATIERNS

Observable

Observer
update( Observable, Object)

MyConcreteObserver
MyObservable

observerState
subject

Key:

I Java

API Class

update( ... )

I I Developer Class I

Figure 17.59 Observer in the Java API

17.7.2.6 Comments on Observer
•

•

•

•

Observer also goes by the widely used name of "Model-View-Controller" (MVC), although there are slight
differences in emphasis. The "Model" in MVC is the Source in Figure 17.55 (the Observable in the Java API).
The "Views" are the Observer objects, and the "Control" is client and possibly setup code. MVC emphasizes
the fact that the model is data and the views are GUls, whereas Observer is conceived with broader
application.
Observer allows the addition and removal of observers without disrupting existing observer code. Only the
loop in Observable.notify() must be augmented. Sometimes the process of adding and removing observers is
considered part of the pattern (rather than being a "setup" function).
Observer may be disadvantageous if very few of the observers need to react to changes (in which case the
numerous notifications waste resources).

Observer is disadvantageous when update is more naturally implemented centrally, or when update policies
among observers have very little in common.

•

Observer can't work if the observable cannot have a reference to all of the observers. For example, we would
not use it in a client/server situation unless we were willing for the server to maintain references to all
clients.

•

In general, having the observers update themselves (as opposed to external software performing it) is good
object-oriented design because it keeps related functionality together.

17.7.3 State

17.7 .3.1 The Design purposes of State
Many contemporary applications are "event-driven." A word processor, for example, waits for the user to click
on an icon or menu item, and only then reacts. Event-driven applications are often designed as state-transition
systems. When a system behaves by essentially transitioning among a set of states, the State design pattern can
be helpful. For example, we can describe the Encounter video game at runtime in terms of the state it is in-it
could transition among the Setting-up, Waiting, Setting-characteristics, and Characters-interacting states, among
others. A design should capture this behavior effectively. As the game becomes better defined, the design

S ELECTED BEHAVIORAL DESIGN PAITERNS

Design Purpose

Cause an object to behave in a
manner determined by its state.
Design Pattern Summary

Aggregate a State object
and delegate behavior to it.
Figure 17.60 The design purpose for the State pattern

should also be capable of gracefully absorbing new states and action handling without disrupting the existing
design. Figure 17. 60 summarizes the purpose and basic technique of the State design pattern.
1 7. 7 . 3.2 State Interfaces for Clients

To use the State pattern, the client simply makes a call on a specific method of a specific object.The client is
shielded from the various possible effects of calling the method, which depend on the object's state.
1 7.7.3.3 The State Class Model

In general terms, suppose that we want to use a method doRequest() of an object target of class Target, where
doRequest() can behave in different ways, according to target's state at the time of the call.This is solved by
introducing a class, which we will call TargetState, and giving Target an attribute (we'll call it targetState) of type
TargetState. We ensure that targetState properly represents the Target object's current state at all times.This is
ensured by targetState being an object of the appropriate TargetState subclass.Figure 17.6 1 shows this.Note that
the State design pattern is in the Delegation form.
The method doRequest()calls targetState.handleRequest(), so the call to doRequest() is translated by the virtual
function property into the particular version of handleRequest() appropriate to the state of target. The client does
not need to know the state of target. The full class model is shown in Figure 17.62.
1 7.7.3.4 Example State Applications

The Encounter video game can typically be in a variety of states. When you start to play the game, you may
have the opportunity to set your characteristics ("Setting Up" state).When you are in the midst of interacting
with other characters, your state is different ("Engaging" state, perhaps).It is reasonable to expect that you
can't change your characteristics in the midst of an engagement because the game would not be much fun to

I { targetState.handleReqUestQj]

I : I
C ient
I
I

•

Target

/

targetState

/ �>-��--------�

doRequestO �

Figure 17.61 The basic structu re of the State design pattern

TargetState
handleRequest()

429

430

CHAPTER 17

SOFTWARE DESIGN PATTERNS

I { targetState.handleReqUestiliil

I : I
C ient
I

!

Target

doRequestO

/ r<=:>----=-------1
./

targetState

---l

I

I

TargetStateA

TargetStateB

handleRequestO

handleRequestO

TargetState
handleRequestO

I

Figure 17.62 The State design pattern : doRequest() behaves a ccording to the state of Target

play in that case. If the game interface had the appearance in Figure 17.6 3, the effect of pressing the Set

Characteristics button would depend on the state of the game at the time.
Figure 17.64 shows how the State design pattern can be used to handle the states and actions of Encounter.
The class MyGame has an attribute called state of type MyGameState. The type of the state object (i.e.,
which subclass of MyGameState it belongs to) determines what happens when setCharacteristics() is called on a
MyGame object.
The code for setCharacteristics() in MyGame passes control to the handleClick() function of state. Each
subclass of MyGameState implements handleClick() in its own manner. For example, if MyGame is in Waiting state,
then the effect of clicking on the "Set Characteristics" button is that a window appears through which the
player can change his characteristics. On the other hand, if MyGame is in SettingQualities state, then nothing
happens because the user is already setting his characteristics.

Figure 17.63 G U I for Encounter role-playing game
Source: Courtesy of Tom vanCourt and Corel.

DESIGN PATIERN FORMS: DELEGATION A N D RECURSION

MyG a m e
setCharacteristicsO '

1<:, ::
"

state
{

I

Setti ngUI2

Waiti ng

handleClickO
,

handleClickO
,

6

state. h andleCIiCk(

}

I

�

M't,GameState
handleClick()

showWindow(};

showWindow(};

" , ,1/ more

" "I/ more

I

Sett i ngC haracte ristics
handleClickO
,

{ 1/ already responding
" . 1/ display message

II

E ngagi ng
handleClickO
,

{ 1/ do nothing

". 1/ display message

}

Figure 1 7 .64 The State design pattern applied to the Encou nter role-playing ga me

1 7 . 7 . 3 . 5 Comments on State
•

•

•

The State design pattern is particularly beneficial when new states are likely to be needed in the future.
State does not handle the question of how to set up the successive state (if required) once handleEventC) has
been performed.Although State does not handle the transition function, it can be a useful framework in
which to implement transition. For example, handleEventC) can contain code that swaps in the new state. A
possible companion to the State design pattern is a state-transition table whose entries indicate what new
state the object transitions into for each "current state-event occurrence" pair.
Whether or not the State design pattern is applied, state-oriented architectures have been used with success
for many applications (see, for example, the work of Shlaer and Mellor [2]). Real-time applications tend to
benefit especially from the state architecture because they often rely on a state/event perspective.

17.8 DESIGN PATTERN FORMS: DELEGATION AND RECURSION
As the examples of design patterns above illustrate, they occur in a limited number of forms.We could say
that there are patterns to the design patterns-meta patterns, if you like. Most design patterns are based on
the delegation or recursion forms, as described in this section.

17.8.1 The Delegation Design Pattern Form
Consider a task that needs doing, the object that initiates it, and an object that does the actual work.Delegation
is a process by which the initiator employs a third object to get the work done by the doer. An example from
real life is the use of a realtor in which the seller (the initiator) wants to sell to a buyer (the doer, in this case).
To achieve flexibility, the KitchenViewer design replaces direct code such as
new Ant i queWallCab i net ( ) i / / appl ies o nly t o a n t i que st yle

431

432

CHAPTER 17

SOFTWARE DESIGN PATTERNS

. . . clientFu nction ( . . . )

. . . intermediaryFunction (. .
. )

{

{

. . . requiredFunction O ..
.

. . . intermediaryFunction( . . . ) . . .

}

Cl ient
clientFunctionO

::: - - - - - - - - - - - -7 intermediaryFunctionO
,

I
I

"

'X

:
:
I

"
rep/ace
,

I
I

"

�

� requiredFunctionO
Figure 17.65 The idea of delegation

with a version that delegates construction to an intermediary method

my S t yl e .g e t WallCabin e t ( )
; j japplies to what ever s t yl e is chos en at runtime

The Abstract Factory design pattern replaces several direct method calls (constructor calls, actually)
with delegated calls to separate methods, which call the desired methods in turn. The basic idea of delegation
is shown in Figure 17.65.
A common way in which design patterns put delegation into practice is through a class that delegates
functionality to the methods of an abstract class. When we apply Abstract Factory in Figure 17. 7, for example,
the work of creating a WallCabinel object is delegated to the methods of a KitchenStyle object.
A common form of Delegation is illustrated in Figure 17.66, where an abstract class is aggregated and
acts as a base class for several concrete subclasses.
The client calls the method interfaceMethod() of the interface class DPlnterface. In turn, interfaceMethod()
delegates the required functionality to its aggregated DoerBase object, doerObject. The functionality is carried
out by having doerObject execute a method that we have named dolt(). At runtime doerObject is an object of
either the class ConcreteDoer J , ConcreteDoer2 , and so on. Since the effect of dolt() depends on runtime conditions,
so does the effect of interfaceMethod(). The class DPlnterface thus has the following form.

class DP l nterf ace

{

DoerB ase doerO b j ect ;
pub lic void interf aceM ethod ( )

{ doerO b j ect. dol t () ;
}

}

DESIGN PATIERN FORMS: DELEGATION AND RECURSION

I �lient I
I
I
I
I
I
I
I

--_... __ .. __ ................ _--_ .............. _-_ ......... .

!

. . .

!{

interfaceMethod(

. . .

. . .

doerObject.doltO

)
. . .

i
}

!

:t ............... ____ ........................................•·s;·-

DPlnterface !
interfaceMethodO

T

doerObject

ConcreteDoer1
doltO

ConcreteDoer2
doltO

Figure 17.66 Basic design pattern form number 1-delegation

Delegation, implemented using the virtual function property, is the most common form of design
patterns. Another common form is Recursion: the use of structures to effectively reference themselves.

17.8.2 The Recursion Design Pattern Form

Several design patterns require recursion-in other words, part of the pattern essentially uses itself. For
example, recursion is useful for representing a linked list of obj ects in which each object of a class aggregates
another obj ect of the same class. Another example is constructing a graphical user interface that allows for
windows within windows within windows . . . and so on. In this case, the Window object aggregates itsel f.
In a recursive pattern form , a dual inheritance-aggregation relationship exists between a base class and a
subclass, as shown in Figure 17.67. Notice that the Recursive form uses the Delegation form-in this case, the
delegation doubles back on itself.
From the dynamic viewpoint, i n a Recursive form the client calls a method of the interface, which we'll
name doOperation(). If the object actually belongs to the subclass RecursiveClass, then executing its doOperation()
involves the object(s) of aggregate. These objects may once again call doOperation(), and so on.
Let's take as an example the case where RecursionBase is the class Employee, doOperation() is the method
printOrganization(), and RecursiveClass is the class Supervisor. The idea is to produce a printout of all the
employees of an organization. The class model is shown in Figure 17.68 .
The method printOrganization() in Supervisor would be programmed to first pri nt the supervisor's name,
then call the printOrganization() method in each of the Employee obj ects in supervisees. For Employee obj ects of the
class IndividualContributor, the method printOrganization() prints only the name of that employee . For Employee
objects of the class Supervisor, printOrganization() prints that supervisor's name and the printing process repeats
recursively. This recursive process eventually prints all of the names. The class Supervisor thus has the
following form.

433

434

CHAPTER 17

SOFTWARE DESIGN PATIERNS

1 Client 1-- - - -

'--__
__-'
--,.;-

NonrecursiveClass

aggregate

RecursiveClass

doOperation()

doOperationO

void doOperation( ... )

{ ... aggregate . . . }
Figure 17.67 Basic design pattern form number 1-recursion

1 Client f - - - - -'---_�----'

IndividualContributor
printOrganizationO

Supervisor
printOrganization()

supervisees

void printOrganization( ... )
... supervisees.printOrganizationO . ..
}

Figure 17.68 The Recursion design pattern form applied to an organizational chart

class Supervisor extends Employee

{
Vector supervisees;
void printOrganization (

. . .

)

S UMMARY

{
supervisees.printOrganization ( ) ;

}
}

17.9 S U MMARY

This chapter introduced design patterns, which are used to satisfy recurring design purposes. A design pattern is
a group of classes (the static viewpoint) that interact in a recognizable way (the dynamic viewpoint) . Typically, a
design pattern consists of an abstract level of classes and a nonabstract ("concrete") level. Three roles (sets of
code ) are involved in the use of design patterns: the application of the design pattern itself, the code that uses it
(the client role ) , and the code that initializes or changes the design pattern application (the setup role) .
Most design patterns use delegation, in which calls to an interface method are handed off to another
method to facilitate variation at runtime. Several design patterns also use a form of recursion, in which a class
references either itself or a base class from which it inherits.
Design patterns can be roughly classified as creational, structural, or behavioral. Creational patterns create
nontrivial object ensembles in a manner determined at runtime. Structural patterns are used to represent
collections of obj ects . Behavioral patterns deal flexibly with behavior among a set of objects .
This chapter described the followi ng creational design patterns by way of example. The Singleton
pattern is used to enforce classes with only a single instance. The Abstract Factory pattern is used when an
interrelated family of classes is required but in a variety of "styles . " A "style" in this sense is a characteristic
applicable to every obj ect in the family.
The followi ng behavioral design patterns were discussed. Facade is a way to treat a group of classes as a
unit, by providing its functionality only through a single object. Adapter is a way to switch user obj ect types
of given functionality at runtime.
The chapter also discussed the following structural design pattern s . Interpreter is used when the
situation is viewed as the execution of a language specially designed for the appl ication. Observer is used for
designs that separate control from presentation and data . State is used to design application parts best thought
of in terms of a set of states .
These poi nts are summarized in Figure 17.69. The reader is referred to Fowler [ 3] and Vlissides [4] for
further explorations of design patterns.

•

•

Design Patterns are recurring designs satisfying recurring design purposes
Described by Static and Dynamic Viewpoints
Typically class models and sequence diagrams, respectively
Use of a pattern application is a Client Role
Client interface carefully controlled
"Setup," typically initialization, a separate role
DeSign pattern Forms usually Delegation or Recursion
Classified as CreationaI, Structural, or Behavioral
•

•

•

•

•

•

Figure 17.69 A summary of this chapter

435

436

CHAPTER 17

SOFTWARE DESIGN PATIERNS

17.10 EXERCISES
1. Which of the following are applications of design patterns? Explain your conclusions.

(a) An obj ect-orientated design
(b) The ability to vary the order i n which a print() method is applied to the elements of a Vector
(c) Varying the order in which a method is applied to the elements of a collecti on of objects by
introducing a class whose methods include a method l ike goToNextElement()
(d) Capturi ng the mutual behavi or of a pair of objects of two classes
(e) Capturing the mutual behavior of a pair of objects of two classes by introducing a third class
aggregati ng the two classes
2.

Characterize the following design purpose as creational, structural, or behavioral. Explain your
conclusion clearly.
We must build an application with 15 different screens involvi ng various combinations of 6
user interface controls (e.g. , l ist boxes) arranged in a simple grid. Performing a mouse action or text
entry on a control (e.g., a button ) in a screen affects other controls on the same screen . In all other
respects the screens are not related and are not similar in appearance. The composition of these
screens is very unlikely to change .

3 . Characterize the followi ng design purpose as creational, structural, or behavioral. Explain your
conclusion clearly.
We must build a human resources appl ication dealing with the management structure at a
large company. We need to represent the organization chart within the application.
4. Characterize the following design purpose as creational, structural, or behavioral. Explain your
conclusion clearly.

We must build an appl ication that allows users to build and change their stock portfolio with a
various kinds of mutual fund picks from specified subcategories. The mutual fund categories are
technology, old industries, utilities, real estate, and mining. The application allows users to pick categories. It
then makes portfoli o recommendations depending on the user's choice. For example, the user can
ask for a low-risk portfolio of utilities and mining stocks, and the appl ication describes its
recommendations within these constraints.
5. Consider the following two statements.
(a) Observer consists of an obj ect of a class that reflects a data source, together with objects of
classes that depend on the data source.
(b) When the data changes value, a method with the name update(J is called on each observing
object.
Which of these two statements takes a static viewpoint and which a dynamic viewpoint?
6. The following figure shows the Observer design pattern class model . Group the classes to
show abstract and concrete levels. Group the classes to show the three roles described in this
chapter.
7. (a) What two design pattern forms are mentioned in this chapter?

BIBLIOGRAPHY

(b) Which of the two forms is more likely to use virtual functions? Explain your answer and give
an example.
(c) Which of the two forms is a linked list of objects likely to be? Explain your answer.
(d) Which of the two forms is the Observer pattern in Exercise 6?
8 . Research the Java Swing software architecture, such as Java Swing, and describe in a few
paragraphs how it makes use of the Observer pattern. Draw a class diagram as part of your answer.
9. Research the Java EE platform and describe in a few paragraphs how it makes use of the Facade
design pattern. Draw a class diagram as part of your solutio n .

BIBLIOGRAPHY
Gamma, Erich, Richard Helm, Ralph Johnson, andJohn Vlissides, "Desigfl Patterns, Elemrnts of Reusable Object-Orieflted Software," Addison­
Wesley,

1995.

2. Shlaer, Sally, and Stephen Mellor. "Object Lifecycles, Modeliflg the World ifl States," Yourdon Press, 1991.
3. Fowler, Martin. "Pattern Hatchiflg, Desigfl Patterns Applied," Addison-Wesley,

1998.

4. Vlissides, John M., "Patterns of Enterprise Application Architecture," Addison-Wesley, 2002.

437

Software Architecture

�ntenance

Testing

The Software
Development
Lifecycle

Planning
\

Requirements
analysis

Implementation
�DeSign /

How do you classify software
architectures?
What are data flow architectures?
What are three-tier architectures and
their generalizations?
What makes database-centric
systems a separate type of
architecture?
What are service-oriented
architectures?
What IEEE standards are there for
expressing designs?
What do real-world architectures look
like?

Figure 18.1 The context and learning goals for this chapter

This part of the book, concerned with design, began by describing design goals and principles and then
described patterns of design that recur throughout. This chapter describes design at the high level, and the
chapter that follows at the detailed level.
A software architecture describes the overall components of an application and how they relate to each
other. Its design goals, as discussed in Chapter 15, include sufficiency, understandability, modularity, high
cohesion, low coupling, robustness , flexibility, reusability, efficiency, and reliability. For a given software

SOFTWARE ARCHITECTURE ALTERNATIVES AND THE I R CLASS MODELS

•

Dataflow architectures
Pipes and filters
Batch sequential
lndependent components
Client-server systems
Parallel communicating processes
Event systems
Service-oriented (added)

•

•

•

•

•

•

•

•

•

•

•

•

Virtual machines
I nterpreters
Rule -based systems
Repository architectures
Databases
Hypertext systems
Blackboards
Layered architectures
•

•

•

Figure 18.2 Shaw and Garlan's categorization of software a rchitectures
Source: Shaw, M.G. and D. Garlan, "software Architecture: Perspectives on an Emerging Discipline," Prentice Hall. 1 996.

devdopment project, there may be several possible appropriate architectures, and selecting one depends
upon the goals that one wants to emphasize.
Flexibility, to choose one of these qualities, is a key goal of many architectures-the ability to
accommodate new features. This usually involves introducing abstraction i nto the process. For example, we
might want the architecture for the Encounter video game case study to support not just this particular game,
but any role-playing video game .
Attaining o n e desirable design property may entail a trade -off against others . For example, a designer
who uses abstractions to obtain a flexible architecture may make it harder to understand.
18.1 A CATEGORIZATION O F ARCH ITECTURES

Shaw and Carlan [ 1] have classified software architectures in a useful manner. Their classification, somewhat
adapted here, is shown in Figure 1 8 . 2 . Section 18.3 explains these architectures. There is a wide variety of
problems requiring software solutions, and there is a wide variety of architectures needed to deal with them.
In most cases, the architecture is unique to the problem. Sometimes, one of the architectures identified by
Shaw and Carlan matches the problem; in many cases they simply provide ideas on which to base the
architecture . This is similar to architecture in house construction, in which classical and standard ideas
provide inspiration for great architecture but are not simply copied.
18.2 SOFTWARE ARC H ITECTURE ALTERNATIVES AND TH EIR C LASS MO DELS

The so ftware architect develops a mental m odel o f how the application is meant to work, often with five
to seven components. The architect's mental model depends on the application in questi o n , of course, but
may benefit from architectures that others have developed in the past, just as a suspension bri dge design
benefits from the study o f previously bui l t suspension bridges. This section elaborates on the architec­
tures classified by Shaw and Carlan. They categorize architectures as data flow, indepen dent compo­
nents, virtual machi nes, repository architectures, and l ayered architecture s . Figure 18 . 2 summarizes these
and their subcategories, and the rest o f this section explains the m . I t also adds service- oriented
arch itecture s .
18.2.1 Data Flow Architectures

Some applications are best viewed as data flowi ng among processing units . Data flow diagrams (DFDs)
illus trate such views. Each processing unit of the DFD is des igned independently of the others . Data

439

440

CHAPTER 18

SOFTWARE ARCHITECTURE

member
banks

I

bank
name

error
account no.
and deposit

account no.

error

account
display

account
data

balance
query

deposit
account
transaction __ account __ data

database

Figure 18.3 partial data flow diagram for an ATM application

emanates from sources , such as the user, and eventually flows back to users, or i n to si nks such as account
databases . The elements of the DFD notation were explained i n Chapter 16. A banking application is
shown in Figure 18. 3 .
Data flow from the user to a "Get deposit" process, which sends the account number and the deposit
amount to a process designed to check these data for consistency. I f they are consistent, the data may be sent
to a process that creates a transaction, and so on. DFDs can be nested. For example, the "Create inquiry
transaction" can itsel f be decomposed into a more detailed data flow diagram.
The functions of a data flow diagram may reside on more than one physical platform . Figure 1 8.4 shows
one possible allocation.

o

Get deposit
Get inquiry
Display account

Consortium

Make inquiry
Do deposit transaction
Create account summary
Validate deposit
Validate inquiry
Figure 18.4 Platforms in data flow architectures, and an example

SOFTWARE ARCHITECTURE ALTERNATIVES AND THEIR CLASS MODELS

18.2.1.1 Pipe and Filter

One kind of data flow architecture, shown in Figure 18.5, is referred to as the pipe and filter architecture . In this
kind the processing elements ("filters") accept streams as input (sequences of a uniform data element) at any
time, and produce output streams. Each filter must be designed to be independent of the other filters. The
architectural feature in Figure 18.5 is implemented by UNIX pipes, for example.
Pipe and filter architectures have the advantage of modularity . An example is shown in Figure 18.6.
In it, the application maintains accounts as transacti ons arrive at random times from communication
l i nes. The architecture includes a step for loggi ng transactions i n case of system failure . The withdraw
functi on would have withdrawal i nput such as lohnDoeAccountNum12345Amount$350o.00, or just lohn­
Doe12345$3500.oo'-that is, a character stream and bank address input such as BankNum9876. The
processing elements, shown i n ellipses, wait until all of the required i nput has arrived before performing
their operatio n .
strea

� filter
I

-,

,,--

__

pipe

Figure 18.5 Pipe and filter architectures

�

Requirement: Maintain wired financial transactions.
account data

E
I

Bank
data

�

account d ta
account data

deposit

f-----,

deposit data

analyze

transaction

transaction result

record

L-_____ account data -------'

Figure 18.6 Example of a pipe-a nd-filter a rchitecture, to maintain wired financial tra nsaction

Log

441

442

CHAPTER 18

SOFTWARE ARCHITECTURE

Transaction
<:
analyze()
recordO

Bank

1 ..n

1-

Account
J withdrawO
J depositO

.....--....

I

Figure 18.7 Obtaining a class model from a data flow a rchitectu re-bank account example

There is no absolutely uni form way to map data flow diagrams (DFDs) onto class models; however,
functional un its of the DFD can frequently map directly onto methods of classes, as shown in Figure IS.7.
The increasing use of distri buted computing is accelerating the application of stream -oriented
computing because remote function calling is often implemented by converting the call to a stream of
characters . Th is is done in Web services, for example. These use serialization, which converts objects to XML
character streams. In addition, I/O is often implemented using streams, and performing 1/0 in a language such
as Java often amounts to a filtering process of the kind we have discussed.
18.2.1.2 Batch Sequential

In the special case where the processing elements are only given batches of data, the result is a batch sequential
form of data flow. As an example, consider a banking application that computes the amount of money
available for mortgage loans (secured by properties) and the amount available for unsecured loans. A data flow
diagram (DFD ) is suggested by Figure IS.S.
Th is DFD is batch sequential because the functions are executed using all of the input data of a given
run, taken together. For example, we collect the funds available for mortgage loans by using all of the account
data . Th is is in contrast with the transaction example in Figure IS.6, in which there are many "virtually
conti nuous" transactions, each using selected data from their sources.
Figure IS.9 shows one mapping into a class model in which the functions of the data flow are real ized as
methods of the Bank class. The "batches" of processing are executed by running the relevant methods of th is cl ass .
Requirement: Manage bank funds available for
mortgages and unsecured lending.
Archi tec ture:

Account
balances

Coliect
mortgage funds

Mortgage
pool

Coliect
unsecured funds

Unsecured
pool

Figure 18.8 Example of a batch-sequential data flow a rchitecture-creating a mortgage pool

[- -

:- Accounts -pac-kage �i

- - - - - - - - - - - - - - - - - - - ----------------------

,
,
,_ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - __ I

r

:

: - -Bank-package - i

- - - - - - - - - .1 __________________ j

Bank
getMtgPoolO
getUnsecurePoolO

'

,
,
,_____________ - - - - ____________ 1

Figure 18.9 Class model for batch sequential data flow-creating a mortgage pool example

SOFTWARE ARCHITECTURE ALTERNATIVES AND THEIR CLASS MODELS

For decades, data flow has been the most common way of expressing architectures, and it is bound to
be useful for some time to come. Engi neers naturally think of data flowing from one processing "station" to
the next and of processing taking place at each stati o n . The disadvantages of data flow diagrams i nclude
the fact that they do not map very cleanly to code, whether object-oriented or not. An exception to th is
appl ies to specific data flow languages (some being actually graphic i n nature), which are built around the
very concept of data flow. We will use the data flow model once again when we discuss detai led design in
Chapter 1 9.
18.2.2 I ndependent Components

The independent components architecture consists of components operating in parallel (at least in principle)
and communicating with each other from time to time. An obvious instance of this can be found on the
World Wide Web, where millions of servers and browsers operate conti nuously i n parallel and periodically
communicate with each other.
"Components" are portions of software that do not change and that do not require knowledge of the
software using them . . NET assemblies and JavaBeans are example component technologies. Components
satisfy guidel ines aimed at making them self-contained. They use other components by aggregation, and
generaIly interact with other components through events.
The case studies i nclude a discussion of the Eclipse project. Eclipse is a development platform designed
to accommodate plug-ins. These are independent components that can be created by developers for various
purposes, and added to the platform without affecting existing functionality.
18.2.2.1 Tiered and Client-Server Architectures

In a client-server architecture , the server component serves the needs of the client upon request. Client­
server relati onships have the advantage of low coupling between the participating components . When
more than one person performs implementation it is natural to parcel out a package of classes to each
developer or group of developers, and developers typically require the services of classes for which others
are responsibl e . In other words , developers' packages are often related as client and server. The problem
is that these services are typically i n varied states of readiness as the application is i n the process of
being built.
A server component acts more effectively when its interface is narrow. "Narrow" means that the
interface (essentiaIly a coIlection of functions) contains only necessary parts, is coIlected in one place , and is
clearly defined. As explained in Chapter 1 7, the Facade design pattern establishes just such an interface to a
package of classes. Facade regulates communication with the objects in its package by exposing only one
obj ect of the package to code using the package, hiding all of the other classes.
Client-server architectures were a steady feature of the 1 980s and 1 990s . Many of them replaced
mainframe/terminal architectures. Client/server architectures have subsequently become more sophisticated
and more varied. Some are now designed as three-tier architectures instead of the original two tiers (client
and server). The third tier lies between the client and the server, providing a useful l evel of indirection. A
common aIlocation of function is to design the CUI for the client, the database management system, or
procedure management for the middle layer, and assorted application programs and/or the database itself for
the third layer. The middle layer can be a common data "bus" that brokers communication. Alternatively,
the middle layer can operate via a standard such as M icrosoft's . NET assemblies. FinaIly, the World Wide Web
can be considered a breed of client/server arch itecture in which "one server/tens of clients" is replaced by "one
server/millions of clients."

443

444

CHAPTER 18

SOFTWARE ARCHITECTURE

18.2.2.2 The Parallel Communicating Processes Architecture

Another type of "independent component" architecture identified by Shaw and Carlan is named parallel
communicating processes. This architecture is characterized by several processes, or threads, executing at the same
time. In his classic book [2], Dijkstra showed that conceiving a process such as the combination of parallel
parts can actually simplify designs. An example of this is a simulation of customers in a bank. Traditional ly,
many such simulations were designed without parallelism by stori ng and handling the events involved. Such
designs can sometimes be simpli fied, however, if the movement of each customer is a separate process (e.g., a
thread obj ect in Java ) . Such a parallel communicating process design has the advantage that it matches more
closely to the activities that it simulates. A good reference to parallel communicating processes in the Java
context is [3]. The parallel processes may run on a single platform or on separate platforms, as illustrated in
Figure 18 .10 .
Encounter uses this architectural parallel element b y having t h e foreign character Freddie move
independently from area to adjacent area while the game progresses . This thread "communicates" whenever
Freddie finds himself in the same area as the player character.
A UML notation that expresses parallelism was discussed in Chapter 16. Th is notation, used in
Figures 18.11 and 18 .12, shows an architecture for a banking application designed to handle multi ple
transactions occurring simultaneously on automated teller machines (ATMs) . This particular arch itecture
allows the customer to i nitiate transactions without having to wait for completion , even when the transaction
takes signi ficant time. The application may, for example, inform a customer that fun ds he deposited will
not be immediately available-that is, not wait for the completion of that process before making the
announcement.
When customer n uses an ATM, an object for customer n is created (Step 1 in Figure 18 .11) . Customer n
creates session m ( 2 ) . Session m then retrieves an Account object such as customer n checking ( 3 ). The retrieval is
performed asynchronously, and a thread, or parallel process, is created because it may take time. This allows
the customer to carry out other business in the meantime. The method call retrieving the Account object is
denoted by a stick arrow head indicating that the Session object proceeds in parallel with this construction,
returning to the customer obj ect. Since we are deali ng at an architectural level, we are omitting detai ls here
such as showing the thread objects involved and showing how the Session objects know that this is its required

Pla tform 1

Pla tform 2

Platform 3

II

;---

-

-

-

-

comunica tion
execu tion

-

Figure 18.10 Platforms for communicating processors

SOFTWARE ARCHITECTURE ALTERNATIVES AND THEIR CLASS MODELS

Requirement: Manage ATM traffic.
Architecture beginning with first session:

I

Customer n
:Customer:

I

I

session m
:Session

create

I

0 : retrieve" 0

customecn_
checking
:Account

I

G

deposit

(5)

deposit"

..

(more wor�)
(thread detail omitted)"
Figure 18.11 Example of parallel communicating processor architecture-managing ATM traffic, fragment of sequence
diagram

call. The Customer object immediately performs a deposit transaction by sending a message to the Session
object (4). The Session object executes the deposit by sending a deposit message asynchronously to the Account
object, spawning a new thread (5) . Other work can go on-including by other sessions-while the deposit is
processed.
In parallel, other Customer objects such as customer s are creating and operating on other sessions such as
session k. This is shown in Figure lB.12.
Figure 18. 1 3 shows the beginning of a class model that handles this kind of architecture .

Requirement:

Manage ATM traffic.

Architecture:

01

I

Customecn
:Customer:

customer s
:Customer

withdraw

I

II

sessio�_m
:Sesslon

create

0:

I

II

sessio�_k
:Sesslon

retrieve"
create

�

customer_
s_saving
: Account

I

I

customecn_
checking
:Account

:1 0
:
retrieve"

deposit

(5)

deposit"

l

withdraw"
(thread detail omitted)"

lJ

Figure 18.12 Example of parallel commu nicating processor arc h itecture-managing ATM traffic-sequence diagram

445

446

CHAPTER 18

SOFTWARE ARCHITECTURE

----------

.

--------

: Sessions

----------

--- -- ------- - ----- - - - - *

[ ���!�����

Account

depositO
withdrawO
retrieveO

'
,
'
,
,------- ----------- - -'

Figure 18.13 Example of parallel communicating processor architecture-managing ATM traffic-class model

18.2.2.3 Event Systems Architectures and the State Design Pattern

Let's turn to event systems, the third type of "independent component" architecture classified by Shaw and
Carlan . This architecture views applications as a set of components, each of which waits until an event occurs
that affects it. Many contemporary applications are event systems. A word processor, for example, waits for
the user to click on an icon or menu item . It then reacts accordingly, by storing the file, enlarging fonts, and
so on. Event systems are often fulfilled as state transition systems, which were introduced i n Chapter 11.
When a system behaves by essentially transitioning among a set of states , the State design pattern
should be considered for the design . This design pattern was explained in Chapter 17. For example, we have
described the overall requirement for Encounter in terms of the state diagram in Figure 1 1.26 of Chapter 11.
Encounter transitions among the Setting up, Waiting, Setting qualities, Reporting, and Engaging states, among others.
Our design should capture this behavior effectively. It should also be capable of gracefully absorbing new
states and action handling as the game becomes more complete , without disrupting the existing design . For
these reasons, we will apply the State design pattern described in Chapter 1 7 to Encounter.
The State pattern solves the problem of how to use an object without having to know its state . In the
context of Encounter we want to be able to write controlling code that handles mouse actions but does not
reference the possible states that the game can be in, or the speci fic effects of the mouse actions. This makes it
possible to add new game situations without disrupting this controlling code .
Figure 1 8 . 14 begi ns to show how the State design pattern can be used to handle the states and actions of
Encounter. The framework class RPGame ("Role-playing game") has an attribute called state, which is of type
GameState. The subtype of state ( i . e . , which subclass of GameState it belongs to) determines what happens when
handleEvent() is called on an RPGame obj ect. The code for handleEvent() in RPGame passes control to the
handleEvent() function of state.
- ----------- -,

: RolePlayingGame I

I

r------------------------------------�------------

RPGame
handleEventO

�
-------

I

state

�

GameState
handleEvent(j

I { state.handleEventO;}J

----------------------------------

EncounterGame

I

Figure 18.14 Beginning of the State design pattern applied to Encounter

SOFTWARE ARCHITECTURE ALTERNATIVES AND THEIR CLASS MODELS

-------------,

l��:�I��������:
state

RPGame

GameState

handleEventO <:::

l),

-J

handleEvent()

6

I { state.handleEventO;}J

EncounterGame

I

�

r-

_______________

I

--------- - ..,

: EncounterGamelI
----------

Waiting

Setting Qualities

handleEventO

handleEventO

---- ""1

SettingUg

Regorting

Engaging

handleEventO

handleEventO

handleEventO

I
I

Figure 18.15 State design pattern applied to the Encounter video game

As shown in Figure 18.15, each subclass of GameState i mplements handleEvent() in its own manner. For
example, if Encounter is in SettingQualities state, and the event is the arrival of a foreign character, then the
window permitting the setting of character quality values disappears because this is what the method
handleEvent() i n SettingQualities is programmed to do . An additional consequence of this particular event/state
combination is that Encounter transitions to the Engaging state, as required by the state - transition diagram.
This transition is implemented by code such as

�ncounterGame.setstate(neWEngaging());

The next time an event occurs in the game, the handleEvent() function of Engaging will execute, reflecting
the fact that the game is now i n the Engaging state .
18.2.3 Virtual Machines

A virtual machine architecture treats an application as a program written in a special-purpose language . Because
an interpreter for such a language has to be built, thi s architecture pays off only if several "programs" are to be
written in the language, generating several appl ications.
The implementation of a complete virtual machine requires the building of an interpreter. The
interpretation requires us to execute an operation-let's call it interpret()-on a program written in our
language . The interpretation of a primitive element alone (e.g., a CPU in the example of Chapter 17, where
the parts of a "CPU" are not relevant) is generally simple (for the example, this could be simply to print "take

447

448

CHAPTER 18

SOFlWARE ARCHITECTURE

CPU out of its box") . The problem is how to execute an interpret() function when applied to a more complex
"program ." To do this, we may use the Interpreter design pattern .
Virtual machine architectures are advantageous if the application consists of the processing of complex
entities, and if these entities, such as the orders in the example, are readily describable by a grammar.
An additional example requiring a virtual machine is an application that provides simple user-level
programming of a special purpose language . A non programmer user, for example, is capable of writing a
script-a simple program-such as the following:

Balance checking / add excess to account + subtract deficit from saving i
Save report / c: Reports + standard headings + except replace "Ed' ,
by "Al" PrintReport / standard headings
e-mail report toJayne@xyz.net.

A virtual machine architecture parses and interprets such scripts . The idea of such architectures is
illustrated in Figure 18.16.
18.2.4 Repository Architectures

An architecture built primarily around data is called a repository architecture . The most common of these are
systems designed to perform transactions against a database. For example, an electric company maintains a
database of customers that includes details about them, such as power usage each month, balance, payment
history, repairs, and so on. Typical operations against this database are adding a new customer, crediting a
payment, requesting a payment history, requesting a list of all customers more than three months in arrears,
and so on. A typical design for this kind of repository architecture is shown in Figure 18. 17. This figure mixes
the flow of data between entities ( solid lines) and control (dashed lines) . "Control" means that one of the
entities prompts the operation of the other-for example, turns it on and off.
Other examples of applications with repository architectures include interactive development environ­
ments ( IDEs ) . IDEs apply processes such as editing and compiling to a database of source and object files.
Our Encounter example in its simplest form does not include a database . I f, however, it were to grow
into a game with many individual characters, then we might require a database rather than a flat file for storing
the characters. This would certainly be true if we wanted to allow the user to call up statistics such as "list the
characters with strength under 10," and so on. Structured Query Language ( SQL) is a common way to express
queries (see, for example, [4]).

Application 1

Application 2

Program 1 written in language

Program 2 written in language

understood by interpreter

understood by interpreter

I Interpreter I

I Interpreter I

Figure 18.16 Virtual machine architectures-leveraging the interpreter concept to facilitate the implementation of

multiple applications

SOFTWARE ARCHITECTURE ALTERNATIVES AND THE I R CLASS MOD ELS

n

Key:
Control flow: +- ...
Dataflow:
+----+

Database

Figure 18.17 A typical repository architecture

Blackboard architectures, developed for artificial i ntellige nce applications, are repositories that behave
in accordance with posting rules. The reader is referred to [5] and [6] for a detailed treatment of blackboard
architectures.
The final type of repository architectures we mention here is the hypertext architecture . The most
common use of hypertext is on the Web. An applicatio n that manages the artifacts of a software engineering
application is another example.
The word "repository" is often used i n industry to denote an application that provi des a unified view of a
collection of databases ( i . e . , not just one) . This relates to data warehouses . Repositories do not change the
structure of these databases, but they allow uniform access to them. This is a special case of repository
architectures as defined by Carlan and Shaw.
Repository architectures occupy a significant fraction of appl ications, since so many architectures make
databases their core . When the processing is negl igible compared to the formatting of data from the database,
repository architectures are appropriate . On the other hand, the presence of a large database can sometimes
mask the fact that a large amount of processing may drive the architecture . Ad hoc database programming
(e. g. , "stored procedures") can easily mushroom into messy applications, which perhaps shoul d be conceived
differently from the repository model .
18.2.5 Layered Architectures

An architectural/ayer is a coherent collection of software artifacts, typically a package of classes . In its common
form, a layer uses at most one other layer, and is used by at most one other layer. BUilding applications layer by
layer can greatly simpl ify the process . Some layers, such as frameworks, can serve several applications.
We have already seen the layered approach applied to the Encounter application, where classes i n the
Encounter packages i nherit from classes in the framework packages. This is shown in Figure t 8 . t 8. The figure
shows how we might organize the use of a 3-D graphics engine as a layer accessible from the Role- Playing
Came l ayer.
Figure t 8. t 9 shows an example of a layered architecture for an Ajax bank printing application. There are
four layers in this architecture, and Figure t 8 . t 9 shows dependency in the reverse direction compared to
Figure t 8. t 8. The appl ication layer, Ajax Bank Pri nting, has to do with printing and formatting. It is built
upon ( i . e . , uses) the Accounts and the Ajax Bank Common Class layers . The latter are built upon a vendor­
supplied layer, which contains general utilities such as sorti ng and searching. Typically, a layer is realized as a

449

450

CHAPTER 18

SOFlWARE ARCHITECTURE

engine layer
D D
Role-playing game layer

3D

I Characters I

I RolePlayingGame I

Application layer

D
«uses»

I Layout I

I Encounter Game I

Figure 18.18 Layered architectures, and example of 3D engine and video game

Requirement: Print monthly statements.
Architecture:
_

I Ajax bank p!inting LaYefJ

!Accounts Layer

"uses"
_____._

Ajax bank common library Layer

t

______ Ve��-suppliedLay�e_r

�

______ �

Figure 18.19 Example of layered architecture for Ajax Bank-highest level view

package of classes. For example, the Ajax common library comprises classes used throughout Ajax
applications, and addresses such issues as the bank's logo and its regulations.
The "using" relationship can be inheritance, aggregation, or object reference . In the example, only
aggregation is applied between layers, as shown in Figure 18 . 20.
18.2.6 Service-Oriented Architectures

Service-Oriented Architectures (SOAs) are gaining in usage . They are closely related to the idea of software as a
service and cloud computing, and warrant inclusion with those discussed above . SOAs are combinations of
services: components that provide functionality according to an interface speci fication. They differ from many
other application architectures in that they describe a set of interoperable components that can be
dynamically harnessed to create functionality-rather than as a way to create a single application.
SOAs are in the spirit of facade objects, and include Web services as a means of implementation. SOAs
are not necessarily object-oriented. In the case of Web services there is no assurance of globally defined
classes as we have provided for Facade in prior examples. For example, suppose that an SOA is for a business­
to-business application concerning orders. In an SOA, we would not assume that a unique Order class is known
to and usable by all service suppliers and consumers . Web services in particular deals with this by defining a
schema for an order data structure, and referenCing the schema when Web services involve orders. This uses a
Web service capability known as Web Service Description Language and has the effect of making an Order class
known to clients. This is summarized in Figures 18 . 21, 18 . 2 2 , and 18 . 2 3 .

SOFTWARE ARCHITECTURE ALTERNATIVES AND THEIR CLASS MODELS

e
� --A�x-���� ��tiijg L��e r 1 � _� s _s _ _
Ajax bank common library Layer
Accounts Layer I
-·- -1I
···
·
·
_
�=:·
·
··
Y��
L�
:
d
l
i
;;;
P
P
,,!��d;;;��;;

A rchitecture:

__

L_ _ _ _

-

_

__ __ __

Class model:

( relationships within
packages not shown)

! I Pri nter I
--

�����������} - - - - - - - - - - - - - - - � � � � � � Vendor-supplied
ioE----:----i layer
j I Account I
not shown
--

,
,

- -

-- ------------- - - ------------ :

- -------------------- -- --

- - -

-

-

Figure 18.20 Layered architecture example using aggregation

Based on components that provi de functionality according to an interface spec.
Principally via Web services
In the spirit of facade objects
Not necessarily 00
Example: An application concerning orders.
Wouldn't assume an Order class known to all
Instead: Define an order schema; reference when Web services involve orders
•

•

•

•

•

Figure 18.21 Service-oriented architectures, 1 of 3

Service-oriented architectures envisage a network (mostly an Internet) -dominated environment in
which applications (and parts of applications) are not permanently wedded to each other. Rather, SOAs
seek to allow dynamic linking of services. For example, suppose that you want to write an appl ication that
orders stationery for a company. You would want the application to identify all qualified ven dors, check
prices and availability, call for bids and terms, select a vendor, and place the order. To do this, the application
can't be permanently wedded to a set of vendors . For this reason , SOAs are built around a registration system.
Figure l S . 2 3 illustrates the four steps involved in publishing and accessing a service. "Querying" is like looking
up a busi ness in a telephone book. "Binding" means contacting the service i n order to i nvoke it.
(The reference for Figures l S . 2 1 , l S . 2 2 , and l S . 2 3 is [ 7] . )
•

"Fire and forget"
S tateless as much as possible
•

•

Extensible

•

Discoverable

•

Account for Quality of Service

•

•

Additional functionality easily added

For example, security

Figure 18.22 Service-oriented architectures, 2 of 3

451

452

CHAPTER 1 8

•

SOFTWARE ARCH ITECTURE

"Fire and forget"
Stateless as much as possible
•

•

Extensible

•

Discoverable

•

Account for Quality of Service

•

•

Additional functionality easily added

For example, security

Figure 1 8.23 Service-oriented arch itectures, 3 of 3

Service-ori ented architectures frequently use a business process layer. This defines the components of the
business such as the customer data base and business. Credit policies are examples of the latter. The service interface
layer defines the services available that are based upon the business processes. It specifies functionality such as
listing all customers in the database and checking a transaction for conformance to business rules. The application
layer consists of applications built using the service interface layer. These points are shown in Figure 18.24.
1 8.2.7 Using Multiple Architectures within an Application

Applications typically use several subsidiary architectures within an overall architecture . Figure 18 . 25 shows
how the framework for role-playing video games could use several of the architecture types listed by Carlan
and Shaw. It could make sense, for example, to organize the Artifacts package as a database . The game
characters could be viewed as parallel communicating processes. We will design the overall control of the
game as an event- driven system.

Service I nterface Layer

Business P roces

Figure 1 8.24 Layering for service-oriented arch itectures
Source: Adapted from Erl, Thomas, "Service-Oriented Architecture: Concepts, Technology, and Design," prentice Hall, 2006.

TRADING OFF ARCHITECTURE ALTERNATIVES

Characters

RolePlayingGame

Parallel
communicating

Event system

processes

Posible

Rule-based
system

--f--

Artifacts
Database

Layered -------1

system

system

Encounter Layout

Figure 1 8. 2 5 Example of the use of multiple su bsidiary architectures-Encounter video game extension

18.3 TRADI N G OFF ARCHITECTU RE ALTERNATIVES

Since the choice of a software architecture is so important, it is wise to create more than one alternative for
consideration. As an example, we will create and compare two architectures for the video store applicatio n .
F o r t h e first candidate , we separate the application into three major parts : T h e "back-end" database, the
middle part, which contains the business logic, and the GUls. Thi s is a three-tier architecture . It is often an
appropriate choice when some or all of the tiers reside on physically separate platforms. In particular, if the
GUls are all on pes, the middle layer on a server, and the databases controlled by a database management
system, then three -tier architectures map neatly to separate hardware and software units. Note that there is no
necessity that hardware decompositions be the same as software architectures; we may want a logical
(conceptual ) view of an application to be entirely independent of the hardware platforms hosting it. (These
are the physical view vs. the logical view . ) Applying three tiers to the video store application, we could obtain
the archi tecture in Figure 1 8 . 26 .

EJ

V80perations

Presentation
tier

Middle
tier

Figure 1 8 .26 Three-tier architecture alternative

I

EJ
Data
tier

453

454

CHAPTER 1 8

SOFTWARE ARCHITECTURE

I

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ....... ............... ....... ....... . . . . . . .... . ..... ..

I

VSCoo"om'"

I

I

DVR,otal,

Figure 18.27 Alternative architecture for a video store application

The strength of this architecture is that it's easy to understand. Another strength is that since the CUI
part is separate from the rental operations it can be changed without disturbing the latter. One weakness is the
coupling between the CUIs package and the VSOperations package; there may be several CUI classes
corresponding to the Customer class, for example. There is also coupling between the classes in the VSData
package and the classes i n VSOperations. A second architecture candidate is shown i n Figure 1 8 . 27.
This architecture groups all of the classes pertaining to the videos i n a package . The Rentals package
contains classes that relate videos and customers. The Customers package contains the classes pertai ning to
customers, i ncluding associated CUls. A third option would be to group all displays in a package. Figure 1 8 . 2 8
summarizes o n e opinion of these architecture alternatives.
18.4 TOOLS FOR ARCH ITECTURES

Various computer-aided software engineering (CASE) tools are used to facilitate the software engineering
process. Some tools represent classes and their relationships, such as Rati onal Rose by IBM Corporation.
These tools facilitate the drafting of object models, linking them with the corresponding source code and
sequence diagrams .
I n selecti ng a modeling too\ ' a list of the requirements for the tool i s drawn u p using procedures similar
to the requirements analysis process for software application development. Here is an example of some
requirements for model ing tools.
•

Essential : Facilitate drawing object models and sequence diagrams

•

Essential : Create classes quickly

Three-tier

Alternative

Understandable?
Flexible?

Yes
Yes : CUI easy to change

Reusable?

Not very: Each layer is special to
video store rentals
Perhaps

Yes
Yes : Basic building blocks easy to
identify
Yes : Easy to generalize to generic rentals

Easy to construct?

Figure 18.28 A comparison of architectures--example

Yes : Clear potential to use Facade

EFFECTS OF ARCHITECTURE SELECTIO N ON THE PROJECT P LAN

•

Essential : Edit classes easily

•

Desirable: Should cost no more than $X per user

•

Desirable: Zoom i nto parts of the model

•

Desirable: Possible to jump directly from the object model to the source code

•

Optional : Reverse engineering available ( i . e . , create object models from source code)

•

Optional: Use color coding for status of class implementati on

Tool packages frequently try to span architecture, detailed design, and implementation . Various
vendors are developing the capability to hyperlink from source code to documentation and vice versa.
Implementation-oriented tools such as Javadoc can sometimes be useful to supplement the design process .
Javadoc is useful for navigating packages because it provides an alphabetical l isting of classes and the parent
hierarchy of each class .
I nteractive development environments (IDEs) are delivered with compilers and are widely used as
partial modeling tools. Obj ect- Oriented IDEs generally show inheritance in graphical form, and developers
are frequently attracted to these tools because of their closeness to the compilation and debugging process .
Eclipse, used as a successful software engineering case study itsel f in this book, is an example of a widely
used IDE.
Component assembly tools create applications by dragging and dropping icons that represent proces­
sing elements. Java Bean environments are typical of these . Within such environments, beans Oava objects
whose classes conform to the Java Beans standard) can be obtained from libraries, customized, and related to
each other by means of events. The Java Beans standard was created with the express purpose of facilitati ng
such simple assemblies by means of graphical tools.
A disadvantage of using modeling tools is the project's dependence on a third-party vendor. In addition
to the complications of the application and the project itself, engineers must be concerned with the viability
of the tool's vendor. Suppose that the vendor goes out of business or tool upgrades become too expensive :
How will the project be affected? Despite these issues , the use of design and development tools has increased
steadily. The right tools leverage productivity, and economic factors favor their usage .

18.5 I E E E STAN DARDS FOR EXPRESS I N G DESIGNS

The IEEE Software Design Document (SDD) standard 1016- 1998 provides guideli nes for the documentation
of design . The table of contents is shown in Figure 18. 29 . IEEE guidelines explain how the SDD could be
written for various architectural styles, most of which are described above. The case study uses the IEEE
standard with a few modifications to account for an emphasis on the obj ect-oriented perspective . As shown in
the figure, Sections 1 through 5 can be considered software architecture, and Section 6 can be considered the
detailed design, to be covered in the next chapter.

18.6 E F FECTS OF ARCH ITECTU RE SE LECTION ON THE PROJ ECT PLAN

Once an architecture has been selected, the schedule can be made more speci fic and more detailed. In
particular, the order i n which parts are built can be determined. For example, in the case study it makes sense
to first develop the Characters framework package, followed by the speCific EncounterCharacters application
package . Si nce these packages will not be completed in the first iteration of the spiral , we name the

455

456

CHAPTER 1 8

SOFTWARE ARCHITECTURE

1 . Introd uction

4. Dependency description

1 .1

Purpose

1 .2

Scope

1 .3

Defin itions, acronyms, j

4. 1

Architecture
.

.. ...

and abbreviations
2. References

Intermodu le dependencies

4.2 Interprocess dependencies
4 . 3 Data dependencies
5. Interface description
5 . 1 Module interface

..

5 . 1 . 1 Module 1 description
5 . 1 .2 Module 2 description

3. Decomposition description
3.1

Module decomposition

3.2

Concu rrent p rocess

5.2 Process interface
5.2. 1 Process 1 description
5.2.2 Process 2 description

3. 1 . 1 Module 1 description
3. 1 . 1 Module 2 description

6. Detai led design

decomposition
3.2. 1 Process 1 description
3.2.2 Process 2 description

6 . 1 Module detailed design
6. 1 . 1 Module 1 detail
6.2.2 Module 2 detail

3 . 3 Data decomposition
3.3. 1 Data entry 1 description
3.3.2 Data entry 2 description

6 . 2 Data detailed design
6.2 . 1 Data entity 1 detail
6.2.2 Data entity 2 detail

Figure 18.29 The architecture parts o f IEEE 1 0 1 6- 1 998-SDD table o f contents
Source: IEEE Std 1 0 1 6- 1 998.

corresponding tasks "Characters I" and "EncounterCharacters I . " Arrows indicate dependence of packages on
others. For example, "EncounterCharacters I" cannot be completed without the completion of "Characters I,"
as shown i n Figure 1 8 . 3 0 . The schedule shows that "Integration and Test I" cannot begin until all of the other
tasks i n Iteration I have been completed.
Month 1

Month 2

Month 3

Month 4

Month 5

1
M ilestones

Iteration 1
Integration
and Test II

Iteration 2
�=====----.J
Figure 18.30 Schedule following architecture selection

I

CASE STUDY: PREPARI NG TO DESIGN ENCOU NTER (STU DENT PROJ ECT G U I D E CONTI N U ED)

18.7 CAS E STU DY: PREPARI N G TO D E S I G N E N COU NTER (STU DENT PROJ ECT G U I DE
CONTI N U ED)

This section describes a scenario of how the Encoun ­
ter proj ect team may have gone about the creation of
the Encounter architecture .
1 8. 7. 1 Preparing
I n accordance with the SPMP, Karen Peters was the
design leader, with Ed Braun backing her up and
inspecting all of the design work. Karen aimed to
develop two thoroughly prepared alternative archi ­
tectures for the Encounter proj ect and bri ng them to
the team's preliminary design review. She was deter­
mined to avoid unpleasant haggling over architectures
that were devised by different engineers . She felt that
ego rather than technical issues predomi nated in such
cases. She had even worse memories of architecture
"compromises" that were created to reconcile com­
peti ng architectures . These frequently resulted i n poor
designs that everyone had to live and work with daily
for months, if not years. On the other hand, Karen did
not want to produce an architecture in isolation. She
decided that she and Ed would select architecture
candidates together, research them thoroughly, and
present the choices to the team.
1 8. 7. 2 Selecting Architectures
AI Pruitt had been thinking about the design of the
game application, and he gave Karen a sketch of an ad
hoc CU I - driven architecture . He pointed out that it
was s imple and would be quick to implement. Ed and
Karen reviewed Carlan and Shaw's classi fication of
architectures to determine whether Encounter ap­
peared to match any of the architecture alternatives .
They first asked whether Encounter could be
described as the flow of data from one processing
element to another. The data would have to be the
positions of the game characters and/or their qual ity
values. This view did not seem to them to match their
conception of the game.
Next, they turned to Carlan and Shaw's "inde ­
pendent components" architectures, the first of
which was "parallel communicati ng processes . " To
Karen this seemed to be a possible match because
each game character could be considered one of the

processes . Each could be run on a separate parallel
thread, and these threads would communicate when­
ever the characters encountered each other. They
noted this as a candidate arc lh itecture .
They considered "c1ient erver" next, but it was
unclear to them what the "c1 ·ent" and "server" roles
would be, so they dismissed his alternative . "Event
systems," the next type list d, appeared to be a
candidate architecture since i the game responded
to either user- initiated events, such as the pressing
of an area hyperlink to enter an area, or to the arrival
of the foreign character in the same area as the player
character. They noted this as another candidate
architecture .
Next, Ed and Karen considered "virtual ma­
chines," asking whether each game execution con ­
sisted essentially of the i nterpretation of a script.
This did not appear to them to be the case .
They considered whether the game could be
thought of as built around a repository of data (a
"repository system") . The data could be the values of
the characters and the status of the game. They
decided that this might indeed be a possibility if there
were many characters and many arti facts, because in
that case, the manipulation of large amounts of data
might predominate. Since Encounter was not to be
data-centric, however, they rejected this candidate .
Finally, they considered a layered architecture .
The question here was whether Encounter could be
viewed as a series of class groupings with each
grouping using one or two of the others . Kare n
felt that there would i ndeed be at least two useful
layers : one for role-playing games in general, and
one for Encounter. They made a note of this candi ­
date architecture, and ended their consideration of
Carlan and Shaw's options.
Now they l isted the arch itecture candidates.

f

AI Pruitt's CUI - driven architecture
Parallel communicating processes
Event systems
Layered

457

458

CHAPTER 18

SOFTWARE ARCHITECTURE

They discussed which of these described the
overall architecture and which were subsidiary to the
overall architecture. To decide among these candi­
dates they evaluated them in terms of the qualities
described in this chapter. Their scheme gave 2 as
the highest value and 0 as the lowest. In the case of
close scores, the team would h ave questioned their
scores closely. I n addition, as they learned more
about the application, they understood the need
to revisit this table up to the time that they had

to commit to architecture. One advantage of the
table (Table 18. 1) is that it allowed them to more
easily reevaluate their reasoning.
Their conclusion was that l ayering was the
primary architectural principle since there was a
generic role-pl aying game layer and the Encounter
l ayer itsel f. They envisaged the "eve nt systems"
archi tecture as subsidiary to the l ayers. They post­
poned a detailed discussion of parallel communicat­
ing processes for the game characters . Conceptually,

Ta ble 1 8.1 Evaluation o f architecture candidates b y means o f design qualities
Parallel
AI

communicating

Pruitt's

processes

Event
systems

Layered

1

1

2

2

0

2

1

2

0

0

1

2

1

0

2

2

0

1

0

1

1

0

2

1

1

0

1

1

0

0

1

2

1

1

2

2

1

2

0

1

Reliability:

0

1

1

2

TOTALS

6

8

13

18

Candidates

Qual i ties
Sufficiency: handles the
requirements

understandability: can be
understood by intended audience

Modularity: divided into well-defined
parts

Cohesion: organized so like-minded
elements are grouped together

coupling: organized to minimize
dependence between elements

Robustness: can deal with wide
variety of input

Flexibili ty: can be readily modified to
handle changes in requirements

Reusability: can use parts of the
design and implementation in other
applications

Information hiding: module internals
are hidden from others

Efficiency: executes within
acceptable time and space limits

CASE STUDY: PREPARIN G TO DESIG N ENCOUNTER (STUDENT PROJECT GUIDE CO NTINUED)

their main architecture selection is reRected i n
Figurel8 . 3 5
They decided t o express the "event systems"
architecture by means of states and transitions. Then
they debated whether to use the State design pattern
or a state/action table to describe the event/transi ­
tions, and deci ded to apply metrics to assist i n
choosing from the architectures under consideration,
including AI Pruitt's.
They used e-mail to try to get agreement on the
weighting o f criteria for architectures (extension,
change, etc.,-see Table 18. 1 i.e., "Evaluation of
architecture candidates by means of design qualit­
ies.") in advance of the meeting, without mentioning
the architecture candidates themselves. They then e­
mailed AI a draft of the comparison table in advance
o f the meeti ng to make sure that they had not m issed
any aspects of his proposal . AI pointed out that the
choice of architecture was heavily dependent on the
weighting, but was willing to accept the team's
weighting. Karen and Ed drew up the spreadsheet
Table 18.1, comparing AI Pruitt's architecture (alter­
native 2) and two others they had developed, and
mailed it to the team members so that they would be
prepared for the meetin g.

18.7.3 Team Meeting (Preliminary Design
Review)
At the meeting, Karen and Ed first con firmed agree­
ment on the weighting of criteria. Because of their
use of e-mail prior to the meeting, the team did not
take long to iron out the few remaining i nconsisten­
cies. No mention was made yet of the archi tectures
themselves. They presented the architecture alter­
natives to the team, showing the spreadsheet results.
After some discussion and modification of their
assessments, the team confirmed their selection of
the layered architecture and the use of the State
design pattern . Karen and Ed's thought process and
presentatio n had been thorough. The team's discus­
sion focused on how to improve the architecture
selected. They solicited ideas for refining the archi­
tecture, but Karen did not try to rank the i deas or
create a si ngle refined version of the architecture at
the meeting. She wanted to thi nk through the sug­
gestions ofRine.

18.7.4 Refining the Architecture
Karen and Ed were now faced with the task of
decom posing each layer. They performed this by
placing the two additional archi tectural elements in
separate packages. In the role-playing game layer they
formed a package for the state machine called Role­
Playing Game. To handle the game characters, which
move around i n parallel , they created a Characters
package. They also created a GameEnvironment package
to contain classes describing the places in which the
characters would m ove. Finally, they envisaged an
Artifacts package for the future to describe the miscel­
laneous items such as shields and swords that would be
involved. This package, postponed for future releases,
would have a Repository architecture.
Their decomposition of the Encounter applica­
tion layer was analogous since m any of i ts classes had
to inherit from the generic game level. They decided
to create narrow access paths to the packages of this
l ayer to prevent a situation in which any class could
reference any other class. They felt that such un ­
restricted references would soon become impossible
to manage duri ng development and maintenance. To
accomplish this n arrow access they used the Facade
design pattern for each appl ication package. Ed had
some reservations about doi n g this because it in­
creased the amount of code the team would have to
create and manage. Methods would not be called
directly, he pointed out, but only through speci al
methods of the facade objects , thereby i ncreasing
the total number o f methods. It also i ntroduced
complications in that i n ternal classes could not
even be mentioned by objects external to the package
(although their generic base classes could be), but
Karen convinced him that the price was worth the
benefit of having a clear i n terface for each package.
They obtained approval for their architecture
at a subsequent team meeting.
18.7.5 Documenting the Architecture
Ed and Karen used Sections 1 through 5 of the IEEE
standard 10 16 to express the architecture i n a Software
Design Document (SOD). Since they had divided the
application i n to two layers, one of which was slated
for reuse, they decided to document the framework
"role-playing game" layer in a separate SOD .

459

460

CHAPTER 18

SOFTWARE ARCHITECTURE

18.8 CASE STUDY: SOFTWARE DESIG N
DOCU M E NT FOR THE ROLE-PLA YING VIDEO
GAME FRAM EWORK

2. References

Software Engineering: An Object-Oriented Perspective, by
E. J. Braude (Wiley, 2001) .

We have two designs to describe . The first is that o f
the Role-Playing Video Game framework; t h e second i s
that of t h e Encounter role-playing game. The SODs
for both designs are spl i t i n to two parts. The first
parts, SOD Sections 1 through 5, shown below,
consist of the architectural aspects of the designs.
The second part, SOD section six, appearing at the
end of Chapter 19, consists of the detailed designs.
The dependence of Encounter on the framework is
specified in the Encounter case study.
H istory of versions of this document:
x/yylzzz K. Peters: i n i tial draft
x/yylzzz K. Peters: revised, incorporating com­
ments by R. Bostwick
x/yylzzz K. Peters: moved details of classes to
Section 3

1. Introdu ction

1.1 Purpose
This document describes the packages and classes of
a framework for role-playing video games.

UML The Unified Modeling Language User Guide, by
C. Booch, J. Rumbaugh, and 1. Jacobson (Addison­
Wesley.
IEEE standard 10 16- 1987 (reaffirmed 1993)
guideli nes for generating a Software Design Document.
3. Decomposition Description

Note to the Student:
This section speci fies how the framework clas­
ses for role-playing video games are to be
grouped. This reAects the top -level decompo­
sition: the detailed decomposition into meth ­
ods, for example, is left for the detailed design
(see case study at the end of the next chapter).

3.1 Module Decomposition

This section shows the decomposition then
explains each part i n a subsection.

1.2 Scope

The framework consists of the RolePlayingGame,
Characters, Artifacts, and Layout packages. These are

This framework covers essentials of role- pl aying
game classes. I ts main i n tention is to provide an
example of a framework for educational purposes.
It is not intended as a framework for commercial
games since its size is kept small to facilitate learning.

decomposed i nto the classes shown in Figure 18.31.
The classes i n these packages are explained below.
Unless otherwise stated, all classes in these packages
are public. As i ndicated by the (UML) italics nota­
tion, all o f the framework classes are abstract.

1.3 Definitions, Acronyms, and Abbreviations

3. 1. 1 RolePlayingGame package
This package is designed as a state-transition ma­
chine. The concept is that a role-playing game is
always in one of several states. Th is package makes it
possible to describe the possible states of the game
and the actions that can take place in response to
events. It implements the State design pattern (see
[8]) . The state of the game is encapsul ated

Framework: a collection of interrelated classes used,
via i nheritance or aggregati o n , to produce famil ies of
appl ications
RPC, Role-playing game: a video game in
which characters i nteract i n a manner that depends
on their characteristics and their environment

CASE STUDY: SOFlWARE DESIG N DOCUMENT FOR THE ROLE-PLA YING VIDEO GAME FRAMEWORK

RolePlayingGame

RPGame
handleEventO

I

Characters

j

L� state

I GameCharacter I

,I

O .. n

/

I'

{ state.handleEventO;}

I

RPGEvent

Artifacts

I

GameState
f-- handleEventO

future
r For
re leases
l
I

f-------"---�

GameEnvironment

l--" I

I GameLayout I

I
)

GameArea

2

r

I GameAreaConnection

Figure 18.31 RPG framework for role-playing video games

(represented) by the particular GameState object ag­
gregated by the (single) RPGame object. This aggre­
gated object is named state. [n other words, state is
an attribute of RPGame of type GameState.
The function handleEvent() of RPGame is called to
handle each event occurring on the monitor ( mouse
clicks, etc . ) . [t executes by calling the handleEvent()
function of state. The applicable version of handle­
Event() depends on the particular subclass of GameState
that state belongs to .

3. 1.3 GameEnvironment package
This package describes the physical environment of
the game. The class GameLayout aggregates connec­
tion objects. Each connection object aggregates the
pair of GameArea objects that it connects. This archi­
tecture allows for multiple connections between two
areas. Each GameArea object aggregates the game
characters that it contains ( i f any) and can detect
encounters among characters .
3. 1.4 Artifacts package (Not Implemented­

3. 1.2 Characters Package
[t may seem strange to have a package con­
taining just one class, but most arti facts in
software design have a tendency to grow.
Even if the pacakge does not grow, this
does not disqual i fy its usefulness. For another
example o f a package with just one class, see
java.applet, whose only class is Applet (but it also
contains a few interfaces) .

This package contains the GameCharacter class,
which describes the characters of the game .

for Future Releases)

This package is intended to store elements to be
located in areas, such as trees or tables, and entities
possessed by characters, such as shields and briefcases.

3.2 Concurrent Process Decomposition
The framework does not involve concurrent processes.

4. Dependency Description

This section describes all the ways in which
the modules depend on each other.

461

462

CHAPTER 18

SO FlW ARE ARCHITECTURE

The only dependency among the framework
modules is the aggregation by GameArea of

5. Interface Description

UML The Unified Modeling Language User Guide, by
G. Booch, J . Rumbaugh , and I. Jacobson (Addison ­
Wesley.
IEEE standard 1016- 1987 (reaffirmed 1993) guide­
lines for generating a Software Design Document.

All classes in these packages are public, and thus the
interfaces consist of all of the methods in their classes.

3. Decomposition Description

GameCharacter.

1 8. 9 CASE STUDY: SOFTWARE DESIGN
DOCUMENT FOR ENCOUNTER (USES THE
FRAMEWORK)

History of versions of this document:

The Encounter architecture is described using three
models: use case , class (object) model, and state. I n
addition, the relationship between the domain pack­
ages of Encounter and the framework described i n
the S D D entitled "Role- Playing Game Arch itecture
Framework" will be shown .

x/yy/zzz K. Peters: i n i tial draft
x/yylzzz K. Peters: added decomposition by
use case model and state model

1 . Introduction
1.1 Purpose
This document describes the design of the Encounter
rol e - pl aying game.

1.2 Scope
This design is for the prototype version of En­
counter, which is a demonstration of architecture,
detailed design, and documentation techniques. The
architecture is intended as the basis for interesting
versions in the future . This description excludes
the framework classes, whose design is provided i n
the S D D entitled "Role - Pl aying Game Architecture
Framework."

1.3 Definitions, Acronyms, and Abbreviations
None

2. References
"Role-Playing Game Architecture Framework," sec­
tion in Software Engineering: An Object-Oriented Perspective,
by E. J. Braude (Wiley, 200 1).

The IEEE standard is extended using Sections
3.4 and 3.5 in order to describe these models.
Recall that the other possible model is data
flow, which we have not considered useful in
this case. In the particular case of this video
game, we chose to use the state description as
part of the requirement as well as the design.

3.1 Module Decomposition (Object Model)
This section should not dupl icate the "detailed
design" section described in the next chapter.
We do not go into detail here regarding the
contents of the packages.
The package arch itecture for Encounter is
shown in Figure 18.32. The three packages are
EncounterGame, EncounterCharacters, and Encounter­
Environment. These h ave facade classes EncounterGame,
EncounterCast, and EncounterEnvironment respective ly.
The facade class of each package has exactly one
i nstantiation, and is an in terface through which all
dealings with the package take place. The rem a i n ­
i n g classes are n o t accessible from outsi de the
package . (See Section 17.7.1 in Chapter 17 and
[1] for a complete description o f the Facade design
pattern. )

CASE STUDY: SOFTWARE DESIGN DOCUMENT FOR ENCOUNTER (USES THE FRAMEWORK)

EncounterGame

EncounterCharacters

I

I

EncounterCast
«facade»

I

I

I

EncounterGame
«facade»

EncounterEnVironment

I

I

j

EncounterEnvironment
«facade»

I

Figure 18.32 Architecture and modularization of Encounter game

3. 1. 1 EncounterGame package
The EncounterGame package consists of the classes con­
troIling the progress of the game as a whole. The
package is designed to react to user actions (events).
3. 1.2 EncounterCharacters package
The EncounterCharacters package encompasses the
characters involved in the game. These include
character(s) under the control of the player together
with the foreign characters.
3. 1.3 EncounterEnvironment package
The EncounterEnvironment package describes the phys­
ical l ayout of Encounter, i ncluding the areas and the
connections between them. It does not include
moveable items, if any.
3.2 Concurrent Process Decomposition
There are two concurrent processes in Encounter. The
first is the main visible action of the game, in which the
player manually moves the main character from area to
adjacent area. The second consists of the movement of
the foreign character from area to adj acent areas.

3.3 Data Decomposition

Describes the structure of the data within the
application

The data structures flowing among the pack­
ages are defined by the Area, EncounterCharacter, and
EncounterAreaConnection classes.

3.4 State Model DecompOSition
Encounter consists of the states shown in Fig­
ure 18.33.

This state diagram was provided in the SRS,
Section 2. 1. 1 , where it was used to describe
the requirements for Encounter. The remain­
ing states mentioned in the requirements will
be im plemented in subsequent releases.

3.5 Use Case Model Decomposition

This section is added to the IEEE specification ,
which does n o t address the use case concept. I t
has been added at the e n d of this section s o as
not to disturb the standard order.
Encounter consists of three use cases: Initialize,
Travel to Adjacent Area, and Encounter Foreign Character.
These use cases are explained in detail in the SRS,
Section 2.2, and are detailed in sections later in this
document.

463

464

CHAPTER 18

SOFTWARE ARCHITECTURE

[S�i�9 Up]
Playetr s
compl
s etupe e

diPls miaysessrest
es
qual
i
t
i
e
widow

rPlestatus
quayeestsr

astsyer to
rs equPlt qual
e
e ities Foreign
character

Foreignr
charact
enters areea

Plquiaytes r

�

Ecompl
ncouentteedr

[foreign character
present}

Figure 18.33 State-transition diagram for Encounter video game architecture

Details are given in the "detailed design"

There are no significant dependencies among

section.

the use cases.

4. Dependency Description

4.1 Intermodule Dependencies (Class Model)

This section describes the dependencies for the
various decompositions described in Section 3.

The dependencies among package in terfaces are
shown in Figure 18.34.

EncounterCharacters

I

l

1
EncounterCast

I

I

�

I EncounterGame I
I

EncounterGame

�

r-�

I

I

I Encou nterEnvi ronment I

I

EncounterEnvlronment

I

Figure 18.34 Architecture (modu larization) of Encou nter video game

I

CASE STUDY: SOFTWARE DESIGN DOCUMENT FOR ENCOUNTER (USES THE FRAMEWORK)

4.4 State Dependencies

The EncounterGame package depe nds on all of the
other Encounter packages. The EncounterEnvironment
package is designed to depend on the Encounter­
Characters package. This is because the game's charac­
ter interaction takes place only in the context of the
environment. In particular, Area obj ects are responsi­
ble for determining the presence of the player's char­
acter together with the foreign character.
Dependencies among nonin terface classes are
explained later in this document.

Such

dependencies

are

detailed

Each state is related to the states into which the game
can transition from it.

4.5 Layer Dependencies
The Encounter application depends on the Role­
Playing Game framework as shown in Figure t 8 . 3 5 .
Each application package uses exactly o n e frame­
work package .

5. Interface Description

design

specifications.

This section describes the interfaces for the object
model. Note that several of the classes described are
defined in the design description of the Role-Playing
Game Framework.

4.2 Interprocess Dependencies
When an engagement takes place , the process of
moving the main character about and the process
controlling the movement of the foreign characters
interact.

5.1 Module Interfaces

4.3 Data Dependencies

5. 1. 1 Interface to the EncQunterGame

The data structures flowing among the packages are
defined by the classes, whose mutual dependencies
are described in Section 6 of this document.

The interface to the EncounterGame package is pro ­
vided by the the EncounterGame obj ect of the Encounter
Game facade class. It consists of the following:

Describes the interaction among the packages

Package

imm mmmmm�:���;;;;;��;;m ml��;�;;:�;;�:��"j
"us es"

! Role-plaving game layer (framework)
! Enco'ln1 te' 'Video ciame"la·ve'

.

.

]!

······················ ·······························.............................. ................................. ......................................·

I

L

i

·

·

I "us es"·

....................

.. .

..

......

. . .

.......... .....................

I EncounterGame I I

��.���.����.�.��i.���.�.��.� I. . . . . . . . . . .1

..... ............................. ..... ..... ...........

Figure 18.35 Framework-i-application dependencies

........................... ........

...

465

466

CHAPTER 18

SOFTWARE ARCHITECTURE

1. EncounterGame getTheEncounterGameOllgets
the only instance
2. GameState

getStateOllcurrent

state

of

the

EncounterGame instance
3. void setState(GameState)ll- of the EncounterGame
instance
4. IIAny event affecting the single EncounterGame
instance:
5. void handleEvent(A WTEvent)

5. 1.2 Interface to the EncounterCharacters
package

The interface to the EncounterCharacters package is
provided by the theEncounterCast object of the Encounter­
Cast facade class. I t consists of the following.
1. EncounterCast getTheEncounterCastOllgets the
single instance
2. GameCharacter getThePl ayerCharacterOlli . e. ,
t h e unique character
3. GameCharacter getTheForeignCharacterOllthe
unique character
4. IIExchange quality values specific to the game
area
5. void engagePlayerWithForeignCharacter
(GameArea)

5. 1.3 Interface to EncounterEnvironment
Package

The interface to the EncounterEnvironment package is
provided by the EncounterEnvironment object of Encounter
Environment Facade class. It consists of the following:

1. EncounterEnvironment getTheEn-counter
Environmen tOllgets the Facade object
2. GameArea getArea(String)

6. Image getNeighborhoodAreas(Area)llgets Area
and areas one or two con nections distant
5.2 Process Interface

We stated in Section 3.2 that there are two
processes involved in Encounter. There is a
significant design decision to be made in re­
gard to the interface to the foreign character
movement process, and we describe the result
here . One option is to have the foreign char­
acter a thread, control ling itsel f. This has
advantages, but requires this character either
to know the environment-a disadvantage in
terms of changing and expanding the game­
or to be able to find out about the environment
dynamically, which would be an elegant de­
sign but too ambitious for the scope of this
case study. The architecture opts for another
alternative, which is stated here.

5.2. 1 Player Character Movement Process
The in terfaces to the process that moves the player's
character about the game consist of the graphical user
interfaces specified in the SRS. The process reacts to
eve nts described in Section 3.4, which are handled by
the EncounterGame package in accordance with its
specifications, described l ater in this document.
5.2.2 Foreign Character Movement Process
The process of moving the foreign character is a
separate process associated with and con trolled by
the EncounterGame singleton object. This process is
controlled by the methods inherited from java. lang.

Thread.
18.10 CASE STUDY: ARCHITECTURE OF
ECLIPSE

3. GameAreaConnection getAreaConnection(String)
4. void movePlayerTo(Area)
5 . void moveForeignCharacterTo(Area)
AreaNotAdjacentException

throws

Note to the Student:
The description that fol l ows describes the
architecture of Eclipse in a top-down fashion.

CASE STUDY: ARCHITECTURE O F ECLIPSE

18. 10. 1 Scope
[Th i s paragraph makes specific the scope of this
document ( the title "Archi tecture of Ecl i pse" seems
clear enough until we read i n this paragraph that it is
qualified).]
As of Apri l 2004, there were three Ecl ipse
releases. We wil l provide an overall descri ption of
the architecture of release 3.
18. 10.2 overview
The Ecli pse architecture has been described by
Gamma and Beck [9] as shown in Figure 18.36.

•

The Plug-In Development Environment allows develop­
ers to create and add plug-ins. It uses the J ava
development tools.

18. 10.3 Platform Module
The pl atform decomposes as shown in Fi gure 18.37.
The modules i n Figure 18.37 are as fol lows:
•

Runtime handles the available plug- ins at runtime.

•

Workspace manages projects, which consist of files
and fol ders.

•

Standard Widget Toolset (SWT) provides graphics
elements

Figure 18.36 has just three parts-a manage­
able number to comprehend. Ecli pse is a large
and very com plex product, however. Together
with the brief expl anations below, th is decom­
position is helpful. One has to search for a
while to find a description like this by looking
th rough http://www.eclipse. org.

•

•

The Pla tform is the i n frastructure of Ecl i pse and is
i n dependent of languages with which Ecli pse can
be used and i n dependent of all plug-ins.

•

JFace is a set of UI frameworks using SWT, used for
common Uls

•

Workbench "defines the Ecl i pse UI paradigm . This
i nvolves editors, views, and perspectives.,,

18. 10.4 Java Development Tools
The design philosophy of Eclipse is to e able to build
any language environment on top of the Pla tform. The
Java Development Tools (JOT) module is the J ava
environment. It consists of the Java Core module. Th is
is shown in Figure 18.38.

The Java Development Tools util ize the Pla tform and is
class model for a Java i nteractive development
environment.

We won't pursue this module or further parts
of the Eclipse architecture in th is case study.

Plug-In Development Environment

JJ. depends on

Java Development Tools

Platform
Figure 1 8 . 3 6 very high-level architecture of EClipse
Source: Adapted from Gamma, Erich, and Back, Kent. "Contributing to Eclipse: Principles, Patterns, Plug-Ins," Addison-Wesley, 2003, p.S.

J

Gamma and Beck [9], p. 6

1

467

468

CHAPTER 18

SOFTWARE ARCHITECTURE

I

I

UI
Workbench

I
I
I

JFace

I

Plug-In Development Environment

----1/1
r-1

I
Standard Widget Toolset

Java Development Tools

.u. depends on

L----

Platform

"

"

Core

"

"

Workspace

"

"

"

"

Runtime

" L-

�

__________________________

Key:

A depends on B.

Figure 18.37 Architecture of Eclipse-platform
Source: Adapted from Gamma, Erich, and Back, Kent. "Contributing to Eclipse: principles, Patterns, Plug-Ins," Addison·Wesley, 2003, p. 283.

The architecture of the OpenOffice.org suite is
designed to be platform-independent. It consists of
four layers, as described in Figure 18.39.

18. 1 1 CASE STUDY: OPENOFFICE
ARCHITECTURE

Note to the Student:
It is not straightforward to locate the description
of the OpenOffice architecture in a single, iden­
tifiable place.

The following is a useful white paper that sets out
the design methodology used for OpenOffice, and
much of this section is adapted or quoted from [ 10].

We wil l not discuss the StarOffice API here . As
indicated in Figure 18.39, however, three lay­
ers depend on it. The author has made local
improvements in the writing of the original.
This architecture description is at a very high
level.

UI
Workbench
JFace
Java Development Tools
SWT

Java Core

Core: Workspace

Core: R u ntime

Figure 18.38 Architecture of Eclipse-the Java development tools module
Source: Adapted from Gamma, Erich, and Back, Kent. "Contributing to Eclipse: Principles, Patterns, and Plug·lns," Addison-Wesley, 2003, p.282.

CASE STUDY: OPENOFFICE ARCHITECTURE

Application
!
e
e
e
n
n
.
U!
t
_
_d
_
_
_
_ p_ _
Framework
D
=�
===
===
===
�o'::: li,..:=======
.
�
Infrastructure
U5
:i----------------;
System Abstraction
:'VOL
;;Operation System I GUI
r
,

····················· ····

i

Q)

0...-«

Layers

L ......................

f

;

OpenOffice Architecture

I��l�[��§3[� �������o
� L ��� Jl ��� l��a��tk
� I UNO II UCB IISBLIISOl
�
U5
l ��� JJ���_�_�J��fl ����
§][�[§J_� ��{�;�fon
n

0:

___

_______

_________

_

(1j

_

____

Infrastructure

____

_

____

__

OS/GUI

__

Figure 18.39 The architecture of OpenOffice
Source: Edited from openOffice, http://www.openoffice.org/white_papers/tech_overview/tech_overview.html#3.

The System Abstractio n l ayer "encapsulates all
system specific APls and provides a consistent ob­
ject- oriented API to access system resources in a
platform i n dependent manner." It provides a kind of
singl e, virtual operating system on which to buil d
OpenOffice.
The In frastructure l ayer is a p latform -indepen­
dent envi ronment for building applications, compo­
nents and services.
The Framework layer: To allow reuse, this l ayer
provi des the environment for appl ications. It also
provi des a l l shared functionality such as common
dialogs, file access, and configuration management.
The Application layer: "All OpenOffice.org appli­
cations are part of this layer. The way these appl i ­
cations i n teract is based on the lower l ayers . "
T h e next sections describe these l ayers i n more
detail.

18, 1 1, 1 System Abstraction Layer
Thi s sectio n is reproduced from [Ill It references
Figure 18.39.
Platform - depended implementations take place
below the System Abstraction Layer (SAL) or are
part of optional modules. "In an ideal world an
implementation of the SAL-specific functionality
and recompiling the upper l ayer module will allow
you to run the applications. To provi de the whole set
of functionality, the optional platform specific mod­
ules, l ike telephony support or speech recognition,
have to be ported, too. " To reduce porti ng efforts,
the SAL functionality is reduced to a m i nimal set,
available on every platform . " . . for some systems
the l ayer includes some implementations to emulate
some functionality or behavior. For example on
systems where no native multithreadi ng is supported,
the layer can support so called 'user land' threads."

469

470

CHAPTER 18

SOFlW ARE ARCHITECTURE

This description is not very clear. In fact, it is
difficult to write meaningfully and clearly at a
high level. What follows next, however, is
indeed clear and meaningfu l .

A s shown in Figure 18.40, the S A L consists of the
Operating System layer ( OSl) the Runtime Library
(RTL) , the Standard Template Library ( STL) , and the
platform-independent part of the Visual Class Library
( VCl) . These are described next.

1 8.1 1 .1 .1 Operating System Layer 'The oper­
ating system layer (OSL) encapsulates all the
operating system specific functionality for using
and accessing system specific resources like files,
memory, sockets , pipes, etc. The OSL is a very
thin layer with an object-orien ted API. In contrast
to the upper layer this object- oriented API is a C­
API . " The reason for this is to allow easy portin g to
various platforms using differen t implementation
languages. "For embedded systems or I n ternet appli­
ances, for example, an assembler language can be
used to realize the implemen tation."
1 8.1 1 .1 .2 Runtime Library 'The ru n time library
provides all semi platform independent functionality.
There is an implementation for string classes pro­
vided. Routines for conversion of strings to differen t
character sets are implemented. T h e memory man­
agement functionality resides in this modul e . "

T h e last sentence i s useful and appropriate a t
this level. T h e meaning of "semi platform
independent" is unclear. The second sentence
is not clear but is presumably explained in the
more detailed sections.

1 8.1 1 .1 .3 Standard Template Library "As a ge­
neric container library the standard template library
is used. It supplies implementations for list, queues,
stacks, maps, etc . "
The relationship with the Standard Template
Library that comes with C+ + should be clarified.

1 8.1 1 .1 .4 Visual Class Library 'The VCl encap­
sul ates all access to the differe n t underlying CU I
systems. The implementation is separated into two
major parts . One is platform -independent and in­
cludes an object-orien ted 2D graphics API with
metaflles, fonts, raster operations and the widget
set use by the OpenOffice . org suite. This approach
virtually guaran tees that all widgets have the same
behavior independently o f the CUI syste m used . As a
result, the look-a nd-feel and the functionality of the
widgets on all platforms are the same . "
This explains the squiggly lines in Figure 18.39
that separate the two parts of the VCL.

Infrastructure Layer
System Abstraction Layer
Visual

Operating

Runtime

Standard

System

Library

Template

Class

Library

Library

(STl)

(VCl)

layer
(OSl)

(RTl)

Operation System / GUI
Figure 18.40 OpenOffice architecture-system abstraction layer
Source: Edited from OpenOffice. http://www.openoffice.org/white_papers/tech_overview/tech_overview.html#3.

CASE STUDY: OPEN OFFICE ARCHITECTURE

The platform - dependent part implements a
2D-graphic drawing canvas that is used by the
platform - independent parts. Th is canvas redirects
functionality directly to the underlying CUI system.
Currently, there exist implementations for the
WinD, X-Wi ndows , OS/2, and Mac. The access
to the pri nting functional ity, cli pboard and drag­
an d·drop is also reali zed inside the VCL. "

18. 1 1.2 Infrastructure Layer
The Infrastructure layer cons ists of the parts shown
i n Figure 18.41. These are each explained next.

libraries. Th is includes a common i mplementation
for handl i n g date and time related data, an i m ple­
mentation of structured storages, a generic registry,
typesafe management, a n d pers i stence of property
data ."

1 8.1 1 .2.3 Universal Network Objects Universal
Network Objects is the component technology used
within OpenOffice.org. "It ... is heavily based on mult i ­
threading and network communication capabil ities."

This paragraph says something important
about the architecture of OpenOffice.

The figure implies that Compound Objects (for
example) depends on the SAL and that the

Infrastructure layer depends on it. It implies no
dependence between Compound Objects, UCB.
and SBL.

1 8.1 1 .2.1 Virtual Operating System Layer The
purpose of this layer is "to make the usage of system
resources like files, threads, sockets, etc. more conve­
nient the virtual operating system layer encapsulates all
the functionality of the operating system layer into C+ +
classes. The C+ + classes here offer an easy to use access
to all system resources in an object-oriented way."
1 8.1 1 .2.2 Tools Libraries ''The tool functional­
ity of OpenO ffice consists of vari ous small tool

"The system consists of several p ieces . An IDL­
Compiler, whi ch generates out of the speci fied defi­
nition of an i nterface a binary representation and
the associ ated C-Header or Java technology files.
The binary representatio n is platform and language
independent and is at runtime used to marshal argu­
ment for remote functi on calls or to generate code on
the Ay for a spec i fi c language to access the imple­
mentation provided by the interface. Thi s techni que
reduced the amount of generated code for the dif­
ferent language bi nding tremendously. The draw­
back is that not only for every language binding a
spec i fic backend for the code generation is needed, it
is that for every specific compiler a bri dgi ng module
is needed at runti me. "

Framework Layer
Infrastructure Layer
Virtual

Tools

Universal

Compound

Scripting

Operating

Libraries

Content

Objects

and Basic

System
Layer

(TOOLS)

Broke r

Library

(UCB)

(SBL)

(VOS)

System Abstraction Layer

Figure 18.41 OpenOffice architecture-infrastructure layer
Source: Edited from OpenOffice, htlp:llwww.openoffice.org/white_papers/tech_overview/tech_overview.html#3.

47 1

472

CHAPTER 18

SOFTWARE ARCHITECTURE

This paragraph is not easy to understand but it
is at a high level and becomes clearer as one
reads more details. It mixes a description of the
architecture with a rationale for it. Require­
ments documents frequently i nclude pieces of
rationale.

"Many parts of the UNO technology are imple­
mented as UNO components . This faci litates flexi­
bility and runtime exte nsions: e . g . , provi ding new
bri dges or communication protocols. UNO provi des
transparent access to components locally or over the
network. 1I0P can be used for network communica­
tion. I f components are realized as shared l ibraries,
they can be loaded by UNO in to process memory o f
the application accessed b y function calls. This does
not require marshalling of arguments as required for
remote function calls."

This paragraph seems to be heralding an am­
bitious design , consisting of objects available
on the network.

18.11.2.4 Universal Content Broker 'The Uni­
versal Content Broker allows all upper layers to
access di fferent kinds of structure content transpar­
ently. The UCB consists of a core and several
Universal Content Providers, which are used to
integrate di fferent access protocols. The current
implementations provides content providers for
the HTTP protoco l , FIP protocol , WebDAV pro ­
toco l , and access t o the local fi l e system.
The UCB does not o n l y provi de access to
the content, it also provides the associated meta
i n formation to the content. Actually there is syn­
chronous and asynchronous m o de for operations
supported."
1 8.1 1 .2.5 OpenOffice.org Compound Objects
'The Compound Object implementation provide
the functional ity to build compound documents,
where for example a spreadsheet is being embedded in
a word-processor document." "The implementation

provides a platform -independent implementation of
this functionality for compound documents and
for embeddi ng visual controls such as multimedia
players and various viewers. Storage is compatible
with the OLE structure storage format. This allows
access to OLE compound documents on every plat­
form where Open Office . org is avai lable. On Win­
dows the implementation i nteracts with O LE services
and so allows a tight i ntegration of OLE-capable
applications."

18.11.2.6 OpenOffice.org Scripting and Basic
Library

"Scripti ng" refers to the ability to write proce­
dures that cause the appl ication to execute
appl ication functions in a desired sequence.
For example, .hat files in Windows and .sh files
in Unix are scri pti ng files. Design documents
inevitably rely on jargon that the reader must
be famil iar with.

'The scripting functional ity that comes with
the OpenOffice .org suite is a BAS IC dialect featuri ng
an interpreter that parses the source statements and
generates meta instructions. These instructions can
be executed directly by the supplied meta-instruc­
tions processor or can be made persistent in modules
or l ibraries for later access . All functional ity supplied
by the upper level appl ication compo nents is acces­
sible via a scri pting interface in the component
technology. This will help to ensure that new com­
ponents using the OpenOffice .org component tech­
nology can be fully scriptable without spendi ng a
huge amount of effort.
The scri pti ng i nterfaces are also implemented
as components that will allow an easy integration of
other scripting languages ." They provide functional­
ity, such as core reflection and i n trospectio n , similar
to Java platform functionali ty.

18. 1 1.3 Framework Layer
The Framework Layer has the parts shown in Figure
18.42.
These parts are described next.

SUM MARY

-

a...
<t:

Q)
()

::E

0
(ij
U5

Application Layer

Framework Layer
Appl ication
Framework Library

SVX Library

Infrastructure Layer

Figure 18.42 OpenOffice architecture-framework layer
Sourw: OpenOffice. http://www.openoffice.org/white_papers/tech_overview/tech_overview.html#3.

1 8.1 1 .3.1 The Application Framework Library
See Figure t 8.42.
"Functionality shared by all application and not
provided by any other layer is realized here. For the
framework, every visual application has to provide a
shell and can provide several views. The library
provides all basic functionality so only the applica­
tion specific features have to be added."
'The Framework is also responsible for content
detection and aggregation ." The AFL provides tem ­
plate management and configuration management. [ t
"is i n some areas related t o the compound docu ­
men ts, because of the func tionality for merging or
switching menus and toolbars. [t also provides the
capability for customization of applications."

18. 1 1.4 Application Layer
This l ayer consists of the actual applications such as
the word processor, spreadsheet, presen tation, chart­
ing, and so on. All these are realized as shared
libraries, loaded by the application framework at
runtime. The framework provides the environment
for these applications and provides the functionality
for interaction among them .

1 8. 1 1 .3.2 SVX Library 'The SVX library provides
shared functionality for all applications which is not
related to a framework. So part of the library is a
complete object-oriented drawing layer that is used
by several applications for graphic editing and output;
also a complete 3D-rendering systems is part of the
drawing functionality. The common dialogs for font
selection , color chooser, etc . , are all part of this library.
Also the whole database connectivity is realized here."

time j ust as it takes time to l earn any com ­

Software architecture descriptions inform
the reader , but in a general manner. They
are necessarily imprecise about the meaning
of the parts. Architectures of nontrival soft ­
ware appl ications have to be l earned over
plex subj ect. This process is hel ped by del v ­
i n g into sel ected details a s needed , perhaps
even to the code level , and then re- reading
needed architecture and detailed design de­
scriptions. In this book , we omit the detailed
design of OpenOffice.

1 8 . 1 2 SU M M ARY
A software architecture describes the components of a software system and the way in which they interact
with each other. There are many different ways a system can be architected. Carlan and Shaw have classified
software architectures into categories such as dataAow, independent components, virtual machines, reposi ­
tory, and layered. Service-oriented architecture is another type of architecture in which various components
are combined to provide a service.
Software designs are documented in a software design documen t (SOD). The [EEE publishes IEEE Std
1 0 16- 1 998 for such a purpose. The SOD for the Encoun ter case study uses this as a document template.

473

474

CHAPTER 18

SOFTWARE ARCHITECTURE

For large software projects, it is important to modularize the software design. Modul arization facilitates
different groups of develo pers working on the different parts simultaneously. To make this work as efficiently
as possible, the Facade design pattern can be used to provide a clean interface for each module. The Facade
pattern is typically appropriate when developers are collocated. In distributed environments, Web services
can often be used.
O nce an architecture is selected, the project schedule is updated to reflect the order in wh ich the parts
are to be developed.

1 8. 1 3 EXE RCISES
1. In a paragraph, explain the purpose of a software architecture and how it relates to design .
2. Suppose that you are designing a batch simulation of customers in a bank. Being a batch simulation,
the characteristics of the simulation are first set, then the simulation is executed without
intervention. How could you describe this as a data flow application ? U se a sim ple skeleton
consisting of four parts to the diagram. (Identify your four parts, and then look at how you could
describe this application as a state - transition diagram . ) Which perspective offers more value in
describing the arch itecture?
3. When designi n g a client-server architecture, there are generally two alternatives: thin and thick
clients. A thin client implies that client functionali ty is kept to a minimum; most of the process ing
is performed via the server. A thick client implies that much of the functionality is contained in the
client; the functionality on the server is kept to a minimum. Discuss the one or two major
advan tages and disadvantages to each of these approaches.
4. Operating systems are frequently designed using a layered architecture. Research the linux
operating system on the Internet, and explain how it utilizes a layered architecture . What are the
benefits of such an architecture?
5. Consider a word processing application with which you are fam i l iar. Sketch the software
architecture of that program using one of the archi tectures described in this chapter. Describe
the purpose of each of the components of your architecture .

6. Select an alternative software architecture for the word process ing application of Exercise 5 .
Compare both architectures you selected and describe their relative merits .
7. Some design patterns are particularly relevant at the archi tectural level . Name two of these and
explain their relevance.
8. Wh ich software architecture is the best candidate for each of the following applications?
a. An application for reordering auto parts from hundreds of stores
b. A real-time application that shows the health of an automobile
c. An application that provi des advice to stock customers. It uses a multi- platform design
consisting of several Web sites . One site continually collects and stores prices and other
information about stocks; a second site continually collects stock advice from analysts; a third
recommends portfolio suggestions to users .
d. A scientific instrument company bui l ds equipment for analyzi ng molecular structures. The
application you are to design analyzes the structure of DNA molecules , which are very large.

BIBLIOGRAPHY

TEAM EXE RCISE
Arch itecture

Develop the architecture for your project. Describe your architecture using the IEEE standard, as in the
case study accompanying this chapter. Make it clear what type of architecture and design patterns
are being applied. Show at least one other architecture that you considered, and explain why you chose
the alternative described. Include the use of metrics. It is not required that you automatically choose the
architectures via metrics alone.
Track the time you spend doing this exercise in increments of five m inutes, and include a time sheet
showing the time spent by individuals and by the team. Use or improved upon the form in Table t 8.2
that records the time spent per person on each module. Give your opinion on whether your tracking of
time paid off, and whether your time could have been better managed.
Table 1 8 .2 Form showing time spent per module
Module

Team member

Smith

1

2

10

4
5

Jones
Brown

3

4

12

2

14

BIBLIOG RAPHY
1 . Shaw, M . G . , a n d D . Garl a n , "SoftlVare Architecture, Perspectives o n a n Emerging Discipline, " Prentice H a l l , 1 996.
2 . Dijkstra, E . , A Discipline of Programming , Prentice H a l l , 1 976.
3. Lea , D., Concurrent Programming in Java, Design Principles and Patterns (Java Series), Addison -Wesley, 1 996.
4.

Kaluzn iacky, E . K., and V . Kanabar. Xbase Programming for the True Beginner, An Introduction to the Xbase Language in the Context of dBase Iii+.

Iv. 5. Foxpro, and Clipper, McGraw H i l l Professional, 1 996.
5 . Jagannathan, V . , Rajen dra Dodhiawala, a n d Lawre nce S . Baum, editors . Blackboard Architectures and Applica tions . Academic Press, 1 9 8 9 .

6 . Engei more, Robert, a n d Anthony Morgan (Editors ) , Blackboard Syslrms (The Insig h t Series i n Artificial /nteUigence), Addison- Wesley, 1 9 8 8 .
7. ErI, Thomas, "Service-Oriented Architecture, Concepts. Technology. a n d Design, " Prentice H a l l , 2006.
8.

Gamma, Eri c h , Richard Helm, Ral p h Johnson, and John Vl issides. Design Pa tterns, Elements of Reusable Ohject-Oriented SoftlVare, Addison­
Wesley, 1 99 9 .

9 . Gamma, Erich , a n d B e c k , Ke nt. "Contributing t o Eclipse, Principles. Patterns. and Plug-Tns. " Addison -Wesley, 200 3 .
1 0 . OpcnOffice Project, http .!lwww .openoffke .org/whi te_papers/teeh_overview/tech_overview . h tm l # 3 [ accessed November 29, 2009 ] '

47 5

Deta i led Design

�

Testing

Maintenance

The Software
Development
L ifecycle

\

Planning

Requianalrements
ysis

Implementation
� DeSign /

How do use cases and architectu res
relate to detailed designs?
What are useful object-oriented
design principles?
Why design against i nterfaces?
What is detailed design for agile
processes?
How do you specify classes ,
functions, and algorithms, particularly
in U ML?
H ow do you plan for component
reuse?
How does one use standards for
expressing detai led design?
H ow is detai led design performed for
large, real-world projects?

Figure 1 9 . 1 The context and learning goals for this chapter

Detai led design is the tech nical activity that fol lows archi tectural selecti on and covers all rem aining
aspects of technical creation short of actual code . It addresses major goals of software design (from
Chapter 1 7) : sufficiency, understandabi l i ty, modularity, coheSion, coupling, robustness, flexibil i ty, reus­
abi l i ty, i n formation hiding, efficiency, and reliability. This chapter starts by relating the detailed design

RELATING USE CASES, ARCHITECTURE, AND DETAILED DESIGN

process to the arti facts that have al ready been developed by the time we get to this point, especially the use
cases of the requirements analysis process and the high - l evel design-the architecture (Section 1 9 . 1 ) .
With regard to sufficiency, detailed design provides enough particulars for developers to implement the
req uirements of the application. As for understandability and modularity, object-oriented designs specify classes,
their attributes, and their methods . Principles of detailed object-oriented designs are introduced in Section 1 9.3.
This form of the application allows us to inspect designs for strong cohesion among grouped components and
weak coupling with others. Flexibility, the reuse of components, and information hiding are discussed in Sections
1 9 .4 and 19.6. Detailed design entails the development of sequence diagrams from use cases (Section 1 9.7), which
are principal sources for the specification of classes and methods. The chapter ends with case studies.
The agile method, discussed in Chapter 4, begi ns coding without a ful l detailed design, and perhaps
without any detailed design at a l l . This means that the detailed design essentially forms i n the m i nds o f the
programmers and is generally documented within the code. Nevertheless, detailed design continues to exist
for agile developers. We discuss this further i n Section 19 .8.

1 9. 1 RELATIN G USE CASES, ARCHITECTU RE, AND DETAILED DESIG N
The relationship between use cases, architecture, and detailed design can be understood by analogy with the
process of designing a bridge . Use cases would be part of the requirements for the bri dge (see the use case
example in Figure 1 9.2) . Based on the requirements, engi neers would then select an architecture by stepping
back, as it were , and l ooking at the big picture . Usually, more than one architecture suffices . I n thi s case, a
sus pension architecture was selected. This process is illustrated by Figure 1 9 . 2 .
Once the archi tecture has been selected, engineers may develop the detailed design t o enable the
required use cases with the architecture selected. This is suggested by Figure 1 9.3.
In the software analogy to the bri dge example, each corresponding stage accumulates additional classes ,
which are shown in Figures t 9.2 and 1 9 .3. In Step t , use cases are specified as part of the requirements. In Step
2, these, together with other sources, are used to identi fy the domain classes . In Step 3, we develop the
software architecture, as described i n Chapter 18. In Step 4 we develop the detailed design by defining design
classes . We start with the domain classes (e.g. , Auto, Road) and add additional design classes (e.g. , Guardrail,
Cable) to complete the des ign . We then veri fy that the architecture and detailed design support the required
use cases . For the bridge analogy, we verify that cars can indeed use the bri dge design to travel from Green's

1 . Use case (!;1art

of regu i rements)
"Cars should be

2 . Domain

able to travel from

classes

the top of G reen's -+
H i l l at 65 m p h , in
a straight line,
and arrive at

I Auto I
I R oad I

......

......

......

......

......

3 . Arch itectu re

Jones Hol low
with i n 3 m i n utes ."

Figure 1 9 . 2 The relationship among use cases, architecture, and detailed design-an analogy from bridge building, 1 of 2

477

478

CHAPTER 1 9

DETAILED DESIG N

1 . Use case (part

3. Architecture

2 . Domain

(not specifically required )

of requirements)
"Cars should be
able to travel from
the top of Green's
Hill at 65 mph , in

i

I I
I I ca�' �

(added for
:- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - .,
deta iled design) Support use case
..
Au to

a straig ht line,
and arrive at
Jones Hollow

.�
�

4. Detallgg

within 3 minutes. "

Desiqn

Guardrail

!

�

Green's
Hill

Figure 1 9 . 3 The relationshi p among use cases, architecture, and detailed design-an analogy from bridge building, 2 of 2

H i l l to Jones Hollow as specified. For software design, we veri fy that the classes and methods specified by the
detailed design are capable of executi ng the required use cases.

1 9.2 A TYPICAL ROAD M A P FOR THE "DETAILED DES I G N " PROCESS
Detailed design starts with the results of the architecture phase and ends with a complete bluepri nt for the
programming phase . Figure t 9 . 4 shows a typical sequence of steps take n to perform detailed design . There is
really no un iversal standard way to go about th is process-and, in fact, we frequently cycle back to designing
when confronted with the real ity of turn ing a design into real i ty . The agile process i n particular, discussed
below in Section t 9 . 8 and in Chapter 4 , is an extreme exam ple of this.
1 . Begin with architectural models
•

class model: domain & architectural classes

•

overall state model"

•

overall data flow model"

•

use case model

2. Introduce classes & design patterns" that connect the
architecture classes with the domain classes
•

concentrate on riskiest parts first; try alternatives

"T�;:;;;:;�;;;���"l:::===;;;�===='...-J
Refine models, make consistent, ensure complete

For each class L.
..

5. Specify methods with pre- and post6. Sketch unit test plans
7. Inspect test plans and design

•

it applicable

l

a .Release for implementation

Figure 1 9 .4 A typical road map for creating detailed designs

OBJECT-ORIENTED DESIGN PRINCIPLES

Step 2 of Figure 19.4 creates the classes that associ ate the architecture on one hand with the domain classes on
the other hand, as illustrated i n the previ ous section. Design patterns may help in doi ng this for software designs.
We often begi n the detailed design process with those aspects of the design that must be implemented, come what
may, or that present the most risk. For example, in designing Encounter we might consider risky the way in which
the classes were modularized (all characters in one package, etc . ) . This should be settled as soon as possible by
specifying the details of the interface methods so that we can get an intimate idea of how this modularization works
out. If the use of the State design pattern were perceived as a risk, we would specify its details first.
Step 3 of Figure 19 .4 i ncludes checki ng that we have a complete design . It also includes ensuri ng that
the object model supports the use cases. Step 6 conti nues the practice of speci fyi ng a test as soon as each
element is specified.
[n test- driven development, often associated with agile development, Steps 6 and 7 are performed prior
to some (perhaps all) of Steps 1-5 , and their implementations are included i n the process. [ n other words,
tests are developed truly as early as possible, and then designs and code created to satisfy them. Regardless of
the methodology used, early speci ficatio n of tests is usually an excellent i dea.

1 9 _3 OBJ ECT-ORIENTED DESIG N PRINCIPLES
Martin [ 1, 2J identified five pri nciples for class design of object-oriented software that also go hand- i n - hand
with agi le development. These are summarized i n Figure 1 9.5.
These pri nciples are similar to, or follow from several that we have already discussed.
The Single Responsibility Principle emphasizes the need for classes to h ave one clearly understood
responsibil i ty such as "represent customer data" or "represent order for cam p i ng items," rather than very

•

Single-Responsibility Pri nciple

"A class should h ave only one reason to change."
== cohesion
'
O p e n - Closed Principle
"An arti fact should be open for extension but closed for modi fication in ways that affect i ts clients."
-especially modules, classes, and functions.
-a module can be extended without changing its code .
2
Liskov Substitution Pri nciple
"Subclasses shoul d be substitutable for their base cl asses . "
3
Dependency- Inversion Principle
"Depend on abstractions. Do not depend on concretions."
Both should depend on abstractions.
Abstractions should not depend on details.
Details should depend on abstractions."
4
In terface S egregation Principle
"Many client specific interfaces are better than one general purpose interface . "
•

•

•

•

•

•

•

•

•

•

•

•

•

Figure 19. 5 Some object-oriented design principles
I

Bertrand Meyer, "Object - O ri ented Software Construction," Second Edi tion, Prentice Hal l , 2007.

2

Barbara Liskov and J o hn Guttag, "Abstraction and Speci fication i n Program Deve l o pment," M IT- Press,

3

Robert Martin, "Agi le So ftware Development: Principles, Patterns, and Practices," Pre ntice Hal l , 200 3 .

4

Ibid.

1 986.

479

480

CHAPTER 19

DETAILED DESIG N

broad topics such as "all there is to know about customers and their habits" or "camping preferences ." I n other
words, classes should exhibit a h igh l evel of cohesion. When classes have only one responsib i l i ty, they are
easier to maintain and reuse.
The Open- Closed Principle (OCP) states that modules should be open for extension but closed for
modi fication. That is, if an existing module needs to support additional requirements, then the existing,
working code would remain intact. It would not need modification. I n other words, new functional ity should
be implemented with new code . Consider the exam ple shown i n Listi ng 19 .1, as described in [ 1] . The code
satisfies the requirement to draw a set of shapes consisting of circles and squares. However, this code violates
the OCP because shapes other than circles and squares cannot be drawn without modi fying-not simply
adding to-the body of the function.

Li sting 1 9 . 1 :

drawAIIShapes()-adding functionality causes erasures

{

v o i d d r awA l l S h ap e s ( V e c t o r < S h ap e > s o m e S h ap e s )
f o r ( i = O ; i < s o m e S h ap e s . l e n g t h ( ) ; + + i )
i f ( s o m e S h ap e s . g e t ( i ) . t yp e ( )

==

{
" c ir c le "

d r aw C i r c l e ( s o m e S h ap e s . g e t ( i ) ) ;
e l s e i f ( ( s o m e S h ap e s . g e t ( i ) . t yp e ( )

==

" s qu a r e "

d r aw S qu a r e ( s o m e S h ap e s . g e t ( i ) ) ;

}
}

A common way to avoi d modification and conform to the OCP is by uti l i z i n g i n heritance and
polymorphism . Li sting 19 . 2 shows how this is accomplished i n a new version o f drawAllShapes O . I n this new
version, shapes such as Circles and Squares inherit from the base class Shape. As a Shape is extracted from the
vector, its polymorphic drawO method is called to draw that shape . This means that each type of shape is
responsible for knowi ng how to draw i tself. I f new shapes need to be supported, drawAllShapes O does not need
to be modi fied-it automatically calls the drawO method of that new shape when it is removed from
the vector.

Listing 1 9. 2 :

drawAIIShapes() - improved version now open for addition

v o i d d r awA l l S h ap e s ( V e c t o r < S h ap e > s o m e S h ap e s )
for ( i

=

{

O ; i < s o m e S h ap e s . l e n g t h ( ) ; + + i )

s o m e S h ap e s . g e t ( i ) . d r aw ( ) ;

}

The Liskov Substitution Principle states that any code referencing an instance of a base class must also work
correctly if, i nstead, it is passed an i nstance of a derived class . In other words, a derived class must honor the
semantics of a base class. If this principle were to be violated, then every time a new derived class is created,
code would have to be modified to reference the new class, violati ng the OCP.

DESIGNING AGAINST INTERFACES

B
� _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _:
�
...
J.

Read

Write

Keyboard

Pri nter

Figure 1 9.6 Dependency inversion

Copy

R eader

Writ er

Read

Write

Keyboard

Printer

Figure 1 9.7 Avoiding dependency inversion using abstraction

The Dependency Inversion Principle (DIP) is concerned with h i ding details. It asks us to design h i gh - l evel
modules in such a way that they do not depend on low-level modules. Instead, each should depend on
abstractions. This makes the modules understandable and usable in themselves. Consider the example
described by Martin [ 3 ] .
The Copy module is dependen t on the lower level modules-Read Keyboard and Write Pri nter, making
i t difficult to reuse as a general purpose copy module. By applyi ng the D I P , we abstract the read and write
modules, as shown in Figure 1 9 .7. Now, Copy depends only on the abstract Reader and Writer, making i t
more flexible and portable. I f n e w types of Readers a n d Writers are created, Copy is unaffected.
The Interface Segregation Principle tells us to collect related methods into separate i nterfaces rather than
mixing unrelated methods (even when needed as a whole group). It draws from lessons o f component design
(e.g., Microsoft's COM) where we learned to package sets of methods i n relatively small, manageable sets. By
keepi n g interfaces smal l , we i ncrease their cohesion .

1 9.4 DESIGNING AGAINST I NTERFACES
The i dea of design i n g agai nst i n terfaces is l ike employing a contract . The program element supplying func ­
tionality ( e . g. , t h e Customer class) guarantees t o provide i n terface functions with speci fied names, parameter
types, and return types (e.g. , void bill(void) and boolean printAccounts(String accountType) ) . The program elements
using the functional ity can then be designed with out havi ng to know how the functionality is i mplemented­
all they need to know is how to use the interface. We h ave discussed thi s concept in the context of design

481

482

CHAPTER 19

DETAILED DESIGN

Client code
BillingClient
l istCustomersO
biliCustomersO

Customer
Customet')

-- written in terms of
(not

specific types of

Used code
bill()
printA ccounts()
Customer

- - + - - - ---.

f;,

Abstract la yer

RegularCustomer
pri ntA ccountsO
biliO

Concrete (non-abstract) layer
Figure 19.8 Designing against interfaces-an example of designing against Customer rather than RegularCustomer

patterns where patterns have clients. Also, the Facade design pattern is a way of provi ding a clean interface to
a package of classes .
Designing against i n terfaces takes many forms. One is the use of abstractio n . For exam ple, if code is to
be written about Mammal objects, then we try to write it so as to mention only Animal obj ects . In other words,
we try to use only the Animal i n terface . This allows greater applicab i l i ty and greater flexibility for our design.
As a further example, suppose that we are wri ting code about customers. This can be understood as
writing against the Customer interface. We can actually consider using an abstract class Customer, which may
have non abstract subclasses such as RegularCustomer, as shown in Figure 19 .8. This design is more flexible than
writing against a concrete (nonabstract) class RegularCustomer because we can easily add other types of
customers , such as SavingsCustomer objects , with specialized versions of bilI(), without havi ng to change the
code that uses Customer objects. The division i nto an abstract and a concrete layer is characteristic of many
design patterns.
For Java i n particular, one tries to use Java-specific "Interfaces" for the interface role described above .
These spec i fy method signatures ( name, return type, and parameters types) only. Unl ike Java i nheritance,
classes can implement any number of i nterfaces. The UML notation for an interface is a dotted- line rectangle,
and a dotted l i n e triangle is used i nstead of a sol i d one.

1 9 . 5 SPECIFYING CLASSES, FUNCTIONS, AND ALGO RITHMS
The goal of complete detailed design is to provide a complete bluepri nt from which a program can be
constructed. A good house bluepri nt leaves the builder with as few doubts as possible about the intentions of
the designer, and the same is true for detailed software design. Figure 19 .9 describes typical steps i n carrying
out detailed design for each class, and the succeeding text explains the steps i n deta i l .
A fully detailed class diagram i ncludes a l l attribute a n d operation names, signatures, visibility , return
types, and so o n . Accessor methods are commonly omitted . It is customary to omit accessor functions ( e . g. ,
getSize() and setSize() , si nce these can b e i n ferred from the presence o f the corresponding attributes (e.g. , size ) .
UML tools have the benefit of allowing designers t o suppress ( i.e . , t o not show) certai n elements of the
figure-for example, the "responsib i l i ties" section or the vari able types. Many tools allow designers to view
only the classes and their relationships, in order to get the big p icture .

SPECIFYING CLASSES, FUNCTIONS, AND ALGORITHMS

1.

Cather the attributes listed in the SRS .
i f the SRS is organized b y class
2 Add addi tional attributes required for the design.
3. Name a method corresponding to each of the requirements for this class .
easy i f the SRS is organized by class
4. Name additional methods required for the design.
5. Show the attributes and methods on the object mode l .
6 . State class invariants .
•

•

Figure 1 9.9 Fully specifying a class

One language-independent manner in which to spec i fy classes is through the CORBA Interface
Definition Language (IDL) . This is a standard, textual format for spec i fying the i nterfaces provided by
collecti ons of classes, their attributes, and their functions . For the specification of I DL, see [4] .
In some organizations, detailed designs are specified by providing code without function bodies rather
than UML This is someti mes true of agile developers . The advantage of this procedure is that there is no need to
translate detailed specifications into code . A disadvantage is that a code form is somewhat less readable than
ordinary prose . The functions in the code form are then filled out at implementation time by programmers .
1 9,,5. 1 preconditions, postconditions, and Invariants

An e ffective way to spec i fy functions is by means of preconditions and postconditions . Preconditions spec i fy the
relati onships among variables and constants that are assumed to exist prior to the function's execution;
postconditions spec i fy the required relationships after the function's execution. For exam ple, the function
withdraw(int withdrawalAmountP) of an Account class could be specified as shown in Figure 19. 10. Another
Invariant of withdraw () :
balancel >= -OVERDRAFT-MAX AND
availableFundsl = balancel + OVERDRAFT_MAX

Precondition* :

Conventions used:
xl denotes an

withdrawalAmountP >= 0

AND

balancel- withdrawalAmountP
>=

OVERDRAFT_MAX

Postcondition* :

attribute;
xP denotes a
function parameter;
x' is the value of x
after execution;
X denotes a class
constant

balance!' = balancel- withdrawalAmountP

*The function invariant is an additional pre- and postcondition
Figure 1 9. 1 0 Example of specifying functions precisely-specifying withdraw() in Account

483

484

CHAPTER 19

DETAILED DESIGN

exam ple of a precondition is an age parameter that a method assumes is greater than zero. The effects of a
method are i ts postconditions. They are the very reason for the method, and must be specified as wel l . In the
experience of the authors, software engineers require significant training in the capacity to specify
preconditions and postconditions with precision, as in Figure 19.10.
Invariants of a method are assertions that are both preconditions and postconditions. They are a way to
maintain intellectual control over the behavior of functions. They spec i fy relationships that do not change,
which is welcome in the environment of an applicati o n , where complex change is so often difficult to manage .
An example from Encounter is the following possible invariant for the adjustQuality() method.
Invariant: the sum of the values of the qualities.
I n other words, when the value of one qual i ty is changed with adjustQuality(), the values o f the remaining
qualities change i n a way that leaves their sum unchanged.
19.5.2 Expressing Algorithms with Activity Diagrams and Pseudocode

It is helpful to spec i fy nontrivial algorithms at detailed design time. The advan tage of doing th is is that
engi neers can inspect the algorithms separate ly without the intrusion of programming complexities, thereby
trapp ing many i mportant defects before they magn i fy into code defects . The more critical the method, the
more i mportant this activity. Methods with complicated branc h i ng are candidates for activity diagrams
("advanced flowcharts") . Activity diagrams were described in Chapter 16.
Pseudocode is a means of expressi n g an algori thm textually without havi ng to specify programming
language detai ls. As an example, pseudocode for a hypothetical automated X-ray controller is shown i n
Figure 19.11. A n advantage of pseudocode is that i t is easy to understand but c a n also b e made precise enough
to express algorithms. Another advantage is that algorithms can be i nspected for correctness i n dependently
of the clutter of a programming language . A third advantage is that defect rates in pseudocode can be
collected and used as a predictor for defect rates i n the product, using h istorical defect data .
Some organizations use inspected pseudocode as annotated comments i n the source code listi ng. Tools
are then able to extract the pseudocode from the source . For example, using "lip" to preface pseudocode
statements, the code could implement the pseudocode cited above-see Figure 19.12 .
Activity diagrams and pseudocode each have the advantages listed in Figures 19. 13 and 19. 14 . The
decision whether to use them or not depends on factors particular to the applicati o n . Some developers shun
activity diagrams as old-fashioned, but activi ty diagrams and pseudocode can be worth the trouble for
selected parts of applications, where they help to produce better quality products .
FOR number of m icroseconds supplied by operator
IF number of microseconds exceeds critical value
Try to get supervisor's approval
IF no supervisor's approval
abort with "no supervisor approval
for unusual duration" message ENDIF ENDIF
IF power level exceeds critical value
abort with "power level exceeded" message ENDIF
IF (patient properly aligned & shield properly placed & machine self-test passed)
Apply X-ray at power level p ENDIF ... ENDFOR
Figure 1 9.1 1 Specifying algorithms with pseudocode----a critical X-ray example

REUSING COMPONENTS

/ /p FOR number of microseconds supplied by operator
for( int i = 0; i < numMicrosecs; ++1 ) {
/ /p IF number of microseconds exceeds critical value
if ( numMicrosecs >
XRayPolicies.CRITICAL_NUM_MICROSECS
/ /p Try to get supervisor's approval
int supervisorMicrosecsApproval=
getApprovalOfSuperForLongExposure();
/ /p IF no supervisor approval
if( supervisorMicrosecsApproval <= a )
throw ( new SupervisorMicrosecsApprovalException() );

Figure 19.12 pseudocode as extractable comments in source code

•
•
•

Clari fy algorithms in many cases
Im pose i ncreased discipl i ne on the process of documenting detailed design
Provide addi tional l evel at which i nspection can be performed
Help to trap defects before they become code
I ncrease product rel iability
May decrease overall costs
•
•

•

Figure 19.13 Some advantages of pseudocode and activity diagrams

•
•
•

Creates an additional l evel of documentation to maintain
Introduces error possibilities i n translating to code
May require tool to extract pseudocode and faci litate drawing activity diagrams

Figure 19.14 Some disadvantages of pseudocode and activity diagrams

19.6 REUSING COMPONENTS

Most engineering disciplines (electrical, mechanical, etc . ) rely on the use of components that can be procured
separately. Bridge designers, for example, try to use standard I - beams. The widespread adoption of obj ect­
oriented, obj ect-l ike, and other component paradigms has helped to promote software reuse . Because of the
large number of methods packaged with each class, functionali ty that we need is often i ncluded and is
relatively convenient to locate. The use of Microsoft l ibraries, Visual Basic controls, Microsoft Assembl ies,
Java Beans, and Java Application Programming I n terface classes are examples of code reuse .
Frameworks, discussed i n the previous chapter on architecture, are packages of components designed
for reuse. We develop frameworks to support application architectures, and so they are e ffectively reusable.
The Java core API is another example o f a widely used framework. Java Beans provi de reusable components
for Java applications . They include graphics beans and "enterprise" beans, which encapsulate corporate tasks

485

486

CHAPTER 19

DETAILED DESIGN

such as database access. In addition to the advantages afforded by being classes, beans obey standards that
make them capable of mani pulation within development environments . Web-based programs (i .e., not
components) such as JavaScript and cel scri pts are often reused .
A t a different leve l , the Standard Template li brary (STL) provides mix - and-match capabi l i ty of
standard algorith ms such as sorting and searching. STL is appl icable to a variety of data structures and
to objects of vi rtually any class. In summary, a component marketplace has emerged and is growing
continually.
The Encounter video game case study presented at the end of this chapter contains examples of reuse
within an enterprise: in this case, a game development business. To be cost-effective-and thus competitive­
the company leverages i ts software as much as possible among projects . For example, rather than invest the
resources to develop a class for the character in Encounter alone, it tries to separate the development into a game
character class, and use a subclass for Encounter's character. The game character class can be reused for other
games. This i dea i s extended in the case study to a game framework consisting of several related classes, which is
the common context for reuse.
H aving found an existing component that could possibly be used in an appl ication, should it be used? The
following factors are typical i n making this decision, and they suggest factors that should be accounted for in
creating one's own components slated for reuse .
•

Is the component documented as thoroughly as the rest of the application? If not, can it be?

•

How much customization of the component and/or the application is required?

•

Has the component been tested to the same level as, or more extensively than, the rest of the appl ication? If
not, can it be?

To decide on reuse of components with significant size, a table comparing the costs can be developed,
similar to the one in Chapter 8 where a make vs . buy example was shown.

19.7 SEQUENCE AND DATA FLOW DIAGRAMS FOR DETAILED DESIGN

Some detailed designs are best communicated via detailed sequence diagrams or detailed data flow
di agrams. Figures 19.15 and 19. 16 provi de gui dance on what needs to be done with sequence di agrams and
data flow diagrams to complete the corresponding detailed des i gn. The text that fol l ows provides de ta i ls
and examples .

t. Begin with the sequence diagrams constructed for detailed requirements and/or architecture (if any)

corresponding to the use cases.
2 . Introduce additional use cases, if necessary, to describe how parts of the design typically interact with
the rest of the app l ication.
3. Provide sequence diagrams with complete details.
be sure that the exact objects and their classes are specified
select specific function names i n place of natural language
(cal l s of one object to another to perform an operation)
•
•

Figure 1 9.1 5 Refining models for detailed designs, 1 of 2-sequence diagrams

SEQUENCE AND DATA FLOW DIAGRAMS FOR DETAILED DESIGN

1. Gather data flow diagrams (DFDs) constructed for detailed requirements and/or architecture (if any).
2. Introduce additional DFDs, i f necessary, to expl ain data and processing flows .
3 . Indicate what partes) of the other models the DFDs correspond to.
for example, "the fol lowing DFD is for each Account object"
4. Provide all details on the DFDs.
indicate clearly the nature of the processing at each node
indicate clearly the kind of data transmitted
expand processing nodes into DFDs if the processing description requires more detail
•

•
•
•

Figure 19.16 Refining models for detailed designs, 2 o f 2-data flow diagrams

19.7.1 Detailed Sequence Diagrams

Recall that use cases can be utilized to express requirements, and that we also use them to determine the key
domain classes for the appl ication. For the detailed design phase, we provide classes with the methods
referenced in the sequence diagrams.
As an example, the sequence diagram for the "Encounter Foreign Character" is shown in Figure 19. 18,
showing the messages between obj ects in the software design. The reasoning behind the functions chosen is
as follows :
1. ForeignCharacter is to have a display function. We will implement this with a method display(). (Since all
characters will need to be displayed, we can actually ensure this requirement by giving the base class
GameCharacter a display() method. ) The sequence diagram shows EncounterGame creati ng the foreign character
(Step 1. 2) and also an Engagement obj ect, and then calling display() . An engagement is to take place , and a
good design is to capture this by creating an Engagement obj ect. Th is is i l lustrated in Figure 19.17.
2. Th is step in the use case indicates that we need an execute() method in Engagement.
2.1 This step requires that Freddie and the main player character be able to change their quality values .
Since th is capability is common t o a l l Encounter characters, w e provide the base EncDunterCharacter class
with a setQuality() method.

I

:Encounter
game

I

:Encounter

I

Cast

I
I

freddie:
Foreign
Character

1 . 1 displayForeignCharO
1 .2 displayO

1 .3 new EngagementO

I

"l

l

engagement:
Engagement
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I

Figure 19.17 Beginning of sequence diagram for Encounter Foreign Character use case

487

488

CHAPTER 19

DETAILED DESIGN

I

I

:Encounter
game

:Encounter
Cast

I

1.1 displayForeignCharO

I

1.2 displayO

"t

1 .3 new EngagementO
2. executeO

II
II

I

freddie:
Foreign
Character

2.1 setPlayerQualityO

engagement:
Engagement

I

I
I
I
I
I
I
I

I

�

:Engagement
Display

:Player's
main
character

2.2 setOualityO

I
2.3 setForeignOualityO

2.4 setOualityO

I

�

I
I
I
I
I
I
I
I
I
I
I
I

3.1 new EngagementDisplayO

I

3.2 displayResultO

\l

I

]

Figure 19.18 Sequence diagram for Encounter Foreign Character use case

3 . Th is step requires that the result of the engagement be shown. The following two substeps constitute one
way to do thi s .
3 . 1 First Engagement creates an EngagementDisplay obj ect.
3.2 Now we show the engagement display by call ing its displayResult() method.
S i nce the methods require d to execute this use case are now known, we can i nclude them on the class
mode l , as i n Figure 19. 19. Continuing this process, the class model and the use case model (in the form of
sequence di agrams ) are completed in detail, as shown i n the case study. The state model (if applicable )
must also be completed i n detail. A data flow diagram is y e t another possibly useful model, and i s discussed
next.
=:t=:::!.!!"'-!.!! /<::>--___---;>/ EngagementDisplay

displayResultO

I EncounterGame I
:;: -k::>-----J.I PlayerCharacter
==�:;::;I�EncounterCast
l setOualityO
displayForeignCharO

setPlayerOualityO

setForeignQualityO

...,..1 ForeignCharacter

1<::>-__

Figure 19.19 Classes for Encounter Foreign Character use case

1

setOualityO

I

I

SEQUENCE AND DATA FLOW DIAGRAMS FOR DETAILED DESIGN

19.7.2 Detailed Data Flow Diagrams

To relate data flow models to classes, we can map each processi ng element to a method of a class. Figure 19. 20
shows a high-level view of a data flow diagram for an ATM banking application. Data flow models can be
telescoped. For example, F i gure 19. 2 1 expands processing elements from the DFD in Figure 19. 20.
Telescoping allows us to show a high-level view, followed by successive stages containing as much
detail as we wish . This avoi ds overwhelming the viewer. Each processi ng element is expanded into a more
detailed DFD, and this expansion process is continued until the lowest l evel processing elements are reached.
The latter are typically individual functions, possibly of di fferent classes. For example, the getDeposit() functi on
is expanded into three functions (getting the password, veri fying it, and making a display) . Two of these
interact with data stores (a local log of transactions, a list of problem users, and a template for screen displays)
that were not shown in the h i gh-level DFD . Note that the data entrances and exits from the detailed
expansions match those i n the versions from which they are expanded.

Balance

Account.

Customer.

getDepositO

getDetailsO

Customer

Logical function
(software or hardware)

Figure 19.20 Detailed data flow diagram for banking application, 1 of 2-high level

Account.
getDepositO

Deposit­

Account.

Account.

screen.

verifyPass­

getPass­

displayO

wordO

wordO

Figure 19.21 Detailed data flow diagram for banking application, 2 of 2-with details

489

490

CHAPTER 19

DETAILED DESIGN

Each processing element is expanded into a more detailed D FD , and this expansion process is con­
tinued until the lowest-level processing elements are reached. The latter are typically individual functions,
possibly of different classes. For example, the getDeposit(J function is expanded into three functions (getting the
password, verifying i t, and making a display). Two of these interact with data stores (a local log of transactions, a
l ist of problem users, and a template for screen displays) that were not shown in the high-level DFD . Note that the
data entrances and exits from the detailed expansions match those in the versions from which they are expanded.
DFDs are not helpful for all applications. For example, they do not add much to the Encounter case study.
19.8 DETAILED DESIGN AND AGILE PROCESSES

Agile processes, described in Chapter 4 and referred to throughout this book, emphasize working code and
place documentation at a lower priority . The latter includes detailed designs. An extreme interpretation of th is is
that detailed design counts for very little, but a more measured interpretation is that an agile process would
create detailed designs for only those parts of a ppl ications where the effort to produce them is worth the bend] t.
An exam ple is a complicated but important algorithm . A non- agile development effort, on the other hand, may
document every method. For l arge development efforts, leaving it to the judgment of hundreds of software
engineers as to whether design details should be documented or not may not be favored by project managers .
It is obvious that software engineers should not engage in activities with insufficient benefits . One issue
that makes this l ess than clear, however, is whether one assesses benefits in the short term or the long term .
Good, detailed design documentation of a class that supports the code (possibly as comments) would help
maintainers. It would also have to be kept up-to-date by maintainers. This is probably a long-term benefit that
is not as clear in the short term .
19.9 DESIGN IN THE UNIFIED DEVELOPMENT PROCESS

Recall that the unified development approach of Jacobson et aI. , described in Chapter 3 , groups iterati ons into
the "Inception:' "Elaboration," "Construction," and 'Transition" categories (see Figure 19. 22). Design takes
place primarily somewhat during "Elaboration" but mostly during the "Construction" iterations. The i dea is

U. P. Term

Requirements

Inception Elaboration I

I

Construction

Transition

---

-

I

Analysis
Design

Implementation
Test

I
-1
I
I
�

--

------

1

�

I
1
I
1
1..--... ..--...I� �

Prelim. Iter.
iterations #1

I

l

iter. Iter.
#n #n+1

I

.. .. .

Figure 19.22 Unified software development method process-design

�

�
l

iter.
#m

.....----

I .. r!n

Iter.
.. .
#m+1

Source: Jacobson. Ivar, J. Rumbaugh, and G. Booch. The Unified software Development process, Addison-Wesley, 1999.

#k

UPDATING A PROJECT WITH DETAILED DESIGN

... 1�4. Dependency description
1. Introduction
4.1 Intermodule dependencies
1.1. Purpose
A�
4.2 Interprocess dependencies
1.2. Scope
4.3 Data dependencies
1.3. Definitions, acronyms,
5. Interface description
and abbreviations
5.1 Module interface
2. References
.,
5.1.1 Module 1 description
3. Decomposition description
5.1.2 Module 2 description
3.1. Module decomposition
5.2 Process interface
3.1.1 Module 1 description
5.2.1 Process 1 description
3.1.1 Module 2 description
5.2.2 P rocess 2 description
3.2 Concurrent process
decomposition
6. Detailed design
3.2.1 Process 1 description
6.1 Module detailed design
3.2.2 Process 2 description
6.1 .1 Module 1 detail
3.3 Data decomposition
6.2.2 Module 2 detail
3.3.1 Data entry 1
6.2 Data detailed design
description

3.3.2 Data entry 2 description

6.2.1 Data entity 1 detail
6.2.2 Data entity 2 detail

Figure 19.23 IEEE 1016-1998 Software Design Document table of contents, with focus on detailed design section

Source: IEEE 1016-1998.

that most of the requirem ents will have been gathered by those stages. An "Analysis" phase is frequently
i dentified as part of the waterfall process . Compared with the terminology of this book, the Analysis phase
consists partly o f requirements analysis and partly of architecture selectio n .
The unified process encourages three types ("stereotypes") of classes at the analysis level : entity, boundary,
and control classes, whereas there is no such restriction on design classes. Entity classes express the essence o f
the concept, and are unl ikely to require change over time o r between applications. Boundary classes handle
communication with enti ty obj ects, and control classes contain methods that pertain to the entity objects but
that are typically special to the application in which the entity cl ass is being used. Boundary classes are
typically l ike the Mediator object in the Mediator design pattern described in Chapter 16. The unified process
promotes visual tools for design. An example of this is the Rational Rose tool sold by I BM.
19.10 IEEE STANDARD 890 FOR DETAILED DESIGN

Recall IEEE standard 1016-1998 for Software Design Documents shown in Chapter 18 on software
architecture, as shown in Figure 19. 23 . This format for the detailed design section of this document consists
of speci fying a description of each module ( package) in turn, with a detailed descri ption of each data part. For
00 designs, the latter can be replaced with a detailed descri ption of each class.
19. 11 UPDATING A PROJECT WITH DETAILED DESIGN

Once a detai led design is in hand, the project plan can be made more specific in several respects . In particular,
cost esti mation can be made much more precise, schedules can be broken down into tasks, and tasks can be
allocated to individuals. Figure 19. 24 includes most of the important updates to be performed once detailed
design is complete.
Since we can estimate the number and size of the methods involved in the application using detailed
designs, a more precise estim ation of the project size is possible. As described in Chapter 8, project costs can
then be in ferred from the size . Figure 19. 25 shows one way of carrying this out.

491

492

CHAPTER 19

DETAILED DESIGN

1. Make sure the SDD reflects l atest version of detailed design , as settled on after inspections.
2. Give complete detail to the schedule (SPM P ) .
3 . Allocate precise tasks t o team members (SPMP) .
4. I mprove project cost and time estimates (see below) .
5 . Update the SCMP to reflect the new parts .
6. Review process by which the detailed design was created, and determi n e improvements. I nclude . .
time taken, broken down to i nclude
preparation of the designs
i nspection
change
defect summary
number remaining open, found at detailed design , closed at detailed design
where i njected; i nclude previous phases and detailed design stages
•

•

•

•

•

•
•

Figure 19.24 Bringing the project up-to-date after completing detailed design

The COCOMO model can now be used again to refine the estimate of job durati o n . It is best to use
personal data to estimate the LOC for very small, smal l , and such jobs. In the absence of these data,
department, division, or corporate data can be used. Otherwise, Humphrey's table (Figure 19. 2 6) [6] may be
usefully applied. Figure 19. 2 6 applies to C+ + LOC per method. On the average, Java and C+ + require the
same number of LOC to i mplement s im ilar functionality [7, 8].
Calculation methods perform numerical computation; data methods manipulate data (e.g., reformat­
ting); logic methods consist mainly of branching; setup methods i n i tialize situations; text methods
manipulate text. Estimates for methods that combine several of these can be computed by averaging. For
example, an unexceptional ("medium") method that performs calculations but also has a substantial logic
component can be estimated as having ( 1 1. 25 + 15 .98 )/2
13 . 62 l ines of code .
Descriptors such as Very Small and Small are "fuzzy" i n that they describe ranges rather than precise
amounts. These ranges can overlap, in which case an average of the correspondi n g table values can be used.
(This is actually a simpli fication of fuzziness, but adequate for our purpose . ) Fuzzy descriptors are practical
=

I.

Start with the list of methods .
ensure completeness, otherwise underestimate will result
2. Estimate the l ines of code ( LOC) for each.
classify as very small, small, medium, large, very large
normally in ± 7%/24%/3 8%/24%/7% proportions
use personal data to covert to LOC
otherwise use Humphrey's table below
3. Sum the LOC.
4. Covert LOC to person-hours .
use personal conversion factor, i f possible
otherwise use published factor
5. Ensure that your estimates of method sizes and time will be compared and saved at project end.
•

•

•

•

•

•

•

Figure 19.25 Estimating size a n d time-to-complete from detailed designs

UPDATING A PROJECT WITH DETAILED DESIGN

Category
Very small

Small

Medium

Large

Very large

2.34
2.60
9. 01
7.55
3.88
3 . 75

5.13
4. 79
12 . 06
10. 98
5.04
8 . 00

1 1. 2 5
8.84
16.15
15.98
6. 56
17. 07

24. 66
16.31
21.62
2 3 .25
8.53
36. 41

54. 04
30.09
2 8 . 93
3 3. 8 3
11. 09
77.67

Calculation
Data
Method type

liD
Logic
Set-up
Text

Figure 19.26 Lines of code

Source: Humphrey, Watts S. A Discipline for Software Engineering (SEI Series in software Engineering). Addision-Wesley, 1995.

because they are easy to understand. They can be made more precise by categorization with the normal
distribution, as shown in Figure 19. 2 7.
On the average, about 3 8 percent of the methods should be classified as "medium ," 24 percent "small,"
and 7 percent "very smal l ," as illustrated in Figure 19. 2 7. These numbers are obtained from the fact that about
38 percent of the values in a normal distribution are within a half of a standard deviatio n of the mean. In
practical terms, if the fraction of methods you estimate as "very large" differs much from 7 percent, for
example, then you should be satisfied that your application really does have an unusual number of very large
methods . Otherwise, you should revise your estimates.
As an example, let's estimate the size of the execute() method of the Engagement class. This method involves
the recalculation of qual ity values, which is the essential mechanism of executing the engagement process.
For th is reason, we coul d class i fy the execute() method as a "calculation . " The size of the execute() method is not
particularly remarkable, since it consists of a fairly straightforward computation of values, so we'l l classify it as
"medium ." Thus, the estimated contribution of execute() is 11. 25 LOC.
A level 5 organization (see Chapter 5 on the Capability Maturi ty Model) would typically plot method
size estimates against actual sizes in order to improve this estimation process. I n the case study, these
estimates are applied to the Encounter video game.
Approximate
percentage of
methods
classified with this
description

..,.7%

�__

-2

-1

o

2

Standard deviations from the mean

Figure 19.27 Normal distribution of "small," "medium," and "large"

493

494

CHAPTER 19

DETAILED DESIGN

19.12 CASE STUDY: DETAILED DESIGN OF ENCOUNTER

What follows is the detailed design for Encounter, based
on the architecture specified earlier in this book, and
using the IEEE standard. Each use case is realized as a
sequence diagram by deciding, for each use case step,
which object should initiate and which should perform
the work step involved. The class models should contain
the classes that appear i n the sequence diagrams.

the handleEvent() method of its aggregated GameState
object. The sequence diagram for this is shown i n
Figure 19. 29. For the current release, the methods are
either trivial or are shown in Fi gure 19.29.

Pseudocode for selected methods within se­
lected classes may be included here. In addi­

6. Detailed Design of Role-Playing Game
Framework

tion, detailed use cases can be included. Since
the methods and their details are still one or
two lines in this case, it is sufficient to elab­
orate on the (barely) nontrivial methods with

6 . 1 Module Detailed Design

the notation shown in Figure 19.28.

Note to the Student:
These sections give all of the nontrivial required
details on each of the modules described in
Section 3.1 in this SDD for the game framework.

6.1.2 The Characters Package
This section elaborates on Section 3 . 1.2 of this SDD.
There is one class in the Character package: GameCharacter.
6 . 1 . 2 . 1 GameCharacter Class
Methods of GameCharacter

6. 1. 1 Role-Playing Game Package

All mouse events are l istened for by objects of the
class RPGMouseEventListener, which i nherits from
MouseListener as shown i n Figure 19.28 . Each object
that is sensitive to mouse events asks an RPGame
object to handle the event. RPGame passes control to

setName( ) .
Preconditions: none;
postconditions: none;
invariants: none

{ rPGameS.handleEventO; }
rPGameS

r----<:::>i

RPGame

RPGMouseEventListener
mouseEnterO

�>------�

stateS

Figure 19.28 Detailed design of RolePlayingGame package

GameState
handleEventO

CASE STUDY: DETAILED DESIGN OF ENCOUNTER

User

I

eventTarget

l

I

:RPGame

I :RPGMouseEventListener I

Jl

J

:GameState

1 . mouse

action

2. mouseClickedO
3. handleEvent

( Event)

4. handleEvent

( Event)

Figure 1 9.29 Sequence diagram for handling mouse events

Pseudocode:

6. 1 Module Detailed Design for Encounter

IF aName parameter OR

maxNumCharslnNameO m ake no sense
Set name to default value and show
this in system window
ELSE

These sections give all of the required details
on each of the modules described in Section
3 . 1 in this SOD (i.e., for Encounter).

IF parameter string too long

truncate at maxNumCharslnNameO
ELSE assign the parameter name

6.1.3 The GameEnvironment Package
This package is described completely by Figure 19. 3 1
in Section 3 . 1 of this SOD ( Chapter 18 ) .
6. 1.4 The Artifacts Package
Not applicable in th is iteration.

6.1.1 The EncounterGame Package

This section gives all of the required details on
Section 3 . 1. 1 in this SOD. It describes com­
pletely the classes of the EncountfrGamf pack­
age, and all of their nontrivial behavior. Most
of this is described by the state transition
diagram. In the interests of keeping the class
model free of clutter, we do not show all object
references.

6. DETAILED DESIGN OF ENCOUNTER

The overall architecture, showing the relationships
among the packages and the domain classes de­
scribed in this section, is shown in Figure 19.30.

The state diagram for Encounter is shown in
Section 2. t. t of the SRS (Fjgure 11.26 of Chapter 1 t ) .
T o realize these states and transitions, the EncounterGame
package class model is designed as in Figure 19. 3 1.

495

496

CHAPTER 19

DETAILED DESIGN

RolePlayingGame
«framework package»

Characters
«framework package»

EncounterCharacters
«application package»

I
II

EncounterCharacter

9>

PlayerCharacter

I I

I

I

EncounterGame

�

«uses

I

«application package»

«u es»

I EncounterGame I I Engagement I
I EngagementDisplay I

I

I

GameEnvironment

«framework package»

I ForeignCharacter I
I PlayerOualityWindow I

l'

(uses»

EncounterEnvironment
«application package»

I Area II EncounterAreaConnection
I ConnectionHyperlink

GameArtifacts

Figure 19.30 Encounter game architecture packages, showing domain classes only
1------------------1
:

,
,,
,,
,,,

,

I

l

RolePlayingGame

:

,------,
I

RPGMouseEventListener
notifyOfEventO

-

RPGame

I

handleEventO

handleEventO

)
EngagementDisplay

{

I

_______

_______________________

---

-

-

-

-

--

---

Waiting

Engaging

l

handleEventO

�--- - -- - -- - �-I

EncounterGame
« singleton»

GameState

handleEventO

_______________________________________________

Engagement

1
,,
,,
,,
,,
,
,,,
1

------------------------------------------------------------------

I

Reporting

Preparing

handleEventO

handleEventO

o - --- - --i�c-;;-u �-;i
- - - - - - - --i- --------- -------t-I Y
r- -, -----------------,
-

-

t

n erG

EncounterEnvironment

Figure 19.31 Detailed design of EncounterGame package

EncounterCast

CASE STUDY: DETAILED DESIGN OF ENCOUNTER

There is exactly one instance of the EncounterGame
class. The states of this object reflect the states and
substates shown i n the above state-transition diagram.
The Encountering state aggregates an Engagement object
that encapsulates the engagement of the game charac­
ters. The Engagement class aggregates a display called
EngagementDisplay. The latter is mouse-sensitive, regis­
tering with an RPGMouseEventListener object. When the
Encounter game is executed, this listener object refer­
ences the EncounterGame object (an RPGame object) . This
enables EncounterGame to handle all events according to
the game's state, using the State design pattern. The
EncounterGame package has the responsibility of direct­
ing the movement of the foreign character over time.
This is performed by methods of the class Character­
Movement, which is a thread class.
State classes need to reference other packages in
order to implement handleEvent() , and this is done through
the Facade objects EncounterCast and EncounterEnvironment.
6 . 1 . 1 . 1 The EncounterGameDisplays Subpack­
Displays
correspondi n g to some of the states are handled by a
separate subpackage, EncounterGameDisplays, which is
shown i n Fi gure 19. 3 2 .

age of the EncounterGame Package

OualListDispl i s a list box consisting of the quali t­
ies of Encounter characters.

OualValueDisp/ is a read-only text box for dis­
playing the value of a quality.

SetOual ValueDispl is an editable text box for
setti ng the value of a quality.

EncounterDisp/ayltem abstracts the properties and
methods of displayable Encounter items such as
these.

EngagementDisplay is designed to display the
current value of any selected qual ity.

SetOualityDisplay is designed to enable the
player to set the value of any quality.

EncounterDisplay abstracts the properties of these
displays, and is a mediator base class.
This document does not provide further details
of the design of these classes .

6 . 1 . 1 .2 Sequence Diagrams for Event Handling
6 . 1 . 1 . 2 . 1 Player Dismisses Report Window
Event Figure 19.3 3 shows the sequence i nvolved
in dismissing the engagement display. (Th is dis­
m i ssal event is shown on the state-transiti on
di agram . )

--------------------- -,

r ----

-

i EncounterGameDisplays i

-------E����;�;;�:;�;7t;���
I
I
I

SetQualityOispJay
Figure 19.32 Detailed design of EncounterGameDisplays subpackage

EncounterCast

I

497

498

CHAPTER 19

DETAILED DESIGN

I

u ser

:EngagementDisplay

1. hit

I

:RPGMouse

I

EventListener

dismiss
button

2. mouseClickedO

I

:ReportingEncounter

:EncounterGame

3. handleEvenlO

I

5. selVisible( false)

I

4. handleEvenlO

6. selSlale
(new WaitingO)

I
Figure 19.33 Sequence diagram for dismissing engagement display

6 . 1 . 1 . 2.2 Player Completes Setup Event Fig­
ure 19. 3 4 shows the sequence i nvolved when the
player completes the setup. (This dismi ssal event is
shown on the state- transition diagram . )

connection hyperlink. (This dismissal even t i s shown
on the state- transition diagram . )

6. 1 . 1 .2.4 Sequence Diagrams for Remaining
Events The remai ning events are handled very
similarly to those described in Sections 6.1. 1.1
through 6.1. 1. 3.

6 . 1 . 1 .2.3 Player Moves to Adjacent Area Event
Figure 19. 35 shows the sequence when the player
moves to an adj acent area by clicking on a
User

I

:PlayerQualityWindow

J

I

I

:SettingUp

:RPGMouse

1 . hit

EventListener

dismiss
button
2. mouseClickedO

'

,�.

11

I

:EncounterGame

3. handleEventO

5. setVisible( false )

Figure 19.34 Sequence diagram for Player Completes Setup use case

'II
L

I

4. handleEventO

6. setState

(new WaitingO)

1

CASE STUDY: DETAILED DESIGN OF ENCOUNTER

User
H

1 . hit

I

:AreaConnectionHyperlink
:RPGMouse

area
connection
hyperlink

I

:EncounterCast

I

EventListener

I

:Waiting

: EncounterEnvironment

I

2. mouseClickedO

,1".5. setVisible( false)

II

3. handleEventO

:EncounterGame

I
"II

I
I

4. handleEventO

I

J

,__________________________________

_ ___

1

�

6. displayAreaO

I

7. displayPlayerCharacterO

_______

J

_____

If foreign character
present
:"------------------------------------- ·

L

_____________________
I
I

Figure 1 9.35 Sequence diagram for Player Moves to Adjacent Area use case

6. 1 . 1 . CM The CharacterMovement Class

As in the SRS, we are using an alphabetical
"numbering" scheme to make it easier to find
and insert classes. There is also a benefit in
being able to trace the requirements to the
SRS .

6. 1 . 2 . EG The EncounterGame Class This is
the facade singleton for the EncounterGame package.

Inheritance
This class inherits from RPGame in the framework.
Attributes of EncounterGame:
EncounterGame encounterGameS:
This is the singleton EncounterGame object.

This class controls the movement of the foreign
character.
Inheritance
This class inherits from java.lang. Thread.
Methods of CharacterMovement
public static EncounterGame run ( ) ;
Starts the foreign character in the dungeon .
Moves the foreign character from area to area
via area connections, changing areas to a ran­
domly selected neighbor, at random times
averaging every two seconds.

Constructors of EncounterGame:
privateEncounterGame():
Preconditions: none
Postconditions: creates an EncounterGame instance
Methods of EncounterGame
public staticEncounterGame
getTheEncounterGame() ;

Precon ditions: none
Postconditions: encounterGameS not null
Returns: encounterGameS

499

500

CHAPTER 19

DETAILED DESIGN

6 . 1 . 3 . EN The Engagement Class Th is class
encapsulates engagements between the player's char­
acter and the foreign character, and corresponds to
requirement 3 . 2 . EN.

Each of these classes implements its handleEvent()
method in accordance with the sequence diagrams of
Section 6. 1. J . J .
6. 1.2 The EncounterCharacters package

Methods
pub lic void engage() ; / /

This section elaborates on Section 3 . 1 .2 in this

SDD .

corresponds to requirement 3 . 2. EN. 3 . 1
Preco nditions: T h e player's character and the
forei gn character are in the same area.
Postconditions: The values of the characters'
qualities are as required by SRS requirement
3 . 2.EN. 3 . 1; the player's character and the for­
eign character are in random but different areas.
6 . 1 .4. ZZ The Engaging, Waiting, preparing, and
Reporting Classes

The ''Z:z'' numbering is used to collect classes
that are not speci fied individually.

The design of the EncounterCharacters package is
shown in Figure 19. 3 6. I t is implemented by the
Facade design pattern, with EncounterCast as the fa­
cade object.
6 . 1 . 5 . EC The EncounterCharacter Class This
class encapsulates the requirements for Encounter
characters that are not covered by RPGameCharacters .
It satisfies requirements SRS 3 . 2. EC.
Class invariant: The values of qual ValueI are
nonnegative (see "attributes" below for the defini ­
tions o f qualValueI) .

Inheritance
These classes i nherit from GameState in the
framework package .
Characters
«framework package»

I nheritance
This class inherits from GameCharacter in the
framework package .

I
GameCharacter

EncounterCharacters

«application package»

I

«facade»

EncounterCast

f).

I

I

I EncounterCharacter J
'r I
r---1 PlayerCharacter I

Figure 1 9.36 Detailed design of EncounterCharacters package

� ForeignCharacter I

CASE STUDY: DETAILED DESIGN OF ENCOUNTER

Attributes of EncounterCharacter
These satisfy requirement SRS 3 . 2.EC \
private stat ic f inal Str ing [ 1
qual ityTypeS
This represents the qualities that Encounter char­
acters possess. These are concentration, sta­
mina, i n telligence, patience, and strength .
private float [ l qualValue I

Set the stated quali ty to the desi red amount.
IF the caller adjusts the only nonzero qual­
i ty value, divide the adjustment amount
equally among all other qual ities.

ELSE change the remaining qualities, re­
taining their mutual proportion,
Set each quality whose value is now less
than 0.5 to zero .

This is an array containing the values of the
qualities.

public float getQuali tyValue
( String qualityp )

Constructors of EncounterCharacter

Preconditions: quali tyP is a vali d quali ty stri ng
Returns: the value of quali tyP

These satisfy requirements 3 . 2.EC 3 of the SRS.
Null constructor
Postcondition: The qualities are all equal
fractions of \ 00.
protected EncounterCharacter
( Str ing nameP )
Postconditions:
( t ) the qualities are all equal fractions of t OO.

(2) the character's name is NameP
Methods of EncounterCharacter
publ ic synchronized void
adj us tQual i ty

( Str ing qua l i t yP , float
qua l ityValueP )
This method satisfies requirement 3 . 2.EC 3 .2.
I nvariants: none
Preconditions:
qualityP is i n quali tyTypesS[]
AND qualityValueP > =0
AND qualityValueP < = the sum of the
quality values
Postconditions :
quali tyP has the value qualityValueP
AND
the remaining qual i ty values are in the same
proportion as
prior to i nvocation, except that values less
than 0. 5 are zero .
The following is the pseudocode for
the method adjustQuality().

publ ic float ge tTolerance (
Returns: the value below which quality values
cannot go
protected int maxNumChar s l nName ( )
Returns: the m aximum number of characters i n
t h e names of Encounter characters
publ ic float sumOfQual ities ( )
Returns : the sum of the values of the qual ities
This method satisfies requirement 3 . 2. EC 3 . 2.
publ ic vo id showCharacter
( C omponent componentP ,
Graphics drawP , Point posP , int
heightPixP , boolean faceLeftP )
Displays the character i n componentP, with cen­
ter at posP, with heigh t heightPixP, facing left if
faceLeftP true
This method satisfies requirements 3 . 2.PC \
and 3 . 2. PQ. t .
p r ivate vo id setQua l i ty ( Str ing
qual ityP , float valueP )
Preconditions: qualityP is a vali d quality stri ng.
Sets the quali ty i ndicated by the parameter to
valueP i f the l atter is > = 0.5, otherwise sets
valueP to zero .
This method satisfies requirement 3 . 2 .
E C 2 ( l ower lim i t on nonzero quality values).

501

502

CHAPTER 19

DETAILED DESIGN

6 . 1 . 6 . ES The EncounterCast Class The
method speci fications for this singleto n , interface
class are given in Section 5 of this document.
6 . 1 . 7 . FC The ForeignCharacter Class Th is
class is analogous to PlayerCharacter, described
next, and is designed to satisfy the SRS 3 . 2 . FC.
6 . 1 . 8 . PC The PlayerCharacter Class This class
is designed to satisfy the requirements 3 . 2 . PC.

I nheritance
Th is class i nherits from EncounterCharacter.
Attributes:
privat e static f ina l P layer
Charact er p layerCharact erS i
Th is is the singleton obj ect representing the
player's character.

6 . 1 . 8 . AR Area Class This class encapsulates the
places i n wh ich the characters exist, and corresponds
to requirement 3 . 2 .AR.

I nheritance
This class inherits from GameArea .
Attributes:
priva t e String nameI i / /
corresponding t o requirement
3 . 2 . AR . I . l
private Image image I i / /
corresponding t o requirement
3 . 2 . AR . I . 2
priva t e String [ ] qualities I i / /
corresponding t o requirement
3 . 2 . AR . I . 3
privat e Vector connect ion
Hyper links I i
Methods

Methods:

pub l ic void display ( ) / /
shows the area object's image on the monitor.

pub lic static f ina l P layer
Charact er ge tPlayerCharacte r { ) i

public static Area getArea
(St ring areaNameP)

Th is method returns playerCharacterS.
6.1. 7 The EncounterEnvironment Package
The classes of this package describe the environment
in which the game takes place . It is shown i n
Figure 19. 37.

I

GameArea

Y

Area

T

returns the area corresponding to areaNameP
accordi ng to requirement 3 . 2 .AR. 2 . 2 .
pub lic static AreaConnect ion
getAreaConnection(St ring
area
Connect ionNameP)

I GameEnviron ment
I
GameAreaConnection

r
6 I

I EncounterEnvironment
Figure 19.37 EncounterEnv;ronment package

GameCharacter

I

�

I
I

ou",e'A",aCO"",_
ConnectionHyperlink

I

I

I

I

EncounterEnviron ment

CASE STUDY: DETAILED DESIGN OF ECLIPSE

returns the area Connection object corresponding
to area ConnectionNameP accordi ng to require­
ment 3 . 2 .AR. 2 . 2 .
6 . 1 . 9 . C O EncounterAreaConnection Class
This class encapsulates the ways to get from areas to
adjacent areas. It i nherits from AreaConnection and
corresponds to requi rement 3 . 2 .CO.

Inheritance
This class inherits from GameArea Con­
nection in the framework package .
Attributes:
p r ivat e Ar e a f i r s t A r e aI ;

I I c o r r e sp o n d in g t o r e qu i r ernent 3 . 2 . C O . 1 . 1

p r ivat e Ar e a s e c ondAr e a I ;

I I c o r r e sp o nding t o r e qu i r ernent 3 . 2 . C O . 1 . 1

Methods : These are accessors for the attributes
above.

Attributes :
p r iva t e Connection connection I ; / /
t he corresponding connect ion
Methods :
The on ly meaningful met hod is
mouseCl ick ( )

.

6 . 2 Data Detailed Design

There are no data structures besi des those mentioned
as part of the classes i n Section 6. 1.
1 9. 1 3 CASE STUDY: DETAILED DESIGN OF
ECLIPSE

References: The JavaDoc for Eclipse is at http ://
www.eclipse . org/documentation/html/plugi ns/org.
ecl i pse. platform . doc. isv/doclreference/api/
overvi ew-summary.html

6 . 1 . 1 0. EE EncounterEnvironment Class This
is the facade class for the EncounterEnvironment package .

Attributes:
privat e EncounterEnvironment
encounter EnvironmentS;
/ /the singleton Facade ob j ect
/ / [ Area name ] [ Area connection
//name ] [ " Nort h " 1 " Sout h "
//1 " East ' , 1 " West " ] :
priva t e Str ing [ 3 ] layou t S;
Methods :
public st atic EncounterEnvironment
getEncounterEnvironment ( )

Retu r ns: encounter Envir onmentS
public static String [ 3 ] getLayout ( )
Ret urns : layoutS
The remaining methods are speci fied i n Section
5 of this document.
6 . 1 . 1 1 . CH ConnectionHyperlink Class Th i s
class encapsulates the ways to g e t from areas to
adj ac e n t are a s . It corre s p o n ds to req u i re m e n t 3 . 2 .
CH . Th i s class i m p l e m e n ts the MouseListener
i n terface .

Note to the Student:
Ecli pse is a large project, and this case study
does not attempt to describe its design i n
detail-merely t o provi de excerpts from a small
example of how detailed design is sometimes
speci fied i n the case of Eclipse. The complete
document would be based on the arch i tecture
decomposition described previously . It would
have a section on each of the Pla tform, the Java
Development Environment, and the Plugin Development
Environment. With i n the Pla tform section, it would
have a Workspace and a Core section . Within the
Core section, it would have a Runtime section .
Part of the latter is shown next.

Platform. Core. Runtime

Ideally, this section could be traced to the Ecli pse
requirements. Although the reader of the Eclipse
documentation can understand the trace in gen­
eral terms, it is not straightforward to locate the
exact references to requirements sections.

503

504

CHAPTER 19

DETAILED DESIGN

Platform
getCommandLineArgs()
getPlugin()

\

\

\

\

\

\

I P�th I
Figu re 1 9.38 Core classes of Eclipse

Platform. Core.Runtime is organized around a small
set of core classes, as shown i n Figure 19. 3 8.
The classes i n Figure 19. 3 8 are described next.
PLA TFORM CLASS

The fol lowi ng is from the Ecli pse javadoc (as
edited by the author). An alternative would be
to provi de the skeleton of the class i tself in the
followi ng form .

// The c e nt r a l c l a s s o f t h e E c l ip s e P l at f o r m

Features include :
•

the platform registry of i nstal led plug- ins

•

the platform adapter manager

•

the platform log

•

the authorization i n fo m anagement

The platform is i n one of two states, running or
not running , at a l l times. The only ways to start the
platform runn i ng, or to shut it down, are on the
bootstrap BootLoader class.

//Runt ime
p ub l i c f in a l c l a s s Platform e x t e n d s Ob j e c t

{

p ub l i c s t at i c g e t l n s t an c e ( ) { } <- no c o nt e nt

}

p ub l i c f in a l c l a s s Platform e x t e n d s Ob j e c t

The central class of the Eclipse Platform Runtime:
This class cannot be i nstantiated or subclassed by
clients; all functionality is provided by static methods.

If a class is to have no i n stances, all i ts methods
are made static.

I n other words, the methods that start or shut
down the platform are found i n the class
BootLoader.
Code in plug- ins will only observe the platform
in the run ning state . The platform cannot be shut­
down from inside (code in plug- ins have no access to

BootLoader) .
publi c static Plugin getPlugin(String id)
Returns the plug- i n runtime object for the
identified plug-in or null if no such plug- i n can be
found. If the plug- i n is defined but not yet activated,
the plug- i n will be activated before being returned.

SUMMARY

Parameters: id - the unique i dentifier of the
desired plug- i n (e.g. , "com .example.acme") .
Returns: the plug- i n runtime object, or null

We have provided just a taste of the begi nning
of the Ecl i pse design . Th is example provides a

sense of how documentation reads that is
generated (via Javadoc) from source code
comments. An advantage of usi ng Javadoc is
that it tends to remain up-to-date as long as the
programmer comments the code according to
the standard.

19. 1 4 SUM MARY

Deta iled design is an activity in which components such as classes and methods are defined in enough detail
so that im pleme ntation can commence. We start with the domain classes from requirements analysis and add
the necessary design classes to complete the design. Design patterns are introduced as required, to implement
any commonly recurring design problems.
Duri ng detailed design , interface functions with speci fied names, parameter types, and return types are
defined. The program elements using these functions can then be designed without having to know how
the functio nal i ty is implemented-all they need to know is how to use the i n terface. This facili tates the
development of each design element separately. The Facade design pattern is one way of providing an
interface to a package of classes.
When design ing object-oriented software, several well - establi shed design principles help ensure a
robust and extensible design : single-responsibi l i ty, open - closed, liskov substitution, dependency-i nversion,
and interface segregation .
When spec i fying the details of a class, we start with the domain classes defined during requirements. We
gather the attributes already defined and add additional attributes required for design. We also define class
and method i nvari ants, and method pre - and postconditions. Pseudocode is written to describe how each
method is to be implemented. We then add addition classes necessary to complete the design and draw a class
model showi ng the static relationsh i p between classes. An activity diagram can also be drawn to graphically
describe nontrivial algorithms . Some detailed designs are best communicated via detailed sequence diagrams
or detai led data flow diagrams . Sequence diagrams show the obj ects associated with a particular use case, and
the messages ( i . e . , function calls) that flow between them. Data flow diagrams show processi n g elements ( i . e . ,
methods) i n a program and t h e data that flow between them.
The detailed design is documented i n a software design speci fication. We have i ntroduced IEEE
standard 1 0 1 6 - 1 9 9 8 for Software Design Documents as an example of such a document.
Detailed design concludes by updati ng the schedule in the SPMP to reflect the details learned. The
process should also be reviewed with respect to the amount of time taken and the number defects discovered.
Im proveme nts can be planned based on how these metrics compare against the plan.

1 9. 1 5 EXERCISES

1. Explain the fol l owing:
(a) The purpose of detailed design (list three benefits)
(b) How i t di ffers from software architecture
(c) Why it is generally a questionable i dea to go directly from architecture to implementati o n .

505

506

CHAPTER 19

DETAILED DESIGN

2 . Your company produces software that controls a robot arm for manufacturi ng. Name four classes
that would be appropriate members of your company's software framework. Explain your
reason i ng.
3. Estimate the number of l i nes of Java code for the following set of methods . The methods are
ordered from smallest to l argest. Assume that there is nothi ng unusual about the job except as
i ndicated in the i n formation below.
Method 1: 1/0; Method 2: Text; Method 3: Calculation; Method 4: Logic;
Method 5: Data; Method 6: Calculation; Method 7: Text; Method 8: Data;
Method 9 : Set-up; Method 10: Calcul ation; Method 11: Text; Method 12 : D ata

4. Comp lete the following, explai n i ng under what circumstances you would use the fol lowing i n
detailed design .
(a) Use activity diagrams when the logic
__
_
_

(b) Use pseudocode for a method when

_
_
_
_

5 . Define appropriate interfaces that the following class exhibits (or "implements" in Java terms) .
Assume that additional methods will b e required a s the application grows. Explain your reasoning.
Hint: The interfaces indicate what kind of transaction this i s .
6. Describe i n your o w n words t h e advantages of spec i fying preconditions, postconditions, a n d
i nvariants. How, spec i fically, d o they help t o i ncrease t h e qual ity o f functions?
7. Perform a design ( both architectural and detailed) for a check-balancing appl ication with the
following requirements. Fix defects in the requirements if you find them. You can play the role of
customer if and when the customer's i nput is requi red. Report the time you spent on signi ficant
activities to the nearest five minutes.
1. The system shall display the current balance i n the system window.
2. The system permits the user to record deposits of up to $ 10,000.
3 . The system perm its the user to withdraw any amount from the current balance. An error
message 'Th is withdrawal amount exceeds your balance" is displayed when the user attempts to
withdraw an amount exceedi ng the balance.
8.

A classic Liskov substitution principle example consists of two classes, Square and Rectangle. Since a
square is-a rectangle, the relationshi p between the two can be modeled using inheritance, with Square
derivi ng from Rectangle. Suppose that Rectangle has methods to set/get the width, and set/get the length.
Explain how this relationship between Square and Rectangle violates the Liskov substitution principle.

TEAM EXERCISES
SOD
Provide an SDD for your proj ect. Use, or improve upon the IEEE standard. Please enclose the latest version of

your SRS.

BIBLIOGRAPHY

Report the time spent by the individuals and the group on the parts of this assignment. Break this down into
activities, including architecture, inspection, review, and detailed design. Comment on how the time spent
could have been better allocated.

BIBLIOGRAPHY
I .

Mart i n , Robert, "Agile Software Development, Principles, Patterns, and Practices, " Prentice Hall, 200 3 .

2 . Mart i n , Robert, "Design Principles a n d Design Patterns, " 2000, www.objectmentor.com/resources/articies/Principles_and_Patterns.pdf
[accessed November 29, 2009] .
3 . Marti n , Robert, 'The Dependency Inversion Principle, " C + + Report, May 1 996, http ://www.objectmentor.com/resources/articles/d i p . pdf
[accessed November 29, 2009] .
4.

The Object Management Croup. www.omg. org ( 1 999).

5 . jurjens, jan, "Secure Systems Development with UML, " Spri nger, 2005.

6 . Humphrey, Watts S., A Discipline for Software Engineering (SEl Series in Software Engineering), Addison -Wesley, 1 995.
7. jones, Capers, "Applied Software Measurement, Assuring Productivity and Quality, " 2nd edition, New York: McCraw - H i l i , 1 996.
8 . QSM Function Point Languages Table, (April 2005, Version 3 . 0 ) http://www.qsm.com/resources/function-point-I anguages- table/
i ndex . html [access November 29, 2009] .
9. Meyer, Bertrand, "Object-Oriented Software Construction, " Second Edition, Prentice Hall, 2007.
1 0. Liskov, Barbara, and john cuttag, "Abstraction and Specification in Program Development, " MIT-Press, 1 98 6 .

507

Design Quality and Metrics

�

Testing

Maintenance
The Software
Development
Lifecycle

Planning
\

Requi
rements
analysi
s

Implementation
�DeSign /

How do you assess the degree of
understandability in a software
design?
How do you assess the degree of
cohesion and coupling?
- degree of sufficiency?
robustness?
- flexibility, reusability?
- time efficiency, space efficiency?
- reliability?
- security?
How is quality in architecture selection
measured?
How is the quality of a detailed design
measured?

Figure 20.1 The context and learning goals for this chapter

Since a set of requirements can be accommodated by several possible designs, we can compare
the quality of candidate designs. As explained in Chapter 15, the qualities of a design include

understandability, modularity, cohesion, coupling, sufficiency, robustness, flexibility, reusability, efficiency, and
reliability. Project leadership specifies the desired levels of quality in these respects, balanced against
the available resources.
Recall that sufficiency means that the design accommodates the requirements. Any measure of design
quality includes this at a minimum. For example, suppose that the requirements are for an application that

DES I G N QUALITY AND METRICS

manages DVD rentals. A design consisting only of the classes Manager and ManagerGUI would not be
sufficient to accommodate the requirements. This is because there is significant data and functionality
specifically associated with the concept of a DVD that is missing. Figures 2 0 . 2 , 20.3, and 20.4 summarize
how design quality can be assessed at a rough level.
The succeeding sections of this chapter elaborate each of the design aspects listed in these Figures.

How ...
•

understandable (How cohesive and clear are the parts and how low is the number of connections
between parts)

0: unclear parts and many connections among them
10: very understandable parts with few interconnections
•

sufficient (How evidently it accommodates the requirements)

0: unrelated to the requirements
10: obviously accommodates every requirement
•

robust

0: any input anomaly has serious consequences
10: every input anomaly accommodated smoothly
Figure 20.2 Qualities of a design-rough metrics, 1 of 3

How ...
•

flexible

0: anticipated additional requirements require extensive change to the design
10: most anticipated requirements require no change to the design
•

reusable

0: no parts of the design can be used in other applications
10: more than 75% of the classes can be used in other applications
Figure 20.3 Qual ities of a design-rough metrics, 2 of 3

How ...
•

efficient: Implementation based on this design

will probably not execute at required speed or use required storage
will execute with as much speed and storage to spare as reasonably conceivable
reliable: Implementation based on this design ...
0: .
will probably fail with a clearly unacceptable frequency
10:
. will probably fail well within the allowable frequency
.

.

.

..

.

.

0:
.
10: .

.

0:
10:

•

•

.

secure:
•

•

.

.

will probably exceed the maximum allowable vulnerability limit
will probably have as few vulnerabilities as can be expected

Figure 20.4 Qual ities of a design-rough metriCS, 3 of 3

509

510

CHAPTER 20

DESIGN QUALITY AND METRICS

20.1 DEGREE OF UNDERSTANDABILITY, COHESION, AND COUPLING
The main reason for a design is to form an understanding among the software engineers of how the application
will actually be coded. It's really a form of communication, and so the quality of a design depends, in part, on its
understandability to people. For each part to make clear sense it has to be cohesive. And if the parts are not
related by too many relationships, we can tell them apart more easily. This is the concept of low coupling. Thus,
the extent to which the cohesion of the modules is high is part of a measure of understandability, and so is the
extent to which the coupling between them is low. (The latter is unlikely to be zero, however, otherwise one
might as well consider the application to consist of entirely separate ones. )

Fan-in and fan-out are measures of the degree of coupling of modules. Fan-in for a component counts the
number of components that reference it; fan-out is the number that it references. These definitions can be refined
by specializing the nature of the references (e.g., "calling a function of"). Low coupling is reflected by low fan-in
and low fan-out.
For more on this, see [1] and [2].
The following is an example of a metric for understandability. It depends on definitions of "strongly
cohesive" and "very few," but these can be made precise for a given family of applications.
Understandability metric

=

Y2

X

Percentage of strongly cohesive modules

+ Y2 x Percentage of modules connected to very few others

Section 20. 10. 1 describes metrics for connectedness alone.

20.2 DEGREE OF SUFFICIENCY AS A QUALITY GOAL
An essential quality goal is to produce a design that accommodates the requirements. Designs can consist of
many parts, but we'll consider a simple example to illustrate degrees of sufficiency. Suppose that our video
store application has the following requirements.
Clerks shall be able to check in DVDs
Clerks shall be able to check out DVDs
The degree of sufficiency measures the ease with which a design accommodates these requirements. Design

1 in, Figure 205, for example, would probably score very low on this quality scale because it fails to capture
the DVD, the customer, or the rental in a readily identifiable way. (This design could be made to work-it's
just not a high-quality design given the requirements. ) Design 2, on the other hand, is sufficient to capture the
requirements for a realistic video store.
The following is a useful metric measuring sufficiency. It depends on having a thorough set of detailed
requirements.

SuffiCiency metric

=

Percentage of detailed requirements clearly accommodated by the design

Increasing the number of classes does not necessarily raise the quality of a design: Redundant classes
actually detract from quality. Additional classes may be needed for other quality measures such as flexibility
and robustness.

DEGREE OF ROBUSTNESS AS A QUALITY GOAL

Design 1
VideoStore
checklnO
checkOutO

/

,/

,/

,/

,/

,/

,/

,/

,/

,/

,/

,/

,/

,/

,------,

,/

,/

,/

,/

,/

,/

,/

,/

,/

,/

,/

,/

Design 2

DVDRentalSet
checklnO
checkOutO

DVDlnventory

Figure 20.5 Measuring the sufficiency of a design-video store example

20.3 DEGREE OF ROBUSTNESS AS A QUALITY GOAL
A good SRS contains explicit robustness requirements. For example, the video store may require that the
application react to the entry of an invalid video name by refreshing the relevant screen with a blank in the

video title window and popping up a window stating "No such video - Please re-enter. " Explicit robustness
requirements like this are measured with the "sufficiency" quality metric. If a statement like this is not an
explicit requirement, then it is measured with the design robustness metric. Figure 20. 6 shows a pair of
designs for the video store application.

Design 1

Design 2

VideoStore
customers
DVDs
rentals

Figure 20.6 Measuring the robustness of a design-video store example

511

512

CHAPTER 20

DESIG N QUALITY AND M ETRICS

Degree to which the
design reacts ideally
to anomalous input

10

-----------------------------------------------------------------------------------------------------

5

o

•________ Application will crash half______-'---_;:.
:;;.
the time when it

Application will crash

encounters any wrong or

without a trace if it

unanticipated input:

encounters any wrong or

Will recover ideally half

unanticipated input

the time

Application will recover
ideally from any wrong or
unanticipated input

Figure 20.7 A rough robustness metric

In Design 1, the VideoStore class contains a collection of VSCustomer objects, a collection of DVD objects,
and a collection of rentals. Each rental can be maintained as a pair consisting of a Customer object and a DVD
object. Design 2 was discussed above. To assess the robustness of Design 1, we think about how to handle
anomalous situations such as attempts to enter data for a nonexistent customer. This is more easily
accommodated with a class containing all customers-similarly for DVDs. The design should also
accommodate erroneous rental entries-for example, a customer forgetting to take his video rental with
him from the store. This is more easily accommodated with a separate DVDRentals class than with a vector
attribute of VideoStore, because the latter is less visible and because it occurs among several other, differing
attributes.
A metric for the robustness of a design is shown in Figure 20 .7. It uses the phrases "reacts ideally" and
"recovers ideally." These have to be defined in the context of the application.

20.4 DEGREE OF FLEXIBILITY AS A DESIGN QUALITY GOAL
It is common to assume that the more flexible a design, the higher its quality. Recall, however, that flexibility
may come with a price in terms of design, development, and maintenance time required. For these reasons, it is
not always pursued. Agile programming, for example, aims for designs that satisfy clear requirements and no
more. Nevertheless, a judicious choice of flexibility in a design can save time by facilitating change. Figure 20.8
shows the trade-offs of creating flexibility in designs.
To measure the degree of flexibility of a design, one can count the levels of class inheritance and the
number of design patterns used. Although these give some indication, they can also encourage poor qualities
in other respects if pursued simply to make a metric become favorable. Extensibility is one facet of flexibility.
And so another way to measure extensibility, in part, is to make a list of reasonable additions to the
application's requirements and to evaluate the design's ability to extend and cover them.

DEGREE OF REUSABILITY AS A DESIGN QUALITY GOAL

Costs of Flexible Designs

® Extra cost (time) needed
® May result in cluttered and

Benefits of Flexible Designs

© Facilitates added requirements

less understandable design

® Time wasted if requirements

© May result in more elegant
and understandable designs

expand in unexpected direction

A

A

D

Figure 20.8 Cost-benefit trade-off of design flexibility

20.5 DEGREE OF REUSABILITY AS A DESIGN QUALITY GOAL
Reusability has many benefits but may detract from an application's quality because it is intended to benefit
future projects rather than just the current one. For example, some energy is diverted from the current project.
However, if the application under design uses a reusable component, then this usually benefits its quality
because the component is likely to be more reliable than those yet unused.
Let's assume that we want a particular component (e.g., a class) to be reusable. For example, how do we
ensure that the DVD class can be used in multiple applications? How do we measure the extent to which a
particular class is reusable? First, the component must have high quality in the usual sense-be well tested, for
example. Interestingly, items can be reusable because they are generic (we use "wood" in many projects) but
also because they are specific (we use 1 'I. -inch machine screws in many projects). This difference places
classes into roughly two reuse categories: those that are useful because they belong in a framework and are
reused because they are general; and those that are special to the business at hand, and form part of its toolkit.
Parameterizing a method makes it reusable but too many parameters make it clumsy. Figure 20.9 lists
some of the key qualities we want for reusability, and their limitations. (The last point in this figure refers to
multiple parameterizations of methods with the same name and similar purposed.) Figure 20.10 indicates how
these may be measured.
Listing 20.1 is an example of a class that would rate high on reusability, as explained below. Using the
measures of Figure 20.10, we would rate the reusability of this code as follows:

•

•

•

Abstract enough to get wide coverage
•

But too abstract

•

For example, class RetailArtifact may have too little content

=

useless

Specific enough to be useful
•

But not too specific

•

For example, AcmeNumher6BrownPencil

Parameterized methods
•

•

But not more than six parameters
Consider f ( x 1 ) also f( x 1, x 2) also f( x 1, x 2, x 3); . . .

Figure 20.9 Attributes o f reusability

513

514

CHAPTER 20

•

DESIGN QUALITY AND METRICS

Degree of coverage
o = negligible coverage of different applications

2
•

=

as wide as can be expected

Degree of content
o = negligible content or substance

2
•

=

very rich content or associations

Parameterization of methods-atIows method reuse
o = very restrictive methods; very narrow scope

2

=

widely applicable methods

Figure 20.10 Measuring reusability

Degree of coverage: VideoProduct covers any video item that a video store could possess, so "coverage"
would rate 2.
Degree of content: The complete version of this class does not have extensive content, but nor does it
have negligible content, so we can rate this as 1.
Parameterization of methods: The names are about as complete as one can expect so this would rate 2.
Its reusability index is thus 5 out of a possible 6.

Listing 20.1:

A detailed design example to be rated for reusability

/*
* Example of a class design highly rated for reuse
*
* Intent: Capture all of the properties and functionality of video
products
* that companies can deal with.
*
* Examples of potential subclasses: DVD, Video
*/
public abstract class VideoProduct

{

// CONSTANTS===========================================
private final static int MAXIMUM_TITLE_LENGTH= 100;
private final static int MAXIMUM_NAME_LENGTH= 100;
private final static int MAXIMUM_NUM_STARS= 20;
// METHODS============================================
/***********************************************
* Returns: The copy number
* Example: 3; if title is "Gone With the Wind, " then this would be the

DEGREE OF REUSABILITY AS A DESIG N QUALITY GOAL

* third copy of this video product.
*/
public abstract int getCopyNumber ( ) ;
/***********************************************
* Returns: duration of this video product in minutes -- if > 0;
* otherwise 0
*/
public abstract int getDurationlnMinutes ( ) ;
/***********************************************
* Returns: Title of this video product in English
*/
public abstract String getEnglishTitle ( ) ;
/***********************************************
* Intent: Enter the title of this product in English
*
* Preconditions:
* ( 1) aTitle != null
* (2) aTitle has between 1 and MAXIMUM_TITLE_LENGTH characters
*/
public abstract void setEnglishTitle (String aTitle) ;
/***********************************************
* Returns: Name of the director of this video product, if known;
* "unknown " if not
* Example: Returns "Stanley S. Kubrik IV "
*/
public abstract String getDirector ( ) ;
/***********************************************
* Intent: Enter the name of the director of this video product
* Example: setDirector ( "Stanley S. Kubrik IV ") ;
* Preconditions:
* ( 1) aDirectorName != null
* (2) aDirectorName has between 1 and MAXIMUM_NAME_LENGTH
* characters
* ( 3) aDirectorName is the name in the form first/last, first/MIl
* last,
* or first/MI/last/suffix
*/
public abstract void setDirector (String aDirectorName) ;
/***********************************************
* Intent: Enter the name of the director of this video product
* Example: setDirector ( "Stanley ", 'S', "Kubrik ", "III " ) ;
* Preconditions:

515

516

CHAPTER 20

DESIGN QUALITY AND METRICS

* ( 1) aDirectorFirstName != null
* (2) aDirectorFirstName has between 1 and MAXIMUM_NAME_LENGTH
* characters
* ( 3) aDirectorLastName != null
* (4) aDirectorLastName has between 1 and MAXIMUM_NAME LENGTH
* characters
* (5) aDirectorSuffix != null
* (2) aDirectorSuffix has between 1 and MAXIMUM_NAME LENGTH
* characters
*/
public abstract void setDirector (
String aDirectorFirstName,
char aDirectorMiddleInitial,
String aDirectorLastName,
String aDirectorSuffix) ;
/***********************************************
* Returns: Title of this video product
*/
public abstract String getTitle () ;
/***********************************************
* Intent: Enter the title of this product in characters as close as
* possible to the orginal
*
* Preconditions:
* (1) aTitle != null
* (2) aTitle has between 1 and MAXIMUM_TITLE_LENGTH characters
*/
public abstract void setTitle (String aTitle) ;
/***********************************************
* Returns: Stars of this video product if known; otherwise
* a single object "unknown "
*/
public abstract String [l getStars () ;
/***********************************************
* Intent: Enter the stars of this video product if known; otherwise
* a single object "unknown "
*
* Preconditions:
* (1) someStars != null
* (2) someStars has between 1 and MAXIMUM_NUM_STARS objects
*/
public abstract void setStars (String [l someStars) ;

}

DEGREE OF TIME EFFICIENCY AS A DESIGN QUALITY MEASURE

20.6 DEGREE OF TIME EFFICIENCY AS A DESIGN QUALITY MEASURE
We inspect designs, and quantify how fast they are likely to execute when built. First, one identifies each
operation whose speed of execution is of interest. For example, we could focus on the speed with which the
Encounter video game transitions from area to area when a hyperlinked connection is pressed. (If this takes
too long, the game loses the player's interest.) This operation is illustrated in Figure 20.11.
To assess the time efficiency of this action, we trace the sequence of method calls that require its
execution and examine each of the methods for timing. Figure 20.12 shows the sequence of function calls
beginning with the pressing of a hyperlink and ending with the monitor displaying the destination area.
To assess probable time delays, a table like Table 20.1 can be used. It identifies the methods that are
potential sources of delay.
We then tackle problem methods one by one. For example, we use double buffering or build a
composite image before rendering it on the monitor.
The example in Figure 20.13 contains no parallelism. Its timing is not complicated to calculate as long as
one has reliable estimates for the parts of the operation. Recall that sequence diagrams are capable of
describing parallel operations, however. In that case, a timing diagram would be needed to deal with such issues
as differing start times and the need for more than one thread to use a resource that it could alter. To handle
this we commonly perform such handling via a method, and we lock all other callers out of calling the method
while it is operating. Figure 20.13 is an example in which thread 1 executed method 2, which locks out all
other callers such as thread 2. The latter waits until method 3 has completed for thread 1. The estimated
elapsed time is measured on the time axis.

Figure 20.11 Time efficiency example from Encounter video game-time to transition among areas

517

518

CHAPTER 20

DESIG N QUALITY AND METRICS

u ser

:AreaConnectionHyperlink

I

1. press

area
connection
hyperlink

I I

J

l

:RPGMouse
EventListener

J

:EncounterEnvironment

l

2. mouseClicked(}

5. setVisible( false)

x

I

l :Waiting

:EnCounterCast

J

:EncounterGame

3. handleEvent(}

'll

4, handleEvent(}

6. displayArea(}

:Area

7. display(}

I

:PlayerCharacter

I

ITl

I

9. showCharacter(}
I

8. displayPlayerCharacter(}

I I

Figure 20.12 Assessing time efficiency-example using a sequence diagram from Encounter video game

Metrics for time efficiency include the following:

Averaged elapsed time for operation X.
Maximum elapsed time for operation X.

Table 20.1 Identifying methods that are highest potential source of delay
Relative speed

Step

Function

0= negligible
1 = neither
2 = significant

1

Press area connection hyperlink

0

2

mouseClickedO

0

3

handleEventO

0

4

handleEventO

0

5

setvisible(false)

1

6

displayAreaO

2

7

displayO

1

8

displayPlayerCharacterO

2

9

showCharacterO

1
TOTAL

7/12

DEGREE OF SPACE EFFICIENCY AS A D ESIG N QUALITY MEASURE

Execute method 1

--.-JI Execute method 2

L-____

c::::::J

thread 1

L-_---'I

Execute method 3

Execute method 4

c=J

Execute method 5

�LI

�

____

Execute method 2

thread 2

Execute method 6

1---+----+---4---1---+---+1---'::»

time

Figure 20.13 Timing diagram for para l lel execution

20.7 DEGREE OF SPACE EFFICIENCY AS A DESIGN QUALITY MEASURE
The second major efficiency issue is space usage: secondary (typically, disk) storage, RAM usage, and binary
source size. We will discuss secondary storage first.
Analyzing secondary storage usage can be performed by identifying the operations that create storage
needs outside RAM. This divides further into temporary data (which is not needed after execution) and
permanent data. Table 20. 2 is typical of how we might account for this in the case of the video store application.

Table 20.2 Analyzing secondary storage
Source method and class
of storage creation or

Maximum rate

Minimum rate

Temporary or

of increase,

of decrease,

reclamation

permanent?

uncompressed

uncompressed

Rental: saveRentalO

T

514 bytes per

worst case

6 clients; Title 100
bytes; director 30
bytes; stars 4 bytes
x 30; length 2.

minute for 2 days

One title every 3
minutes.

Rental: removeRental()

o bytes per

P

minute for 2 days

90% of renta ls

returned within 2

days
DVDlnventory: saveDvDO

. . .

. . .

. . .

. . .

DVDlnventory: removeDVDO

. . .

. . .

. . .

. . .

519

1
I

Storage

1
l

1

11
21
31
41
5
6
71
81
91
101
111
12
13
1500

1

+

15001

2250

-4501
-7501
15001

r- 2550 1

-7501
15001

1

-451
-751
-4501
-7501
1500
.

3105

1

-301
-451
-751
-4501
-7501
15OD1

3240

i

1

-151
-301
-451
-751
-450
-750
15001

3360

1

1

-151
-151
-301
-451
-75
-450
-7501
15001

3465

1

1

Fseri�t] I

3570

1

-151
01
-151
-151
-151
-151
-301
-151
-451
-30
-7�-45
-4501
-751
-7501
-4501
-7501
15001
15001

4500 I_�=--"""'''''''''
''' ''''
'' '''''"'''''''''''''''''''''''''
''''''' ''
.,.
....
. ...1
4000 t-----------..;;..:---.;:.,.;.::;.
.
�...,.�:!::::.---1
.
3500 t---...;.------:x::
. _-:?....d!::...:.--�.,...
.
.,�-'-----!
3000 t-....-'.
-�
..-...::::...:.-:;:...
...
. +-...;.
2500 t--.7.-:::...:....;.....
2000 t-'&:...:.-...;..-:-':...,..,;....,...:....:."':-::-...l>�...,.-,:..:.
-l
.;.
1500 H�T""..--o:'i��....
..,.
.;.jo.l,..;���,..:;----l
1000 t-���...."""':---.-��,.�A�
500 t-���������������
O��������������
2 3
5 6
8
9
10 11 12 13

1 -2955i

2775 -

-751
-4501
-7501
15001

Figure 20.14 Secondary storage needs over time-video store example

�.

r:

B
�

r!
f!

9
D

31

r

r

�
!j
�
5

D

�- I

r

51
fl

al

[I
a-I

fl

DI

___

1I
0
rr-

rented on

3675

1

1

1

01
01
-151
-151
-15
-30
-451
-751
-4501
-7501
15001

I

sa

37801

1

1

01
01
01
-151
-15
-15
-301
-451
-751
-4501
-7501
1500

-­

38851-

-15
-15
-30
-45
-75
-450
-750
1500

�

0
0
0
0

��-4----�--���������--� ���--�r-��--�r-��--�+-��--��r

�

C/l

n

;;0

�

»
z
o
S

�

r

»

c

Gi
z
.0

m
C/l

o

;;0
N
o

�
m

»

o
I

CI1
N
o

DEGREE OF RELIABILITY AS A DESIGN QUAL ITY MEASURE

Data are often compressed prior to storage (at the expense of speed). In that case the uncompressed storage
needs are converted into compressed-form needs. Usually, the key issue in storage is the amount required over
the long run-in other words, the accumulation of data. Suppose for simplicity that the 5 1 4 maximum bytes are
compressed to 1 00 bytes and that the store is open 15 hours a day. The accumulating needs are shown in the
spreadsheet and graph in Figure 20. 1 4, and they suggest the problem that requires resolution.
Storage needs that increase without bound require special consideration. For this reason, designs often
involve periodic archiving or purging. In the case of the video store, this could consist of iterating through the
database weekly, charging all customers with videos whose fines exceed the DVD's value and archiving those
DVD records.

20.8 DEGREE OF RELIABILITY AS A DESIGN QUALITY MEASURE
This section discusses means for ensuring and assessing reliability at design time. To assess reliability in an
overall design, we look for points at which the application is most likely to fail. Recall that the UML design
models are use case, class, data flow, and state. We look for a high level for failure likelihood within each of these
models. Figure 20. 1 5 indicates places for use cases where failure is typically most likely.
Now let's consider how failures are likely to be evident at the class level. Here, we seek parts of the class
model that are most likely to harbor failures. Figure 20.16 illustrates two likely types of failure: choke points and

deep inheritance.
•

Data collection
•

From users

•

From other applications

•

From data communication

•

Steps causing complexity

•

Anomalous situations

"

•

Use case indicates involved operations
For example, attempt to rent multiple copies of a movie

Figure 20.15 Identifiable places in use cases where failure is typica lly most likely to occur

.. Choke points
A class that relates to
many other classes

II

Deep inheritance
Three or more levels of
substantive inheritance

Figure 20.16 Identifia ble places in class model where failure is typica lly most likely to occur-video store exam ple

521

522

CHAPTER 20

DESIGN QUALITY AND METRICS

member
banks
I

bank
name
account
display

account #

error

alert/none

account #

& deposit

account

Do
deposit
transaction

Create

data
deposit

transaction ---.

account

_

account

account

data

summary

database

Figure 20.17 Identifiable places in data flow diagrams where failure is typically most likely to occur-banking example

Choke points are potentially problematical because developers tend to make mistakes when the
situation is complicated. Deep inheritance can harbor errors because inherited properties are not readily
apparent to the developer. The number of types employed should be reduced, or aggregation should be used
instead to indicate what qualities are added between types.

Data flow diagrams can expose failure points most readily where multiple streams of data converge.Figure
20. t 7 shows a partial data flow for an ATM application. The validate deposit and validate inquiry functions each
relate to the most streams. The account database also relates to a relatively higher number of data streams. For
these reasons we would investigate these first for reliability. Since use cases control function call sequences in
data flow diagrams, we would investigate by checking whether use cases behave clearly at these points. We
would ask whether a different decomposition would make this clearer-for example, whether it is advisable to
get separate types of inquiries via separate operations.
Choke points can be reduced by introducing additional processing nodes and by decomposing nodes
into multiple nodes. For example, we could split Validate Inquiry into several validation operations.
The final design model we can inspect for reliability is the state model. Figure 20.1 8 shows the state model
for the Encounter video game. The Waiting state involves the most transitions, so we would check its
reliability first. If time allows, we would then move on to Engaging, and so on.
State diagram bottlenecks can be avoided by splitting states into several states or by introducing
substates. For example, if Waiting state becomes excessively involved, it may be possible to distinguish several
modes of waiting.

DEGREE OF SECURITY AS A DESIGN QUALITY MEASURE

Player
quits

�

�

Player moves t
adjacent area

{foreign
character
absent}

{foreign
character
present}

Encounter
completed
'-

Foreign
character ----­
enters area

Figure 20.18 Identifia ble places in state models where failure is typica l ly most likely to occur-Encounter video

game example

20.9 DEGREE OF SECURITY AS A DESIGN QUALITY MEASURE
Security is a special case among metrics because it concerns illegitimate "functionality" of the application that
it is capable of but is not specified. It may require a skilled perpetrator to obtain this functionality. An example
is "shall be capable of sending customer credit card information to any specified e-mail!"
How can one measure the degree of security of a design? Recognize first that every application must
communicate with hardware or software external to itself, otherwise it could not execute. In so doing,
however, it acquires some vulnerability. Figure 20. 1 9 illustrates the kinds of artifacts with which an
application's object code could make contact. These, in turn, can make contact with other artifacts.
In assessing the degree of security of a design, we are thus obliged to take a systems approach-that is,
one that accounts for the vulnerability of our application in the context of the larger system within which it

�;==='I

Figure 20.19 Analysis for security quality

�I

Drive d:

I

523

524

CHAPTER 20

DESIGN QUALITY AND METRICS

Security
encryptO
getUsersFromURLO

/

/

/

/

User
id*
password*

'encrypted

Figure 20.20 Beginning design for simple secure login

must operate. The added dimension here is that we must look not only at the potential of our application for
exploitation and damage, but also at its potential to harm artifacts to which it is connected.
Figure 20. 20 shows a start for a design of a critical security element of an application. Inspecting it for
each security factor in Figures 20.2 1 and 20.2 2 provides a framework for assessing its level of security. We
need to satisfy ourselves that an implementation exists of the class model that satisfies every security factor-the
class model by itself does not guarantee any of them.
There are many approaches to measuring the security of a detailed design. We will discuss a few
examples. In the first example, we make rough assessments, on a scale of 0 to 10, of the main aspects of
security, as introduced in Chapter 1 8. These are shown in Figures 20. 2 1 and 20. 2 2. Although it is difficult to
make these assessments based on a detailed design, this process is better than making a single, overall
assessment about the degree of security.
For a second approach example, consider the following metric examples, adapted from [3].
Metric 1 Baseline Defenses Coverage: This is a measurement of how well the detailed design enables
one to protect the environment of the application against "the most basic information security threats" These
require careful definition, but they do include viruses, for example. This metric assumes that security tools will
be used such as firewalls and antivirus software. Some vendors claim that the coverage of devices by these

•

Confidentiality
•

•

•

•

Degree to which data passed may become visible to the unauthorized
#
Estimated percentage of data compromises

Nonrepudiation
•

Degree to which parties can prove the existence of agreements

•

Estimated percentage of unprovable agreements

Integrity
•

Extent of ability to validate that data are not altered in transit

•

Estimated percentage of messages alterable in transit

Figure 20.21 property-based security metrics, 1 of 2

#

i. e. , of a specified severity

ASSESSING QUALITY IN ARCHITECTURE SELECTION

•

•

Authentication
•

Extent of ability to validate user's identity

•

Estimated percentage of improper authentications

Authorization
Degree to which permission to deal with privileged data may be compromised
•

•

•

Estimated percentage of unauthorized permissions

Availability
•

Degree to which availability could be compromised; e.g., by denial-of-service attacks

•

Estimated number of availability* compromises per year
*i.e., of given severity

Figure 20.22 property-based security metrics, 2 of 2

security tools should be "in the range of 94 percent to 98 percent. " The meaning of these percentages would
require definition too, and backup for claims would be needed.
Metric 2 Patch Latency: This is the time between the identification of a successful security exploit and the
development of a patch that renders it impossible. Patches are usually replacement files. Thus, if the detailed design
decomposes the application into an appropriate number of well-identified files, patch latency is likely to improve.
Metric 3 Password Strength: This metric measures how hard it is to break (guess at) a password, in some
well-defined sense, including finding potential weak spots where systems use default passwords. Breaking
passwords is usually performed with the assistance of separate software.
Metric 4 Legitimate Traffic Analysis: This is a family of metrics that measures the extent to which
illegitimate traffic could be allowed. It includes incoming and outgoing traffic volume, incoming and outgoing
traffic size, and traffic flow with the application.
A third approach is to put the detailed design under a microscope, as it were, and measure the extent to
which it is likely to avoid common known security gaps. One example is buffer overflow, in which the bounds
of an array are exceeded in order to access data in regions of memory adjacent to it. The content type of these
regions is effectively guessed at. Another is SQL injection, which exploits the manner in which database
queries are processed. This exploit effectively inserts comm ands such as "send all credit cards

. " within an

apparently innocuous input data field. Detailed designs can be specified that help guard against many such
exploits. Tools are available to check for these types of oversights in code, but designs are less standardized
and tools checking for security flaws are rarer.
In reality, we combine elements of all three approaches. A good reference for some of the ideas in this
section is Anderson [7].

20 .. 1 0 ASSESSING QUALITY IN ARCHITECTURE SELECTION
So far, this chapter has based design assessment on the individual qualities that good designs must possess.
Now we explore a more holistic view of quality, starting with the high-level view.

20.10.1 Metrics for Architecture Quality
Although most applications can be implemented using one of several possible architectures, some choices are
much better than others. Important decisions like architecture selection are m ade by first developing and
comparing alternatives. Proposed architectures are thoroughly examined for defects, because finding a defect
at an early development stage has a huge payoff compared with allOWing one to persist through the process
and then trying to repair it.
As described in Figure 2 0 . 2 3, one simple way to compare architectures is to weight the attributes required
and then assign a fuzzy qualifier to each candidate. The kind of procedure described in Figure 20.2 3 can then be

525

526

CHAPTER 20

DESIGN QUALITY A N D METRICS

Architecture alternative

1.

State

design

pattern

2. ad hoc GUI-

3. State-transition

driven

table

Quality weight:

Quality

1- 1 0

Extension

9

Change

7

Simplicity

High

=

9; Medium

=

5; Low

=

2

High

Low

Medium

High

Low

Medium

5

Low

High

Medium

Efficiency: speed

5

Medium

High

Medium

Efficiency: storage

2

Low

Low

Medium

1 83

1 26

140

TOTAL (higher

=

1

better)

Figure 20.23 A fuzzy method for comparing architectures

used to compare alternatives. For the sake of simplicity, we have omitted some of the design qualities discussed
above in this example. One way to weight qualities is to pick the most important one and give it a weight of to, or

9 (if you want to provide for a quality that may be introduced later). The least significant are assigned t , and the
remaining ones are given weights in between.
Important decisions such as architecture are often made by groups. A group uses a Delphi process when
the members make individual decisions first, then submit them to the coordinator or leader. Boehm and
Farquhar (see, for example, [4]) introduced the "wideband" Delphi process in which the leader plots the
results on a chart without attribution to the owners and leads a discussion on the factors involved.
The following metrics from the IEEE [5] can be used to measure the complexity to software designs.
IEEE metric t 3. Number of entries and exits per module (package) . This can be equated with the number of
public methods accessible from outside the module. The number of exit points can be counted by the
number of public functions that return values to the caller or make changes in the environment external
to themselves. The goal is to keep this measure as low as possible to favor narrow interfaces.
IEEE metric 15. Graph-theoretic complexity for architecture. The simpler ("static") version of this metric is
(Number of modules in the architecture) (Number of modules having at least one connection between them) + t
The goal is to keep this number high, since a low number indicates many connections and thus an
increased potential for errors.
IEEE metric 2 5 . Data or information flow complexity. This measures the information flow of large-scale
structures, the procedure and module flow complexity, and the complexity of the interconnections
between modules. The reader is referred to metric 4.25 of [5] for the details.

ASSESSING QUALITY IN ARCHITECTURE SELECTION

:
f-si�lt���
!.-------..:----,
l

- - -- - -- ----------- - - - .

!QueueForTellelf<
-

---

--,

,.--

-

:

/
/

/

: imEventl:
:�Simltem��: ----1lS
:

--:mmn

_____

: SimEvents :

;-------------!---�

m i
_

......-...-

:

,
,
,

,,

,-------------,

v"'-

......-...-

SimContiguration I
setUPO

:

I

.......

...-.......

:
,
I

executeO
....--

initializeO

--

--

I
I

r

:

-mnnn�

I
I

:

,------------

,
I

:- - - - - - - - - - - - - - ---!

,

SimDriver :

- - - -� - - - �- -- - - - - - - - - - �
:
I
I

I

I

-�-R��d�� i

I
I

+
I
I

timeO

:

:- - ---- - --'- --------- ---:

�-m-

Simulation

�:: !Number!::
Teller

.......:.......

/

!..._________..o _____ .,

ervic�Duration

...- "'-

I

ScheduledEvents

!

:

:
:
,

:

,,
,,
removeEarliestO
,,
'---- - ------------ - --------------'
addEventO

Figure 20.24 An architecture for a si mulation

A connection between modules A and B is dependence in either direction. As an example, we can apply
metric 15 to the architecture of a bank simulation shown in Figure 20.24.
The architecture divides the simulation into the following packages.

SimConfiguration-which describes the way in which the stations are laid out within the bank
SimItems-which describes the entities that move about within the bank (primarily customers)
SimEvents-which handles the present and future simulated events that take place in the bank (e. g. , a
customer arriving at a teller window)

Simulation-the mechanism that drives the simulation (primarily by selecting the next event to execute,
executing it, then orchestrating the consequences, including the generation of resulting events, and
queuing them in the ScheduledEvents object)

Random-the package that handles the generation of random numbers according to various distributions
(for example, producing the duration of service for the next transaction)
This architecture is designed using the Facade design pattern, and we will suppose that the only
interfaces between packages are those shown. There are five nodes (packages), and there are five pairs of
modules between which there are function calls (either way). Thus, the graph-theoretic architecture
complexity is 5 - 5 + 1 = 1. This suggests an uncomplicated architecture, which is generally good.
Metrics like those listed above provide quantification, but how do we use the resulting numbers?
Typically, this has to do with historical data. For example, we can easily tell that the EncounterGame package
has four public functions at this point (see the case study on the book Web site). Perhaps we can forecast that
this number will grow to between 10 and 15. These numbers are compared with the corresponding average
numbers for past projects. If the average number is 10 and we have been satisfied with the modularization of
past projects, then this value causes no alarm. However, if the average number for past projects is 8 and we are
headed toward 15, then a closer look at the architecture and such is needed.

527

528

CHAPTER 20

DESIGN QUALITY AN D METRICS

.... - - - - - - - - - - - ...,
RolePlayingGame I

:

I
I

r------------------------------------� ------------

I

:

state

I
I
I
I
I

:
�

:

I
I
I
I
I

( state.handleEventO; J
_____________

________

:

J

:E����t;;G���:

i - - L-------.--'

---------------�

I
I
I
I
I
I
I
I

handleEventO

: ,-------'--,
: handleEventO

Engaging

I
I

handleEventO

I

handleEventO

Figure 20.25 An architecture for Encounter: State design pattern appl ied to the video game

20.10.2 Choosing an Architecture among Alternatives
We resist the urge to commit immediately to one architecture by comparing alternatives. As an example, let's
consider the architecture of the Encounter case study.

Alternative 1 for the Encounter case study: State design pattern.
As shown in Figure 20.25, the State design pattern is a possible architecture for Encounter, and we will
trade it off against other candidates.

Alternative 2 for the Encounter case study: ad hoc GUI- driven architecture.
A second architecture might dispense with the idea of state altogether and build separate event­
handling code into each GUI object that is sensitive to mouse or keyboard actions. Such an architecture is
shown in Figure 20. 26, where selected methods are included to clarify it.

IA�tk,;;L � L�;;;-e�
�
_ _ _ _ _ _

�------

I

I

Area
display()

0
'---

12

.

I

AreaConnector
area 1
area2
transition()

-, ForeignCharacter

I
I

Play'erCharacterWindow

I PlayerCharacter
Figure 20.26 A second a lternative architecture for Encounter

set( Quality, float )
exit()

ASSESS I N G QUALITY IN ARCHITECTURE SELECTION

Event

Key, if this ->
went OCC14f5
while EHcoutltrr
is iH this 1
s tate, the..
�erfonn the

Click on
exit

Dismiss
quality
window

Request
quality
change

Foreign
character
enters

comspoHdiHg

Go to

Show quality

Remove qual ity

Show both

actioH iH the

i ndicated area

wi ndow

window, and

characters, and

table.

Transition to

transition to

Waiti"9 state

Engaging state

Foreign character leaves

Compute
results of

Engaging

Current
State

engagement,

(do noth i n g )

and transi tion
to WaitiHg
state

+

Setting
qualities

Transition t o

Transition to

Transition to

WaitiHg state

EHgagiHg state

WaitiHg state

Figure 20.27 A third a lternative architecture for Encounter: table-driven state-transitions

In th is architecture the hyperli n ks at the exits to areas are (CUI representations of) AreaConnector
objects; and each has event-handl i n g code . For example, clicking on an exit to the dungeon should cause
the screen to display the dungeon area. The resulting design is C U I - driven, somewhat ad hoc, and
language - speci fic. There i!; n o clear connection, however, between the code for th is design and the
conception of the game as a series of state transitions. As a benefit, however, the class model contains fewer
classes .
Alternative 3 for the Encounter case study: state - transition table .
A third architectural alternative is t o retai n the idea of states, but express the state transitions b y means
of a table. Table-driven state transitions are emphasized by Shlaer and Mellor [6], for example. Figure 20. 27 is
an example of such a table. Th is architecture uses the State concept, but it does not use the State design
pattern .
Here is a list of pros and cons contrasting the State design pattern with the table- driven approach. A
ful ler comparison of the three architectures follows.
Pros of using the State design pattern:
•

Can easily add or modify states to accommodate change i n game design

•

C lari fies what acti ons can be done in various circumstances

•

Classi fies all mouse events that can affect Encounter
Cons of using the State design pattern:

•

•

Class model i s more i nvolved and i nitially more difficult to understand.
Duplicate data: The state of Encounter could be deduced from variables other than the state obj ect,
incurri ng the possibility of programmer error if these variables and the state object become inconsistent.

529

530

CHAPTER 20

DESIG N QUALITY AND M ETRICS

Fuzzy method for compari ng
arch i tectures

Architecture alternative

1 . State design
pattern

2 . ad hoc CUI­
driven

3. State - transition
table

Quality

Quality weight:
1-10

Extension

9

H i gh

Low

Medium

Change

7

H i gh

Low

Medium

Simplicity

5

Low

H i gh

High

=

9; Medium

=

5 ; Low

=

2

Medium
�

5

Efficiency: speed

Medium

H i gh

Medium

Low

Medium

1 26

1 40

+

Efficiency: storage

2

Low
+

TOTAL (higher

=

better)

1 83

Figure 20.28 Fuzzy method for comparing a rchitectures for Encounter

Pros of using a table for describing state:
•

The table is easy to understand and the contents are easy to change .

•

Th is arch itecture can be implemented in a non-object-oriented language .

•

Documentation on this approach is available usi ng the Shlaer-Mellor method.
Cons of using a table for describing state :

•

It requires a data structure that is virtually global (the table ) .

•

Augmenting the table with new states a n d actions may disrupt existing code a n d design .

Figure 2 0 . 2 8 shows a comparison of the three architectures using the pros/cons tech n ique described
above . Given the weighting shown , which favors extensibility and change, the architecture based on the
State design pattern comes out ahead.
Regardless of the systematic means one uses to evaluate alternatives, engineers also perform "sanity
checks," using hol istic perspectives and the intuition and experience of team members. Th is may concern the
number of classes i nvolved or even subjective factors such as elegance. If the result disagrees with that of the
more objective process we have described, engineers may re -examine the process and the results.

20. 1 0.3 Verifying Architectures
Use cases are developed to express customer requirements. They can't take into account the application's
archi tecture since it will not yet have been determ ined. Once the architecture has been selected, however, it
is essential to revisit the use cases to check that the architecture supports them adequately. For example, the
Engage Foreign Character use case shown i n Chapter 1 1 must execute upon the architecture we have developed.

ASSESSI N G THE QUALITY OF DETAILED DESIGNS

Gn;i 'p]
Player
completes
setup

Player
dismisses
window

Player
dismisses
qualities
menu

Foreign
character
enters area
character
enters area
Figure 20.29 Defects in the state-tran sition diagram for Encounter

Since we retain the domain classes throughout the process, the classes originally referred to in the use case
should be present among the classes in the design . Typically, the sequence diagrams for the use cases now
involve additional architectural classes (e.g., Facade classes) .
Archi tectures are inspected agai nst requirements . The metrics mentioned above provide a concrete
basi s for the i nspection. For example, i nspection of the archi tectural framework packages for Encounter could
lead to the conclusion that there are no requi rements yet for game arti facts and that the presence of theArtifact
package is a defect. Consider the Encounter state-transition diagram shown in Figure 20.29 as an additional
example. A perusal of th is state diagram could yield the defects noted in the figure . These defects can be
removed by clari fying the names and/or descri ptions of the events referenced.

20.1 1 ASSESSING THE QUALITY OF DETAILED DESIGNS
Recall that detailed design consists of all design that is not at the highest, architectural level , but is short of
code itself. In this section, we review quantitative measures of effectiveness i n detailed design .

20.1 1 .1 Techniques for Assessing the Quality of Detailed Designs
Figures 20. 30, 20.3 1 , and 20.3 2, show steps for ensuring the quality of detailed designs.
Metrics for detailed design are provided in this section that satisfy Step I in Figure 20.3 0. Steps 2, 3 , and
4 are checks that the detailed design expands on all of the architecture, and nothing more.
Step 5 ensures that a design is complete. It is easy enough to check that every method of every class is
properly speci fied, but how do we know that we have included all of the classes and methods that are
necessary? To do this, we return to the requirements and ensure that the detailed design we have developed
accommodates all of the requirements. If we use the requirements organization as in the case study, then we
know that every functional requirement corresponds to a specific method. Thus, the functional completeness
task is reduced to ensuri ng that each of these methods can be called at an appropriate point in the execution.
Consider, for example, the requirement:

53 1

532

CHAPTER 20

DESIGN QUALITY AND M ETRICS

1 . Prepare to record metrics duri ng the design process .
Include ( 1 . 1 ) time taken; ( 1 . 2 ) type of defect; ( 1 . 3 ) severity
2 . Ensure that each architecture module is expanded.
3. Ensure that each element of the detailed design is part of the architecture .
If an element does not belong to any such module, the archi tecture may have to be revised.
4. Ensure that the design ful fills its required functions.
5 . Ensure that design is complete (classes and methods ) .
6. Ensure that the design is testable. +
t See Chapter 5 for inspection procedures.
•

•

Figure 20.30 I nspecting deta iled deSigns, 1 of 3

7. Check detailed design for •

•

•

•

•

simplicity
a design that few can understand (after a legitimate effort!) is expensive to maintain, and can result i n
defects
generality
enables design of similar applications?
expandabil i ty
enables enhancements?
efficiency
speed, storage
portability

Figure 20.31 I nspecting detai led deSigns, 2 of 3

8. Ensure that all detail is provided
•

Classes
Class i nvariants clear? (required limits on attributes; required relationships among attributes)
Methods
Preconditions
I nvariants
Postconditions
Pseudocode
•

•

•

•

•

•

Figure 20.32 Inspecting detailed designs, 3 of 3

3 . 2 . EC. 3 . 2 Configurability oj Encounter character quality values
Whenever an Encounter character is alone in an area, the value of any of its qual ities may be set.
The value chosen must be less than or equal to the sum of the qual ity values .
We have already ensured that a function to perform this requirement exists, but to veri fy that our design
supports the execution of this function, we have to effectively walk through a fully representative set of

ASSESSING THE QUALITY OF DETAILED DESIGNS

function calling sequences, each of which exercises the function. This amounts to developing a set of mental
test cases, and the results should be saved for the testing phase. Here is such a set.

Begin game; call up window to set qualities; set quality; set quality again; dismiss window.
Move to area with no foreign character; call up window to set qualities; set quality; dismiss window.
Complete engagement; wait until foreign character departs; call up window to set qualities; set quality; dismiss
window.
For each of these scenarios, we verify that the classes and methods do indeed exist to accommodate it.
Once we have done this for every functional requirement, we will have verified our design from the functional
point of view. We can perform a similar process with our detailed design for every nonfunctional requirement:
We can verify mentally, and via calculation (e.g., in the case of timing) that the design supports each of them.
Once again, the work we do to create each of these sequences can be used to develop tests that we apply once
the i mplementation has been performed.
Step 6 calls for testability. In other words, is it a reasonable process to test the elements of the design? A
design that can't be readily separated into parts tends to be untestable. An effective way to ensure this
property is to write tests for each design element as soon as it is specified.
Step 7 concerns the properties that we desire from our detailed designs. We desire all of these
properties, but it is usually not possible to have them all. In particular, simplicity may be in conAict with
generality and expandability. Design patterns often introduce additional classes, too. Thus, it is best to specify in
advance which of these properties we care most about, and then evaluate the design against them. If
portability is paramount, we can establish scenarios for implementation on each desired platform.
Step 8 checks that every detail is given, short of code. The orthodox definition of "detail" refers to a complete
description of the design short of code itself. Agile methods tend to focus only on key details up front, typically
leaving most details until code time. It is common for designers to postpone many details until implementation
time because the specification of detail is time consuming. For critical portions of an application, however, this is
usually a mistake. There are many issues to consider at implementation time, and so thinking through the details of
critical sections beforehand, and inspecting them separately, can pay off handsomely.

20.1 1 .2 Metrics for Detailed Design

Detailed design metrics include counting the number of modules, functions, entry points, and exit points. For
object-oriented implementations, this translates into counting the number of packages, the number of classes,
the number of methods, the number of parameters, the number of attributes, and so on. When classes are
provided with complete class invariants, this increases the chances that the resulting method is of high
quality. When preconditions, invariants, and postconditions for a method are all stated in precise terms,
chances are that the resulting method is of higher quality than otherwise. These can be measured as follows:

Percentage of classes supplied with precise class invariants

Percentage of nontrivial methods supplied with precise preconditions, invariants, and postconditions

533

534

CHAPTER 20

DESIGN QUALITY AND METRICS

A comprehensive, albeit more complicated metric is IEEE metric 19 "design structure" (see [5]), which
determines "the simplicity of the detailed design" of a program.
20 .1 1 . 3 Inspection of Deta i led Designs

The overall principles and practice of inspections were expressed in Chapter 5. The inspection of detailed
designs consists of inspecting classes, their method prototypes (name, return type, and parameter types), the
flowcharts and pseudocode, and the relationships among classes and methods within various models. These
models can include the use case models and their associated sequence diagrams, the class model, the state
models, and the data flow model.
As with all inspections, data about each defect are noted, including its severity, its type, and the
probable source of the defect in the project life cycle. The IEEE standard 1044. 1 classifies severity as shown in
Figure 20. 33.
Designating a defect classification scheme helps to prioritize repair work: However, we avoid using
more categories than necessary because time is consumed categorizing defects. The triage classification,
shown in Figure 20. 34, is fast but provides less information than IEEE 1044 . 1.
Defect types can include those listed below, which have been taken from IEEE standard 1044. t - 1995.
The types that apply to detailed designs for Javadoc-Ievel inspections are marked "XDOC," and for
pseudocode-level inspections are marked "PS" .
•

•

Logic problem (forgotten cases or steps; duplicate logic; extreme conditions neglected; unnecessary
functions; misinterpretation; missing condition test; checking wrong variable; iterating loop incorrectly,
etc.) PS
Computational problem (equation insufficient or incorrect; precision loss; sign convention fault) PS

Severity

Description

Urgent

Failure causes system crash, unrecoverable data loss; or jeopardizes personnel
Causes impairment of critical system functions, and no workaround solution does exist
Causes impairment of critical system functions, though a workaround solution does exist
Causes inconvenience or annoyance
None of the above

High
Medium
Low
None

Figure 20.33 IEEE 1044.1 Severity classification
Source: IEEE 1044.1, 1995.

Defect Severity Classi fication using Triage
Severity

Description

Major

Requirement(s) not satisfied
Neither major nor trivial
A defect that will not affect operation or maintenance

Medium
Trivial

Figure 20.34 Classifying defects by severity using triage

ASSESSI N G THE QUALITY OF DETAILED DESIGNS

•

•

•

•

Interfacerriming problem (interrupts handled incorrectly; I/O timing incorrect; subroutine/module
mismatch) PS
Data-handling problem (initialized data incorrectly; accessed or stored data incorrectly; scaling or units of
data incorrect; dimension of data incorrect) XDOC, PS
Scope of data incorrect XDOC, PS
Data problem (sensor data incorrect or missing; operator data incorrect or missing; embedded data in tables
incorrect or missing; external data incorrect or missing; output data incorrect or missing; input data
incorrect or missing) XDOC, PS

•

Documentation problem (ambiguous description, etc.) XDOC, PS

•

Document quality problem (applicable standards not met, etc.) XDOC, PS

•

Enhancement (change in program requirements, etc.) XDOC, PS

•

Failure caused by a previous fix XDOC, PS

•

Performance problem (associated with test phase)

•

Interoperability problem (not compatible with other software or components) XDOC, PS

•

Standards conformance problem XDOC, PS

•

Other (none of the above) XDOC, PS

Let's inspect pseudocode examples. The inspection focuses on defects in commission (whether the
methods chosen are appropriate) and omission (whether there are other methods that should be
included). The pseudocode for a method should be checked against the corresponding requirement in
the SRS or in the SDD. For example, the following is an early draft of a D-requirements of Encounter
from the SRS:
"(essential) Every game character has the same set of qualities. Each quality shall he a non-negative floating point
number with at least one decimal of precision. These are all initialized equally so that the sum of their values is 100.
For the first release the qualities shall be concentration, stamina, intelligence, patience, and strength. The value of a
quality cannot be both greater than Zero and less than 0.5."
This requirement is implemented by the function adjustOuality(String aOuality, float aOualityValue) with
the pseudocode to be inspected as shown in Figure 20. 35.
An inspection of this pseudocode should expose the following defects.
1. Line 9: method setOualityC) should be mentioned.
2. Line 10: lacks detail on how to allocate the remaining quality values; also, why always "reduce" (why not
sometimes "increase")?
Recall that the inspection process should merely establish that there is a defect in each case. No time
should be spent by the in spection team trying to repair this defect during the inspection meeting. The
triage severity classi fication of defect 2 (relating to line 10) is "maj or" because its interpretation can lead
to significant differences in the product. Using the IEEE 1044. 1 standard, its classification is
"computational."

535

536

CHAPTER 20

DESIGN QUALITY AND METRICS

1

IF aQuality is not recognized

2

Log error to log file

3

Inform user qualities unchanged

4

setQuality()
IF aQualityVa/ue out of bounds

5

mentioned

Log error to log file

6

should be

Inform user qualities unchanged

ELSE
Set the stated quality to aQualityVa/ue
Reduce the remaining qualities,
Make these

... retaining their mutual proportion,

preconditions

... making the sum of qualities unchanged

as well
L-.-____-----I

DIF

ENDIF

Lacks detail on how to allocate
the remaining quality values

Figure 20.35 Inspecting pseudocode for defects

20.1 2 SUM MARY

A software design is assessed in terms of design qualities such as sufficiency, robustness, flexibility, reusability,
efficiency, and reliability. Metrics are defined, collected, and assessed for each quality. In addition, the IEEE has
defined several metrics for assessing the complexity of designs. These include number of entries and exits per module,
graph-theoretic complexity for architecture, and data or information flow complexity.
When selecting an appropriate software architecture for an application, we explore several alternatives
and compare their relative strengths and weaknesses. Each is measured against several qualities to determine
which alternative is the strongest.
The quality of detailed designs is pursued by following steps such as ensuring that each architectural
module is expanded, each part of the detailed design maps back to part of the architecture, the design fulfills
its requirements, the design is complete and testable, and all the necessary details are provided.
Inspections are used to find design defects. They focus on inspecting classes, their method prototypes
(name, return type, and parameter types), the flowcharts and pseudocode, and the relationships among classes
and methods within various models, such as use case, class, data flow, and state. Defect types can be classified
using the categories specified in IEEE standard 1044. 1- 1995. These include the following types of problems:
logic, computational, interface/timing, data handling, incorrect scope, data, documentation, performance,
interoperability, and standards conformance.

20.1 3 EXERCISES
1.

a. List the qualities that designs should possess. In your own words, describe the meaning of each.
b. Choose three of these qualities. For each, give enough of two different designs for the
following application to clearly distinguish one that scores higher than the other in terms of

BIBLIOGRAPHY

the quality. The application takes as input the academic record of a high school student and
produces as output three careers to which the student appears to be well-suited. An
explanati on is provided as well.
2. Consider an application that helps manage a fabric store. Assume that the stores sell fabrics and
associated items such as buttons and ribbons. Give three to four robustness issues specific to this
application. Explain your choices.
3. Below is code for a method divide(). Make the method more robust in at least two ways.

public double divide ( Double aNumerator , Double aDenominator )
{
return aNumerator. doubleValue ( ) / aDenominator . doubleValue () ;
}

4. Consider a design for a video store application.
a. Suppose that we use just one class VideoStore, which allows the entry and removal of a video
name assigned to a customer, stored via a telephone number as key. What exactly is inflexible
about this design?
b. Give an alternative UML class model that would accommodate the inclusion of additional
operations.
c. Which of the classes that you introduced are likely to be reusable in other applications?
d. How can you make more reusable the classes that reference Video?
e. Which classes are unlikely to be reusable in other applications in any case?
5. Your instructor will pair up student project teams. Conduct an inspection of the other team's
software design. Evaluate the classes specified in the design and score them using the list of
qualities and metrics described in this chapter. How would you rate the overall design?
"-----------�

BIBLIOGRAPHY
I. Henry, S., and D. Kailua, "Software Structure Metrics Baseclon Infonnation Flow," JEEE Transactions on Software Engineering, Volume SE-7,

NO.5, pp. 510--518, September 1981.
2. Shepperd, Martin, "Design metrics, an empirical analysis," JEEE Software Engineering Journal, Vol. 5, No. 1, January 1990, pp. 3-10.
3. Berinato, Scott. "A Few Good Information Security Metrics," July 2005, httpj/www.csoonline.comlarticlel2204621A_Few_Cood_lnfonnation_
Security_Metrics7page� I) [accessed November 29, 2009].

4. Boehm, Barry, "Software Engineering Economics," Prentice Hall, 1981.
5.

"IEEE Std 982.1-2005 IEEE Standard Dictionary of Measures of the Software Aspects of Dependability," IEEE Std 982.1-2005.

6. Shlaer, Sally, and Stephan Mellor, "Object Ufecycles, Modeling the World in States," Prentice Hall, 1992.
7. Anderson, Ross, "Security Engineering," John Wiley & Sons, 200 I.

537

Advanced and Emerging
Methods in Software Design
(Online Chapter)

21 .1 DESIGNING I N A DISTRIBUTED ENVIRO N M ENT
21 .2 I NTRODUCTIO N TO ASPECT-ORIENTED PROG RAM MING
21 .3 DESIG N I NG FOR SECURITY WITH U M LsEc
21 .4 MODEL-DRIVEN ARCH ITECTU RES
21 .5 THE FORMAL DESIGN PROCESS I N B
21 .6 SUMMARY
21 . 7 EXERCISES

To access this online chapter please visit waveland.com/Extra_Material/32306/.

principles of Implementation

;<'�n.n�

Testing

The Software
Development
Lifecycle

Implementation

Planning

How do teams choose programming
languages for implementations?
How does one define classes? methods?

\

What are standard implementation
practices?

Requirements
analysis

�DeSign /

How do you handle variable naming? Global
variables? Function parameters?
Initialization? Comments?
What is "defensive programming"?
How do you handle errors?
What does it mean to "enforce intentions?"
What are good coding standards?
What implementation tools and environments
are available for programming?
How do software engineers working on large
projects go about programming?
How should student teams organize for the
implementation phase?

Figure 22.1 The context and learning goals for this chapter

540

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

Code is created from design, whether the design is expressed in writing or not. In the 00 case, this
means that many of the classes-and perhaps the methods as well-may already have been identified and
defined by the time programming begins. The main goal of the programmer is to translate the design into
code that is correct, bug free, and maintainable. Many techniques and guidelines exist to help the
programmer achieve these goals, and these are covered in this chapter.
Code listings are provided in Section 22.t5 that illustrate several of the precepts discussed in this
chapter.
22.1 AG ILE AND NON-AG ILE APPROACHES TO I MPLEM ENTATION

This book has reviewed the idea that agile and non-agile approaches differ but also support each other. If the
approach used on a proj ect is agile, then implementation-the subject of this chapter-is begun just as soon
as the first user story has been understood. That is very early compared with non-agile approaches. For agile
projects, implementation is viewed not only as building the application but also as a process of understanding
the requirements. The very act of determining classes and methods is a process of fleshing out a realization
of the current user story. There is no other requirements analysis or design or documentation process unless
the team feels the need for these in the course of implementing each user story. As the implementation
progresses, the process of refactoring (see Chapter 24) is viewed as enabling developers to alter the design
and implementation to suit evolving requirements.
On the other hand, if the approach is non-agile, then requirements and a design (though not necessarily
of the entire application) are in place when implementation begins.
22.2 CHOOSING A PROG RAMM ING LANGUAGE

The programming language selected for implementing a design is usually dictated by the company, the
customer, or the environment in which the application must run. For example, if the application is Web­
based, some JavaScript may be required. If the company is a Microsoft-only shop, then C# may be the only
choice. Given a programming language, it is then necessary to select an interactive development environment
such as Eclipse for Java or Visual Studio for C#. When the freedom exists to select a programming language,
an identification and weighting of selection criteria can be used to assist the decision. Features of languages
needed for the application constitute one set of criteria. Another criterion is the availability of useful libraries.
The degree of software engineers' expertise in a language is yet another factor, and its weight is usually high.
As of 2009, most languages used are object-oriented. Many of the principles discussed in this chapter
apply, whether the language is object-oriented or not; others make sense only for 00 applications.
22.3 IDENTIFYING CLASSES

Let us first look at the origin of classes, which is the basis for an implementation. Each class has one of three
origins. Domain classes refer back to the corresponding parts of the requirements for their intent; design classes
refer to the Software Design Document (SOD). Inevitably, additional classes will be needed that were
not envisaged in the design. We can call these implementation classes. The origins of a class are summarized in
Figure 22.2.
A class should have a name that makes sense to its audience. For example, VideoStoreCustomer is such a
name, whereas StObsNobKI probably isn't. Class invariants should be stated and observed by all of the
methods of the class. These are concrete statements (e.g., limits on values) about the class attributes and their
relationships. The constructors and nonstatic methods of the class are designed to assume but also to enforce
the class invariants, thereby making their purpose within the class more explicit and, in consequence, making

DEFIN ING METHODS

•

Domain class
•

•

•

Design class
•

•

•

•

Corresponds to a requirements paragraph
Example: DVD

Specified i n SOD
Not a domain class
Example: RentalItem

Implementation class
•

Too mi nor to specify i n design

Figure 22.2 Where the classes in an 00 implementation come from

the class more reliable. The Rental class in listing 22.2 (Section 22. 15. 1)' for example, specifies the following
invariant and a method, checkInvariant() used for unit testing.

/* Class invariant:
E ITHE R
the rental is inactive , id == ID_WHE N_RE NTAL_NOT_IN_E FFE CT ,
rentalCustome r == null , and rentalIte m
null
OR
ID_WHE N_RE NTAL_NOT_ IN_E FFE CT < id < =
HIGHE ST_ALLOWABLE _RE NTAL_ ID ,
re ntalCustome r ! = null , and rentalltem ! null
*/
==

=

The most important goal of a block of code is for it to satisfy its purpose. We refer to such code as
"correct." This means, first, that the programmer knows what that purpose is; second, the programmer writes
down that purpose precisely within the comments; third, the code implements the purpose; and fourth, the
programmer explains, formally or i nformally, why the code fulfills the purpose. The intent/preconditions/
postconditions/return/inline comment format covered in the next section is designed to help realize the goal of
correctness .
22.4 DEFI N I NG M ETHODS

When all is said and done, the work of an application is performed by its methods (also known procedures or
functions). For that reason we take special care to state the purpose of each within the code comments . These
can be effectively organized under categories such as intent, precondition, postcondition, return, invariant, exceptions,
and known issues. The intent and known issues are informal, but the rest are precise. They specify completely,
couching statements in terms of named variables .
The intent is documentation that programmers usually provide: an i nformal statement of what the
method is intended to do. For example, the methodg etNextRentalNum b er () in the class Rental of Listing 22.2 has
the following:

Intent: Get the next ava ilable nu mbe r for ass igning a rental

541

542

CHAPTER 22

PRINCIPLES OF IMPLEMEN TATION

This helps a lot in explaining the meaning of the method. Note that it is not a precise or thorough
definition. If the method corresponds to a documented detailed requirement or if it is specified in the design,
the intent statement may simply reference this.
The preconditions define the assumptions that the method makes about the value of variables external
to the method, including the parameters. This excludes local variables. The method setld() in listing 22. 2,for
example, has the following preconditions:

anId > RE NTAL_ID_WHEN_NOT_IN_E FFE CT &&
anId <= HIGHE ST_ALLOWABLE _RE NTAL_ID
In other words, the method's code assumes that anId is within the legal bounds. Notice that the
specification of preconditions is precise-usually stated in terms of concrete, named variables. For all but the
"Intent" section, vague statements lead to ambiguity and should be avoided.
The postconditions specify the method's effects. Every method has a return or a postcondition. This is
because methods exist to have effects. There is no reason for their existence otherwise. The effect does not
have to be permanent. For example, a method that displays the acknowledgement "DVD Rental Completed"
has the following postcondition:

"DVD Rental Completed" is present on the monitor .
More commonly, postconditions refer to variables whose values could change. The constructor

public Rental
( intanId , RentalCu stomer aRentalCu stomer , RentalItem aRentalItem )
throws E xception
has the following postconditions:

(1) as for postconditions of setId ( anId
( 2 ) RentalCu stomer == aRentalCu stomer
( 3) RentalItem == aRentalItem
When a method depends on another method from which preconditions or postconditions are to be
repeated, it is preferable not to literally repeat the preconditions, but merely to reference the methods on
which it depends. This practice is applied in precondition ( 1). The benefit of such a reference is that if the
preconditions in the called method change, it is not necessary to then update the preconditions in every
method using them. The postconditions in this example are pretty much what one would expect for a
constructor.
As another example, if we define a method

int weirdSu m ( int addend 1 , int addend2
so that addend2 is assigned the sum of addend j and addend2, then addend2 is mentioned in the postconditions as
follows:

Postcondition: addend2'

=

addend1 + addend2

DEFINING METHODS

•

Intent. An informal statement of what the method is intended to do

•

Preconditions. Conditions on nonlocal variables that the method assumes

•

•

•

•

Don't specify the details here: the other categories provide them.
Includes parameters.
Verification of these conditions not promised in method itself.

Postconditions.Value of non-local variables after execution
•

•

Includes parameters.
Notation : x' denotes the value of variable x after execution .

Figure 22.3 programming conventions-documenting methods, 1 of 2

The notation x' refers to the value of a variable x at the conclusion of a method.
The invariant specifies a relationship among the variables that the method does not alter. This program­
mer may want to draw attention to an invariant. For example, he may want to stress that the class invariant is
honored by the method. Specifying an invariant is equivalent to stating it among the preconditions and the
postconditions.
The return specifies the exact nature of what the method is intended to return . Once again, this is
specified in precise terms.
Figures 22. 3 and 22.4 summarize these points.
Figure 22.5 shows an example. Instead of postcondition I, we could have specified that the original
elements of gameBoard are invariant because moves already made should not be changed.
A method is purely junctional if it has a return, no postconditions, and its preconditions refer only to
parameters. In this case, Return describes the entire reason for the method's existence. We make methods
purely functional unless we want them to participate in an object-oriented design (which is often, however) .
When there are objects of a class at runtime-which we want in most cases-we need methods that
manipulate the attributes of the obj ects and are thus not purely functional. Take, for example the method area ()
in the class Rectangle. We could define area() purely functionally by passing the length and width, as in

class Rectangle { . . .
public double area ( double aLength , double aWidth )
}

•

Invariant: Relationship among nonlocal variables that the method's execution leaves unchanged
(The values of the individual variables may change, however.)
Equivalent to inclusion in both pre- and postconditions.
There may also be invariants among local variables.
•

•

•

Return :

•

Known issues:

•

Exceptions:

•

•

•

What the method returns.
Honest statement of what has to be done, defects that have not been repaired, etc.
These are often thrown when the preconditions are not met because this indicates an abnormality in
execution .

Figure 22.4 Programming conventions-documenting methods, 2 of 2

543

544

CHAPTER 22

PRINCIPLES OF IM PLEMENTATION

/** Intent: Record anOorX at aRow/aCol if aRow/aCol blank; Return 'N' if
* not permitted; return anOorX if full row/column/diagonal
*
* Preconditions: anOorX='O' OR anOorX='X'; 1<=aRowO<=3; 1<=aCol<=3
*
* Postconditions (note use of x and x')
* PostO. All preconditions are met OR Exception thrown
* Postl. gameBoard' contains all non-blank elements of gameBoard
,
OR return = 'N'

* Post2. gameBoard [aRow-l) [aCol-l) = '

* Post3. gameBoard[aRow-l) [aCol-l) != "

OR

* gameBoard' [aRow-l) [aCol-l) = anOorX
* Post4. There is no full line of anOorX in gameBoard' OR return = anOorX
*/
public static char makeMove( char anOorX, int aRow, int aCol ) throws Exception{
Figure 22.5 Example of method documentation-tic-tac-toe

This has the property of being independent of the class it belongs to, and we would typically make it

static. We would invoke this version of areaO as i n
. . . Rectangle . area ( 1 , w )
Alternatively, we could define areaO with preconditions on the instance variables length and width of

Rectangle, as in
class Rectangle { . . .
public double area ( ) . . . . }
Thi s leverages the object- oriented nature of Rectangle. We would invoke this version of areaC) as in

. . . rectangle . area ( )

22.5 IMPLEM ENTATION PRACTIC ES

Figures 22. 6, 22. 7, and 22. 8 summarize good habits for implementi ng code. They are described in more detail
in the following sections, and many of them are put i nto practice in; Listing 22.2, found in Section 22.15.1;
and also applied to the Rental class of our video store example.
22.5 .1 Use Expressive Nami ng

When assigning names to variables, parameters, functions, classes, and so on , the most important criteria are
that the names are expressive and that they convey mean i ng. They should not include vague, ambiguous
terms. This helps the reader to understand their purpose (recall that our job i ncludes produci ng maintainable
work). Consider the following piece of code:

I M P LEMENTATION PRACTICES

•

Use expressive naming: the names of the function, the parameters, and the variables should indicate

their purpose

•

•

.

•

.

manipulate(J/oat aFloat, int anInt) r- poor
.. getBaseRaisedToExponent(J/oat aBase, int anExponent) r- better
.

.

Avoid global variables: consider passing parameters instead

. extract(int anEntry) { ... ... table = . . } r- replace?
. extract(int anEntry, EmployeeTable anEmployeeTable) r- better
But not when the number of parameters exceeds ± 7
.

.

Figure 22.6 Good implementation practices, 1 of 3-naming variables; global variables

•

Don't use parameters as method variables

•

myMethod(int i) ( . . . . .. for(i=O; . . r- no!
Limit number of parameters to 6 or 7
.

•

Give names to numbers

•

for(i
0; i < 8927; ++i) r- poor: why 8927?
Instead:
int NUM_CELLS
8927/1 . . . .
for{cellCounter = 0; cellCounter < NUM_CELLS; ++ceIlCounter)
Introduce variables near their first usage
=

=

Figure 22.7 Good implementation practices, 2 of 3-parameters; no unnamed numbers

•

Initialize all variables

•

Check loop counters, especially for range correctness

re-initialize where necessary to "reset"

•

•

Avoid nesting loops more than 3 levels

introduce auxiliary methods to avoid

•

•

Ensure loop termination

a proof is ideal-in any case, document reasoning

•

Figure 22.8 Good implementation practices, 3 of 3-initializing variables; handling loops

/ / Example of poor use of naming
int Dolt (int a , intb)
{

int C i
c=a* bi
return C i

}
What does this function do? It multiplies the two parameters and returns the result, but what exactly is
its purpose? It is hard to tell by the names of the function or the variables-they do not convey any meaning.
Now consider this simple function rewritten using expressive names:

545

546

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

int ComputeRectangleArea ( intlength , int width)
{
intarea;
area = length* width;
return area;
}
Even without comments, the purpose of the function is now clear: it computes the area of a rectangle,
using the length and width that are passed as parameters.
22.5.2 G lobal Va riables

Global variables are data accessible from anywhere in a program. Using global variables compromises the
principle of information biding, which we discussed in Chapter 15. Instead, we want to minimize their use to
reduce the dependence on other parts of the implementation and to hide implementation details.
22.5.3 Function Parameters
Don't use parameters as working variables this is not their purpose. Parameters should only be used to pass
information into and out of a function. If a working variable is needed, it should be declared within the
function. Otherwise, unintended errors can be introduced. For example, if an input parameter is used as a
working variable, its original value may be modified. Then if the parameter is used later in the function with
the assumption that it contains its original value, an error will occur.
Limit the number of parameters to 6 or 7 -it is hard to keep track of parameters and use them properly
if there are more than 6 or 7. Also, the more parameters are used, the more tightly coupled the calling function
is with the called function. If so much data need to be passed, reexamine the design and see whether the
coupled functions should be combined, or if they belong in the same class, with the parameters becoming
private class members.
-

22.5 .4 Explicit N umbers

It is not good practice to use explicit numbers in code. Consider the following:

for ( i = 0; i < 8927; ++i )
It is not clear what 8927 means. Why loop 8927 times? Using a number like this hides the true meaning
of the loop. Now consider the following:

constintNUM_CELLS = 8927; / /

for ( cellCounter

=

0; cellCounter < NUM_CELLS; ++cellCounter )

This is much clearer-the program contains cells, there are 8927 of them, and we are looping through
all of them.

IMPLEMENTATION PRACTICES

The other problem with using explicit numbers, especially if used throughout the code, is that they are
very difficult to find and change correctly at a later time. Consider the example above, where 8297 is used
explicitly in the for loop. Suppose 8297 is also used in many other places, and we want to increase the number
of cells to 9999. We would then need to locate all occurrences of 8927 and change them to 9999. What if the
number 8927 is also used for some other purpose-for example, the number of names in a list? You would
have to examine the code to determine whether a particular occurrence of 8927 means the number of cells or
the number of names. A better approach is to use a named constant such as NUM_CELLS, as in the example
above. Then, in order to change the number of cell to 9999, all that is required is to edit the one statement
where NUM_CELLS is defined, and all references to NUM_CELLS will use the new value.
22.5.5 I n itialization and Declaration

22.5.5.1 Variable Declaration
It is good practice to declare variables as close to their first use as possible. If you are reading a piece of code
you will then be more likely to find and understand the variables it references.

22.5.5.2 Variable Initialization
The reason we initialize variables is to take control of them, avoiding default or garbage values that the system
assigns. This avoids potential errors where a variable is used and contains an unexpected value. It is good
practice to initialize a variable when it is declared, as in the following example:

floatbalance = 0; / / Initializebalance to 0
22.5.6 LOOpS

Loops can be complicated and are common sources of serious failures. They are thus special targets of
verification. McConnell [ 1] suggests the following questions to be answered as guidelines to ensuring loop
correctness:
•

Is a while loop being used instead of a for loop?

•

Is the loop entered from the top?

•

Does the loop body have something in it? Is it nonempty?

•

Is the loop short enough to review all at once?

•

Have long loop contents been moved into their own function?

•

Is the loop limited to at most three levels?

•

If the loop is a for loop, does the body of the loop avoid modifying the loop index variable?

•

Does the loop always terminate?

•

If break or continue are used, are they used correctly?

They are described in more detail in the following sections, and many of them are put into practice in
Listing 22.2, found in Section 22. 15. 1 and applied to the Rental class of our video store example.

547

548

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

22.6 DEFENSIVE PROGRAM M ING

An effective practice for minimizing bugs is to anticipate potential errors and implement code to handle them.
This technique is called defensive programming. One of the most common error sources is illegal data, either from
a bad value in a function's input parameters, or from an external source such as a file, database, or data
communication line. In each case the bad data must be detected and a strategy employed to handle it. There
are a number of effective defensive strategies such as ignoring the error, substituting a default value, or if the
error is from an external source, waiting for valid data. These are discussed in more detail in the next section.
Exception handling is a mechanism that passes control to error handling code that knows how to respond
to the error. Many languages such as Java and C++ have bUilt-in exception-handling facilities. Exception
handling is covered in Section 22.6.2.
Other methods of defensive programming include buffer overflow prevention and "enforcing inten­
tions." Each is discussed at the end of this section.
22.6.1 Error Handling

Developers are constantly faced with the issue of what to do with potentially illegal data. An example of
illegal data is an account number that does not correspond to an actual bank account. Although we try to
make implementations as simple as possible, the real world is not simple. A large fraction of programming
goes toward the handling of errors. A disciplined approach is essential: pick an approach, state it, and be sure
everyone on the team understands and abides by it.
Given that the possibility of errors must be dealt with, how does one program a method to handle illegal
input-for example, a method that gives the balance on an account number when the method's preconditions
clearly require that the account parameter be legal? If all of the aspects of the development process have been
properly practiced, the method's parameters will always be legal whenever the method is called. But should we
program a check of the parameter value in case our design or implementation is flawed? The answer depends on
the requirements. For example, suppose there is a system requirement that the continued execution of the
application is paramount, even if the execution is degraded or flawed. In this case, the programmer must deal
with all inputs, even those that make no sense. Techniques for handling illegal data are described below [ 1].
Wait for a legal data value. If the illegal data are from an external source such as a user interface, database,
or communication device, one possibility is to interact with the data source until the input is changed to a legal
one before the processing continues. This is possible for much of user interface programming, where we can
often ensure that only legal inputs are permitted. If the only allowable strings that can be entered in a text field
are "car," "truck," or "bus," it is easy to prevent the user from continuing until a legal entry is made. A list box is a
common way to do this. Even here, however, subtle errors may creep in. For example, the user may enter date of
birth as t/t/80 and age (in 2000) of 30. It is possible to check consistencies, but the onus is on the designer to
handle all possible consistency and boundary checks (sometimes called "business rules").
Another example might be when data are transmitted over a faulty communication line. The receiving
method may be designed to expect certain data, but the application is often explicitly required to continue
execution, even when the data are not legal. Here, the data must be checked and errors processed in
accordance with the requirements (e.g., "If the signal is not between 3.6 and to.9, discard the signal and listen
for the next signal ... ").
Set a default value. Sometimes a default value can replace a bad data value. As an example, consider an
application that monitors heart functions and controls an oxygen supply to a patient. Let's suppose that we are
coding a method process ( int measurementType,
) where measurementType must be
positive. Let us assume that this application cannot afford to crash even when an internal method has
been given an illegal integer due to a development defect. To deal with this, the code would check the input
•

•

•

DEFEN SIVE PROGRAMMING

and set safe default values if possible. If this is not possible, it may place the entire application in a default
mode of operation. In either case, some kind of alert would be raised indicating an internal error occurred.
Use the previous result. Some software continuously monitors the value of something-for example,
real·time stock quotes. If one time the software reads an illegal value, a possible reaction is to use the last legal
value that was read. This a good approach when the data values are read frequently enough that you don't
expect much deviation between reads. However, if illegal values are read consecutively, the program may
want to raise an alert or log an error to indicate the problem.
Log error. Many software applications implement a logging subsystem to store error information for
later use. Log information is typically written to nonvolatile storage such as a file, with data saved including an
error description, software function where error occurred, call stack at time of error, register values, and so on.
Throw an exception. Exceptions are a mechanism to handle unexpected program errors, including
illegal data values. Languages such as C++ and Java have built-in exception support. Exceptions are covered
in more detail in the next section.
Abort. In some applications any bad data are considered fatal and the system is aborted and reset. This is
most often the case in applications where safety is a concern and a bad value can cause harm. This can also
occur in embedded systems that manage their own memory and detect memory corruption. If logging is
available, error information is saved before the software resets.
In some of our previous examples, the action taken in response to illegal data is dictated by the re­
quirements: abort if safety-critical, use the previous result if it is not expected to change, and so on. Now let us
consider methods whose exceptional behavior is not determined by the requirements. First, their precondi­
tions must be thoroughly specified so that the conditions under which they are called are clear-but should
their parameter values be checked to ensure that the preconditions are met? We distinguish here between
execution during development and execution during deployment.
Executing during development allows test and verification code in many parts of an application, and we
might well want to insert code that checks preconditions, as in the following:

/** precondition: parameters are positive* /
int su m ( int intlP, int int2P ) {
/ / verification code for u se in development: check parameters positive
/ / now do the work
. . . }
Executing the delivered product requires a different perspective. If the method is called with negative
parameters, this indicates a defect in the application itself. We would like to protect ourselves against our own
mistakes, but the cure must be preferable to the illness.

/** precondition: parameters are positive* /
int su m ( int intlP, int int2P ) {
/ / verif ication code for deployed application: check parameters
positive
/ / only if we have a clear philosophy of what to do if parameters
not positive
/ / now do the work
. . . }

549

550

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

Developers lose control of their application when they apply an arbitrary default whose conse­
quences are not known. This must be bal anced against the continued execution of an application with
wrong values, however. It may be unethi cal to distribute, wi thout warni ng, an application that handles
defective development with an i ncorrect continuation (i.e., a continuation not stated in the require­
ments). A defect is a mi stake, but an arbitrary default not explicitly speci fied in the req uirements is a
cover- up. It is often preferable to relaunch an aborted application rather than have it execute incorrectly
(think of an application plotting airplane courses). Undisciplined error processing hi des defects, and i t
becomes expensive t o find the defect compared with allowing the application t o crash (hopefully a t test
time).

22 .6.2 Exception Handling

Exceptions are a mechanism to handle unexpected program errors. Languages such as C++ and Java have
built-in support for exceptions. For those languages without explicit support, developers sometimes design
and implement their own exception-handling code.
In general, when an error is detected an exception is thrown, meaning control is passed to that part of the
program that knows how to deal with the error. This is also known as catching the exception. As a general rule
you should catch those exceptions that you know how to handle. A method handling an exception looks like

Retu rnType myMethod ( . . . ) { . . .
try { . . . / / call method throwing E xcept ionX }
catch ( ExceptionX e ) ( . . . / / handle it )
. . . }
A method not handling an exception (i.e. , passing it to callers) looks like the following.

Retu rnType myMethod ( . . . ) throws E xceptionX { .

.

. }

The following are some guidelines for implementing exceptions:
•

•

•

•

If the present method cannot handle the exception, there has to be a handler in an outer scope that can
do so.
If you can handle part of the exception, then handle that part and then rethrow the exception for handling
within an outer scope.
Make reasonable expectations about the ability of callers to handle the exception you are throwing;
otherwise, find an alternative design since unhandled exceptions crash applications.
"If you must choose between throwing an exception and continuing the computation, continue if you can"
[2] . The point here is that the continuation of an application can be preferable to shutting it down in cases
when the consequences have been thought through.

As an example, the Encounter case study continues to perform with a default name when given a faulty
parameter string (e. g . , null), since this is preferable to shutting down the game just because a name is illegal.
On the other hand, a banking transaction with an illegal amount would not be allowed to continue.

DEFENSIVE PROGRAMMING

There are differences of opinion concerning the use of exceptions when a method is called and does not
satisfy its preconditions. Some believe that this is a legitimate use for exceptions; others disagree, and believe
that this is a matter for testing alone. The authors' opinion is that since code is naturally error-prone, a
consistent policy for throwing exceptions in such cases is a beneficial practice.
22.6.3 Buffer Overflow Prevention

Some languages, notably C and C++, allow writing to memory that exceeds the space declared in the code.
For, example, the following C code declares an array within a method:
c h a r myCh a r A r r ay [ l O ] i

Clearly, we intend to write no more than 10 characters to myCharArray. However, the following code
will place new bits beyond the memory allocated to myCharArray if someCharArray happens to be longer than
10 characters:
s t r c p y ( myCh a r Ar r ay , s om e C h a r Ar r ay ) i

The effects of this overwriting can be benign, but they can also be catastrophic for the application; if
exploited by a malicious hacker, they can produce a security breach, This can be prevented by checking
variable size at key points (e.g" when a user provides input).
22.6.4 "Enforce I ntentions"

If you intend something about how the code you are constructing is to be used by other parts of the application,
then try to enforce this intention, The authors call this the "Enforce Intentions" principle. It is often evident in
user interfaces, where applications try to prevent the user from entering illegal data. We are stressing the
"Enforce Intentions" principle for internal processing here. The principle is analogous to constructing curbs and
islands on roadways to direct traffic along just those paths intended by traffic engineers, and no others, Such
enforcement of intentions makes roads safer; it is commonly applied in many engineering disciplines. The
following includes examples of the "Enforce Intentions" principle in software engineering:
•

•

•

•

•

•

Use qualifiers such as final, const in C++, and abstract to enforce the corresponding intentions. final classes
can't be inherited from; final methods can't be overridden in inherited classes; the value offinal variables can't
be changed. If this causes compile-time errors, it means that you do not fully understand your own program
yet, and no harm has been done. What we especially seek to avoid are runtime errors.
Make constants, variables, and classes as local as possible. For example, define loop counters within the
loop-don't give them wider scope if this is not your intention.
Use the Singleton design pattern if there is to be only one instance of a class (see Chapter 17).
Generally speaking, make members inaccessible if they are not specifically intended to be accessed
directly.
Make attri butes protected. Access them through more public accessor functions if required. (In Java,
making attributes protected gives objects of subclasses access to members of their base classes, which is
often undesirable.)
Make methods private if they are for use only by methods of the same class.

551

552

CHAPTER 22

PRINCIPLES OF IMPLEMEN TATION

Con sider introducing classes to encapsulate legal parameter values that prevent bad data. For
example, if the inten tion for a method evaluate(J is to accept only "car," "truck," or "bus" as parameters, then
it might be worthwhile not to use String as a parameter because it introduces the possibility of illegal
parameters. It would be better to defi ne a class such as Specialized Vehicle with a private constructor and
factory functio ns:
Sp e c i a l i z e dV e h i c l e c r e at e ACar ( ) { . . . }
Sp e c i a l i z e dV e h i c l e c r e at eAT r u c k ( ) { . . . }
Sp e c i a l i z e dV e h i c l e c r e at eAB u s ( ) { . .
}
.

The method in question can then take only a parameter of this type. In other words, instead of
e v a luat e ( St r i n g v e h i c l e )

. . .

// p r o b l e m w i t h i l l e ga l s t r i n g s

use
e v a luat e ( Sp e c i a l i z e dV e h i c l e v e h i c l e )

. . . / / p a r ame t e r v a l u e c an n o t

b e i l l e ga l

When the possible parameter values are restricted but infinite, a separate class can still be valuable. For
example, a person's age is an integer between 0 and 105, let's say, and so a method
g e t Y e a r Of B i r t h ( int age )

may have to deal with errors. In fact, the same error processing would have to be repeated for all methods taking

age as a parameter. On the other hand, a class Age with a private constructor and a public factory method
A g e g e t Ag e ( i n t a g e P )

would handle erroneous input in a consistent manner, located in the same place as all the other aspects of age.
Some options for dealing with this error are described below. The disadvantage of this method is the
proliferation of additional classes, and the slight awkwardness of calls such as
. . .

g e t Y e arOfB i r t h ( ge tAge ( n ) )

.

. .

in place of such simpler calls as
. . .

g e t Y e ar OfB i r t h ( n )

22.7 CODING STAN DARDS

Applying coding standards across a team improves discipline, code readability, and code portability. We will
present one set of standards as an example. Some of these are adapted from Scott Ambler [ 3]. Other standards

CODING STANDARDS

can be found at Sun Corporation's Java site. The exact nature of a standard is not nearly as important as the
fact that the team uses one.
22. 7 .1 Naming conventions

Use a naming convention for variables. Engineers tend to become emotional about their favorite conventions ,
and true consensus is often impossible. Nevertheless, conventions are necessary. A limited time should be set
aside for deciding on conventions and a method for finalizing them. For example, a team member can be
designated to draft conventions, e-mail them to the other members for comments, then have the choices
final ized by the designated person with the approval of the team leader. There should be guidelines as to
when exceptions to conventions are to be allowed.
The following are examples of naming conventions in the Java tradition:

•

•

•

•

•

•

Name entities with concatenated words as in length Cylinder. These are easy to understand and they conserve
space. Exceptions may be permitted at the discretion of the programmer.
Begin class names with capitals. This distinguishes them from variables. Some tools precede the name of
entities with standard letters or combinations of letters, such as C . . . for classes as in CCustomer. This is
useful when the importance of knowing the types of names exceeds the resulting awkwardness .
Name variables beginning with lowercase letters. Constants may b e excepted.
Name constants with capitals as in LAM_A_CONSTANT (use static fina\). lAMA CONSTANT is hard to
read; IamAConstant could be confused with a class; iAmAName gives no indication that it is a constant.
Some organizations distinguish between variables local to a method and those of the class ("instance
variables") . For example, begin (or end) the name of instance variables of classes with an underscore as in
_timeOfDay to distinguish them from other variables, since they are global to their object; this is used by
Gamma et aL [4] but derided by Ambler [5]. A convention used in the case study is to append the suffix I to
indicate instance variables, as in timeOfDayI. Each instance variable is global to each class instance, and
when one is encountered in a block of code, it is useful to know this.
Consider using a notation to distinguish the static variables of a class. The case study uses the suffix S, as in

numCarsEverBuiltS.Recall that a static variable is global to a class, and it is helpful to know that a variable
encountered in a block of code is one of these.
•

•

Useget ... , set . , and is . for accessor methods as ingetName(), setName(), isBox() (where the latter returns
a boolean value) . Alternatively use name() and name(String), for attribute name (e.g., in CORBA-see [6]).
.

.

.

.

Augment these with standardized additional "getters" and "setters" of collections, for example insertlntoName(),

removeFromName(), newName().
•

Consider a convention for parameters. One convention is to use the prefix a, as in sum(int anlntergen, int

anlnterger2)' The case study uses the suffix P, as in sum(int num lP, int num2P).
22. 7.2 Other Conventions

Use a consistent standard for separation. Since single blank lines are useful for separating code sections within
methods, a consistent standard is to use double blank lines between methods. Within methods, consider
standards such as the following:

553

554

CHAPTER 22

PRINCIPLES OF IM PLEMEN TATION

•

Perform only one operation per line.

•

Try to keep methods to a single screen .

•

Use parentheses within expressions to clarify their meaning, even if the syntax of the language makes them
unnecessary.This is an application of "if you know it, show it. "

In naming classes, use singular names such as Customer, un less the express purpose is to collect objects (in
which case Customers might be appropriate). To prevent the proliferation of classes , it is sometimes desirable to
have a class collect its own instances. This would be done with a static data member of the class.

22.8 COM M E NTS

Comments are nonexecuted lines in a program whose purpose is to describe the intent of the program.
Effective use of comments is important to understanding code.
Good comments should not simply repeat what is obvious from reading the code. They should provide
meaning, explaining how and why a piece of code is doing something. For example,
i + + ; II i n c r e m e n t i

The comment here provides no additional information regarding what the variable j means and why it is
being incremented.
Now consider this example, using the function doltO we saw earlier in the chapter.
i n t d o l t ( i n t a , int b )

{

int c ;
c = a * b;
r e tur n c ;

}
With no comments and poor naming of the function and parameters, the purpose of Dolt is not obvious.
By adding comments we can make its purpose clear.

I I d o l t - c omp u t e and r e t u r n t h e a r e a o f r e c t an g l e g iv e n i t s l e n gt h and
width

II a - l e ngth
li b - width
int d o l t ( i n t a , i n t b )

{

}

int c ;
c = a * b;
return C ;

Even though the names of the function and parameters are still unclear, the comments clarify its purpose
and the meaning of the parameters.

TOOLS AND ENVIRONMENTS FOR PROGRAM MING

22.8.1 Documenting Attri butes

For each class attribute, state its purpose and provide all applicable invariants. For example, in the class

Triangle, we would code somewhat like the following:
clas s Tr i an g l e {
private static final double DE FAULT_TRI ANGLE_SI DE = D o ub l e . MAX_VALUE i
II I nv a r i an t : 0 < l e n1 < = D o ub l e . MAX_VALUE
protected double l e n l = DE FAULT_TRI ANGLE_SI DE i
I I I nv a r i an t : 0 < l e n 2 < = D o ub l e . MAX_VALUE
protected double l e n 2 = DE FAULT_TRI ANGLE_SI DE i
I I I nv a r i an t : 0 < l e n 3 < = D o ub l e . MAX_VALUE
protected double l e n 3 = DE FAULT_TRIANGLE_SI DE i
II I nv a r i an t : l e n x + l e ny > l e n z f o r ( x , y , Z ) = ( 1 , 2 , 3 ) , ( 1 , 3 , 2 )
I I and ( 2 , 3 , 1 )
}
for example,
II

1 < _ag e < 1 3 0 " o r " 3 6 < _l e n g t h* _w i d t h < 1 9 3 " .

As a reviewer of this book has noted, one can write a separate private or protected method that is called
by other methods when the invariant needs checking.
22.9 TOOLS AN D E NVIRO N M E NTS FOR PROGRAMM I N G

I t has been said often that, a s a species, w e are toolmakers, and this i s n o less true o f software developers. An
increasing number of tools are available that help developers.
Interactive development environments (IDEs) are widely used to enable programmers to produce more
code in less time. They include drag-and-drop facilities for forming CUI components, graphical representa­
tion of directories, debuggers, "wizards," and refactoring facilities (discussed in Chapter 24).
Profilers such as lProbe can be used to accumulate statistics on code such as
•

Cumulative CPU and elapsed time

•

Time spent by each method

•

Cumulative count of objects generated

•

Number of calls

•

Average method time

Reverse-engineering tools are available that take source code as input and produce limited documen­
tation. An example of a reverse-engineering source code tool is Javadoc. Reverse engineering is discussed
more fully in Chapter 24.
Several object-oriented tools (such as Rational Rose, TogetherlJlC++) generate source code from class
models. These forward-engineering tools cannot be expected to generate more than code skeletons within

555

556

CHAPTER 22

PRINCIPLES OF I MPLEMENTATION

which the programmer must work to produce the eventual implementation. However, as our discussion of MDA
in Chapter 2 1 showed, plans are under way for ambitious code generation capabilities. The same tools also
perform reverse engineering by mechanically producing class models from source code (hence the term "round­
trip engineering").
The history of tools in other branches of engineering (e. g., CAD/CAM) suggests that, despite a rocky
start and several false directions, programming tools will continue to improve significantly, that they will
continue to leverage programming skills, and that they will reduce drudgery and mechanical tasks.

22 . 1 0 CASE STUDY: ENCOU NTER I M PLEMENTATION

•

Note to the Student:
This section contains implementation notes
for the Encounter case study. The source
code for Encounter is available online so
that the student can inspect the final product.

Several purely implementation issues need to
be documented, as listed next. We include a
discussion of where these issues should be
documented. The sections that follow contain
examples of the documentation content.

•

Programming conventions. These can be provided in
the SPMP since they are part of project manage­
ment to a degree. They could be provided in the
SOD although they are not part of the actual
design. They could be stated in a separate docu­
ment, but there are already many documents. They
could be provided in a document dedicated to
implementation, which would be useful. Finally,
they could be included in the SQAP since they are
a direct contributor to quality. The Encounter case
study selected this option.

•

Thr implrmenlation model. This specifies how the
physical files are organized (source code, binary,
help files, etc.). The SOD is a possible repository
for this, although the implementation model is not
actually part of the design. A separate document is
a possibility. A document on implementation
issues alone would be appropriate. Another possi­
bility is the SCMP since it is concerned with
configurations and version. The Encounter case
study selected this option.

Implementation notes. A document is maintained by
individual engineers to describe the current state of
their work.

22 . 1 0. 1 Progra m m ing Conventions

Programming conventions are added to Sec­
tion 5: Standards, Practices, Conventions, and
MetricS, of the Encounter SQAP .

5.2. 1 Programming Conventions
(this section has been added to the standard)
The following conventions will be used.
1. Parts of nonconstant names are delineated by
capitalization: for example, thisIsAName.
2.

Class and interface names begin with a capital:
for example, Account.

3. Instance variables in classes begin with a low­
ercase character and end with "I": for example,

balanceI.

4. Static (class) variables begin with a lowercase
character, and end with "S": for example,

intrresfRateS.
5. Variables defined in, and global to, a method
begin with a lowercase character and end with
"M": for example, inferrsfM.
6. Parameters begin with a lowercase character and
end with "P": for example, principalP.
7. Final variables shall be written in capitals
and shall use underscores: for example,
BANK_NAME.

CASE STU DY: ENCOU N TER I MPLEMENTATION

5.2.2 Notation for Showing the Location
of Files
We win use UML to describe the implementation [ 7].
5.2.3 Personal Software Documentation
Each engineer will maintai n documentation of his
current work, which is referred to as his Personal
Software Documentation (PSD). This enables the
engineer to report status at all times , and it be­
comes part of the proj ect's archive. The team or
proj ect leader will determine how to organi ze the
PSD of the team. Typically, a personal software
document set corresponds to a task that has been
allocated to the engineer and cons i sts of a set of
classes.

22.1 0.2 I m plementation Model

A description of the implementation model,
which describes how the physical flies are
organized, is added as an appendix to the
Encounter SCMP.

Appendix for Encounter SCMP:
Im plementation Model

A part of the Encounter implementation model is
shown in Figure 2 2 . 9 .
22.1 0.3 I m plementation Notes for
Encou nter: Part 1 of 2

This document is maintained by individual
engineers to describe the current state of their
work. It should be complete enough to allow

An example of PSD is provided in Section
2 2 . 1 0. 3 below.

Design model

I

1--------------------,

: RolePlayingGame :

,
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I

I mplementati o n m o d e l

Framework R P G .

I

RolePlayingGame

I

- - - - - - - --.
I

1 RPGame � r -

«file»
R PGame .java

I
I
I

1 RPGEvent H--

«file»
R P G Event .java

I
I
I
I

I'G-am-e-S-t-a-te""H - R P G M o u s e EventListe n e r

-

I
I
I
I
I

H-

,-____________________--,

I
I
-------------------------------�

R PG a m e . ci ass

R PG Event.ciass

«file»

«file»

R PG a m e .java

R PGame . c l ass

RP . . . . . java

R P . . . . . c i ass

--

« fi l e »

Figure 22.9 Design model and implementation model for the Encounter vi deo game

557

558

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

3. Time Recording Log

the engineer to report his or her status at
meetings, or to allow another engineer to
take over the work in a reasonable amount

Engineers maintain records of how long it takes

of time if necessary.

them to perform the various activities required
by software engineering. These data are essen­
tial for the project, and they provide the engi­
neer with a professional "toolkit." Timing data

1. Introduction

can be collected via written forms or software
tools residing on desktop computers, hand-held

This document describes the work ofJohnJones on the

computers, and so on. Engineers have to de­

class EncounterCharacter. It is under configuration

velop a common understanding of the degree of

control with the file name PSD_EncounterCharacter.

precision required by the organization. Note

The files referenced here are stored in the directory

that approximate time measurements can easily

Encounter\PSD\lJones on the Galaxy system.

become too inconsistent for practical use.

2. Defect Recording Log

These data are stored in file Time_Reeording_Log

The log in Figure 22.10 is maintained in file defeetLog.

and an example is shown in Figure 22.11.

Date

Number

Type

Phase Injected

Phase
Removed

Repair Time
(minutes)

6/14/99

142

Interface

Personal
detailed design

Personal code
review

10

Personal code
review

4

Description: omitted checks on name length in EneounterCharaeter.
6/16/99

143

Documentation

Code

Description: incorrect Javadoc description of EneounterCharaeter.

This table concludes with defects found during unit test
Figure 22.10 Example of a defect recording log
Source: Humphrey, Watts S., "Introduction to the Team Software process," Addison-Wesley, 2000.

Date

Start

Stop

Interruptns,

Time
taken

Phase

Comments

6/99

10:04
am

10:25'
am

4+6

II

Detailed Design

Consulted with
V.N.

6/99

1:20
pm

4:34
pm

15+20

159

Personal Code
review

Defect 14

7/99
Figure 22.11 A time recording log

CASE STUDY: OPENOFFICE

22.10.4 Source Code (without Test Code):

EncounterCharacter
The reader is referred to Section 22.15.2 for a listing
of this code.

22.11 CASE STUDY: ECLIPSE

Note to the Student:

Additional rules: The names of methods should
follow common practice for naming getters (getX()),
setters (setXOl, and predicates (isXO, hasXOl.
22.12 CASE STUDY: OPENOFFICE

[This section presents examples of OpenOffice docu­
mentation that relates to implementation.]
22.12.1 OpenOffice standards

The implementation of Eclipse is a larg� body
of code and related artifacts. This section

Note to the Student:

selects just one very small example of stan­

There are many standards associated with

dards as an illustration.

OpenOffice development. We will give one
small example.

Eclipse development standards and resources
are listed at [8]. They are quoted from [8] as follows:

Conventions and Guidelines

These cover coding standards, naming conventions,
and other guidelines. For example, naming conven­
tions are decomposed as follows:
•

Eclipse workspace projects

•

Java packages

•

Classes and interfaces

•

Methods

•

Variables

•

Plug-ins and extension points

Next, we give an example of one of the above.

Methods: Methods should be verbs, in mixed
case with the first letter lowercase, with the first letter
of each internal word capitalized. Examples:
run () ;
runFast ();
getBackground() ;

Each OpenOffice class must begin with the
following header from [9].

/*******************************
*OpenOffice. org - a multi-platform
* office productivity suite
*
* $RCSfile: code, v $
*
* $Revision: 1. 2 $
*
* last change: $Author: st $ $Date:
* 2005/09/02 16:31:54 $
*
* The Contents of this file are made
* available subj ect to the terms of
* GNU Lesser General Public License
* Version 2.1.
*
* GNU Lesser General Public License
* Version 2.1
* ===============================
* Copyright 2005 by Sun Micro­
* systems, Inc.
* 901 San Antonio Road, Palo Alto, CA
* 943 03, U SA
*
* This library is free software; you
* can redistribute it and/or modify
* it under the terms of the GNU Lesser
* General Public License version

559

560

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

* 2.1, as published by the Free
* Software Foundation.
*
* This library is distributed in the
* hope that it will be useful, but
* WITHOUT ANY WARRANTY i without even
* the implied warranty of MERCHANT­
* ABILITY or FITNE S S FOR A PARTICULAR
* PURPOSE. See theGNU LesserGeneral
* Public License for more details.
*
* You should have received a copy of
* the GNU Lesser General Public
* License along with this library i if
* not, write to the Free Software
* Foundation, Inc., 59 Temple Place,
* Suite 3 3 0, Boston, MA 02111-13 07
* U SA
* ******************************/

The following is quoted from [ 10]. Notice that
the term "guide" is used here instead of "stan­
dards." Since many developers contribute to
OpenOffke, this is a useful document for
unraveling the implementation structure.

1.1 What This Manual Covers

'The OpenOfflce.org SD K contains now the
new Developer's Guide (PDF version). The goal of
the guide is to give developers and solution providers
the necessary means to use OpenOffice.org as com
ponentware, using it in their own projects and
extending it according to their needs. The primary
target languages are Java and C++, although the use
of OpenOffice.org BasiC, CLI (.NET), Python, and
MS Automation is treated as well.
The initial version of this guide was a collabo­
ration work of the 000 core developers and two
external authors The developers have collected
their detailed knowledge about UNO I and the
OpenOffice.org API.. . . . . The manual will cover
­

I

The developer's guide title page and URL are
shown partially in Figure 22.12

Section 1 (Reader's Guide) begins to explain
the scope of this document. The idea is that to
add to OpenOffice, the developer creates
components using a set of standards. We
continue to quote directly from the Develop­
er's Guide with occasional, minor editing.

22.12.2 Developer's Guide

.

all important aspects of software development with
OpenOffice.org, including the base technology
UNO, the programming languages supported by
OpenOffice.org, the development of custom com­
ponents, and of course the office applications Writer,
Calc, Draw, Impress, Chart, and Base.
This Developer's Guide should be considered
as a growing document where all new API concepts
will be described in detail combined with a set of
UML diagrams and examples how to use these APls.
This first version is an initial step for an ongoing
documentation task and Sun Microsystems will take
care of this project for the OpenOffice.org commu­
nity.

This manual describes how to write programs using
the component technology UNO (Universal Net­
work Objects) with OpenOffice.org. Most examples
provided are written in Java. As well as Java, the
language binding for C++, the UNO access for
OpenOffice.org Basic and the OLE Automation
bridge that uses OpenOffice.org through Microsoft's
component technology COM/DCOM is described.
1.2 How This Book Is Organized
First Steps

The First Steps chapter describes the
setting up of a Java UNO development
environment to achieve the solutions

The component technology UNO (Universal Network Objects)

CASE STUDY: OPENOFFICE

i::l

Search
AQdress

l.fl http://api.openoffice.org/docs/DevelopersGuide/DevelopersGuide.htm
I \0 I PagoRank {;JlS98 blocked

Go gle. Ie openoffice source code' 31 � Search Web
& files

· Documents
· Version

· Issue

·

control

tracker

· Developer's
· IDL

Guide

· IDl

Design Guide
Docu Guide

I � Options 6J

Reader's Guide

reference

· IDL

•

Contents
1

API and SDK

'SDK
· SDK Survey
· Examples

-Java UNO
Reference
'

Favor�es

C++ UNO

Reference

1.1

What This Manual Covers

1.2

How This Book is Organized

1.3

OgenOffice.org Version Histor�

1.4

Related documentation

1 .5

Conventions

1.6

Acknowledgments

· Download
· Tips

2

'n' tricks

'FAQ

First Steps

- Internal 00 Spots
· External

2.1

Programming with UNO

2.2

Fields of Apglication for UNO

2.3

Getting Started

Resources

· Miscellaneous
· Developer
· Mailing
· News

Projects

list Rules

Letter Archive

Search

I This project :::oJ
I

Go

l

2.3.1

Required Files

2.3.2

Installation Sets

2.3.3

Configuration

Figure 22.12 Contents of OpenOffice developer's guide

you need. At the end of this chapter, you
will be equipped with the essentials re­
quired for the following chapters about
the OpenOffice.org applications.

There is much more to the Developer's Guide,
but our sample ends here.

22.12.3 Sample OpenOffice Code

Figure 22.13 is an example of the selected use
of UML in this document. It shows the inheri­
tance of a pair of classes and the interfaces
(denoted with circles) that each of the two
classes implement.

All chapters provide one or more examples that show
the use of the API in the current descriptions of this
guide. . . .

The following sample, Listing 22.1, is from
[11]. The authors' comments are in different
type and in bold.

561

562

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

com.sun .star.view.XPrinta b le

get P rinter
set P rin te r
p r in t
com.su n .star.frame . XStora b le
hasLocation

get Location
isReadOnly
store

sto reA sU rl
storeToUrl

co m .sun .star.document .
OfficeDocument

com.sun.star.frame.XModel

«service»

attach Resource

getURL
getArgs
connect Controller

disconnectController
lockControllers

u n loc kCont rollers
hasControllersLocked
setCurrentController

getCurrentController

com.sun.star.utiI.XModifiable
isModified
setModified

com.sun.star.text.XTextDocument
getText
reformat

com.sun.star.util.XSearchable
com.sun.star.text.
TextDocument
«service»

createSearchDescriptor

findAII

fi nd Fi rst
findNext

com.5un.star.util.XRefreshable
refresh
addRefreshListener
removeRefreshListener
Figure 22.13 UML excerpts from OpenOffice developer's guide

CASE STUDY: OPENOFFICE

Listing 22.1: Code excerpt from OpenOffice
1 ***************************
*
*
*
*
*

*

$RCSfile: ViewSample.j ava, v $
$Revision: 1. 3 $
last change: $Author: hr $ $Date: 2003/ 06/ 30 15: 46: 21 $
Ii there will be a list of these

****************************

1

import com.sun.star.uno.UnoRuntime;
11

______

implementation

___________________

1 ** Create and modify a spreadsheet view.

*

1
public class ViewSample extends SpreadsheetDocHelper
{
11
public static void main ( String args[] )
{
try
{
ViewSample aSample = new View
Sample ( args ) ;
aSample.doSampleFunction () ;
}
catch ( Exception ex)
{
System.out.println ( "Samp1e caught exception! " + ex ) ;
System.exit ( 1 ) ;
-------

}
System.out.println ( "\nSampl-es done."
System.exit ( 0 ) ;
}
11

);

-------

public ViewSample ( String[] args )
{

super ( args ) ;
}
11
1 ** This sample function performs all changes on the view. * 1
-------

11 informal description

563

564

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

public void do SampleFunction() throws Exception
{
corn.sun.star.sheet.X SpreadsheetDocument xDoc = getDocument();
corn.sun.star.frame.XModel xModel = (corn.sun.star.frame.XModel)
UnoRuntime.querylnterface(com.sun.star.frame.XModel.class,
xDoc);
corn.sun.star.frame.XController xController =
xModel.getCurrentController();

I I --- Spreadsheet view --I I freeze the first column and first two rows
com.sun.star.sheet.XViewFreezable xFreeze = (com.sun.star.sheet.
XViewFreezable)
UnoRuntime.querylnterface( com.sun.star.sheet.XViewFreezable.
class, xController);
if ( null! = xFreeze )
System.out.println( " got xFreeze" );
xFreeze.freezeAtPosition( 1,2 );
I I --- View pane --I I get the cell range shown in the second pane and assign a cell
I I background to them
corn.sun.star.container.XlndexAccess xlndex =
UnoRuntime.querylnterface( com.sun.star.container.XlndexAccess.
class, xController );
Obj ect aPane = xlndex.getBylndex (1) ;
I I --- View settings --I I --- Range selection --synchronized (aListener) I I extensive use of synchronize to prevent interruption

{

aListener.wait ( ) ; I I wait until the selection is done
}
xRngSel.removeRangeSelectionListener ( aListener );

}
11

__________________________

I I listener to react on finished selection
class ExampleRangeListener implements com.sun.star.sheet.
XRangeSelectionListener

private

{
public String aResul t;
public void done( com.sun.star.sheet. RangeSelectionEvent aEvent

STUDENT TEAM GUIDANCE FOR IMPLEMENTATION

{

aResult = aEvent.RangeDescriptor;
synchronized ( this)
{

notify () ;

}
}

public void aborted ( com.sun.star.sheet.RangeSelectionEvent aEvent)

{

synchronized ( this)
{

notify () ;
}
}

public void disposing ( com.sun.star.lang.EventObj ect aObj )

{
}
}
11 -------­
}

The following paragraph invites readers to
contribute to the developer's guide. This
kind of invitation helps to create a cooperative
atmosphere. Developers are less likely to feel
constricted by standards and guidelines when
they participate in establishing them.

Make a contribution
We would like to invite you to participate in this
effort, so as to cover the needs of the community and
to bring in the community's experience. Please let us
know what you would expect from the Developer's
Guide, what might be missing in the current version,
which use cases the guide should cover and which
extensions you can think of. . . .
12.13 STUDENT TEAM GUIDANCE FOR
IMPLEMENTATION

Before commencing with the implementation of
your student team project, you should produce the

The programming conventions need not be exten­
sive, but should provide enough detail so that code
produced by different students exhibit a consistent
style.
It is important to document your implementation
model so the entire team knows where files are to be
stored and from where they are to be retrieved.
An integration plan is written so you understand
the order of implementation and how modules will
be tested.
Once you have completed the documentation
listed above, use your detailed design as a guide and
implement your project. At a minimum you can
implement key portions of your application to
form a prototype.

565

566

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

22.14 SUMMARY

Program code is created from designs. In the object-oriented paradigm, classes form the basis of the design
and implementation. Classes are either domain classes, which originate from the requirements, design classes,
which originate from the SDD, or implementation classes, which are created during implementation.
Defensive programming is an approach to reducing errors. It involves anticipating errors such as illegal data
in function parameters and bad data from external sources such as data communication lines. There are several
effective strategies for dealing with the illegal data, including ignoring the error, substituting a default value,
or waiting for valid data. The philosophy of "enforcing intentions" is fundamental to good, defensive
programming.
There are a number of best practices to follow when implementing code, including using expressive naming,
avoid using global variables, not using parameters and method variables, limiting the number of function
parameters, using named constants, initializing variables, checking loop counters, and ensuring loop termina­
tion. Each is intended to reduce the likelihood of introducing errors and make code more maintainable.
Programming standards are used to improve team discipline, code readability, and code portability.
Standards cover all aspects of coding including naming conventions, code layout, use of brackets, and use of
parentheses. Comments, especially those that observe programming standards, are an important aid to
understanding code. They should convey meaning, purpose, and intent, and not repeat what is obvious
from reading the code. In particular, a good way to define a method within a class is to explicitly specify in
comments its intent, preconditions, postconditions, invariants, exceptions, and known issues. Postconditions define a
method's purpose precisely. The result is an increased understanding of the method, which leads to a reduced
likelihood of errors.
22.15 CODE LISTINGS REFERRED TO IN THIS CHAPTER
22.15.1 Code Listing for Video Rental Example

The code in Listing 22.2 below illustrates some of the principles discussed in this chapter, applied to the Rental
class of our video store example.

Listing 22.2: Video store application code-Rental, Rentalltem classes
/**========================
* Oescribes a OVO
*/
class OVO extends RentalItem
{
}
/**
* Intent: SOD for Rental Framework: http://. . . . .
*
* Known issues:
* (1) This class is not complete for a first build
* (2) Relies on log() method to log development problems -- not yet
created
*
* (3 ) Unit test to be moved from main() and upgraded to use JUnit.
*/

CODE LISTINGS REFERRED TO IN THIS CHAPTER

import j ava.i0 * ;
abstract class Rental
{
/ / CONSTANTS = = = = = = = = == == =
private final static int HIGHEST_ALLOWABLE_RENTAL_ID = 99999999;
private final static int ID_WHEN_RENTAL_ NOT_IN_EFFECT = 0;
private final static int TOLERANCE_ON_RENTAL_I D = 1000;
private static String FILE_WITH_NEXT_USABLE_RENTAL_NUMBER =
"RentalNumber.txt" ;
•

/ / VARIABLES = = == == = = = = = = = = = = == ==
protected int id = I D_WHEN_RENTAL_NOT_I N_EFFECT; / / rental
identification
protected RentalCustomer rentalCustomer = null ; / / customer rented to
protected Rentalltem rentalltem = null ; / / item rented
/ * Class invariant:
EI THER
the rental is inactive, id == I D_WHEN_RENTAL_NOT_I N_EFFECT,
rentalCustomer == null, and rentalltem = = null
OR
I D_WHEN_RENTAL_NOT_IN_EFFECT < id < = HI GHEST_ALLOWABLE
RENTAL_I D,
rentalCustomer ! = null, and rentalltem != null
*/
/ / CONSTRUCTORS = = = = = = == == = = = = ==
/ ************************************
* I ntent: Satisfy class invariant with rental not in effect
* Postconditions: id == I D_WHEN_RENTAL_NOT_I N_EFFECT,
* rentalCustomer == null, and rentalltem = = null
*/
public Rental ()
/ ************************************/
{
id = ID_WHEN_RENTAL_NOT_IN_EFFECT;
rentalCustomer = null ;
rentalltem = null ;
}
/ ************************************
* I ntent: Create a specific rental
*
* Preconditions:
* ( 1) anI D > I D_WHEN_RENTAL NOT I N EFFECT
* ( 2) anI D <= HI GHEST_ALLOWABLE_RENTAL_I D
* ( 3) aRentalCustomer != null
* ( 4) aRentalltem ! = null

567

568

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

*
* Postconditions:
* (1) as for setI d ( anI d )
* ( 2) rentalCustomer = = aRentalCustomer
* ( 3) rentalI tem == aRentalI tem
*
* Known issues:
* ( 1) Exception not specific enough
* ( 2) No handling of violated preconditions
*/
public Rental
( int anI d, RentalCustomer aRentalCustomer, RentalItem aRentalItem )
throws Exception
/ ***********************************/
{
setI d ( anI d ) ;
rentalCustomer = aRentalCustomer;
rentalI tem = aRentalI tem;
checkI nvariant () ;
}
/ / METHODS = = = = = = = = = = = = = = = = = = = = = =
/ ************************************
* I ntent: A check that the class invariant is valid; present for
* demonstation only. I t is possible that this method is not actually
* used.
* Exception: Thrown if the class invariant is violated
* Known issues: Exception not specific enough
*/
public void checkInvariant() throws Exception
/ ******************************/
{
if ( ( id = = ID_WHEN_RENTAL_NOT_IN_EFFECT ) &&
( ( rentalCustomer ! = null ) II ( rentalItem ! = nu l l ) ) )
{
throw new Exception ( "I nvariant in 'Rental' violated" ) ;
}
if ( ( id > ID_WHEN_RENTAL_NOT_IN_EFFECT ) &&
( ( id > HIGHEST_ALLOWABLE_RENTAL_ID ) I I
( rentalCustomer == null ) II ( rentalItem = = null ) ) )
{

throw new Exception ( "I nvariant in 'Rental' "violated" ) ;
}
}
/ ************************************
* I ntent: Get the next available number for assigning a rental
*
* Returns: The integer on the only line of the local file

CODE LISTINGS REFERRED TO IN THIS CHAPTER

* FILE_WI TH_NEXT_USABLE_RENTAL_NUMBER
*
* Postcondition: The integer on the local file FI LE_WITH_NEXT_
* USABLE_RENTAL_NUMBER has been incremented
*
* Exception that exits the application:
* I f the file cannot be accessed or the data is not an integer
*/
private static int getNextRentalNumber ()
/ ************************************/
{
String nextRentalNumberString = new String () i / /
String form int nextUsableRentalNumberReturn = -1000i
BufferedReader reader = nulli
FileReader fileReader = nulli
DataOutputStream writer = nulli

try
{

/ / Prepare to read from the file
FileReader = new FileReader ( FILE_WITH_NEXT_USABLE_RENTAL_NUMBER ) i
reader new BufferedReader ( fileReader ) i
nextRentalNumber String = reader.readLine () i
System.out.println ( nextRentalNumberString ) i
=

/ / Convert to integer
nextUsableRentalNumberReturn =
( new Integer ( nextRentalNumberString ) ) .intValue() i
/ / I ncrement the next available number for assigning a rental
int incrementedNumber = 1 + nextUsableRentalNumberReturni
Integer integerForm = new Integer ( incrementedNumber ) i
/ / and replace the existing record
writer = new DataOutputStream
(new FileOutputStream ( FILE_WITH_NEXT_USABLE_RENTAL_NUMBER)) i
writer.writeBytes ( integerForm.toString () ) i
}
catch( Exception e )
{
System.out.println ( e ) i
System.out.println ( e.toString () ) i
}
return nextUsableRentalNumberReturni
}
/ ********************************

569

570

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

* I ntent: Self-test of this class
* Known issue: Not migrated to JUnit
*/
public static voidmain ( String[] args ) throws Exception
/ ***********************************/
{
/ / Create concrete classes because all are abstract
class RentalTest extends Rental
{
public RentalTest () throws Exception
super () ;
{
}
public RentalTest
( int anI d, RentalCustomer aRentalCustomer,
RentalI tem aRentalI tem )
throws Exception
super ( anI d, aRentalCustomer, aRentalI tem ) ;
{
}
};

class ConcreteRentalCustomer extends RentalCustomer {} ;
class ConcreteRentalI tem extends RentaII tem {} ;
/ / Create obj ects
ConcreteRentalCustomer concreteRentalCustomer
new ConcreteRentalCustomer () ;
ConcreteRentalI tem concreteRentalI tem new ConcreteRentaII tem () ;
=

=

/ / Test invariant checker first because it is used in testing
// -------------RentalTest rentalTestO new RentalTest () ;
// Test 0.1
rentalTestO.id 0;
rentalTestO.rentalCustomer null ;
rentalTestO.rentalI tem null ;
try
rentaITestO.checkI nvariant () ;
{
System.out.println ( "Test 0.1 succeeded" ) ;
=

=

=

=

}
catch ( Exception e )
{ System.out.println ( "Test 0.1: Should be no exception"
// Test O.2
rentalTestO. id

=

1 + HIGHEST_ALLOWABLE_RENTAL_ID;

); }

CODE LISTINGS REFERRED TO IN THIS CHAPTER

try
{
rentalTestO.checklnvariant () ;
System.out.println ( "Test 0.2 succeeded"

);

}
catch( Exception e )
{ System.out.println ( "Test 0.2: Exception as expected"

); }

// Test O.3
rentalTestO.id 1;
rentalTestO.rentalCustomer null ;
rentalTestO.rentalltem = concreteRentalltem;
try{ rentalTestO.checklnvariant () ; System.out.println ( "Test 0.3
succeeded" ) ;
}
catch ( Exception e )
{ System.out.println ( "Test 0.3: Exception as expected" ) ; }
=

=

// Test 0.4
rentalTestO.id = 1;
rentalTestO.rentalCustomer concreteRentalCustomer;
rentalTestO.rentalltem null ;
try
=

=

{
rentalTestO.checklnvariant () ;
System.out.println ( "Test 0.4 succeeded"

);

}
catch( Exception e )
{ System.out.println ( "Test 0.4: Exception as expected"

); }

/ / Test constructors
// ----------------/ / Test 1.1: Empty constructor
RentalTest rentalTestl
try

=

new RentalTest() ;

{
rentalTestl.checklnvariant () ;
System.out.println ( "Test 1.1 succeeded"

);

}
catch ( Exception e )
{ System.out.println ( "Test 1.1: Should be no exception"
}
/ / Non-empty constructor
/ / Test 1.2: Legal construction

);

571

572

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

RentalTest rentalTest2 =
new RentalTest ( 1, concreteRentalCustomer, concreteRentalI tem ) ;
try

{
rentalTest2.checkI nvariant ( ) ;
System.out.println ( "Test 1.2 succeeded" ); }
catch ( Exception e )
{ System.out.println ( "Test 1.2: Should be no exception" );
}
/ / Test 1.2.1: Legal construction with warning
RentalTest rentalTest2point1 =
new RentalTest ( 99999900, concreteRentalCustomer,
concreteRentalI tem ) ;
try

{
rentalTest2point1.checkI nvariant ( ) ;
System.out.println ( "Test 1.2 succeeded"

);

}
catch ( Exception e )

{
System.out.print in ( II Test 1.2: Should be no except ion"

);

}

/ / I llegal constructions
// Test 1.3
try

{
RentalTest rentalTest3 =
new RentalTest ( 0, concreteRentalCustomer,

concreteRentalI tem ) ;
}
catch ( Exception e )

{ System.out.println ( "Test 1.3 : Exception as expected" );
}
// Test 1.4
try

{
RentalTest rentalTest4 =
new RentalTest ( 1 + HIGHEST_ALLOWABLE_RENTAL_ID,

concreteRentalCustomer, concreteRentalI tem ) ;
}
catch ( Exception e )

{ System.out.println ( "Test 1.4: Exception as expected"

); }

CODE LISTINGS REFERRED TO IN THIS CHAPTER

/ / Test 1. 5
try

{
RentalTest rentalTest5 =
new RentalTest ( 1, null, concreteRentalItem) ;
}
catch ( Exception e )
{ System.out.println ( "Test 1.5: Exception as expected" ) ; }
/ / Test 2: of getNextRentalNumber ()
Systern.out.println ( "current integer <
> " + getNextRentalNumber ( ) ) ;
--

}
/ ************************************
* I ntent: set the id if the parameter is legal ; warn if the number
* of rentals is getting close to the maximum.
*
* Precondition:
* anId > RENTAL_ID_WHEN NOT IN EFFECT &&
* anId <= HIGHEST_ALLOWABLE_RENTAL_ID
*
* Postconditions:
* ( 1) id = = anI d
* ( 2) if the rental number is within TOLERANCE_ON_RENTAL_ID of
* HIGHEST_ALLOWABLE_RENTAL_ID, a warning is present on the console.
*
* Exception: if preconditions violated
*
* Known issue: method "log () , , to be implemented
*/
private void setId ( int anId ) throws Exception
/ ********************************/
{
if ( ( ID_WHEN_RENTAL_NOT_IN_EFFECT < anId ) &&
( anId <= HIGHEST_ALLOWABLE...!.RENTAL_ID ) )
{
id = anId ;
if ( anId > HIGHEST_ALLOWABLE_RENTAL_ID 1000)
{ / *tbs:
Log.log ( "setNumber () in 'Rental' set 'id' " +
"within 1000 of highest allowed id" ) ;
*/
System.out.println ( "WARNING: Rental IDwithin" +
TOLERANCE_ON_RENTAL_ID + " of highest allowed value"
);
-

}
}

573

574

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

else // do not change id

{

throw new Exception ( 1/ setNumber() in Rental tried setting id 1/ +

1/ out of bounds: 1/ + anId );
}
}
}
/**== == == == == == == == == == == == == == ==
*
*/ abstract class RentalCustomer
{
}
/**=== == == == == == == == == == == == == ==
*
*/
abstract class RentalItem

{

private String title = 1/ RentalItem title not assigned yet" ;
public float length = 0; // 'public' for demo purposes

// Static constants
private static final float MAX_RENTAL_ITEM_TITLE_LENGTH = 20;

/***********************************
* Intent: Requirement http://tbd.tbd.tbd#3.2.DVD.1.1
*
* Postcondition:
* If 'aTitle' consists of English alphanumeric characters in lower
* or upper case, and punctuation marks ! , :, ", or ?, then title ==
* aTitle if length of 'aTitle' <= MAX_DVD_TITLE_LENGTH
* otherwise title == first MAX DVD_TITLE_LENGTH characters of
* 'aTitle'
*/
private void setTitle( String aTitle
/***************************/

{
// Check that' aTitle' consists of English alphanumeric characters in
// lower or upper case, or punctuation marks ! , :, " or ?
boolean charactersAcceptable = true; // make false when

unacceptable character found

char C h = I X ' ;

for ( int i = O; i < aTitle.length(); ++i

{

CODE LISTINGS REFERRED TO IN THIS CHAPTER

ch = aTitle.charAt( i ) ; I I temporary name for clar ity

I I Make 'charactersAcceptable' false if 'ch' unacceptable
I I true otherwise
charactersAcceptable = charactersAcceptable &&
(
( ( ch >= 'a' ) &&( ch <= 'z' ) ) I I
( ( ch >= 'A' ) &&( ch <= 'Z' ) ) I I
'
ch == '!' I I ch == ' ' I I ch == ' II
I I ch == '?'
);
.

}
if( charactersAcceptable
{
title = aTitle;
} I I (otherwise leave 'tit Ie' unchanged)

}
}

22.15.2 Code Listing for EncounterCharacter

Source code for the EncounterCharacter class in the Encounter video game (described in Section 22.10) is shown
in Listing 22.3. Source code for all of the Encounter case study is available online.

Listing 22.3: sample code from the Encounter video game implementation
package Encounter.EncounterCharacters;

1* Class Name: EncounterCharacter
* Date: 01/13/2000
* Copyright Notice : copyr ight (c) 1999-2000 by Eric J. Braude
*1
import java.awt.*;
import java.io.*;
imp 0 rt FrameworkRPG.Characters.*;
import TestUtilities.*;
1** Base class for the characters of the Encounter game. SDD reference:
* 6.2.1
* <p> Invariants: The values of qualValueI[j are >= 0
* @ author Eric Braude, Tom VanCourt
* @version 0.2
*1

575

576

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

public class EncounterCharacter extends GameCharacter

{
/** Total quality points at initialization.*/
private static final float QUAL_TOTAL_INIT = 100. Of;
// Symbols used when other classes refer to specific qualities.
/** Symbol for one of a character's qualities */
public static final String QUAL_CONCENTRATION = " concentration" ;
/** Symbol for one of a character's qualities */
public static final String QUAL_INTELLIGENCE = "intelligence" ;
/** Symbol for one of a character's qualities */
public static final String QUAL_PATIENCE = "patience" ;
/** Symbol for one of a character's qualities */
public static final String QUAL_STAMINA = "stamina' , ;
/** Symbol for one of a character's qualities */
public static final String QUAL_STRENGTH= "strength" ; /** Qualities that
each Encounter character posesses <p>Req: 3.2. EC.1.2 */
private static final String[] qualityTypeS =

{ QUAL_CONCENTRATION, QUAL_STAMINA, QUAL_INTELLIGENCE, QUAL_PATIENCE,
QUAL_STRENGTH

}
/* INSTANCE VARIABLE S */
/** Values of the qualities <p> Requirement 3.2.EC.1.2 */
private float [1 qualValueI =new float[ qualityTypeS.length ] ;
/** Name of the GIF file containing the character's image.
* The character in this image is assumed to be facing left.
* Select this character's height, relative to heights of other
* characters, by padding the top and bottom with transparent pixels. No
* padding gives the tallest possible character.
*/
private String imageFileNameI = null;
/* CONSTRUCTORS */
/** Allocate initial total quality points equally among the qualities.
* <p> Requirement: 3.2.EC.1.2 (quality value initialization)
*/
protected EncounterCharacter()
super();
{
for( int i=O; i < qualityTypeS.length; ++i )
qualValueI [i] = QUAL_TOTAL_INIT / qualityTypeS.length;
}

CODE LISTINGS REFERRED TO IN THIS CHAPTER

/ ** Construct a new character using the given name and image file.
* <p> Requirement:
3.2.EC.1.1 ( character naming)
* @param nameP
Printable name for the character.
* @param imageFileP Filename, relative to document base, .... for
* character image.
*/
protected EncounterCharacter ( String nameP, String imageFileP )
this () ;
{
setName ( nameP ) ;
imageFileNameI imageFileP;
=

}
/ ** Construct a new character using the given name.
3.2.EC.1.1 ( character naming)
* <p> Requirement:
* @param
nameP
Printable name for the character.
*/
protected EncounterCharacter ( String nameP )
{ this ( nameP, null ) ;
}
/ * METHODS */
/ ** Requirement 3.2.EC. 3.2: "Configurability of Encounter character
,
* quality values.'
* Synchronization holds qualityValueI constanteven with other threads
* running.
* <p> SDD reference: 6.1.2.1.1
* <p> I nvariants: see the class invariants
* <p> Preconditions: qualityp is in qualityTypesS[ J
AND qualityValueP >= 0
*
AND qualityValueP <= the sum of the quality values
*
* <p> Postconditions: qualityphas the value qualityValueP
*
AND the remaining quality values are in the same proportion as prior
*
to invocation, except that values less than some tolerance are
*
zero.
* @param qualityp Quality whose value is to be adjusted.
* @param qualityValueP The value to set this quality to.
*/ public synchronized void adjustQuality (String qualityP, float qualityValueP)
{

/ / Value of the quality to be changed
float qualityValueM qualValueI [ indexOf ( qualityp) ];
/ / Save the sum of the values
float originalSumM sumOfQualities () ;
/ / pc Set the stated quality to the desired amount, adjusted to the
/ / threshold value.
setQuality ( qualityP, qualityValueP ) ;
/ / pc I f the caller adjusts the only non-zero quality value,
/ / divide the adjustment amount equally among all other qualities.
=

=

577

578

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

if ( originalSumM== qualityValueM )

{
float qualityDiffEach = (originalSumM - qualityValueP) / (qualityTypeS.
length - 1) ;
for ( int i= 0; i < qualityTypeS.length; ++i )
if ( !qualityTypeS [ i].equalsI gnoreCase ( qualityP )
setQuality ( qualityTypeS [ i) , qualityDiffEach ) ;
}
else {
,
1* Compute factor ( "proportionM' ) by which all other qualities must
* change.
* Example: if the values were 1,3,5 ( i.e. sum9) , and the first quality
* is changed
,
,
* from 1 to 2, then " "3' and "5' change from 8/9 of the total to 7 19
* of the total, so each should be multiplied by 7 18, i.e., by (9-2) I
* (9-1) .
*1
float proportionM= (originalSumM - qualityValueP) / (originalSumM qualityValueM) ;
Ilpc Adjust the remainingqualities, retaining their mutual proportion
for ( int i=O; i < qualityTypeS.length; ++i )
if ( !qualityTypeS [ i].equalsI gnoreCase ( qualityp) )
setQuality ( qualityTypeS [ i) , qualValueI [ i) * proportionM ) ;
}
}
1** Get a copy of the list of names of quality values.
* @return working copies of name strings representing qualities.
*1
public static String [ ] getQualityTypesO
{

String [ ] returnListM= new String [ qualityTypeS.length ]; I I Copy the
string array.
for ( int i= 0; i < qualityTypeS.length; i++ )
I I Copy each string.
returnListM [ i]= new Str�ng ( qualityTypeS [ i] ) ;
return returnListM ;
I I Return the copy.
}
1** Returns the value of the specified quality.
* <p>Precondition:
qualityp is a valid member of qualityTypeS[ J
* @param qualityp
The quality we want the value for.
* @return
The value of the specified quality.
*1
public float getQualityValue ( String qualityp)
return qualValueI [ indexOf ( qualityP ) ];
{
}

CODE LISTINGS REFERRED TO IN THIS CHAPTER

/ ** Quality values below this threshold are set to zero to avoid having
* the game go on for an indeterminate amount of time.
* <p>Requirement: e.g. 3.2.EC.1.2 ( lower limit on non-zero quality
* values)
* @return
Tolerance value
*/
static final float getTolerance ()
return 0.5f;
{
}
/ ** Returns the index of the specified quality.
* <p> Precondition:
qualityp is in qualityTypeS[}, give or take
* capitalization.
* @param
qualityp The quality we are searching for.
* @return
The quality index.
*/
private static int indexOf ( String qualityP
{
int returnlndexM -1;
/ / Default to "missing', value.
for ( int i 0; i < qualityTypeS .length; ++i )
/ / Search quality name table.
if ( qualityTypeS [ i ] .equalslgnoreCase( qualityP»
/ / Quality name match?
{
returnlndexM i;
/ / Note the index value.
=

=

=

break;

}
return returnlndexM;
}
/ ** Set default maximum allowable number of characters in names of
* characters.
* <p>Requirement:
3.2.EC.1.1 ( limit on character name length)
* @return
Maximum number of characters allowed in a
character name
*/
protected int maxNumCharslnName()

{
}

return 15;

/ ** Set a quality value without regard to the values of other qualities.
* Truncate any value below the threshold value down to zero.
* Synchronization prevents changes to qualityValueI while other
* threads are using it.
* <p>Requirements:
3.2.EC.2 ( lower limit on non-zero quality
* values) ,
* <p>Precondition:
qualityp is a valid member of qualityTypeS[ J

579

580

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

* <p>Postcondition:
Quality values are greater than tolerance
*
or are o.
*
* @param qualityp The quality to set the value of.
* @param valueP
The value to set the quality to.
*/
public synchronized void setQuality( String qualityP, float valueP)
{

if ( valueP < getTolerance() )
qualValueI [ indexOf( qualityP) 1 =O.Of;
else
qualValueI [ indexOf( qualityp) ] =valueP;

}
/ ** Display the character
* <p>Requirements: 2.1.2.1 ( character displayed in game Area) I
* 3.2.PC.1 ( character image selection) I
* 3.2.PQ.1 ( character image in quality update window)
ur component in which to draw the character
* @param compP
* @param drawP
Graphics context for doing the drawing.
Pixel coordinates within compP for the center of
* @param posP
* the image.
* @param heightPixP
Desired image height I in pixels.
* @param faceLeftP
<tt>true </tt> if character faces left I
*
<tt>false if faces right.
*/
public void showCharacter( Component compP, Graphics drawP, Point posP,
int heightPixP, boolean faceLeftP)

{

if ( imageFileNameI = = null)
/ / No image file name. Print the character name instead.
{
drawP.setColor( Color.magenta);
/ / Normally a visible
color.
FontMetrics fm =drawP.getFontMetrics();
drawP.drawString( getName(),
posP.x - fm.stringWidth( getName(»

/ / Print the name I centered
/ 2, / / at the character location.

posP.y - fm. getHeight () / 2 ) ;
else

{

/ / File name was provided. Draw the image file.
Image chImage =compP.getToolkit().getImage( imageFileNameI);

int imageWidth =chImage.getWidth( compP); / / Raw size of the image.
int imageHeight =chImage. getHeight ( compP);
int scaledWidth=imageWidth * heightPixP / imageHeight; / / Scale width same
as height.
/ / Assume that the normal image faces left. Decide whether to reverse
the image.

EXERCISES

if ( faceLeftp )
// Draw the image as given,
drawP.drawlmage ( chlmage,
posP.x - scaledWidth/2, posP.y - heightPixP/2, // scaled and centered.
posP.x + scaledWidth/2, posP.y + heightPixP/2,
0, 0, imageWidth-l, imageHeight-l, compP);

else
drawP.drawlmage ( chlmage, / / Draw the image reversed,
posP.x + scaledWidth/2, posP.y - heightPixP/2, // scaled and centered.
posP.x - scaledWidth/2, posP.y + heightPixP/2,
0, 0, imageWidth-l, imageHeight-l, compP);

}
// End of showCharacter.
}
/** Computes the sum of the quality values.
* Synchronization makes sure that another thread won't change
* qualityValueI
* while this thread is part-way through computing the total.
* <p> Requirements:
3.2.EC.3.2 (proportions among quality values)
* @return The sum of the player's qualities, a value 0 or greater.
*/
public synchronized float sumOfQua lities ()

{
float sumM=O.Of;
for( int i =0; i < qua lityTypeS. length; ++i
sumM +=qua lVa lue I [iJ ;

return sumM;
}
} // end of EncounterCharacter

22.16 EXERCISES
1. In your own words, describe what is meant by code being "correct."

2. Suppose that you are about to code a method. What are the major sources describing for you what
this method is to do?

3. Provide an example of a domain class, a design class, and an implementation class that might be
used in the implementation of a bank ATM application. Explain why you chose each class.
4. Specify the intent, preconditions, and postconditions of a function that computes the square root
of an input parameter x.

581

582

CHAPTER 22

PRINCIPLES OF IMPLEMENTATION

5. Explain why the use of global variables works against the principle of information hiding. Cive an

example of when this can lead to program errors.

6. The following function returns the correct value, but violates one of the implementation practices
described in this chapter. Which implementation practice is violated, and how might it lead to a
problem in the future? How would you fix the problem?

// compute amount of interest and return
float computelnterest (float balance, float interestRate)

{
// compute interest earned
balance balance * interestRate;
return balance;
=

}
7. Describe two to four advantages and one or two disadvantages of enforcing coding standards.

8. For each of the error handling methods described in Section 22.6. t give an example of when it is
sensible to use the method.

9. What does the following function compute? How would you modify the function using comments
and more descriptive variable names to make it easier to understand its purpose?

int compute (int a )

{
int result = 1, num
while (num < = a) {
result * = 1;
num++;

=

1;

}
return result;
}
/ / Intent: Compute the factorial of the input parameter
/ / Precondition: 0 <

=

factorialNumber

/ / Postcondition: Return factorialNumber!
int computeFactorial (int factorialNumber )

int current = 1; factorial = 1;
while (current <= factorialNumber)
factorial *= current;
current++;

return factorial;

to. Describe how the principle of "Enforce Intentions" leads to improved code quality. Provide at least

three examples to support your answer.

BIBLIOGRAPHY

II. Choose three of the "good practices" listed in this chapter and describe exceptional situations in

which they would not apply.
12. Code is rarely perfect. Give three criticisms of the code in the case studies.

TEAM EXERCISE

Implementation
Implement key parts of your application to form a prototype.

BIBLIOGRAPHY
I.

McConnell, Steve, "Code Complete, A Practical Handbook of Software Construction," 2nd Ed, Microsoft Press, 2004.

2. Horstmann, Cay. S., "Practical Object-Oriented Development in C++ and Java," John Wiley & Sons, 1997.
3. Ambler, Scott, "The Object Primer, The Application Developer's Guide to Object Orientation and the UML," Cambridge University Press, 2001.
4. Gamma, Erich, Richard Helm, RalphJohnson, andJohn Vlissides, "Design Patterns, Elements of Reusable Object-Oriented Software," Addison­
Wesley, 1999.
5. Ambler, Scott. www.ambysoft.com (1999) [accessed 12/13/09].
6.

Oman P.,). Hagemeister, and D. Ash, "A Definition and Taxonomy for Software Maintainability." University of Idaho, Moscow,
Software Engineering Test Laboratory Report #91-08-TR, ID 83843 (1992).

7.

Booch, Grady, James Rumbaugh, Ivar Jacobson, "The Unified Modeling Language User Guide," Addison-Wesley ProfeSSional, 2005.

8. Eclipse Project. http.//www.eclipse.org/eclipse/index php [accessed 12/13/09].
9. OpenOfflce Project. http'//www.openofflce.org/dev_docslsource/templateslcode [accessed 12/13109].
10. OpenOfflce Developers Guide. http'//wiki.services.openofflce.org/wiki/Documentation/DevGUide/OpenOffice.org_Developers_
Guide [accessed 12/13/09].
11. OpenOfflce Project. http'//api.openofflce.org/sourcelbrowse/api/odklexamples/Deve!opersGuide/SpreadsheetiViewSample.java?
rev=I.3&content-type=text/vnd.viewcvs-markup [accessed 12/13/09].

583

Quality and Metrics in
Implementation

�

Testing

Maintenance
The Software
Development
Lifecycle

Planning
\

How do you assess the degree of
sufficiency of an implementation?
How do you measure the degree of
robustness?
What metrics are there for flexibility?

Requianalrements
ysis

Implementation
�DeSign /

Reusability metrics? Efficiency?
Reliability? Scalability?
How does one assess the degree of
security of an implementation?
How do code inspections improve code
quality? What about code reviews?
How does pair programming improve
code quality?

Figure 23.1 The context and learning goals for this chapter

The quality of an implementation can be measured with attributes simil ar to those used for assessing a
design. The nrst part of this chapter describes these attributes. The second discusses code inspections-an
effective quality process for discovering defects before code is tested. As usual , most metrics described below
are meaningful only in the context of comparative data from pas t projects . In addition, each metric is most
effective when used in conjunction with other metrics rather than by itsel f.

QUALITY OF IMPLEMENTATION

As mentioned in precious chapters, there are two sides to assessing the quality of implementations. One
is the verification side, in which quality is assessed based on looking at the source code. This chapter discusses
the verification side. This includes code inspection, the subject of the second part of this chapter. Included in
that part is pair programming, a kind of continual inspection favored in agile projects. The other side of
implementation quality is an assessment of the completed code. That side is validation-essentially, testing­
which is the next part of this book.

23.1 QUALITY OF IMPLEMENTATION
The qualities of an implementation can be categorized as shown in Table 23. 1. For each category, the two
extremes are captured with a rough scale on which 0 indicates low quality and 10 high. More precise
measurements for these categories are discussed in this chapter.
Some of these qualities support others, depending on the application. For example, robust code is less
sensitive to anomalous conditions, and thus makes application more reliable since they stay operational
Table 23.1 Rough measures of quality of an implementation
Degree of

Rough metric

.. .

o ...

110

(maximum score)

Fails to implement the corresponding design specification

sufficiency

I

Satisfies all of the design specifications for this element

Will cause crash on any anomalous event

robustness

I

Recovers from all anomalous events as well as can be expected

Will have to be replaced entirely if the design or requirements change

flexibility

I

As easily adaptable to reasonable changes as can be expected

Cannot be used in other applications

reusability

I

Usable in all reasonably related applications without modification

Fails to satisfy speed or data storage requirement

efficiency

I

Satisfies speed or data storage requirement with reasonable margin

Obviously won't achieve required mean time between failure

reliability

I

Obviously will achieve required mean time between failure

Can't be used as the basis of a larger version

scalability

liS

an outstanding basis for a version with much larger scope

Security not accounted for at all

security

I

No known manner of breaching security is known

585

586

CHAPTER 23

QUALITY AND METRICS IN IMPLEMENTATION

robustness

/
I
/
I / scalability
I/ "/
.,/
/ .,/
I

j'''/

.,/

�
/

l'

reliability

.,/
.,/

�
_

��--

-- flexibility

t

efficiencyr:::. - - - - - ereusability
JSgy: usually competes: • --e

usually supports: �

Figure 23.2 Supporting and competing relationships among implementation qualities

l onger. On the other hand, some of these goals compete. The goals of reliabil ity and Aexibility often compete
because Aexibility tends to introduce increased opportunity for error. It is difficult, freq uently impossib l e, for
a design to enjoy al l of these qual ities at once. Figure 23.2 shows common support and contradictions among
them. Software engineers trade off properties by prioritizing qualities. Agil e development, for example,
places a lower priority on Aexibility and reusability than on sufficiency and reliability.
The sections that fol l ow el aborate upon each of these impl ementation qual ities.

23.1.1 The Sufficiency of an Implementation
The sufficiency of an impl ementation measures the percentage of the req uirements and design specifi cations
actuall y implemented. Although we expect to implement al l requirements , time l imitations often force us to
implement in order of priority, omitting some. The sufficiency of an impl ementation can be calcul ated from
the foll owing formul a ( which requires us to have a compl etel y specified list of detailed requirements).

Percentage of detailed requirements that are implemented.
If the SOD is detailed, the design specifies classes and methods. Another measure for the sufficiency of
an implementation is as fol lows.

Percentage of methods specified in the design that are implemented.
A rougher metric is the fol l owing.

Percentage of cl asses specified in the design that are implemented.

A probl em with the l atter is how to account for cl asses specifi ed in the SOD that are onl y partial l y
implemented.

QUALITY OF IMPLEMENTATION

1. Assess input to the method
a. Anomalous parameter values
b. Anomalous global variables
c. Anomalous event variables

2. Assess dependent methods

Measure extent of compromise

Figure 23.3 Assessing the robustness of a method

23.1 .2 The Robustness of an Implementation
An im plementation's robustness is the extent to which it handles anomalous input ( i . e. , input whose form or
content is unexpected). In the fi nal analysis, the work of an application is performed by its methods.
However, not every method needs to be robust in every way. For example, suppose that a medicine is highly
toxic when taken in large quantities. A method that computes doses for it must be as robust as possible. O n
the other hand , a m ethod that takes input and creates a string for displaying a n automobile does not need t o
b e a s robust. There are two avenues for assessing the robustness o f a method, a s listed i n Figure 23.3.
To assess the robustness of a method relative to its potential inputs, we investigate the preconditions.
First, we assess their completeness. In other words, we ensure that every assumption made by the method is
expressed in the preconditions. We then assess whether the method defends against possible violations of
each precondition. Consider, for example, the Rectangle class in Listing 23. 1.
How robust is the method setArea()? Let's assume that we do not want to restrict the size of the float
inputs.

Listing 23.1: A Rectangle class
/ **=======================================
*/

public class Rectangle
{

/ / VARIABLES=====================================

float area = 0 i
float length = 0 i
float width = 0 i
// CONSTRUCTORS ==================================
/**************************************
*/

public Rectangle ()

/**************************************/

{
}

587

588

CHAPTER 23

QUALITY AND METRICS IN IMPLEMENTATION

/**************************************
*/ public Rectangle ( float aLength, float aWidth
/**************************************/
{

length = aLength;

width = aWidth;

}
// METHODS ========================================
/**************************************
* Preconditions:
* (1) length> = 0
*(2)width>=O

*
* Postconditions:
* (1) area == length * width

*/
public void setArea ( )
/**************************************/
{

}

}

area = length * width;

Note t: The first q uesti on is whether the preconditions are complete. In view of the stated desire not to
restrict the values of length and width, the preconditions appear to be adequate. ( O ne is not always correct i n
one's i ntenti ons, but the point i s that they are documented and s o can b e revi sited. Undocumented intenti ons,
on the other hand, lead to confusion and greater errors.)
Note 2: Next, we assess whether the method allows a reasonable recovery if the precondition fails. S i nce
there is no provi si on for this in the code, the method's robustness is compromised. A check on length and width
that leaves area unchanged, and that generates reasonable noti ces, would elevate the method's robustness.
Li sti ng 23.2 is a more robust version of Rectangle. It restri cts the values of fields to what is intended, a
practice that usually makes computi ng more robust. The objection in Note 2 above is also addressed .
Nevertheless, Listing 2 is still subj ect to critici sms, which are di scussed below.

Listing 23.2: A more robust Rectangle class
/**============================================
* Rectangle class, including safeguards for limits on area
*
* Known Issues:
* (1) Limits dimensions to floats, not double.

QUALITY OF IMPLEMENTATION

* (2) See known issue(s) for individual method (s) .
*/
public class MoreRobustRectangle
{

// VARIABLES ====================================
// Class invar iant (intent: the corresponding area is limited) :
// 0 <= length && 0 <= width && ( length * width <= Float . MAX_VALUE
private float area
0;
private float length = 0 ;
private float width
0;
=

=

//CONSTRUCTORS =================================
/**************************************
*/
public MoreRobustRectangle ()
/**************************************/
{
}

/**************************************
* Intent: Robust constructor
* Postconditions:
* (1) If the class invar iant is true, length == aLength && width == aWidth
* (2) Otherwise
(i) a message has been logged to the log file described in ErrorUtility
*
stating that the class invariant was violated and
*
(ii) the same message appears on the console
*
*/
public MoreRobustRectangle ( float aLength, float aWidth )
/**************************************/
{

if( classInvariantHolds( aLength, aWidth )
{

length = aLength;
width = aWidth;

}
else
{

// Postcondition (2)

String errorMessage ="Attempt in RobustRectangle( float, float ) "+
"to use values that make the area too large. Ignored";
ErrorUtility.logAndReportToConsole( errorMessage );

}

}

589

590

CHAPTER 23

QUALITY AND METRICS IN IMPLEMENTATION

IIMETHODS =====================================

1**************************************
* Intent: A single location for checking required class invariant.
*
* Returns: true if the class invariant would be valid after construction
* with length == aLength and width == aWidth; false otherwise
*
* Known issue: Does not deal with aLength > Double.MAX_VALUE or
* aWidth > Double.MAX_VALUE
*1
private boolean classInvariantHolds ( float aLength, float aWidth )
1**************************************1
{

IICreate Double form to allow check on product of floats

double aLengthDouble = ( new Double( aLength ) ).doubleValue() ;
double aWidthDouble = ( new Double( aWidth ) ).doubleValue() ;
IIdouble form of Float. MAX_VALUE

double floatMaxValue = ( new Double( Float . MAX_VALUE ))

•

doubleValue();

return
aLength >= 0 &&
aWidth >= 0 &&

aLengthDouble * aWidthDouble <= floatMaxValue
) ;

1**************************************
* Precondition: The class invariant
*
* Postcondition: area == length * width
*1
public void setArea()
1**************************************1
{

if ( classInvariantHolds( length, width ) )
{

area = length * width;

}
else II Postcondition (2)
{

String errorMessage ="Attempt in MoreRobustRectangle.setArea ( ) "+
"to use out-of-bound value(s). Ignored";
ErrorUtility.logAndReportToConsole( errorMessage );

QUALITY OF IMPLEMENTATION

}

}

/**************************************
* Precondition: The class invariant
* Postcondition: length== aLength
*/
public void setLength( float aLength )
/**************************************/

{

// Safety check on the precondition
if( classInvariantHolds( aLength, width )

{

length= aLengthi

}

else

{

StringerrorMessage= "AttemptinMoreRobustRectangle.setLength()"+
"to use out-of-bound value for length. Ignored" i
ErrorUtility.logAndReportToConsole(errorMessage)i

}

}

/**************************************
* Precondition: The class invariant
* Postcondition: width== aWidth
*/
publicvoidsetWidth(floataWidth )
/**************************************/

{

// Safetycheck onthe precondition
if(classInvariantHolds(length, aWidth)

{

width=aWidthi

}

else

{

StringerrorMessage= "AttemptinMoreRobustRectangle.setWidth() " +
"touse out-of-bound value for width. Ignored"i
ErrorUtility.logAndReportToConsole(errorMessage)i

}

}

}

591

592

CHAPTER 23

QUALITY AND METRICS IN IMPLEMENTATION

A metric for each method: No robustness

=

0, some

=

0.5, complete

=

1

A metric for classes

L (degree of method's robustness on scale of ° to 1)

all ""thod

Number of methods
Figure 23.4 A robustness metric for classes on a scale of 0 to 1

A metric for the robustness of a block of code is shown in Figure 23.4.
Let's calculate the robustness of MoreRobustRectangle. This class has six methods (we include construc­
tors). The null constructor is guaranteed to leave al\ values zero, so it respects the class invariant, and is robust.
The checkInvariant() method is robust. The rest of the methods check on the preconditions but do nothing if
the precondition is not valid. We can give these the score of Y2. The formula in Figure 23.4 thus yields the
following robustness measure for RobustRectangle.

(1 + 1 + 1/2 + 1/2 + 1/2 + 1/2)/6

=

67%

It is considerably more robust than Rectangle, which has a low score.

23.1.3 The Flexibility of an Implementation
An implementation isj/exible if it can easily accommodate new or changed requirements. Figures 23.5 and 23.6
list implementation techniques that increase flexibility.

1. Document precisely and thoroughly
•

Reason: cannot adapt code that you don't understand

2. Name constants
•

3.

Reason: understandability

Hide where possible
•

Variables and methods

•

Reason: reducing complexity increases understanding

4. Collect common code
•

As helper methods and classes

•

Reason: reduce complexity

Figure 23.5 Factors in implementation that increase flexibility, 1 of 2

5.

Reduce dependency on global variables

- and on any variables external to the method
•

Parameterize methods

•

Reason: allows method to be used in other contexts

6 . Program at a general level
•

Reason: applies to more situations

7. Use understandable variable and function names
Figure 23.6 Factors in implementation that increase flexibility, 2 of 2

QUALITY OF IMPLEMENTATION

We discuss these factors below and subject the code above for RobustRectangle to each factor.

1. Document. The idea is that the more effectively code is documented, the more easily it can be reused.
For example, we can still fault the overall class description in MoreRobustRectangle for lacking sufficient
description of the purpose of a class. O ne could possibly fault the "variables" section as lacking a
description, although none is needed where obvious.

2. Name Constants. When constants are named rather than being stated explicitly, the code becomes more
easily targeted to new uses. There are several places in the MoreRobustRectangle code where constants would
have improved its fl exibility- for example, naming Float.MAX_VALUE as MAX_ALLOWABLLAREA.
As another example, instead of the statements
private float length = 0 ;
private float width = 0 ;

w e could state the following:
private static final float DEFAULT_LENGTH = 0 ;
private static final float DEFAULT _WIDTH = 0 ;
private float length = DEFAULT _LENGTH;
private float width = DEFAULT _WIDTH;

3. Hide Where Possible. In software engineering, our main adversary is complexity. One useful technique for
combating complexity is to hide from view the parts that are not relevant at the time. "H iding" applies to
code that is not available to other code that should not need it. Class members that are not to be accessed
by methods of other classes are thus made private ( or protected if inheritance is required). Classes that are
not to be accessed by methods of classes outside their package are not made public.

4. Collect Common Code. When common code is collected into a method, the result is greater flexibility;
otherwise the common code would have to be changed in multiple places. RobustRectangle does a good j ob
of this by collecting the checking of the invariant in one place: classlnvariantHolds C) . In this respect, then,
the code is flexible.

5. Reduce Dependency on Global Variables. This means that each method and each class should be self-contained
so that they can be mixed and matched.
Perusing the methods of RobustRectangle, we see that the only method referring to an attribute of the

class is setArea() , which refers to area. In principle, we can eliminate area as a variable, eliminating setArea C)

and introducing getArea() that returns the area. This is an improvement in flexibility, but it could collide
with another quality: efficiency. If the application requires very frequent use of area, it may be preferable

to compute it once and refer to it often.

6. Program Generically. Here we ask whether the code is at a sufficiently abstract level to be usable for
additional or changed requirements. It is possible to approach this at the design level by using abstract
classes, but our focus here is on implementation flexibility. Flexibility depends on the direction that an

application is taking. For example, if this class is to be part of a 3D application, we may want area C) to
compute the area on the monitor of a rectangle in space, seen at an angle-that is, taking perspective into
account. This is a far more generic computation.

7. Use Understandable Variable and Function Names. In discussing flexibility, we indicated that variables and
methods must be understandable for the code to be flexible. In fact, the very name of a variable or method
is an important way of making it understandable. Names should be as explicit as possible without
becoming cumbersome. Figure 23.7 shows examples.

593

594

CHAPTER 23

QUALITY AND METRICS IN IMPLEMENTATION

Poor

Better

Best

Dose

dai lyDosage

maxDailyDosage

mOD

minDailyDosage
commonDailyDosage

Figure 23.7 Naming variables to i mprove code quality

Table 23.2 Metrics for various attributes of an implementation
Metric

Attribute
1. Degree of docu mentation

a) percentage of comment lines
b) percentage of commented lines

2. Extent of named constants

3. Hide where possible

Percentage of nu merals with names (see Note 1)
a) Standard deviation of class size (see Note 2)
b) Standard deviation of method size

4. Degree to which common code is collected

Percentage of repeated code paragraphs (see Note 3)

5. Degree of dependency on global variables

a) Percentage of public fields
b) percentage of protected f ields
c) Percentage of unlabeled fields

6. Degree of generic programming

Percentage of generic classes

7. Use u nderstandable variable and function names

percentage of names clearly difficult to understand

Metrics for robustness can be based on the attributes of robustness. One can measure them as in Table 23.2,
probably using an automated process, or manually by taking random samples from the code base. ( Counting all
lines manually is usually impractical).
The following elaborates on the indicated points in Table 23.2.
Note 1 : One looks for plain numbers in the code and counts those not present in a definition,
such as "135" in the following:
final int TANK_CAPACITY = 135;

Note 2: High standard deviation means high deviation from the average. Measured over a
large number of classes, a deviation higher than the usual means an unusual variation in class si ze.
This is not necessarily bad, but it does suggest that the largest and smallest classes should be
revi ewed, focusing on their si ze.
Note

3: One considers paragraphs of code, selected at random, and determines the

percentage of paragraphs that are repeated at least once ( or at least twice, etc. ).
Note 4: The higher the percentage of public fields compared with the normal percentage,
the more global the variables.

23.1 .4 The Reusability of an Implementation
Reusabi lity of code is the capacity for its use in other applications. Maki ng a component more flexible usually
makes it more reusable. Reusability is possible at the method, class, and package levels, although the method
level is usually too granular. To make a class reusable, the following factors are considered.

QUALITY OF IMPLEMENTATION

Table 23.3 Metrics for reusability
Attribute

Metric

1. The matching of classes to a real-world

Percent of classes that clearly match an understandable concept

concept

(see Note 1)

2. Level of abstraction

Average number of inheritance levels from a class in the Java library

3. Degree of description

Percent of classes that are clearly documented (see Note 3)

(see Note 2)

1. The matching of the class to a real-world concept is important, otherwise developers are unlikely to
understand it.

2. The level of abstraction should be high enough to cover many applications but low enough to allow

substance. For example, if a development organization creates insurance industry applications, the level
of a class Cadil1acEldoradolnsurancePolicy is probably too low and Policy too high, as far as reusability is
concerned. An AutomobilePolicy class, on the other hand, would be substantive and probably reusable.

3. The reliability of code promotes reusability, otherwise no one is likely to reuse the class. It should
contain complete error checking, for example. In a somewhat circular process, classes that are widely used

become trusted and understood, and thus more widely reused.
Metrics for reusability can be based on the attributes of reusability. O ne can measure them as in Table 23.3,
based on an automated process or by manual random samples taken from the code base. ( Counting all lines
manually is usually impractical).
Note 1: Th is can be calculated on a random sample by taking a vote among inspectors, for example.
Note 2: The higher this number, the more likely the class can be reused.
Note 3: The better a class is described, the more likely it is to be reusable. Section 23.1.4 described
measures of documentation, and those can be used here too.

23.1.5 The Efficiency of an Implementation
Recall that there are two kinds of efficiency: process speed and storage use. Efficiency requirements may or
may not be speCified in the SRS. For example, suppose that one is specifying the requirements for a calendar
application; one should specify time limits such as "the application will reset all calendars with new
appointments with in !14 second. " When efficiency requirements are not specified, we apply common sense
limits as best we can. Neither space nor time is unlimited in practice. For example, a Web site shopping cart
application may not specify maximum delays, but it is common sense that the user should not wait more than
a minute for a credit card approval, excluding I nternet delays.
An appropriate metric for speed efficiency is the fraction of the speed required. For example, if an
application is required to process a transaction in at most half a second but actually takes two seconds, we can
fairly say that its efficiency measure is V2/2 =25%. If an application were faster than required, we would still
like to be able to measure its speed efficiency. The same formula applies. For example, if the application
processes transactions in one quarter second on average, then its efficiency measure would be Y2 1!14

=

200%.

It has high q uality in this respect, with 100% being the success baseline.

An appropriate metric for space efficiency is simi lar. For example, if an application is required to use no
more than 2 MB of disk space but uses 5 MB , then we can fairly say that its space efficiency is 2/5

=

40%. Once

again, the formula applies even if usage exceeds requirements. For example, if the application were to use only
1 MB , we would rate its storage use efficiency as 2/1

=

200%.

595

596

CHAPTER 23

QUALITY AND METRICS IN IMPLEMENTATION

23.1.6 The Reliability of an Implementation
Reli abi li ty is a quali ty that goes further than suffi ci ency and robustness. To "rely" on an appli cati on is to be
sure first that i t does what i t is supposed to; thi s i ncludes suffici ency, as described above. Reli abi lity can be
considered sometimes to include robustness, where the appli cati on behaves appropri ately in the presence of
anomalous input. An application that is sufficient and robust may sti ll have defects and thus be less than
reliable, however. For example, an appli cati on may be req ui red to add any pai r of i ntegers, each between

-

1 00,000 and 1 00,000. It can be sufficient in that i t does the job req uired and robust in that it di splays an error
message for any i nput not an i nteger between - 100,000 and 100,000. H owever, if the application crashes
after successfully computing addi tions for an hour (perhaps because of uncontrolled memory use), it is not
reliable. Defects affecti ng reli abi li ty are found by i nspecti on and testi ng.
The most commonly used metri c for reli abi li ty is the mean time between failure ( MTBF). To measure MTBF,
one first defines "failure. " Typi cally, thi s means that the appli cation has to be restarted. Run the appli cati on
several ti mes, for si gni fi cant durations, and calculate MTB F as follows:

MTB F

=

(total time up and running)/( number of failures detected in that ti me)

23.1 .7 The Scalability of an Implementation
An i mplementati on is scalable if it is suffici ent for all reasonably anti ci pated homogeneous growth ( i . e. , growth
in the same general di recti on as i ts current capability). For example, a method that stores data m ay work well
for a data rate of one record per second. If the maximum anti ci pated data rate is 1, 000 records per second, the
method's scalabi li ty is effecti vely i ts adequacy for this growth req ui rement. We i nspect and test the m ethod
with thi s in mind as soon as possible. Inspecti on and testing for scalability have li mi tati ons, however.
Scalability can be difficult to assess through i nspections; early testing at the req ui red scale can be expensive or
even impractical because of the work req uired to create a scaled-up test structure.
Scalability metrics measure speeds and data storage in these si mulated or accelerated environments.

23.1 .8 The Degree of Security of an Implementation
Applications often i nclude or are connected to networked parts. The parts may be components of the
executi ng code ( as with Web Servi ces, for example), they may consi st of di stri buted data, they may consist of
a downloaded Web site, or they may simply be accessible through the I nternet or another network. Often,
some of the data are confidenti al. For these reasons, security is a si gni fi cant consi deration. Consider the
simple example of logging in. The appli cati on checks the user's [0 and password before allowi ng access. We
w i ll assume that these data must reside on a fi le situated remotely from the appli cati on. This scenari o raises
many securi ty questions, as li sted in Fi gure 23.8.
Recall that security consi derations can be di vi ded i nto categories. We can base initial i mplementati on
metrics on these, possibly weighted, as shown in Fi gure 23.9, measured for every uni t of code-for example,

•

Store [Os and passwords without allowi ng unauthorized access

•

Ensure that data go only to authorized requesters

•

Design so that security is easily mai ntai ned as appli cation evolves
•

[solate security-affecting classes?

Figure 23.8 Security challenges for Simple Login example

CODE I N SPECTIONS AND RELATED QUALITY PROCEDURES

•

Confidentiality: Measure by degree of difficulty: gaining disallowed access to information

.. repudiating agreement

•

Nonrepudiation:

•

Integrity: . . . altering data in transit, undetected

•

•

Authentication:

.

.. . verifying identity
gaining disallowed access to a location

Authorization: . . .
o

=

easy; 1

=

not easy but conceivable; 2

=

not conceivable

Figure 23.9 Metrics for security-high-Ievel metric using security attributes

on classes and relevant methods. Although this categorization helps, the nontrivial part lies in assessing the
liability of the implementation to each kind of security breach.
The difficulty in assessing the degree of security of an implementation is conceiving of breaches. The
"not conceivable" category of Figure 23.9 does not necessarily imply that breaches are impossible-merely
that the evaluator cannot imagine one.

23.2 CODE INSPECTIONS AND RELATED QUALITY PROCEDURES
The topic of inspecting project artifacts was covered in general in Section 6.3. Now we will describe a specific
process for inspecting code.
Code inspections are an effective tool for producing high quality code. As with other artifacts produced
-

during development, code is reviewed by a team of peers whose goal is to identify as many defects as possible
of as high a severity as possible. Inspections are typically conducted after a segment of code is written but
before it is unit tested.
Before code is inspected it should be desk-checked by its author. This entails the developer reading the
code looking for syntax and other obvious errors. There is no point in having others examine your code if you
haven't carefully looked through it yourself. The code should compile with no errors or even warnings; if it
doesn't, there are obvious errors that need to be fixed bef or e inspection.
Once desk-checking is complete, the inspection process commences: The author distributes the code to
a group of reviewers. Sometimes an overview meeting is held before the actual inspection. The goal of this
type of meeting is to present an overview of the code, presenting its layout and the overall design. This helps
orient the reviewers and provides perspective while they read the code.
The team next prepares for the inspection meeting by haVing each inspector read the code looking for
faults. Their first point of focus is to verify that the code exhibits the qualities listed in Table 23.1, to the
extent they are specified in the requirements. In addition, an effective ,method is to use a checklist, which
includes specific errors the inspector should be looking for as he or she reads the code. The follOWing is an
example list of items found in a code review checklist.
Code Inspection Checklist
1. Variables
•

Do variables have meaningful names?

•

Are hard-coded numbers used instead of named constants?

•

Is a variable value read-only? If so is it declared const or final?

•

Are all variables used?

597

598

CHAPTER 23

QUALITY AND METRICS IN IMPLEMENTATION

2. Functions
•

Do functions have meaningful names?

•

Are all parameters used?

3. Correctness
•

Are all parentheses properly matched?

•

Are brackets properly matched?

•

Does each case in a switch statement terminate with a break? Is there a default case?

4. Initialization
•

Are variables initialized before their first use?

5. Loops
•

Do all loops successfully terminate?

•

If used, do break and continue statements work correctly?

•

Does the body of the loop modify the loop variables?

6. Dynamic Allocation
•

Is every dynamically allocated piece of memory properly de-allocated?

7. Pointers
•

Can a NULL pointer be de-referenced?

8. Comments
•

Is the code properly commented?

•

Do the comments accurately describe the corresponding code?

9. Defensive Programming
•

Are checks made to prevent errors such as divide by zero or illegal data?
Inspectors should read the code line by line, to fully understand what they are reading. For each line or

block of code, skim through the inspection checklist, looking for items that apply. For each applicable item,
determine whether the code correctly addresses the item. If not, write this down, as it is a potential defect.
This list is brought to the inspection meeting for further review. In order to make efficient use of people's time
during the inspection meeting, any syntax or trivial errors discovered can be forwarded to the author prior to
the meeting. This way the meeting can focus on more substantial errors.
During the inspection meeting the facilitator leads the group through the code. As a block of code is reached,
inspectors raise issues found during their prior code reading. If it is agreed that an issue is indeed a defect, it is duly
recorded. An important point is that the fault should only be recorded. It should not be solved, and new code
should not be written during the meeting. This is left to the author to execute at a time subsequent to the meeting.
During this and all other inspections, metrics should be collected. Example metrics are as follows:
•

Number of defects discovered, by severity and type

•

Number of defects discovered by each category of stakeholder inspecting the artifact

EXERCISES

•

Number of defects per page reviewed

•

Review rate (number of pages/hour)
The checklists and data referenced above can be arranged in a form or a CUI for software engineers' use

and for data collection.

23.2.1 Code walkthroughs and Code Reviews
Many teams employ code walkthroughs or code reviews. The meaning of these terms differs from project to project,
but they always involve a meeting-perhaps only a synchronous online meeting. They cover some of the
ground of inspections but are less formal. For example, participants may not cover every line of code, and they
may not be required to prepare for the meeting. A detailed list of defects may not be compiled. A major
difference is that whereas inspections are dedicated to finding defects alone, walkthroughs and reviews are
not. In particular, suggesting and discussing alternatives is permitted-sometimes encouraged-at walk­
throughs but discouraged for inspections.

23.2.2 pair programming
Pair programming is a process by which programming is performed by two software engineers sitting side by
side and using a single computer. Typically, one of them enters code while the other inspects continuously­
essentially for quality. As a simple example, one engineer types a method for dividing two numbers while the
other continually thinks of things that could go wrong (e.g., division by zero) or that the first has missed (e.g.,
documentation giving the context or limits) or left unclear (e.g., why a standard library is not being used).
The pair switches roles periodically. It is clear that the quality of software produced via pair programming will
be higher than that produced by a single person. The trade-offs become more complex to assess when one
compares pair programming with single-person programming augmented by inspections.

23.3 SUMMARY
In order to assess the quality of an implementation, it is useful to categorize its qualities in the same way as for
a design. The qualities we considered in this chapter are sufficiency, robustness, flexibility, reusability,
effiCiency, reliability, scalability, and security. Various metrics are available to measure the extent of each of
these in the application.
Code inspections are a specific type of artifact inspection that is conducted after a piece of code is
written but before it is unit tested. The goal is to detect and fix defects in the code as close to their injection
point as possible. Checklists are commonly used to guide reviewers to the types of errors they should look for
while reading the code.

23.4 EXERCISES
1. List the qualities that implementations should possess. In your own words, describe the meaning of

each quality.

2. Explain how efficiency and reusability can sometimes be competing implementation qualities. Provide
an example to support your answer.

599

600

CHAPTER 23

QUALITY AND METRICS IN IMPLEMENTATION

3. Describe six factors that increase the flexibility of an implementation , and provide an example of

how each contributes to increased flexibility.

4. The code inspection checklist in Section 23.2 is not an exhaustive list. Specify three additional
items you think would be useful to add to the checklist, and explain why you have added each.

5. Your instructor will pair up student project teams. Conduct a code inspection of the other team's

implementation. Use the code inspection checklist in Section 23.2 to guide your inspection.
6. Chapter 22 contains a code listing for a part of the Encounter video game. Where feasible, apply

the informal and formal metrics mentioned in this chapter to measure its robustness. Explain
whether the use of a relevant robustness metric is not feasible in this case and describe the
reliability of the metrics' use in this case.

7. Chapter 22 contains a code listing for a part of the Encounter video game. Where feasible, apply

the informal and formal metrics mentioned in this chapter to assess its flexibility. Explain whether

the use of a relevant flexibility metric is not feasible in this case and describe the reliability of the
metrics' use in this case.
8. Chapter 2 2 contains a code listing for a part of the Encounter video game. Where feasible, apply

the informal and formal metrics mentioned in this chapter to assess its reusability. Explain whether
the use of a relevant reusability metric is not feasible in this case and describe the reliability of the
metrics' use in this case.

9. Chapter 22 contains a code listing for a part of the Encounter video game. Where feasible, apply

the informal and formal metrics mentioned in this chapter to assess its reliability. Explain whether
the use of a relevant reliability metric is not feasible in this case and describe the reliability of the

metrics' use in this case.
to. Chapter 22 contains a code listing for a part of the Encounter video game. Where feaSible, apply

the informal and formal metrics mentioned in this chapter to assess its scalability. Explain if the use

of a relevant scalability metric is not feasible in this case and describe the reliability of the metrics'
use in this case.

Refactoring

�

Testing

Maintenance
The Software
Development
Lifecycle

Planning
\

Requianalrements
ysis

Implementation
�DeSign /

What is refactoring?
How does refactoring work at large scales?
How do you refactor at the method level?
Can you reorganize classes using
refactoring? Reorganize data?
Can you refactor at the module/package level?
In what way is refactoring essential for agile projects?
How is refactoring used in non-agile projects?
How does refactoring relate to design patterns?

Figure 24.1 The context and learning goals for this chapter

Refactoring is a process of altering source code so as to leave its existing functionality unchanged.
Motives for refactoring vary, but a principal one is to improve maintainability, especially enhancement. It is
considered as soon as software engineers begin writing code, and is an essential part of most agile approaches.
Refactoring was introduced to a wide audience by Fowler in his classic book [1 ].
All design evolves, and this is especially true for software projects. In the past it has often not been
effective to modify code very much as needs evolve. However, object-orientation, improved development
environments, and, especially, refactoring, have made this increasingly effective.
Perhaps the simplest illustrative example of refactoring is renaming, in which the name of a variable­
including a class or package name-can be changed. Most development environments automate renaming, as

602

CHAPTER 24

REFACTORING

discussed bel ow. When th e name is changed, al l references to it except for comments are automatical l y
changed a t th e same time. Before renaming became avail able, naming a variabl e was, in practice, a n important
decision that became h ard to alter once made and used for a time. If he or she wanted a new variabl e name, th e
programmer was often obl iged to alter so many occurrences of th e name in multipl e cl asses that it was sel dom
worth whil e to carry out for a l arge program. Naming variabl es is j ust as i mportant as in the past, but th e abil ity
to rename virtual l y at will h as freed some programmer ti me and al lowed new flexibility.
What foll ows is a second example that demonstrates the flavor of refactoring. It is cal l ed "Promote
Attribute to Cl ass," and is used to convert a simple attribute into a class. To accommodate th e increased scope
of an application, we often need to introduce a new cl ass to replace an attribute. For exampl e, suppose that we
already h ave a cl ass Automobile with integer attribute mileage .

cl a s s Auto mobile

{

int mile age i

}

We may decide l ater that "mil eage" for used automobil es, however, is substantial l y more involved than a
single int variabl e. For example, th e auto's m otor may be a replacement, resulting in a motor mi l eage different
from a chassis mileage. In addition, if our application is required to account for fraud, th e reported "mil eage"
woul d h ave to be modified by other attributes such as whether the car had ever been stol en. For these reasons,
we would consider th e "Promote Attribute to a Cl ass" refactoring. This woul d involve introducing a Mileage
class l ike

Listing 24. 1 : Mileage class-promotion of mileage field
cl a s s Mile age

{

int no min al Mile ageV al ue = 0 i

// sho wn on o do mete r

int ch a s si s Mile ageV al ue' = 0 i

// be st e sti mate

int engine Mile ageV al ue = 0 i

// be st e sti m ate , acco unting fo r
repl ace ment

p ublic int co mp uteE f fective Mile age ( ) { . . .

}

cl a s s Auto mobile

{

Mile age mile age i

}

}

// to obt ain e sti mate

REFACTORING

•

e . jilvil

Ecli psc SDK

tefactor

NaviQate

(RI

� �: I�ImI
�

�

________________________

Search

D ErTtpluyee Jd\o <3 X

Rcndmc fic l d

Project

R...,

�

� Update teferenees

ShiftlAltfR

'------11 O Ren"",. getter rroethcod

_____

pub1ic c1ass Emp loyee

Str ing

o Update �extual occlIJ'enees in convnent. «>d strinc;Is (forces preview)

ORename �etter �d

{

Preview >

e . j dvd

II

OK

II

Cancel

Ec li pse SDK

� Update teferenees
o Update �extual oca.rrences in convnents «>d strings (forces preview)

o Renarr,e :Jetter method
o Rename �ett.r method

pub1ic c1ass Emp l o ye e

Str ing n�_;

I Prevtew > I I

OK

II

{

Cancel

Figure 24.2 Using a refactoring wizard-an Eclipse example

Depending on the progress of this application, even the cl ass Mileage could be considered worthy of
further refactoring-for exampl e, by extracting some of its properties into separate types of mileage classes.
Another direction for refactoring is to extract interfaces for it so that client code ( code that uses it) can assume
that it possesses a given set of method signatures such as computeEffectiveMileageO .
Some refactorings are computer-assisted. This usua l l y takes the form of a wizard that interacts with the
programmer. Almost a l l interactive development environments are equipped with several such refactoring
wizards. For exampl e to use Rename in Ecl ipse, one can pl ace the cursor on the variabl e ( in this case name) and
press ShiftlAl t/R. The user is then sh own the window seen in Figure 24 . 2 for the entry of the new name ( in
this case n ame) . The wizard automatical l y makes this change throughout the application except within
comments.
The rest of this chapter introduces many of the refactorings described by Fowler, as well as an additional
one, Introducing Methods. IDEs regul arl y incl ude new refactorings, and it is a good idea to explore these besides
the refactorings in [ 1]. Th is chapter is intended to give the reader a substantive taste for refactoring and to
place it in a software engineering context.
Fowler organizes his refactoring as in Figure 24.3. This chapter does not attempt to explain all of
Fowl er's refactorings. For example, Simplifying Condition al Expressions and Making Method Calls Simpler are not
elaborated in this book, and the reader is referred to [ 1].

603

604

CHAPTER 24

REFACTORING

1. Big Refactorings
2. Composing M ethods
3. Move Features between Objects
4. Organize D ata
5. Dealing with Generalization

6. Simpl ifying Conditional Expressions
7. Making methods Cal ls Simpl er
Figure 24,3 Fowler's main refactoring taxonomy
Source: Fowler et a I . , Refactoring: Im proving the Design of Existing Code, Copyright ([;) 1 999 by Pearson Education, Inc.
Reproduced by permission of Pearson Education, Inc.

24.1 BIG REFACTORINGS
The refactorings described in this section are mainly at the class l evel and have more of an architectural impact.
They are thus call ed "big refactorings." Fowler describes four: "Tease Apart Inheritance," "Convert Procedural
Design to Obj ects," "Separate Domain from Presentation," and "Extract Hierarchy." Each is described bel ow.

Tease Apart Inheritance can be applied when subclasses of a cl ass proliferate into multiple combinations, as
exempl ified by Figure 24.4 . E ffectivel y, we want to factor the combinations as if converting a product such as
9 ( = 3x3) classes that describe every combination into a sum such as 6 ( = 3+ 3) cl asses. We do this by

identifying characteristics, which we encapsulate via inheritance and aggregation. These are Employee types
and Status types in the case of Figure 24 . 4 .
T h e next "big" refactoring we' l l consider, Convert Procedural Design to Objects, i s appropriate for use when a
design h as not ful l y l everaged object orientation by being unnecessaril y procedural . This is common for
inexperienced programmers and even for experienced programmers working in a hurry. For exam pl e, as

I

I

ParttimeSoftwareEmp
RetiredSoftwareEmp

Softwa re E m p

I

I

I

I

ParttimeMaintceEmp
RetiredMaintceEmp

Mai ntce E m p

I

I

I

I

ParttimeClericalEmp
RetiredClericalEmp

C l e rica l E m p

Figure 24.4 Big refactori ngs, 1 o f 4-Tease Apart Inheritance
Source: Fowler et a I . , Refactoring: I m proving the Design of Existing Code, Copyright © 1 999 by Pearson Education, Inc.
Reprod uced by permission of Pearson Education, Inc.

I

I

BIG REFACTORINGS

�r::J,0

�0

I VideoGame I

,----,

�
startGameO
displayCharacterO
moveCharacterO

I

YideoGame
start()

I GameCharacter I

I

GameCbaracter
display()
move()

Figure 24. 5 Big refactonngs, 1. OT 4-conVert I-'roceaura l ueslgn to uOJects
Source: Fowler et a I . , Refactoring: I mproving the Design of Existing Code. copyright © 1 999 by Pearson Education, Inc.
Reproduced by permission of pearson Education. Inc.

shown in Figure 2 4 . 5, a designer may use a class such as Control to control a video game (i.e. , to start and stop
various elements of the game). The problem with this is that control classes, when needed, should be used to
manage objects only by initiating their methods, not as a replacement for the work that should be performed
within an object. When an object is required to control, it should be kept to a minimum: usually a simple,
single call to a method in an appropriate object that sets off the entire process. Figure 24.5 shows how

elements of what used to be control, such as moveO, have been relocated to the objects to which they properly

apply. The instances of GameCharacter now move themselves. Minimal control may still be needed outside
of VideoGame and GameCharacter, but it would initiate the work rather than doi ng it.
The next "big" refactoring we'll consider, Separate Domain from Presentation, is used when a design mixes
control with output formats-in particular, when GUI code occurs in the same class as the computational
algorithms or the data repository. For example, as shown in Figure 24.6, a designer may use a class such as

Account to perform computations but also to produce displays. Such a design lacks reusability and conceptual

�
name
balance
displayStandardO
displayHTMLO
StandardAccountG U I
display ( )

name
balance

HTMLAccountG U I
display ( )

Figure 24.6 B i g refactorings, 3 o f 4-Separate Domain from Presentation
Source: Fowler et a I . , Refactoring: I mproving the Design of Existing Code. Copyright © 1 999 by Pearson Education, Inc.
Reproduced by permission of pearson Education, Inc.

605

606

CHAPTER 24

REFACTORING

CustomerEntertainmentProject

Figure 24. 7 Big refactorings"-Extract Hierarchy
Source: Fowler et a I . , Refactoring: I mproving the Design of Existing Code, Copyright © 1 999 by Pearson Education, Inc.
Reproduced by permission of pearson Education, Inc.

simplicity. (Consider how complicated it would be to change just the CUI parts or to allow several displays
for the same account data.) Figure 24.6 shows how the original design can be decomposed into the core part
of Account, separated from classes describing various ways to display the account.
Our final example of a "big" refactoring, Extract Hierarchy, applies when it has become clear that a new or
extended hierarchy of classes is needed-in particular, when the classes in the existing hierarchy are not
refined enough for the task at hand. For example, as shown in Figure 24.7, a designer may use a class such as
Project to implement a proj ect management application. We'll presume that the application has become too
sophisticated for a generic project. So, for example, quite different functionality is needed by software
engineering projects vs. entertainment projects. As shown in Figure 24.7, extracting a hierarchy of classes
from the original becomes a needed refactoring.

24 .2 COM POSING METHODS
The "composing methods" category of refactorings concerns the process of creating, removing, and
combining methods to suit an evolving application. The various types of method composition examined
by Fowler are shown in Figure 2 4 . 8. They are explained below.

•

Extract method

•

Inline method

•

Inline temp (remove a temporary variable)

•

Replace temp with query (i. e . , a function)

•

Introduce explaining variable (to replace complicated expression)

•

Split temporary variable (i.e., used more than once)

•

Remove assignment to parameters

•

Replace method with method object

Figure 24, 8 "Compose methods" refactorings
Source: Fowler et a I . , Refactoring: I m proving the Design of Existing Code, Copyright © 1 999 by Pearson Education, Inc.
Reproduced by permission of Pearson Education, Inc.

COMPOSING METHODS

Extract Method refers to the process of i dentifying a block of code and creating a method that serves its
purpose. The block of code can then be replaced with a call to that method. One performs such a
replacement when the benefit of reducing clutter outweighs the penalty of having to look elsewhere for
code details. This depends on the sense of purpose of the code extracted, its relative complexity, its size,
and how frequently the functionality involved is needed. As a rough guide, note that the average length of
a method in an 00 implementation is on the order of 10 lines ( i.e., not 100 lines). If several methods call
the same block of code, that is strong reason for extracting it to a method. When there are three such

calling methods, we very often extract as a matter of course. Most IDEs are instrumented with Extract

Method .
Inline Method refers to the opposite of Extract Method . We replace a call to a method with the actual code
from that method. The occasion to consolidate is reflected by the opposite of the justification described in

Extract Method : when a method is so short or inconsequential that it is simpler to include the code itself instead
of the method call. Another case is when the overhead (time or heap space used) of a method call must be
avoided .

Inline Temp refers to the process of replacing a temporary variable instead of using the whole expression
that it replaces. One considers this very strongly if, for example, the expression is complicated and has more
than two terms. An example is replacing y- (x-z) +x* *y by a temporary variable in expression (24. 1 ) .

[x(y + z) - 1 ] j [y - (x - z) + x**y]

( 24 1 )
.

Replace Temp with Query refers to using a method call instead of a temporary variable. For example, we
might want to save expression (24. 1 ) in a temporary variable v and then use v several times; or we might want
to dispense with a temporary variable and call the method that evaluates this expression each time we need it.
This would make sense if the variable we use takes up a lot of space (true for a large data structure but not for a
floating point number like the one above). Another factor to consider here is whether or not the variables in
the expression change. The penalty for introducing Replace Temp with Query is the time it takes to make the
computation.

Introduce Explaining Variable is the opposite of Replace Temp with Query. It introduces temporary variables to
facilitate worki ng with complicated expressions. Although the hiding quality of Replace Temp with Query is
usually beneficial, it is counterproductive when there is little to hide.

Split Temporary Variable applies when you use a temporary variable for purposes different from its original
one. It consists of introducing one or more additional variables instead. Generally speaking, it is good practice
to use a temporary variable only for a single purpose.

Remove Assignment to Parameters fixes the problem of changing the value of a parameter this is not expressly
designed to be an in/out variable. Generally speaking, it is poor practice to write to a parameter unless the
method is specifically designed for this, expecting and using the changed values. In fact, it is usually good
practice to make methods parameters final (in Java notation) to prevent their use other than for the values they
provide.

Replace Method With Method Object is the process of replacing a method such as doFinancialCa lculation O with
a function call on a dedicated object of a specially designed class (FinanciaICa lculation) such as financialCalcu­

lation 2 4 . executeO . The effect of calling executeO with object financiaiCalcuiation 2 4 of a separate class gains
advantages when the functionality required has too many effects to be handled conveniently by a simple
function call alone. Another example is when we need to count the number of times that functionality such as

estimateProfitO in class StockHelper is executed. Instead of simply making estimateProfitO a method of StockHelper,
we create a class ProfitEstimation that aggregates StockHeiper, and we call the method executeO of ProfitEstimation .
A final example is when we want an undo capability. If we store the object representing the function, there is a
possibility for undoing. Otherwise, we couldn't retrieve the function call that brought us to a current state and
would be unable to go back.

607

608

CHAPTER 24

REFACTO R I N G

24.3 MOVI N G FEATU RES BETWEEN OBJECTS

This category of refactoring concerns changes in the placement of class features. These are summarized in
Figures 24.9 and 24. to.
Move Method changes the location of a method from one class to another. For example, we may have
classes Customer, Book, and Order, as well as a method that performs ordering. The application could be built
with executeOrder(Book aBook) , a method of Customer. However, this would usually be inappropriate; and
executeOrderO can be moved with this refactoring to the more appropriate class Order.
Move Field is similar to Move Method. These refactorings are especially needed when we introduce new
classes and recognize better homes for existing variables.
Extract Class allows the software engineer to create a class from a collection of attributes and methods
that already exist within a class. We apply Extract Class when such a collection makes logical sense together
and stands out from its containing class. As an example, an application may be implemented with a Customer
class containing data about books-perhaps because favorite books were initially understood to be a
characteristic of a customer. However, if the application changes to one for which the book notion becomes
significant, then we would apply Extract Class to create a Book class.
Inline Class, the opposite of Extract Class, is the incorporation of a class A, let's say, into another, B,
deleting A in the process. In other words, there is really no need for A.
Hide Delegate is used when a class references classes that are supposed to use it, the effect being to remove
these references. Clients of a class need to reference the used class, but the reverse should be avoided. This is
expanded upon below.
Remove Middle Man is the opposite of Hide Delegate. Hide Delegate is accomplished by introducing a separate
class, as shown in Figure 24.11; reversing the process amounts to removing this "Middle Man."
Figure 24.11 shows Hide Delegates in some detail. Method(s) in Client call method2() in (server) class Class2.
However, method20 requires the use of Class! in a way that forces Client to reference Class! as well. An example
is the following:

•

Move Method

•

Move Field

•

Extract Class

•

Inline Class

•

•

•

•

Trades off method holding vs. usage
Trades off holding vs. usage
Encapsulate a set of attributes and methods of a class
Opposite of Extract Class

Figure 24.9 "Moving Features between Objects" refactorings, 1 of 2
Source: Fowler et aI., Refactoring: Improving the Design of Existing Code, Copyright © 1999 by Pearson Education, Inc.

Reproduced by permission of Pearson Education, Inc.

•

Hide Delegate Hide class dependencies from client classes

•

Remove Middle Man
•

Opposite of Hide Delegate

Figure 24.10 "Moving Features between Objects" refactorings, 2 of 2
Source: Fowler et aI., Refactoring: Improving the DeSign of Existing Code, Copyright © 1999 by Pearson Education, Inc.

Reproduced by permission of Pearson Education, Inc.

ORGAN IZING DATA

1---I

B----�

I
I
I
c ____

1

Class1

.. method2 0

Class2
method20

Key:

0

=

changed

delegate.method20

Figure 24. 1 1 "Hide delegates" refactoring
Source: Fowler et aI., Refactoring: Improving the Design of Existing Code, Copyright © 1999 by Pearson Education, Inc.

Reproduced by permission of pearson Education, Inc.

Client. Tax preparation
Class2. Personal profile
Class!. Employer
method2(). Prepare summary tax page
In summary, Client has been saddled with unnecessary responsibility. Hide Delegates allows Client to depend
only on Class2 by aggregating Class! to Class2 (making a Class! object an attribute of Class2). As a result, Client
now depends only on Class2.
24.4 ORGAN IZI N G DATA

In the refactorings of this section, Fowler lists those having to do with the location of data in a design or
implementation.
Self Encapsulate Field changes direct access of an attribute (e.g., pub lic String name; ) to that via
accessors (e.g., private String name; . . . String getName ( ) . . . ). One would use this
refactoring if one forgets to make or postpones making fields private, available only via accessor methods.
Using accessors in 00 is generally good practice because it allows control such as checking an assigned value
to ensure that it is within bounds.
Replace Data Value with Object: As an example, change the attribute public String name to
pub lic Name name. One would apply Replace Data Value with Object here when the idea of a name becomes
too complex for String. An example is when it becomes necessary to track all parts of a name as well as aliases,
married names, and former unmarried ones.
Change Value to Reference is used when the value of an object's attribute is better obtained via a function
(typically, because obtaining the value is complex) rather than with an explicit instance or with null, as in the
following example. In the first version below, the attribute customer has the value null. In the second version, it
is a Customer object created by a static method of Customer. This has the advantage of centralizing the creation
of Customer objects, which is often desirable. This advantage becomes clear when several different classes need

609

610

CHAPTER 24

REFACTORING

Customer objects in a standard manner, such as when instantiating a default customer. The undesirable
alternative is to repeat the code that creates such objects for each of these classes.
c lass Order { . . .

Customer customer;

}

. replaced by . .
c lass Order { .

.

Customer customer = Customer. getCustomer ( String . . . . ) ;

}

Change Reference to Value is the opposite of the previous refactoring. This would be needed when the
machinery of a reference is found to be unnecessary, perhaps because the program turns out to be less
complex than anticipated in this respect.
Replace Array with Object: Arrays have the benefit of being standard in form and of having random access.
However, they are not as flexible as specially built classes even though both may have essentially the same
contents. When the use of an array loses the balance of its advantages, this refactoring makes the conversion.
An example is the following.
Change Company [1 companiesl . . . . to class Companies { . . . }. This refactor­
ing may be beneficial because there are better way to access companies (e.g. , why should IBM be
companiesl [3] in particular?), whereas accessing a company by name (e.g., Companies compa­
nies2 . . . companies2. getCompany ( I I IBM' , ) ) may be much more appropriate .
The preceding refactorings are summarized in Figure 24.12.
Change Bidirectional Association to Unidirectional: We usually want the relationship between classes C1 and C2
to be one-way rather than two-way. For example, C1 refers to C2 but C2 does not also refer to C1. Otherwise,
we cannot use one in another application without the other. Circular references are awkward in any case.
Employee and Employer is an example; if the application is a corporate one, we would probably want Employer to
reference Employee, and there may be no need for the reverse. The result is as follows.
Employee .- Employer.

•

Self Encapsulate Field

•

Replace Data Value with Object

•

Change Value to Reference

•

Change direct access of an attribute to accessor use

class Order { Customer customer;
class Order { private Customer getCustomer(String
•

Change Reference to Value

•

Replace Array with Object

.J

Figure 24.12 "Organizing data" refactorings, 1 of 4
Source: Fowler et aI., Refactoring: Improving the Design of Existing Code, Copyright CD 1999 by Pearson Education, Inc.

Reproduced by permission of Pearson Education, Inc.

ORGAN I Z I N G DATA

Change Unidirectional Association to Bidirectional is the opposite operation from the preceding refactoring. If
there is no clear way to eliminate the dual association direction entirely, we typically try to create a third class
to handle the relationship. An example is as follows.
Employee f- EmploymentRelationship --> Employer.
However, if this is not feasible, we apply Change Unidirectional Association to Bidirectional by establishing a
reference in Employee to Employer.
Replace "Magic Number" with Symbolic Constant is the process of using symbols for constants within code .
An example is NUM_WORKING_MONT HS instead of purely "\0." This helps readability, since the
reader understands NUM WORKING_MONTHS but not necessarily just 10. This process also helps
with maintenance, since it allows easy changes-for example, changing NUM_WORKI NG_MONTHS
to 11 instead of hunting for all occurrences of 10, checking their context, and changing to 11 where
applicable.
Encapsulate Field is the process of changing accessible variables to private ones, supplying an accessor
method or methods. For convenience, we might intentionally make all variables public when first creating a
class and then apply this refactoring.
The preceding set of refactorings is summarized in Figure 24.1 3 .
Replace Record with Data Class is used when we need to encapsulate the data of a class in a database record .
In other words, it suits the application better to deal with records as self-contained units. The records become
objects with private data fields and accessor methods. This is similar to the Replace Data Value with Object
refactoring mentioned above.
Replace Type Code with Class is used when a group of attributes of a class essentially speci fy what type an
instance of the class is. For example, in the class Shoe, the attributes countryOf manufacture, quality, and
designerName would effectively indicate the type as high fashion, intermediate, or low fashion. This refactoring
applies when it becomes advisable to call out a specific type class (ShoeFashionType with at least three values for
the example). Typically, the type class is aggregated with the original class.
Replace Type Code with Subclass: This refactoring implements the same problem as for Replace Type Code with
Class by using inherited classes, each a different type, as shown in Figure 24.15.
The preceding refactorings are summarized in Figure 24.14.
Replace Type Code with State/Strategy: This refactoring deals with the same type of issue as that described in
Replace Type Code with Class/Subclass but combines classes into a hierarchy, as shown in Figure 24.15. The result
is the aggregation of a type class, such as AcountType and inherited subclasses such as RegularAccountType and
WholesaleAccountType. At runtime, the AcountType attribute of Account is instantiated with an object of type
RegularAccountType or WholesaleAccountType.
__

•

Change Unidirectional Association to Bidirectional

•

Change Bidirectional Association to Unidirectional

•

Replace "Magic Number" with Constant

•

Encapsulate Field

•

•

•

(Only if necessary); install backpointer
Find a way to drop; consider third party.

public attribute to private/accessor

Figure 24.13 "Organizing data" refactorings, 2 of 4
Source: Fowler et al.. Refactoring: Improving the DeSign of Existing Code. Copyright Q) 1999 by Pearson Education. Inc.

Reproduced by permission of Pearson Education. Inc.

61 1

612

CHAPT ER 24

R EFACTOR I N G

•

Replace Record with Data Class

•

Replace Type Code with Class

o Simplest object with private data field, accessor

type

I�

AccountType

REGULAR: AccountType
BIG_DISCOUNT: AccountType
SMALL_DISCOUNT: AccountType

Figure 24. 1 4 "Organizing data" refactorings, 3 of 4
Source: Fowler et al.. Refactoring: Improving the Design of Existing Code, Copyright © 1999 by pearson Education, Inc.

Reproduced by permission of Pearson Education, Inc.

•

Replace Type Code with Subclass

type

•

Replace Type Code with State/Strategy

type

Figu re 24. 1 5 "organizing data" refactorings, 4 of 4
Source: Fowler et aI., Refactoring: Improving the Design of Existing Code, Copyright © 1999 by Pearson Education, Inc.

Reproduced by permission of Pearson Education, Inc.

24.5 G E N ERALIZATION

The refactorings in this section exploit inheritance to convert a design and code base from one form to
another that better suits the situation.
Pull Up Field is used when a field (e.g., order in WholesaleOrder and in RetailOrder) occurs in several subclasses of
a class (which we'll call the base class) . It declares the recurring field in the base class, helping us to extend the
functionality of the design since the base class becomes more useful as a result. Figure 24. 1 6 shows an example.
Pull Up Method is the same as Pull Up Field except that it refers to recurring methods instead.

G E N E RALIZAT I O N

Fowler: Dealing with Generalization 1

•

Pull up field

•

Pull up method

•

Pull up constructor body
o Replace by super(. . .)

•

Push Down Method
o When base class method not used by most subclasses

•

Push Down Field

Figure 24. 1 6 "Dealing with generalization" refactorings, 1 of 5
Source: Fowler et aI., Refactoring: Improving the Design of Existing Code. Copyright © 1999 by Pearson Education. Inc.

Reproduced by permission of Pearson Education, Inc.

Pull Up Constructor Body i s similar t o Pull Up Method, but here w e are referring t o a block of code that recurs
in the constructors of subclasses. This block is placed in the base class constructor. The derived class
constructors must call superO in order to effect it. An example in the context of Figure 24.16 is when it
becomes clear that there is substantial common code in constructing WholesaleOrder and RetailOrder objects.
Pull Down Field or Method is the opposite of Pull Up . . . . We abolish the field or method in the base class
when it is needed only once or twice in derived classes. An example is when we write a Jewelry class with the
method estimateTimeToCutO and realize later that this applies to very few subclasses-such as diamonds and
sapphires-and that even they do not have a large amount in common when it comes to this operation.
These refactorings are summarized in Figure 24.16, where the typical motive for each is included.
Extract Subclass is a more extensive version of Push Down. Here, we recognize parts of a class that are
specialized and are liable to be used together, and so deserve class-hood. The process is exemplified in
Figure 24.17, where we recognize the wholesale nature of many orders made to an enterprise.
Extract Superclass is an opposite version of Pull Up. Here, we recognize parts of class that can and should
be abstracted into a superclass. The process is exemplified in Figure 24.17, where we recognize a generic
"employee" aspects of manager and engineer objects. Extract Sub/Superclass enable generalization by refining
the class model. These two refactorings make it easier to introduce new kinds of capabilities going forward
because general concepts are better defined.
Extract Interface arises from asking how a collection of classes would be used by clients . In the example
illustrated in Figure 24.18, we ask how a collection of classes, including Manager and Engineer, would be used.
The idea is to collect this information together in a convenient form. In this case, we may come to the
conclusion-in the context of the application-that users of these classes need only understand that their
functionality is concerned with the concepts of billability (for charging customers) and employment. Then we
create an interface that reflects these concepts.
Collapse Hierarchy applies when we have built an inheritance structure that's unnecessarily refined-that
is, it has too many levels. An example from gymnastics is UnevenBarPerformer --7 Gymnast --7 Sports Woman --7
HSStudent --7 Student --7 Youth --7 Person. For a small application, this is probably too deep and needs
consolidation. For this example, Collapse Hierarchy concerns the steps needed to reduce this to the following:
Gymnast --7 Student --7 Person

613

614

CHAPT ER 24

REFACTOR ING

Order
•

Extract Subclass

quantity
discount

WholesaleOrder

minimum

discount

type

•

minimum

Employee

Extract Superclass

name

salary

Manager
name
salary
numSupervisees

Engineer
name
salary
skiliSet

Figure 24. 1 7 "Dealing with generalization" refactorings, 2 of 5
Source: Fowler et aI., Refactoring: Improving the Design of Existing Code, Copyright © 1999 by Pearson Education, Inc.

Reproduced by permission of pearson Education, Inc.

•

Extract Interface

Engineer

salary

name

numSupervisees

salary

bill Rate

I

---,, --

Manager
name

:-i';P0v;e:
Bil/able : : getName() :
: getRate() : I getSalary()
1------

IT\
I
I

I
l ___,, __ "

IT\
I

!

skiliSet
bill Rate

•

Collapse Hierarchy
o Inherited class not special enough

Figure 24. 1 8 "Dealing with generalization" refactorings, 3 of 5
Source: Fowler et aI., Refactoring: Improving the Design of Existing Code. copyright © 1999 by Pearson Education, inC.

Reproduced by permission of P.earson Education, Inc.

Form Template Method applies when we notice a skeleton algorithm within a body of code that is common
to several algorithms. In effect, we are evolving a design into an application of the Template design pattern.
The example in Figure 24.19 shows how the algorithms for writeBikelnstructionsO and writeTrikeInstructionsO,
which generate assembly instruction manuals depending on parameters, have a common algorithm core. This
core consists of parts that can be pulled out as common to both writeBikeInstructionsO and writeTrikeInstructionsO:
writePrepO, writeSafetyO, write WrapUpO, and writeManualO.
Replace Inheritance with Delegation, somewhat self-explanatory, usually effects an improvement on a design.
00 languages such as Java do not allow for more than one base class, so that there is an advantage to

G E N ERALIZAT ION

Assemblylnstructions
writePrepO
writeSafetyO
writeWrapUPO
writeManualO

L;i
BicycieAssemblylnstructions

BicycleAssemblylnstructions

writePrepO

writeBikelnstructionsO

writeSafetyO
writeWrapUPO

TricycleAssemblylnstructions

I

writeTrikelnstructionsO

TricycleAssemblylnstructions
writePrepO
writeSafetyO
writeWrapUPO

Figure 24.1 9 "Dealing with generalization" refactorings, 4 of 5, Form Template Method
Source: Fowler et aI., Refactoring: Improving the Design of Existing Code, Copyright © 1999 by Pearson Education, Inc.

Reproduced by permission of Pearson Education, Inc.

eliminating an inheritance. For the example in Figure 24.20, Account can inherit from another class once the
refactoring is done, resulting in greater flexibility. The refactoring gives a sequence of steps that ensure a
smooth and safe transition from the original form to the refactored form.
Replace Delegation with Inheritance would be appropriate when we want to repair a design in which code
becomes understood as having a generalization relationship such as Employee/Person. We effect this in code by
means of inheritance.

•

Replace Inheritance with Delegation

=>

•

Account

Record

lastChangedO

'lastChangedO

Replace Delegation with Inheritance

Figure 24.20 "Dealing with generalization" refactorings, 5 of 5
Source: Fowler et aI., Refactoring: Improving the Design of Existing Code, Copyright © 1999 by Pearson Education, Inc.

Reproduced by permission of Pearson Education, Inc.

615

616

C HAPTER 24

REFACTORING

24.6 INTRODU CING MOD ULES

Good design requires modularization: a process of separating its essential elements. Whenever feasible, this
should be performed in advance. However, it is very useful to modularize after the fact as well-in other
words, to recognize useful modularization as the application grows and transitions into maintenance.
Classes by themselves are a means of modularization, but an application can contain hundreds of classes,
and so classes need organizing to enable designers to manage and apply them. A useful way to handle
modularity on this scale is via the Facade design pattern. Simplifying matters, the problem can be reduced to
that shown in Figure 24.21 , in which the design involves classes U, V, and W, where U references (mentions)
classes V and W. An example is U=Transaction, V=Customer, and W= Loan poo!. Suppose that we want to
avoid multiple references like this (think of many classes instead of just the two in this simplification, and you
can imagine the resulting complexity). Class U must be modified because it should no longer reference both
classes V and W.
The refactoring in Figure 24.2 1 is simple if U does not need to instantiate V objects or W objects. This is
the case when U needs only static methods of V or W. (Example: A transaction needs only a generic customer
functionality such as getting average assets of all customers; and the total amount in the loan poo!.) In that
case, U references functionality in F only, and F does the work of translating such function calls into the static
calls on V or W.
The situation may be more involved, however. Suppose that U requires V instances in order to operate
(such as is usually the case when a transaction involves a customer). If we want to protect V within a package,
then U has to depend on the facade interface F and no longer on V directly. Figure 24.22 shows how this can
be dealt with. First, V is provided with an abstract interface VI (Step 1) that abstracts its public methods.
The Extract Interface refactoring can be used for this. Next, in Step 2, V is enclosed in a module (or package)

package

,--fj
@}-- �--�
:---§
Figure 24.21 Refactoring by introducing facade

Figure 24.22 "Introduce module" refactoring, 1 of 2

REFACTORING IN PROJECTS

I

Trnsctn

�1

Cust

I

I/C�sfl
�
l_

I

Trnsctn

_1

� -1 � I
C st

Figure 24.23 "Introduce module" refactoring, 2 of 2

•

Trnsctn has attribute of type Cust
•

Replacing (ust cust; with r(ust cust;
(ust has only private attributes (i.e., use via methods only)
Trnsctn does not instantiate (ust instances

OK if

•

•

•

Trnsctn has method with parameter of type Cust

Replacing myMethod((ust) with myMethod (I(ust)
(ust has only private attributes (i. e., use via methods only)
Trnsctn has method returning type (usf
Replacing (ust myMethod(); with r(ust myMethod();
Trnsctn has method with variable of type (ust
Replacing (ust cust; with r(ust cust; Unresolved as a general matter
•

OK if ...

•

•

•

•

OK

•

Figure 24.24 Types of references of one class to another

with facade F. The class U must now be modified so as to reference vr and F only. It is far less of a problem for
a class to reference an interface than to reference a class.
Let's apply this to an example, shown in Figure 24.23, where a transaction object of class Trnsctn depends
on a customer class (usl.
We can introduce interface reust, with (ust being unchanged, but we need to deal with the resulting
changes needed to Trnsctn. The dependence of Trnsctn on (usl is replaced with dependence on r(us/. This is a
significant improvement because it increases modularity. Think of it as follows: Imagine Trnsctn as a bicycle
pump. Such a pump would be of little use if it were able to operate only on Ajax tires (not an interface) but
would be very useful if it were able to operate on any tire satisfying the standard valve interface. Figure 24.24
lists the implications of this change for Trnsctn and introduces remedies for most situations.
24.7 REFACTORING IN PROJECTS

As mentioned at the beginning of this chapter, refactoring can be profitably applied as soon as software
engineers begin writing code. Figure 24.25 was introduced in Chapter 4 on agile methods, but with our
increased knowledge of refactoring we now have an opportunity to reexamine it. Recall that agile
methodologies repeat the waterfall sequence many times but with several differences. Each cycle begins
with the (functional) code base. Requirements are usually in the form of user stories. The existing code base

617

618

CHAPTER 24

REFACTORI N G

Obtain high-level

_+_� Obtain requirements for

requirements

next period's' segment

Refactor to
Refactorto
clean up

accommodate
new
requirements

Modify code and test code base
to handle additional requirements

•

Typically 1-6 weeks

Figure 24.25 Agile methods-cycle of activities

will have been expressly designed for the existing requirements. It is a tenet of most agile methodologies not to
try to anticipate forthcoming requirements. The existing code base may thus be unsuited to the additional
requirements in one or more ways-and refactoring would then be appropriate in order to accommodate
them. An example is the user story for a video store application that introduces candy sales (i.e., not just the
management of rentals). A new module at the architectural level may be required; and this, in turn, may
require pulling control functionality out in order to orchestrate the rental/sales activities.
24.7.1 Refa ctoring in the Agile project Li fe Cycle

Figure 24.25 shows an additional refactoring step-the task of cleanup. Most software addition and
modification work leaves a "mess" of one kind and magnitude or other. An example is a set of displayAc­
countO methods, one for an existing account type and two more for added account types. Even if the
application does not continue to evolve in this direction, the disorganization described should be cleaned up
to make it more reliable and readable. Refactoring is thus an essential part of agile design, implementation,
and testing. It is part of the expectation for agile projects.
24.7.2 Refactori ng and Design Patterns

Fowler's refactorings, described in [1], stand mostly apart from design patterns-at least in explicit terms.
However, refactoring is really an integral part of all design and implementation. In particular, the need for
refactoring often points to the need for new design patterns. The classic source for these is [2], in which
Kerievsky names most of his patterns in one of the following forms:
"Extract <Design Pattern>"
or

EX ERCISES

"Extract/Move/Replace <Situation> with/to <Design Pattern>"
Our purpose here is only to draw the reader's attention to this work. Here are some examples.
•

Encapsulate Classes with Factory. Helps the software engineer recognize . . .
when Factory is a better way to construct objects that he or she is dealing with, and how to go
about the conversion
·

•

Move Embellishment to Decorator .
when the amount of functionality being added dynamically to objects of a class is extensive
enough to require the use of the Decorator design pattern, and how to go about the conversion
·

•

Replace State-Altering Conditionals with State
when the State design pattern is a better way to handle events that alter the state of the
application, and how to make the transition
·

24.8 SUMMARY

"Refactoring" refers to a discipline of replacing code in such a way as to improve the application but without
changing its functionality. The improvement can be of the following kinds:
•

A simplification of the design and code (removing unnecessary complexity)

•

An increase in its reusability for other parts of the code base for other applications

•

Improved preparedness of the design and code for increasing functionality

Refactoring is possible at the architectural level and at the detailed code level. It extends the life of
applications because it increases their capacity for modification in response to changing requirements.
Some refactorings can be done with wizards supplied with development environments.
Refactoring is essential to agile development. This is because it facilitates the evolution of applications
so as to include additional functionality.
This chapter has cited several classical refactorings. There are many more. An active research
community explores new refactorings-see [3], for example.

24.9 EXERCISES

1. One refactoring is to "separate domain from presentation. " Explain what this means, and apply it to
a calendar application.
2. Write a single that computes the roots of a quadratic equation. Apply "extract method" to it.
3. Describe an application not mentioned in this chapter-or part of an application-in which
"Convert Method to Object" would be appropriate.
4. Apply "Extract Class" to the following.

619

620

CHAPTER 24

REFACTOR I N G

class Rental{
String customer;
Str ing dvd;
int customerLicense;
Str ing director;
Date date;
}
5. This chapter cites the following class diagram for Change Bidirectional Association to Unidirectional:

Employee «-- <> Employment Relationship <> --0> Employer
(see Section 24.4). Write code consistent with this model that allocates seven employees among
two employers and lists them.
6. Give an example in which the addition of a method to a calendar application would cause the
software engineer to apply Pull Up Method.
7. Explain where Introduce Facade was used in the Encounter video game case study.
8. Section 2 4 . 7 cited two stages at which refactoring is used in agile projects. Give examples of each
in the evolution of a calendar application.
9. The introductory section of this chapter refers to a class Mileage. Show how the refactoring of it
could progress usefully along the directions suggested there.

BIBLIOGRAPHY
1. Fowler, Martin, "Refactoring, Improving the Design of Existing Code," Addison-Wesley, 1999.
2. Kerievsky, Joshua, "Refactoring to Patterns," Addison-Wesley, 2004.
3. Refactoring. httpjlwww.refactoring.com/[accessed 12/14/09].

Introduction to Software
Testing

Planning

When and why do you retest?

� Mai ntenance
Testing

The Software
Development
Lifecycle

\

What is the difference between black
box and white box testing?
What distinguishes unit testing?

Requirements

/

analysis

Implementation

�

Why test early? Why often?

DeSign

How do you document tests?
How do you plan for testing?
How do you know when to stop
testing?
Where does test input come from?
Who is involved in testing?
How much effort does it take to test?

Figure 25.1 The context and learning goals for this chapter

Software testing is a validation process. Executing code from the evolving application is provided with
input, and the resulting output is compared with the required output. Each discrepancy or unintended side
effect indicates a fault, bug, or error in the implementation, design, or requirements. We will use the word
defect to cover all these terms, defined by the IEEE (IEEE Standard Glossary of Software Engineering

622

C HAPTER 25

I NTRODUCTION TO SOFTWARE TESTING

Terminology, IEEE Std 610.121990) as "an incorrect step, process, or data definition in a computer program."
"Incorrect" we will understand to mean something that causes a failure to satisfy the requirements in any way.
The goal of testing is to uncover as many defects, at the highest level of seriousness, as possible . It is not
possible to test an application with every possible input value due to the extraordinarily large number of
combinations of input values. For this reason, testing can establish the presence of defects but not their absence (as
so aptly put by Edsgar Dijkstra). In other words, for any practical application, the following is a false
statement: "It has been thoroughly tested and therefore has no defects." Thorough testing is nevertheless
indispensable.
This chapter describes essential principles of software testing. It also summarizes testing practices so
that the reader can understand testing types and their context without getting bogged down in details.
Chapters 26 and 27 provide details.
25.1 TESTI N G EARLY AND OFTE N ; A N D THE AG I LE CON N E CTION

Two basic principles of software testing are "test early" and "test often." These precepts have been respected
for many years and are a principal feature of agile methodologies.
'Testing early" means testing parts as soon as they are implemented rather than waiting for the completion
of the units they are part of. In the video store application, for example, suppose that we are constructing a
method that stores rental information using Video and Customer objects as input parameters. 'Testing early"
implies testing this method alone as much as possible before constructing additional methods in the class.
'Testing often" means running tests at every reasonable opportunity, including after small additions or
changes have been made. For the video store example, suppose that we add functionality to the rental storage
method mentioned above. 'Testing often" translates here into first rerunning the prior tests and then testing
for the new functionality. One reason for testing often is that changes sometimes invalidate code already
implemented. We discuss this next.
A goal of modern development methods, and especially of agile methods, is for the application under
development to grow only-in other words, not to require any other kind of alteration such as erasures.
Accomplishing this (which is not always easy) means that existing tests continue to apply as new elements are
developed.
25.2 RETESTI NG: REGRESSION TESTI N G

Suppose that we thoroughly test part P of an application. Part P necessarily depends on other parts. ( If part P
depends on no other parts, it can be treated like a separate application. ) Now suppose that we add to or alter
part Q of the application. If P depends on Q, then P should be retested. Retesting software to ensure that its
capability has not been compromised is called regression testing. A regression test is designed to assure us that the
code added since the last test has not compromised the functionality that was present before the change(s)
were made. Such a test usually consists of a repeat or subset of the tests that were executed on the artifact
before changes were made.
As an example, we could find that adding functionality to DVDRental to estimate when a customer will
return the DVD (mysteriously!) changes the due date. This kind of occurrence is caused by an erroneous
addition, a poor design, or an incomplete understanding of the application. Figure 25. 2 summarizes this.
A problem in regression testing is assessing whether or not added or changed code affects a given body
of already-tested code. Also, we may not always be able to retest every part of an application because this
sometimes becomes prohibitively time-consuming (an operating system is such an example). Figure 25. 3
explains such situations by considering what regression testing is necessary after code N has been added or
changed.

BLACK BOX AND WH ITE BOX TESTING

Original
test

Original
Original

code

code

artifact

artifact

addition

1. Regression
test (= original
test?)

2. Test of
added
functionality

Figure 25 .2 The idea of regression testing

Suppose that C is a body of already-tested code in
an application A. Suppose that A has been altered
with new or changed code N.

A

11;

snjtgkjfdkUiktdjgkfdjkgj
�b���fdjbkldjb�

�fkb
l jkfdfb
j k{djbJk,

ifdk/tJjfdklbjkffdjbkld�b

•

If C is known to depend on N

I

Perform regression testing on C

•

If C is reliably known to be completely independent of N
There is no need to regression test C

•

Otherwise
Regression test C

I

I�HVOA8FoSGKJGF j
;
kfjdfkbljfdklbjoikhkgkjk

�

JTIURjskjgls,a/40rgnsj

234�

g;b,kdfl

dfkOHVDABFDSl
bljldklHVDABFDS
kgt V
N

!�

ghjkkJj;ljk fghjhjgfj

�fjg kfdjk

GKJGfURjSkjgl

Figure 25.3 Parts to be retested in regression testing

25.3 BLACK BOX AND WHITE BOX TESTI N G

Suppose that we have built the video store application and we want to test it. We may run the application with
data like the following, and then compare the application's behavior with its required behavior.

Abel rents "The Matrix" on January 24
Barry rents "Gone With the Wind" on January 25
Abel returns "The Matrix" on January 30

This type of testing is known as black box testing because it does not take into account the manner in
which the application was designed or implemented. Black box testing can be performed by someone who
needs to know only what the application is required to produce . ( He or she does not need to know how the
application was built. ) This is analogous to building an automobile and then testing it by driving it under
various conditions.

623

624

CHAPTER 25

INTRODUCTION TO SOFTWARE TESTING

Actual output
compared with

... requirements

required output

White box

Validation

... design

f---- of expected

elements

behavior

Figure 25.4 Black box and white box testing

Black box testing is essential. However, to uncover as many defects as possible, we also need to utilize
knowledge of how the application has been designed and implemented. Continuing the automobile analogy,
if the car is built with a new design for its automatic transmission, we would be wise to use this knowledge,
stressing multiple gear changes and running tests that focus on changing gears in as many ways and
circumstances as possible. Tests based on design and implementation knowledge are called white box or glass
box tests. Figure 25. 4 illustrates the difference between black box and white box testing.
White box testing methods are typically performed during unit testing, which is described in Chapter
26. Black box testing is performed both during and after unit testing and is described in Chapters 26 and 28.
Tests that focus substantively on both on the knowledge of how an application is intended to operate as
well as how it is constructed are sometimes called gray box tests.
25.4 UNIT TESTING VS. POST-U N IT TESTING

Software applications consist of numerous parts. As with all construction, the soundness of the whole depends
on the soundness of the parts. This is illustrated by the cantilevered bridge in Figure 25.5.
Because of this dependence, we test software parts thoroughly before assembling them-a process
known as unit testing. Individual methods are considered units for testing purposes, and so are classes. A part as
substantial as a grammar checker in a word processor is probably too large to be considered a "unit." At times
we inadvertently allow a defect in a unit to remain undetected until the product is complete. In that case, the
cost of isolating and repairing the defect is tens or hundreds of times the cost of doing so within the phase
during which the defect was created. In other words, there is a very large payoff in detecting defects early-at
the unit level.

Figure 25.5 A bridge made from parts depends on their individual reliability

TEST I N G OBJECT-O RIENTED IMPLEMENTATIONS

•

Interface testing

•

Integration ...

•

System

validates functions exposed by modules
. . . combinations of modules
•

Robustness

ability to handle anomalies

whole application
•

Usability

user satisfaction
•

Regression

•

Acceptance

•

Installation

•

Performance

changes did not create defects in existing code

fast enough, uses acceptable amount of
memory

customer agreement that contract satisfied
works as specified once installed on required platform
Figure 25.6 Some major types of post-unit tests

Application
on final
platform

system testing
usability testing

installation testing
acceptance testing

Regression testing throughout
Figure 25.7 Various non-unit test types

Various types of post-unit tests are also administered. Figure 25. 6 summarizes some of the major types.
They are covered in Chapter 28.
Figure 25.7 is a summary of when each of the post-unit testing activities is performed during the process
of building an application.
25.5 TESTING OBJECT-ORIENTED IMPLEMENTATIONS

Object-oriented applications, when developed well, benefit from their organization into classes. like any
modularization, this helps with testing because the classes can often be tested separately from-and in

625

626

CHAPTER 25

INTRODUCTION TO SOFTWARE T ESTING

addition to-black box functionality. Prior to the advent of 00, modularization tended to be in terms of
functional units, decomposed into lower level functional units ("structured programming"). These units can be
separately tested but only when cleanly designed. As will be seen in Chapter 26, on unit testing, 00 testing
includes method, class, and package testing .
25. 6 DOCU MENTING TESTS

It requires significant time to decide what to test, how to test, when to do so, and with what data. In addition,
test results must be analyzed to determine what defects they uncovered. We therefore treat each test as an
item of value. Test procedures, test data, and test records are maintained; tests are reused or modified where
possible. Examples of test documentation can be found in Chapters 26 and 2 7 .
25.7 TEST PLANNING

To maximize the effectiveness of resources spent on testing, a systematic approach is required and a plan
is devised . Recall that the goal is to detect as many errors as possible at as serious a level as possible
with the resources available . Typical planning steps are shown in Figure 25.8 and elaborated in the rest of
this section.
25. 7 .1 Orga n ize " U n it" VS . No n-unit Tests

The limits of what constitutes a "unit" have to be defined by the development team . For example, do they
include the testing of packages , or is this to be considered another type of testing?

1 . Define "units" vs. non-units for testing
2 . Determine what types of testing will be performed
3. Determine extent
Do not just "test until time expires"
Prioritize, so that important tests are definitely performed
•

•

4. Document

Individual's personal document set included?
How/when to incorporate all types of testing?
How/when to incorporate in formal documents?
How/when to use tools/test utilities?
5. Determine input sources
6. Decide who will test
Individual engineer responsible for some (units)?
How/when i n spected by QA?
How/when designed and performed by third parties?
7. Estimate resources
Use historical data if available
8. Identify metrics to be collected
Define, gather, use
For example, time, defect count, type, and source
•

•

•

•

•

•

•

•

•

•

Figure 25.8 A plan for testing

TEST P LAN N I N G

•

When tester has not been able to find another defect in 5 ( 1 O? 30? 1 00?) m i nutes of testi ng

•

When all nominal , boundary and out-of-bounds test examples show n o defect

•

When a give n checklist o f test types has been completed

•

After completing a series o f targeted coverage ( e . g . , branch coverage for unit testi ng)

•

When testi ng runs out o f its scheduled time

Figure 25. 9 Stopping criteria for testing

For obj ect- oriented development projects, a common sequence of unit testing is to test the methods o f
e a c h c l a s s , t h e n t h e classes o f e a c h package , and then t h e package as a whole . I f we were building a
fram ework, we would test the classes in each framework package first a n d then move on to the application
package s , because the latter depend on the former. Once the "un i ts" and n o n - u n i t tests have been i de n ti fied,
they must be organized and saved i n a systematic manner.

25.7.2 Determ i ne the Extent of Testing
S i nce i t i s i m p ossible to test for every possible s i tuati o n , the extent o f testi ng should be considered and defined
i n advance. For exam ple, i f a banki ng application consi sts o f wi thdrawals, de posits, and queri es, u n i t testing

could speci fy that every method should be tested w i th an equal amount of legal , boun dary, and i l l egal data; or
perhaps, due to the i r sensi tivity, with drawal and deposit methods are tested three times as extens ively as
query methods, and so on. Test cases are selected both from normal expected operatio n , as well as from those
judged most l i kely to fai l . Stopping criteria are establ ished i n advance; these are concrete conditions upon which
testi n g sto p s . Examples are listed i n Fi gure 25. 9 .

25.7.3 Decide How Tests Wi l l B e Docu mented
Test documentation consi sts of test procedures, i n put data, the code that executes the test, output data,
known issues that cannot be atte n ded to yet, and efficiency data . Test drivers and uti l i ties are used to execute
unit tests , and these are documented for future use. J U n i t i s an example o f a u n i t test uti l i ty (described i n more

detail i n Chapter 2 6 ) . J U n i t - l ike and various professional test uti l i ties help developers to retain test
docum e n tati o n . J U n i t classes, i n particular, tend to be maintained along with the applicati o n .

25.7 .4 Decide How a n d Where t o Get Test I n put
Appl ications are developed to solve probl ems i n a spec i fic area, and there i s o ften a set o f test data spec i a l to
the applicati o n . Examples are as fol l ows:

•

Standard test stock marke t data for a brokerage application

•

Standa rd test chemical reactions for a chemical engineeri n g appl ication

•

Standard FDA procedures for the pharmaceutical i n dustry

•

•

Standard test i n put for a compi ler
Output from previous vers i o n s o f the application
The procurement process and use o f such domai n - spec i fic test i nput must be planned.

627

628

CHAPTER 25

I NTRODUCTIO N TO SOFTWARE TESTI N G

25.7 .5 Decide W h o Wi l l B e I nvolved i n Testing
U n i t testing i s usually perform ed by developers i n a manner o f the i r o w n c h o o s i n g . Tes t i n g beyond t h e unit
level i s planned and performed by people other than the developer-usually an i n ternal QA orga n i zati o n .
U n i t tests are made availab l e for i nspecti on and for possible i ncorporation i n to h i gher-level tests . S o m e post­
unit testing requ i res QA engi neers to understand the des ign , but most organi zations do not support th is
capab i l i ty, and so they assign QA to h igher- leve l , black box testing only. Some of the i nde pendence of QA
can be captured by havi ng development engineers unit-test each o ther's code. I t can also be attai ned by QA
assu m i n g an overs i gh t respo n s i b i l i ty, e nsuri n g that u n i t testing i s performed thoroughly by devel opers .

25.7 .6 Estimate the Resou rces Req u i red
Unit testi ng is often bundled with the development process rather than being called out as a separate budget
item . Good l eaders foster an attitude that the rel iabi l ity of u n i ts is essenti al, and they allow developers
sufficient time to attain re l i able units . Testing beyond the u n i t l evel is an i dentifiably separate i te m , usually
associated with the proj ect's budget but sometimes a part of QA's whole budget. Employing a th i rd party for
testing is sometimes used-i ncludi ng offshored resources-a n d must be budgeted for .

25.7 .7 Arra nge t o Track Metrics
The development organization specifies the form in which engin eers record defect counts , defect types , and
time spent on testing. The resulting data are used to assess the state o f the applicati o n , to forecast the j ob's
eve ntual qual i ty and completion date , and as h istorical data for future projects. The data also become part of
the organi zation's h i s torical record.

25.8 TESTING TEST SU ITES BY FAU LT INJECTION
Suites o f tests and t e s t p l a n s can be evaluated , and there are ways to i m p rove the m . Mutation testing, i n
particul ar, val i dates testing suites rather than t h e code under test itsel f. Suppose that w e have developed a
suite of tests for all or part of an applicati o n . Fault injection is the process of del iberately i nserti ng faults i n to a
progra m . Mutation tes ting is a kind of fault injection whereby we change the source code i n smal l , controlled,
and del iberately incorrect ways to determ ine whether the resulting i nj ected errors are detected by the test
suite . Exam ples are changi n g a true to a false and a ">" to a ">=". If our tests continue to pass des p i te fault
i njections, thi s exposes weakness i n our curre nt test suite . We can i n fer that the test suite is probably fai l i ng to
fi n d defects that we did not i n sert. By worki n g on faul t i nsert i o n , it is possible to estimate the number of
defects that our test suite is fai l i n g to find.
Mutation i s said to have origi nated by R. Lipton i n a 1 97 1 class. It i s computationally i ntensive, which is
one reason it took some time to become active as an area o f research and practic e .

25.9 SU MMARY
Software testi n g is a val i dation process , the purpose of which is to detect as many defects of as high a level o f
seriousness as possib l e . Defects are detected w h e n t h e software under t e s t i s provided w i t h i nput, and the
resulting output does not m atch the expected output.
Two basic pri nciples o f so ftware testi n g are "test early" and "test ofte n . " ''Test early" means that as soon as
a software part is i m plemented i t should be tested. Th i s en sures that defects are detected as close to the ir
i n troduction as possible, making them easier and cheaper to detect and correct. ''Testi ng o fte n" means

EXERCISES

run n i n g tests at every reasonable opportun ity, i ncluding after addi tions or modifications have been made .
Updated code may adversely affect the existing code, and the errors should be found and repaired as quickly
as poss i b l e . The testi ng for capabi lities alre ady attained prior to update is known as regression testing and is
performed throughout the testing process.
There are two basic test methodologi e s : black box and whi te box. Black box testing does not take into
account the manner in wh ich the software is designed or implemented. Test i n puts are prOVided based on the
requirements of the applicat i o n , and outputs are examined to ensure they match what is expected. White box
testi ng takes the design and implementati on into consi deration, and i nputs are devised with these i n mind.
U n i t test i n g is performed on the methods and classes of the software . It employs both wh ite box and
black box techn i ques. It ensures that the underlying structure of the software is sound. After some or all units
are tested, post-u n i t tests are run that test the larger syste m . These i nclude interface , integration, system,
usab i l i ty, regressio n , acceptance, and i nstallation testi ng.

25. 1 0 EXERCISES

1 . Why not wait for many p arts to be built, and then test them together? Th is seems to kill several
birds with one stone .

2 . Suppose that you have a developing applicati on, tested so far, to which you add code . Why not, as
the next ste p , test the combined result?
3. Expla i n why (a) wh i te box testing, by i tsel f, is not enough and (b) black box testing, by i tself, is not
enough .

4. Why is unit testing most commonly performed by software engi neers who program and post-unit
testing by QA personnel?

5 . Why shoul d test planning be speci fically i denti fied as an activity rather than being pursued
i n formally when the time comes?

629

Unit Testing

�nl
Testing

Planning
en.nco

The Software
Development
Lifecycle

How do you go about unit testing?

\

What is statement coverage? Branch
coverage? Path coverage?

Requirements
analysis

Implementation

� DeSign

What parts of the code should be
subjected to unit testing?

/

How does equivalence partitioning help in
selecting test cases?
How do you use stubs when the unit under
test requires other - but unbuilt - units?
How do you use J Unit?
What is test-driven development?
How is unit testing done in case studies?

Figure 2 6 . 1 The context and learning goals for this chapter

Unit testing is the testing of the parts of an a p p l i cation in isolatio n . Typically these are the methods and
classes . Unit testing i s conducted by so ftware developers e i ther i n paral lel with i m plementati on or after a part
of the appl icati on is coded. In e i ther case both wh i te box and black box methods are employed. Wh i te box
uni t tests focus on the unit's i nternals such as program logic, branch poi nts, and code paths . Black box u n i t
tests focus on provid i n g i n puts b a s e d on t h e particular requirements of t h e unit, val idating th at correct
outputs are produced. Once they are successfully tested in isolati o n , un i ts are ready to be i n tegrated and

UNIT TEST M ETHODS

Key: --+

I

"specifies"

Implementation-time
specification

Example:
get O VO title

Design document
(SOD)
Requi rement
document

�

(SRS)

Example: "It shall be
possible to add a OVO
to the video store's
inventory"

I

Domain
classes

I

I mplementation

I

f-----.

Example:
method addOVO( . . )
"Preconditions: .
Postconditions: .

unit
(code for method or class)

Example:
void setOVOName( . . )

Figure 26.2 The source of un its for unit testing

tested together. Th i s is what we will call post-unit testing and is covered in Chapter 27. The rest of th i s chapter
descri bes spec i fi c test meth o ds and strategies employed i n unit testi n g .

26.1 THE SOU RCES OF U N ITS FOR U N IT TESTI N G
The first step i n u n i t tes ting i s identi fying u n i ts a n d determi n i n g what they are intended t o do . These are
obtained from the SRS or the S O D . They may also be elements too m i nor to spec i fy in the S O D . Figure 2 6 . 2
i l l ustrates this for the video store exam p l e .
F o r units ari s i n g from des i gn , w e m a y not possess expl i c i t requirements against w h i c h t o perform tests .
An example is a test for the class GameCharacter, i n troduced for the des i gn of our vi deo game; none of the
original requirements speci fically i nvolves GameCharacter per se. Separate speci ficati o n s should be written for
all design classes once the design i s created. When these are not wri tte n , as i s often the case, test cases have to
be devised against the functi o n a l i ty that the class is supposed (by the tester) to possess . Figure 2 6 . 3 illustrates
u n i t testi n g against requirements and against des ign .

26.2 U N IT TEST METHODS
Both white box and black box methods are uti l i zed duri ng unit testing. Some o f the pri ncipal techniques
are shown i n Figure 2 6 . 4 . As described in Chapter 25, wh i te box testi n g i s conducted with knowledge of
the design and i m plementation o f the u n i t under test. The wh ite box unit tests focus o n the i n ternal code
structure , testi n g each program statement, every decision point, and each i n dependent path through the
code . Black box methods focus on testing the unit wi thout using i ts i n ternal structure . Tech n i ques used to
conduct bl ack box unit tests i nclude equivalence parti tioning and boundary value analys i s , topics that are
explained in detail below.
There has bee n , and conti nues to be, research on the relationship among these testi ng types since they
o ften overlap and also leave various kinds o f gap s . An example o f past research i s described by S. Rapps and
E . J . Weyuker [ 1 ] , i n which paths are selected on the basis o f where variables are defined vs . where they are
used. Nevertheless, the types discussed form a good starti n g p o i n t and practical bas i s .

631

632

CHAPTER 26

U N IT TESTING

( 1 ) D-Requirements

(2) Design

3.2.EC . 1 .2 Qualities of Encounter

GameCharacter: An abstract class

characters

with attribute name . . .

,

Every game character has the
same set of qualities. Each quality
shall be a nonnegative floating
point number with at least one
decimal of precision . . . .

\

"-

"-

Test this class . . .
. . . against this requirement

,

/

Characters

.......

Test this method . . .

Figure 26.3 Relating tests to req uirements and desi g n

26.2 . 1 Statement Coverage
At a minimum, every statement in a program must be executed at least once duri ng unit testi ng. If a l i n e of
code contains a defect, tests that never execute the line will not detect the defect. Untested statements are
thought by many to be a major cause of latent defects .
Consider the function computeFine 0 shown in Listi ng 26. 1 . We will use a directed graph , called a program
control graph, to graphically represent the control paths of the progra m . Figure 26. 5 conta i n s the program
control graph of computeFineO , where each node in the graph represents an executable l i n e of code, and each

White Box Methods
•

Statement coverage

Test cases cause every line of code to be executed
•

Branch coverage

Test cases cause every decision point to execute
•

Path coverage

Test cases cause every i n dependent code path to be executed
Black Box Methods
•

EqUivalence partitioning

Divide input values i nto equivalent groups
•

Boundary value analysis

Test at boundary conditions
Figure 26.4 Methods for unit testing , categorized by black box and wh ite box types

UNIT TEST METHODS

Figure26.5 Control flow graph of computeFineO, with numbers keyed to listing 26.1

edge represents the transition between lines of code. In the graph we represent decision points such as if, while,
or for statements as a diamond, and all other executable statements as a circle.

Listing 26.1: Computing a fine for a late rental
int computeFine (int daysLate , boolean printOn)
{
int MAX_FINE_PERIOD = 21, fine = 0;
1
if (daysLate <= MAX_FINE_PERIOD) {
2
fine = daysLate *DAILY_FINE ;
3

6

}
logF ine (fine) ;
if (printOn == TRUE) {
printF ine (fine) ;

7

}
return fine ;

4
5

}

In order to satisfy statement coverage, tests are devised with inputs that ensure each line of code is
executed at least once. As shown in Table 26.1, only one test is necessary to satisfy statement coverage of

computeFine() (but not truly complete coverage, as we shall see).

633

634

CHAPTER26

UNIT TESTING

Table26.1 A test for computeFineO
Test Case #

daysLate

printON

path

1

1

TRUE

1 -2 -3 -4-5-6 -7

26.2.2 Branch Coverage
Statement coverage is satisfactory for determining whether a particular line of code has an error, but it will not
catch all types of errors by any means. In fact, computeFine() does have a defect: the variable fine should be
initialized to MAX_FINE on line t , not to O. The defect will manifest if daysLate is input with a value greater

than MAX_FINE_PERIOD. This was not detected in the statement coverage test because, although the if
statement on line 2 was executed, the branch for daysLate > MAX_FINE_PERIOD was not tested.
A stronger form of test coverage, one that includes statement coverage and detects this type of defect, is

branch coverage, which means that for every decision point in the code, every branch is executed at least once.
listing 26.2 contains an updated computeFine() function, with the aforementioned defect repaired-the
variable fine is now initialized to MAX_FINE on line 1.

Listing 26.2: An updated computeFineO function
int computeFine (int daysLate , boolean printOn)
{
1
int MAX_FINE_PERIOD = 21 , fine = MAX_FINE ; //defect fixed
2
if (daysLate <= MAX_FINE_PERIOD) {
3
fine = daysLate *DAILY_FINE ;

6

}
logFine (fine) ;
if (printOn == TRUE) {
printFine (fine) ;

7

}
return fine ;

4
5

}

To satisfy branch coverage, one or more tests are run with appropriate inputs to ensure that every
statement is executed at least once and every branch decision is executed at least once. The two test cases in
Table 26.2, for example, satisfy these conditions.
The execution path of each test case is shown in the program control graphs of Figure 26.6, with the

bold arrows depicting the control flow.
26.2.3 Path Coverage
An even stronger form of test coverage is path coverage, in which all distinct code paths are executed by at least
one test case. By distinct code paths we are referring to the complete set of sequences of branches and loop

UNIT TEST METHODS

Table 26.2 Tests sufficient to satisfy branch coverage
Test case #

days Late

printON

path

1

1

TRUE

1-2-3-4-5-67

2

60

FALSE

1-2-4-5-7

Test Case #1

Test Case #2

False

False

Figure26.6 Branch coverage of computeFineO, with numbers keyed to Listing 26.1

traversals, even if they differ by just one small part of the path.This type of testing detects errors that only
occur if a specific path is executed. Path coverage subsumes statement and branch coverage. As an example,

computeFine() contains two if statements, each with two branch decisions: true and false. Therefore computeFine()
has four distinct paths through the function as illustrated in Figure 26.7.
Four test cases would be required to test all the distinct paths of computeFineO, one for each path, as
shown in Table 26.3.
As the number of branches and loops increase, the number of distinct paths grows exponentially. It
quickly becomes impractical to test them all. For example, if the number of decision points is 3D, the number
of distinct paths is over 1 billion. It is therefore necessary to limit the number of paths to test. A commonly
used method of making the tests viable while gaining Significant confidence is to compute the number of
linearly independent paths, or basis paths, through the code under test. This can be thought of as the minimum
number of paths that can be combined to generate every possible path, and is the minimum number of paths
that should be tested.

635

636

CHAPTER 26

UNIT TESTING

Path #3

Path #2

Path #1

Path #4

False

False

False

False

Figure 26.7 Distinct paths of computerFineO, with numbers keyed to Listing 26.1

The number of basis paths can be calculated by computing the cyc/omatic complexity [2], which has its
roots in graph theory. The first step in computing the cyc\omatic complexity is to represent the code with a
program control graph. Then the cyc\omatic complexity (CC) is calculated with the following formula:
CC =e- n+2
where e = the number of edges, and n

=

the number of nodes.

As an example, Listing 26.3 contains an updated version of computeFines() that has input an array
containing the number of days late for a list of DVDs. [n order to process the list, a for loop is introduced,
adding an additional decision point in the function. Figure 26.8 shows the corresponding program control
graph for this computeFines()'

Table 26.3 Test cases for all the distinct paths of computeFineO
Test Case #

daysLate

printoN

Path

1

1

TRUE

1 -2-3 -4 -5-67

2

60

FALSE

1-2-4 -5--7

3

1

FALSE

1 -2-3-4-5-7

4

60

TRUE

1 -2-4 -5-6-7

UNI TTEST METHODS

.----7'" 2 ,.-----,

'-------.<1 0
Figure 26.8 Program control graph for computeFinesO, with numbering keyed to Listing 26.3

listing 26.3: updated function--computeFinesO
int computeFines (int daysLate[J , int numDVD , boolean printOn)

{

1 int MA X_FINE_PERIOD = 21, int cumF ine = 0;
2 for (i=O ; i < numDVD ; i++) {

5

fine = MA X_FINE
if (daysLate[iJ <= MA X_FINE_PERIOD) {
fine = daysLate[iJ *DAILY_FINE ;

6
7
8

}
logFine (fine) ;
if (printOn = = TRUE) {
printFine (fine) ;

9

}
cumF ine += fine ;

3
4

}

10 return cumFine ;

}

637

638

CHAPTER 26

UNIT TESTING

To calculate the cyclomatic complexity of computeFines(), we refer to the program control graph in
Figure 26.8 and note that there are 12 edges and 10 nodes. Therefore, CC is calculated as follows:
CC

=

12 - 10 + 2 = 4

This tells us that there are four basis paths. To generate a specific set of basis paths, the following steps
can be followed.
1. Start with the straight path through the code (all conditions true) .

2. Set the first condition to false, keeping all the rest true.
3. Reset the first condition to true, set the second condition to false, keeping all the rest true.
4. Continue, setting the next condition false with all the rest true.
5. Stop after the last condition has been set false.

That is, each basis path varies only one of the conditions at a time. Note that the condition nodes in this

function are 2, 4, and 7, which are the for statement and the two if statements.Using this algorithm, the four
basis paths for computeFines() are as follows:
Basis Path #1: 1-2-3-4-5-6-7-8-9-10 all true
Basis Path #2: 1-2-10 for statement false
Basis Path # 3: 1-2- 3-4-6-7-8-9- to first if statement false
Basis Path #4: 1-2- 3-4-5-6-7-9-10 second if statement false
The corresponding program control graphs are shown in Figure 26.9.
Four tests are then devised with appropriate inputs to ensure that each basis path is executed once, as
shown in Table 26.4.

26.2.4 Equivalence Partitioning
The challenge of testing is the selection of a test set. For example, a function such as computeFine(),
which takes a simple integer parameter daysLate, has all of 232

=

4 billion possible input values. Any test

set is a truly tiny subset of the collection of all possibilities, and so we want it to be as representative as
possible.
Equivalence partitioning is a black box test method in which parameter values are divided into
nonoverlapping sets that constitute the complete set of possibilities ("partitions"), with the values in each
partition expected to produce similar test results. If we can identify such a partitioning, we can have some
confidence in a test that selects one value per equivalence partition as test input.Equivalence partitioning is
also used in system testing, which is discussed in Chapter 28.
The potential input values for a test can be thought of as points in parameter space: an n-dimensional space
with one dimension per parameter. For example, if we are testing a method intended to compute the area of a
rectangle, the parameter space is two-dimensional; each width/length pair is a point in two-dimensional space.
As another example, suppose we want to test that the video store function discussed above correctly
computes the fine on late movies. Suppose that the store's penalty depends on the number of days late-as
usual-but also on whether the movie is a new release, old release, or "one-of-a-kind." The parameter space

Figure 26.9 Basis paths for computeFinesO

'---��r10

r---< 2 )><11..
_---.

Basis Path #1

2 )><IIlIIf----,

Basis Path #2

2 ) ..

Basis Paths #3

Basis Path #4

0W
-0

o
C/)

:::I:
o

�

s:

:q

-t
m

=i

c
z

640

CHAPTER 26

UNIT TESTING

Table 26.4 Tests that cover all basis paths
Test Case #

daysLatell

numDVD

printON

Basis path

1

[1,5,14]

3

TRUE

1-2-3-4-5-6-7-8-9-10

2

[1,5,14]

0

TRUE

1-2-10

3

[1,5,60]

3

TRUE

1-2-3-4-6-7-8-9-10

4

[1,5,14]

3

FALSE

1-2-3-4-5-6-7-9-10

can be thought of as consisting of the points shown in Figure 26. 10. The parameter space is not limited to
legal values; it includes values that are not permitted. Figure 26. 10 suggests the shape of this parameter space.
Suppose that the store's fine calculation requirement is as follows:
The fine shall be $2 per day for the first 5 days and $ 1 per day after that, up to the value of the
movie. The value of all new releases shall be taken to be $20, one-of-a-kind releases $ 15, and old

releases $ 10.

The parameter space decomposes into corresponding regions such as "new release between 0 and 5 days
late," each having the following property.

The application behaves in a similar manner for all values in each region.
These are called equivalence partitions, or equivalence classes.
Creating equivalence classes can be demanding. To focus on one region in our video store example, we
expect that the algorithm behaves in the same way for all of the parameter points in the new releasei6-15 days late
partition shown in Figure 26.11.

Each element represents a pair: (Days latel Movie name)

,

,,' ::::: I 111111111 1 :..:.:1 11111 :::::
old releases '. ::::: 111111
11111 1 :..:.:1 11111:::::
new releases

,
,
,
,

,

I

I

one-of-a-kind

'-

,

11111111111 ::
" ':1 11111:::::
............................................. >
-5

o

5

10

e.g., (6 days late, "Casablanca")
Figure 26.10 Parameter space for computeFinesO

15

Days late

,
,
,
,

U NITTEST METHODS

88888888881

new release

o

5

Days late
Figure 26.11 One equivalence partition of computeFinesO

new release
old release
one-of-a-kind

-5

o

5

10

15

Days late
New release DVDs
6- 15 days late
Figure 26.12 Equivalence partitions of computeFineO method

A full parameter space equivalence partition for this example is shown in Figure 26.12.
To identify equivalence partitions, determine the limits-or boundaries-on the individual variables or
combinations of variables. These limits can be seen either in the code itself or in the requirements that the
variables reflect. Often, the relevant requirements are in the form of business rules. The fine policy of the video
store example is a good example of a rule for doing the business of renting. Once the equivalence partitions
have been determined, we create test cases as in Figure 26.13.

26.2.5 Boundary value Analysis
Many errors occur at the boundaries between equivalence classes. As an example, computeFine() contains a
boundary between 5 and 6 days late, because at 6 days a fine starts accruing. A common coding error might be

Test
•

values strictly within each region

•

values at region borders

Notes:
•

•

Include all illegal regions
Within each constraint, select randomly
For example, with "new release" input, select lateness days at random between 6 and j 5, excluding 6 and i 5
•

Figure 26.13 Using equivalence partitions to create test cases

641

642

CHAPTER 26

UNITTESTING

to use ">=" instead of "=" when checking for a boundary condition. For example, the code that checks for the

new re1easei6-15 days late equivalence class in computeFineCJ should read as follows.
if ( (numDaysLate > 5) && (numDaysLate <= 15))
However, a common error is to write code like the following.

if ( (numDaysLate >= 5) && (numDaysLate <= 15))
If we were to use only a value of 6 to test this equivalence class, the boundary error would not be
detected.
Values equal to and on either side of a boundary should be tested. In the example above, we are
interested in testing the equivalence class with values in the range [5 ..15]' inclusive. Test cases should be
executed that include the following values for numDaysLate as input: 4, 5, 6, 10, 14 , 15, 16.
In general, one identifies boundaries as follows, the principal sources for unit testing being class
invariants and method preconditions.
1. Identify all of the variables involved, global and local.
2. Identify their limits, individually and in combination (example: the condition 2<x+y<7 identifies 2 and

7 as boundaries for x+y).
3. Test for combinations of these variable/combination/values. Testing all combinations is ideal but when
this is impractical, we select those that appear most likely to fail or we select combinations at random or
both.
Note that 2 being a boundary for x+y implicates the straight line x+y=2 in the x-y plane as a boundary.

26.3 TESTING METHODS
Unit testing typically starts by testing the methods of a class. In this section we discuss how to carry this out in
an orderly way, incorporating the methodologies covered in the previous section.

26.3.1 Checklist for Testing Methods
Humphrey [3J recommends the checklists in Table 26.5 for performing method tests.

26.3.2 Organizing Test Cases
By now you may be overwhelmed by the sheer number of different types of tests. Several test types overlap.
For example, a test with normal inputs may have statement coverage, branch coverage, and path coverage.
One way to simplify and organize the unit tests is to list the testing types as in Table 26.6, and to number the
individual tests accordingly.

26.3.3 Stubs
A method frequently depends on classes other than the one containing it. This presents no problem if the
needed classes have already been built and tested. Otherwise, we use stand-ins with the same name but with

TESTING METHODS

Table26.5

Humphrey's unit-testing checklist, categorized black box or white box in the context of a method test

operation

comment

1. verify operation at normal parameter values

a black box test based on the unit's requirements

2. Verify operation at limit parameter values

black box

3. Verify operation outside parameter values

black box

4. Ensure that all instructions execute

statement coverage

5. Check all paths, including both sides of all branches

path coverage

6. Check the use of all called objects

white box

7 . verify the handling of all data structures

white box

8. verify the handling of all files

white box

9. Check normal termination of all loops

white box: part of a correctness proof

10.Check abnormal termination of all loops

white box

1 1.Check normal termination of all recursions

white box

1 2. Check abnormal termination of all recursions

white box

13. verify the handling of all error conditions

gray box

1 4 . Check timing and synchronization

gray box

1 5. Verify all hardware dependencies

gray box

just enough substance to support the method under test. These are called stubs. For example, suppose that we
want to test the rent() method in the Rental class of the video store application framework. It depends on the
classes Rentalltem and RentalCustomer as shown in Figure 26.14. We therefore create stubs for these two classes as
shown.
Simple stubs like these are not sufficient beyond the method-testing level. As we will describe in
Chapter 27, in that case we require artifacts known as "drivers" as well.

26.3.4 Example of a Method-Level unit Test
As an example of a unit test, we will test for the following detailed requirement for the Encounter case study.
3.2.EC.l.2 Qualities of Encounter characters. Every game character has the same set of qualities.

Each quality shall be a nonnegative floating point number with at least one decimal of precision.
These are all initialized equally so that the sum of their values is 100. The value of a quality cannot
be both greater than zero and less than 0.5. For the first release the qualities shall be concentration,

stamina, intelligence, patience, and strength.
An appropriate test set for a method adjustQuality(String qualityP, float valueP) is given next. This method
sets the quality named by qualityP to valueP and adjusts the remaining qualities so that the proportion of
the remaining available points remains the same. Within each of the "on range boundaries," "outside range, "

643

644

CHAPTER 26

UNIT TESTING

Table 26.6

Checklist for unit tests-an example showing which
tests fulfilled each question
Test type

Tests

1. Within bounds?

1, 1 2 , 1 4, 15

2. On boundary?

1 2,3,5

3. Out of bounds?

6,3, 4

4. Covers all statements?

9

5. Covers all branches?

1

6. Covers all paths?

1, 10

7. Assertions tested?

12

8. Use all called objects?

6

9. Verifies handling data structures?

8, 7

10. Handles all files?

12

1 1. Tests all loops with normal terminations?

12

1 2. Tests loops with abnormal terminations?

7

13. Tests all normal recursions?

N/A

1 4. Tests all abnormal recursions?

N/A

15. Tests all error conditions?

11

16. Tests all synchronizations?

N/A

17. Tests all hardware dependencies?

N/A

Rentalltem

Rental

RentalCustomer

neededByRentO

rentO

neededByRentO

dependence

Rentalltem

Rental
renlO

neededByRentO
•.....

for testing
.

Figure 26.14 Using stubs to test a method

stubbed

RentalCustomer
neededByRenlO
.. .
. .

TESTING METHODS

Figure 26.15 Partitioning adjustQualityO at the top level

Results in zero

Does not result in zero

Figure 26.16 partitioning adjustQualityO-"within range"

and "within range" categories, we try to obtain systematic coverage by seeking representatives of each
equivalence partition. Figure 26. t 5 is typical of a systematic decomposition of the input space into
equivalence partitions.
The next levels of partitioning are shown in Figures 26. t 6,26. t 7, and 26.18, and the actual test cases are
listed below.
A resulting test suite is shown in Table 26.7.

On boundary

Parameter

=

Parameter

zero

Figure 26.17 Partitioning adjustQualityO-"on boundary"

Out of range

Figure 26.18 Partitioning adjustQualityO-"out of range"

=

total current points

645

646

CHAPTER 2 6

UNIT TESTING

Table 26.7 A test suite for adjustQualityO
Key to unit tests of adjustQualityO (Details for each test follow this table)

1. Within range
1.1 adjustQualityO does not result in a zero value
1.1.1 quality parameter == "concentration"
1.1.2 quality parameter = = "stamina"
.. .
1.2 adjustQualityO does result in a zero value
1.2.1 quality parameter == "concentration"
1 .2.2 quality parameter == "stamina"
.

.

.

2. Parameters at range boundaries
2.1 zero parameter
2.1.1 quality parameter == "concentration"
2.1.2 quality parameter == "stamina"
...
. .. .
2.2 parameter value == current total points
2.2.1 quality parameter == "concentration"
2.2.2 quality parameter == "stamina"
.. .
3. Parameters outside range
3.1 Above upper limit of parameter values
3.1.1 quality parameter = "concentration"; total pOints = 100; parameter 10 1
. ..
3.2 Below lower limit of parameter values
3.2.1 quality parameter = "concentration"; total points = 100; parameter -10 1
.

.

.

The following are the details for each of the tests.
Test 1.1.1

Input: (Ideally, choose these at random between 0 and 100 to sum to an amount less than 100.)
Concentration 20; Stamina 20 [1/4 of the non-"concentration" pointsllntelligence 20; Patience 20; Strength 20;

Execute: adjustQuality("concentration," 10) (Ideally, this value is chosen at random within bounds guaranteed
not to result in a zero "concentration" value. )

TEST-DRIVEN D EVELOPMENT

Expected output: Concentration 20 + to
"concentration" points); Intelligence 70/4
Tests 1.1.2, 1.1.3, .. .

=

=

30; Stamina 70/4= 17.5; (Note: remains 1/4 of the non-

17.5; Patience 70/4= 17.5; Strength 70/4= 17.5;

are similar, using the other qualities instead of concentration.

Test 1.2. 1

Input: Concentration 20; Stamina 20; Intelligence 20; Patience 20; Strength 20;
Execute: adjustOua/ity("concentration", 99)
Expected output: Concentration 99; Stamina ° ( 1/4 result replaced by zero) ; Intelligence ° ( 1/4 result
replaced by zero);Patience ° ( 1/4 result replaced by zero); Strength ° ( 1/4 result replaced by zero);
Tests 1.2. 2, 1.2.3, . . .

are similar, using the other qualities instead of concentration.

Test 2. 1. 1

Input: Concentration 0; Stamina 25; Intelligence 25; Patience 25; Strength 25;
Execute: adjustOua/ity("stamina", 74)
Expected output: Concentration 0; Stamina 99; Intelligence ° (result of 1/3 is set to zero) ; Patience ° (result
of 1/3 is set to zero); Strength ° (result of 1/3 is set to zero)
Tests 2.1..1.2, 2.1.1.3,
Tests 2.2, 2.3,

. ..

. .. are similar

pertain to other extremes. For example:

2.N adjustOualityC) called with parameter equaling a current value
Input: Concentration 0; Stamina 25; Intelligence 25; Patience 25; Strength 25;

Execute: adjustOua/ity("stamina", -25 )
Expected output: Concentration 0; Stamina 0; Intelligence 3 3; Patience 3 3; Strength 33;
Test 3.1.1

Input: Concentration 20; Stamina 20; Intelligence 20; Patience 20; Strength 20;
Execute: adjustOua/ity("concentration , 81 )
Expected output: Message to error log stating that adjustOua/ityC) was called with out-of-range input;
"

Concentration 100; (20+81 set to 100); Stamina 0; (after concentration is set, there are no remaining quality
points to distribute); Intelligence 0; Patience 0; Strength °
Tests 3.1.2, 3.1.3,

. . . are similar

Tests 3. 2, 3.3, . . . are similar to test 3. 1
Test 3.N.l

Input: Concentration 20; Stamina 20; Intelligence 20; Patience 20; Strength 20;
Execute: adjustOua/ity("concentration", -21 )
Expected output: Message to error log stating that adjustOua/ity() was called with out-of-range input;
Concentration 0; (20-2 1 set to zero); Stamina 25; ( 100/4); Intelligence 25 ( 100/4); Patience 25 ( 100/4);
Strength 25 ( 100/4).
The remaining test set is generated in a similar manner.
The relevant parts of the code for adjustOua/ity are part of the class EncounterCharacter, given in Listing
26.to found in Section 5. 1.

26.4 TEST-DRIVEN DEVELOPMENT
An effective method for performing unit testing is to conduct testing in parallel with implementation.In fact,
an effective way to build quality into an implementation is to specify the tests that an implementation must
pass before writing the code. After writing such a test, one adds to the implementation until the test succeeds.

647

648

CHAPTER 26

UNIT TESTING

This is called test-driven development (TOO) . TOO is often associated with agile development, but it is useful
within any development process. The general steps involved in TOO are as follows:
t. Write a test case for some code that is yet to be implemented.

Envision what the code is supposed to do. Oepending on how thoroughly this part of the code was
previously designed, a bit of detailed design may be required. Tests are typically created to test only a
relatively small amount of code-as little as several lines.
2. Run the test case to verify it, which fails.
The first run of the test should always fail, since the code to make it pass has yet to be written. If it does
pass, there is a bug in the test case and it needs to be fixed.
3. Write only as much code as necessary to make the test pass.

In this way a clean implementation emerges with minimal extraneous code.
4. Run the test case.
If it still fails, go back to Step 3 and fix the problem in the implementation. If it passes, the test case is
complete. If there is more implementation to be done, repeat these four steps.
Figure 26. t 9 summarizes this process.
There are many advantages to TOO, including the following:
Statement coverage-A natural by-product of TOO is that after the tests are written and pass, every line
of code is executed by at least one test. Thus statement coverage is satisfied.
Cleaner code-As we mentioned previously, only as much code as necessary is written to make a test
pass. This results in an implementation that tends to be clean and contains little extraneous code.
Rapid feedbac k-Once a section of code is written, it is immediately tested, providing instant feedback
as to its correctness. This leads to quicker development time as bugs are easier to identify and correct.
Suite of unit te st s -After a test is written and passes, it is saved along with other tests being developed. In
this way a suite of unit tests is created and can be used for future testing activities such as regression testing.
It is common to perform TOO within a testing framework such as lUnit, which we describe next.

Test fails

Figure 26.19 Test-drive development-the activities

Test passes, more
tests to be written

TEST-DRIVEN DEVELOPMENT

26.4.1 Using JUnit for unit Testing

lUnit is a public-domain test framework widely used to "write and run repeatable tests" [4].It is implemented
in and used for testing Java programs. It supports unit testing with tools for test result execution, reporting,
and error handling.
Suppose, for example, we have a Calculator class and we want to write a test for a yet-to-be coded

subtract method. If we are using TDD, the first step is to write a unit test for the envisioned method. By
convention, when testing a class X, tests are placed in a class TestX and every method performing a test of
method mmmmO is labeled testMmmmO.
Listing 26.4 is a TestCalculator class that contains one test called testSubtract.
Listing 26.4: JUnit class for testing Calculator
import juni t.fr amework.TestCase i
public class TestCalculator extends TestCase
{
public void testSubtract( )
{
Calculator c = new Calculator ( ) i
// Test 1: Nominal Case
double r = c.subtr act (2.0000000001, 3.0000000002) i
assertEquals(-l. OOOOOOOOOl, r , 0) i
// Test 2: Corner Case
r = c.subtract (Double.MAx_vALuE , Double.MAx_vALUE) i
assertEquals ( 0. 0, r , 0) i
}
}

By examining testSubtract we can imagine the code we must write to pass the test:
1. A subtract method that takes two double arguments and returns a double result.

2. An implementation of a subtract method that subtracts the second argument from the first and returns the
result of the subtraction.
To fulfill our envisioned method, we write a subtract method such as in Listing 26.5.

Listing 26.5: Building subtractO method for the class Calculator
package EB .calc i
public class Calculator

{

649

650

CHAPTER 26

UNIT TESTING

publ ic double subtract (double nl, double n2)

{

return nl - n2;

}
}

Test class name:

EBI::.::..:.: .c..:.31..:...c.T..e..:....: sI..:..c3....:'c_u'..:.aIor..:.. .

...lI_...l1 CJ �

________

...

� Reload classes IMIfY roo
Runs: 1'1

x Errors: 0

x Failures: 0

u

Resuls:

I.,
XF..-es

�mlshed: 0.04 seconds
Figure 26.20 Output of JUnit for a simple test

The result of running TestCalculator in JUnit is the window in Figure 26.20 showing a green bar (for
"passed").
To illustrate what happens when a test fails, we will force a defect with a new subtract that erroneously
converts to float, as in Listing 26.6.

Listing 26.6: Example of a test that will fail
package EB .calc;
publ ic class Calculator

{

publ ic double subtract (double nl, double n2)

{

float subtract ion = (float) nl - (float) n2;
return subtract ion;

}
}

TEST-DRIVEN DEVELOPMENT

J

JUmt

"

,!Unit
Test Class name:

�=====J
=;l� D I

I_
EB_.�
ca=IC . Te st c a IC U lat o r
����=_�= ____�_�_____

o Reload Classes every run

Runs: 111

x Failures:

x Errors: 0

u
1

Results:

x testSubtract(EB.calc.TestCalculator):expected:<-1.0000000001> butwas:<-1.0> '"

x FaUures

Run

l�· ·.·.·.·iF.·.....·.·.'.·.·.·.·.·.·...... .#••••••••••••.••••••�"

•.f,• .•••• •.• ••••••••• •••�.... ....../ ."'.................. ...""............... .. �•••••••••• •••••.••••• .•

I�

•
•• •••••••••••• " •• ••••••••,. •••• ••• • •
• •
•

junil.framework.AsserlionFailedError: expected:<·1.0000000001 > but was:<·1.0>
at EBcalc.TestCalculator.testSubtract(TestCalculator.java:11)
at sun.reftect.NativeMethodAccessorlmpl.invokeO(Native Method)
at sun.reftect.NativeMethodAccessorlmpl.invoke(Unknown Source)

IFinished: 0.04 seconds

Exit

Figure26.21 JUnit display for a failed test

Re-executing the test5ubtract unit test from
Listing 26.4 results in a JUnit response like that shown in Figure 26.21, with a red bar indicating failure.
In order to run multiple unit tests, JUnit implements the YestSuite class.Suppose that in addition to the
YestCalculator/Calculator pair we also have a YestConcatenator/Concatenator pair, as shown in Listings 26.7 and
26.8, respectively. If we run JUnit using the YestAII class shown in Listing 26.9, both of these tests will be
executed.

Listing 26.7: Test for Concatenator class
import junit.f ramework.TestCasei
public class TestConcatenator extends TestCase

{

public void testconcatenation ()

{
Concatenator c = new Concatenator () i
String string = c.concatenationOf ("abc", "def")
assertEquals ("abcdef ", string) i

}
}

651

652

CHAPTER 26

UNIT TESTING

Listing 26.8: Concatenator class
publ ic class Concatenator

{
public Str ing concatenat ionOf (Str ing aStr ingl,
Str ing aStr ing2)

{
return aStr ingl.concat (aStr ing2) ;

}
}

Listing 26.9: A TestSuite example. co mbining tests for Calculator and Concatenator
import junit.f ramework.Test;
import junit.f ramework.TestSu ite;
publ ic class TestAll extends TestSu ite

{
publ ic stat ic Test su ite ()

{
TestSu ite testSu ite = new TestSuite ("A s imple test su ite example") ;
testSu ite.addTestSu ite (TestCalculator.class) ; / / Add all tests
f rom TestCalculator class
testSuite.addTes-tSu ite (TestConcatenator.class) ; / / Add all
tests f rom TestConcatenator class
return testSuite;

}
}

26.5 CASE STUDY: ENCOUNTER VIDEO GAME
26.5.1 Code Listing for EncounterCharacter Class
Listing 26.10 is the class El1coul1terCharacter from the Encounter video game.

CAS E STUDY: ENCOUNTER VID EO GAME

Listing 26.10: EncounterCharacter class from the Encounter video ga me
/* Class Name:
* Date:

EncounterCharacter

01/13/2000

* Copyr ight Not ice: copyr ight (c) 1999-2000 by Er ic J. Braude
* Ed it h istory:
*

24 Dec 2003 Er ic Braude

*
*

24 Jul 2000 Tom VanCourt

*

to show un it test of ad justValue ()
Cached character image rather than

recreat ing it on every repaint.

* 13 May 2000 Tom VanCourt
*

Ed ited to s imple stand-alone version

Moved saveQual ityValues, getOldValue

and oldValueI f rom PlayerCharacter

*/
import java.awt.* i
import java. io.* i

/** Base class f or the characters of the Encounter game.
* <p>Requ irements: SRS 3.2. EC
* <p>Design: SDD6.2.1
* <p>Invar iants: <01>
* <l i>encounterCharacterS contains all ob jects of th is class
* <l i>The values of qualValueI [1 are >= 0
* </01>
* <p>Des ign issues: <ul>
* <l i>Character images are sw itched f reely between r ight- and
* lef t-handed f orms. That means that sword f ighters w ill sw itch
* hands i scabbards w ill sw ing back and forth i scars, tattoos, etc.
* w ill move around, ha ir styles w ill f lop back and f orth, etc.
* It's good enough f or now, though.
* </ul>
* @author Er ic Braude, Tom VanCourt
* @version 0.2
*/
public class EncounterCharacter extends GameCharacter

{

/** Total quality po ints at in it ializat ion.
* <p>Requ irement 3.2. EC.1.2
*/
public static final float QUAL_TOTAL_INIT = 100. Of i

/ / Symbols used when other classes ref er to spec if ic qualit ies.
/** Symbol f or one of a character's qual it ies */
public static final Str ing QUAL_CONCENTRATION = "concentrat ion" i

653

654

CHAPTER 26

UNIT TESTING

/** Symbol for one of a character's qual it ies * /

public static final Str ing QUAL_INTELLIGENCE = " intell igence";
/** Symbol for one of a character's qual it ies * /

public static final Str ing QUAL_PATIENCE = "pat ience";
/** Symbol for one of a character's qual it ies */

public static final Str ing QUAL_STAMINA = "stamina";
/** Symbol for one of a character's qual it ies */

public static final Str ing QUAL_STRENGTH = "strength";
/** Qual it ies that each Encounter character possesses.
* <p>Req: 3.2.EC.1.2
*/

protected static final Str ing[l qual i tyTypeS =
QUAL_STAMINA,
{ QUAL_CONCENTRATION,
QUAL_INTELLIGENCE,

QUAL_PATIENCE,

QUAL_STRENGTH

} ;
/** Root d irectory for graphics f iles. * /

static final Str ing FILE_ROOT = "edu/bu/braude/SWEngExample/";
/* INSTANCE VARIABLES * /
/* * Values of the qual it ies. <p> Requ irement 3.2. EC.1.2 * /

protected float[ 1 qualValueI = newfloat[ q u al i tyTypeS.length l ;
/** Quality values before the last engagement
* <p> Requ irement: 3.2.AR.4 .6
*/

protected float[ 1 oldValueI = new float[qualValueI.length 1 ;
/** Name of GIF f ile conta in ing the character image.
* The character in th is image is assumed to be fac ing left.
* Select th is character's he ight, relative to he ights of other
* characters,
* by padd ing the top and bottom w ith transparent p ixels. No padding g ives
* the tallest possible character.
*/

protected Str ing imageF ileNameI = null;
/** D isplayable image for the character. In it ialized when used. */

private Image chImageI = null;
/* CONSTRUCTORS * /

CASE STUDY: ENCOUNTER VI D EO GAME

/**Allocate initial total quality points equally among the qualities.
* <p> R equirement: 3.2.E C.1.2 (quality value initialization)
*/
protected EncounterCharacter ()
{ super() i
for(int i = 0 i i < quali tyTypeS. length i ++i)
qualValueI[i 1 = QUAL_TOTAL_INIT / quali tyTypeS. length i
saveQualityValues() i

}
/** Construct a new character using the given name.
* <p>Requirement:
3.2.E C.1.1 (character naming)
* @param nameP
Printable name for the character.
*/
protected EncounterCharacter (String nameP)
{ this (nameP , null) i

}
/** Construct a new character using the given name and image file.
* <p> R equirement:
3.2.EC.1.1 (character naming)
* @param
nameP
Printable name for the character.
imageF ileP Filename , relative to document base ,
* @param
*
for the character image file.
*/
protected EncounterCharacter (String nameP , String imageFileP)
{ this() i
setName(nameP) i
imageF ileName I = FILE_ROOT + imageF ileP i

}
/* METHODS * /
/** Adjust quality values , normally retaining a constant total.
* Synchronization holds qualityValue I constant even with other
* threads running.
.
* <p> Invariants: see the class invariants
* <p> Precondi tions: quali tyP is in quali tyTypesS[ 1
* AND qualityValueP >= 0
* AND qualityValueP <= the sum of the quality values
* <p> Postconditions: qualityp has the value qualityValueP
* AND the remaining quality values are in the same proportion as prior to
*invocation , except that values less than some tolerance are zero.
* <p> SDD: 6 .1.2.1.1
* <p>SRS: 3.2.E C.3.2: "Configurability of Encounter character quality
*values."
* @param qualityP Quality whose value is to be adjusted.

655

656

CHAPTER 26

UNIT TESTING

* @param qualityValueP
The value to set this quality to.
*1
public synchronized void adjustQuality (Str ing qualityP,
float qualityValueP)
{ II Value of the quality to be changed
float qualityValueM = qualValueI[indexO f (qualityp)1 ;
II Save the sum of the values
float originalSumM = sumO fQuali ties ( ) ;
II Set the stated quality to the desired amount,
II adjusted to the threshold value.
setQuality(qualityp, qualityValueP) ;
II If the caller adjusts the only non-zero quality value,
II divide the adjustment amount equally among all other qualities.
if (or iginalSurnM == quali tyValueM)

{

float quali tyDiffEach = ( originalSumM - qualityValueP)
I ( qualityTypeS length - 1) ;
for(int i = 0; i < quali tyTypeS. length ; ++i)
if ( ! qualityTypeS[i 1 equalsIgnor eCase ( qualityP))
setQuality(qualityTypes[il, qualityDiffEach) ;
} else {
1* Compute factor ( "proportionM") by which all other qualities must
change.
* Example: if the valueswere1,3,S ( i.e. sum9) andthe first
* qualities changed from 1 to 2, then "3" and"5" change fr om8/9 of
* the total to 719 of the total, so each shouldbe multipliedby 7/8,
* i. e. , by (9- 2) I ( 9-1) .
*1
float proportionM = (or iginalSurnM - qualityValueP) I
(originalSurnM - qualityValueM) ;
•

•

IIAdjust remaining qualities, retaining their mutual proportion
for(int i = 0; i < quali tyTypeS.length ; ++i)
if ( ! quali tyTypeS[i 1 . equalsIgnor eCase ( qualityP))
setQuality(qualityTypes[il, qualValueI[il *proportionM) ;

}
}
1** Get a copy of the list of names of quality values.
* @return
working copies of name str ings representing qualities.
*1
public static String[ 1 getQualityTypes ( )
{

CASE STUDY: ENCOUNTER VIDEO GAME

String [l returnListM =
//Copy the string array.
new String[qualityTypeS.length 1 ;
for( int i =O; i < qualityTypes.length; i++) //Copy each string.
returnListM[il =new String(qualityTypes[il) ;
return returnListM;
//R eturn the copy.

}
/**R eturns the value of the specif ied quality.
qualityp is a valid member of qualityTypeS[l
* <p>Precondition:
* @param qualityp
The quality we want the value for.
The value of the specified quality.
* @return
*/
public float getQuali tyValue(String quali tyP)

{

return qualValue I[indexOf(qualityP) l;

}
/**Quality values below this threshold are set to zero to
*avoid having the game go on for an indeterminate amount of time.
*<p>Requirement: e.g.3.2.EC.1.2 (lowerlimitonnon-zeroqualityvalues)
Tolerance value
*@return
*/
staticfinalfloatgetTolerance ()
{ returnO. Sf;

}
/**Returns the index of the the specified quality.
*<p>Precondition: qualityp is in qualityTypeS[l ,
*give or take capitalization.
*@param qualityp
The quality we are searching for.
*@return
The quality index.
*/
protectecistatic intindexOf (String qualityp)

{
//Oefault to "missing" value.
intreturnlndexM=-1;
//Search quality name table and note the index value.
for( inti=0; i < qualityTypeS length; ++i)
if(qualityTypeS[il.equalsIgnoreCase (qualityp) ) {
returnlndexM=i;
break;
•

}
return returnlndexM;
}

657

658

CHAPTER 26

UNIT TESTING

/** Set default maximum number of characters in names of characters .
*<p>Requirement: 3 .2 . EC . 1 . 1 (limit on character name length)
* @return
*/

Maximum number of characters allowed in a character name

protectedintmaxNumCharslnName()
{ r eturn 15;

}
/** Preserve the current qualityvalues . */
public synchronizedvoidsaveQualityValues()

{
for (inti = O; i< qualValueLlength; i++)
oldValueI[il = qualValueI[il;

}
/** Set a qualityvalue without regard to thevalues of other qualities .
* Truncate anyvalue below the thresholdvalue down to zero .
* Synchronization prevents changes to qualityValue I while other
* threads are using it .
*<p>Requirements:
3 .2 . EC .2 (lower limit on non-zero qualityvalues) I
*<p>Precondition: qualityp is avalid member of qualityTypeS[1
*<p>Postcondition:
Qualityvalues are greater than tolerance or are o.
*
* @param
qualityp
The quality to set thevalue of .
* @param
valueP
Thevalue to set the quality to .
*/
public synchronizedvoidsetQuality(String qualityp I floatvalueP)

{
if(valueP< getTolerance())
qualValueI[indexOf(qualityp)1 = o. Of;
else
qualValueI[indexOf(qualityP)1 =valueP;

}
/** computes the sum of the qualityvalues .

I

* Synchronization makes sure that another thread won t change
* qualityValuel while this thread is part-way through computing the
* total .
*<p> Requirements: 3 .2 .EC .3 .2 (proportions among qualityvalues) I
*<br> SRS 3 .2 .EC .3 .1 Living points
* @return
The sum of the player I s qualities I avalue 0 or greater .
*/
public synchronizedfloat sumOfQuali ties( )

{
floatsumM = 0 .Of ;

CASE STUDY: ENCOUNTER VIDEO GAME

for (int i = 0 i i < quali tyTypeS length i ++i)
•

sumM += qualValueI[i1 i

return sumM i
}
} // end of EncounterCharacter

26.5. 2 unit Tests for the

EncounterCharacter Class

Note to the Student:
The format of this document is derived from
the IEEE Standard for Software Test Docu­
mentation. This document applies to the test­
ing of one class. JUnit was not used in this case
but could have been.

UNIT TEST FOR THE

ENCOUNTERCHARACTER CLASS
1. Test Design Specification

The unit test for EncounterCharacter consists of two
public methods as follows.

For simplicity, this unit test includes test data
with the method. Normally, however, the
input data and the expected output are re­
trieved from a file.

3. Test Procedure Specification
The unit tests for Encoul1terCharacter are initiated by
executing the main() method of EncounterCharacter.
The parameter supplied to main() specifies the file
to which the results are written.
This is a simple procedure. However, the
procedure becomes considerably more com­
plex when source files and user interaction are
involved. For example, this will be the case in
unit testing the class El1coul1terGame.

testEncoul1terCharacterMethods() tests each of the
methods in turn

testEl1counterCharacterClass() tests sequences of
methods
These methods can be executed by Encounter­
Character's main() method or by an external object.
2. Test Case Specification

The test cases for EncounterCharacter are built into
testEncounterCharacterMethodsC) and testEncounterCharac­
terClass().

4. Test Results Documentation

The test results documentation consists of the test
log, test incident report, and test summary report.

4.1 Test Log
This is an account of the test's results. See the
example below.

659

660

CHAPTER 26

UNIT TESTING

This is contained in file EncounterCharacter_

Test_Log_day_month-year.doc

> > > >setQualityO Test 1 : nominal value
« <
Actual float
expected float.
> > > >setQualityO Test 2: nominal value
« « <
Actual float
expected float.
> > > >adjustQualityO test 0: verify that values
add to 1 00« « <
Actual float
expected float.
> > > >adjustQualityO test 1 : verify values sum
to 1 00 after adjusting< < < < <
Actual float
expected float.
> > > >adjustQualityO test 2: verify values ad­
justed as commanded« « <
Actual float
expected float.
> > > >adjustQualityO test 3: verify low value
reverts to zero< < < < <
Actual float
expected float.
> > > >adjustQualityO test 4: verify values sum
to 1 00 after adjusting< < < < <
Actual float
expected float.
Class test:
> > > >Class test ge-aq-so< < < < <
1 00.0< - - Obtained
1 00.0< - - Required
> > > >Class test ge-aq-aq-gq-so: part
« < «
20.9876< - - Obtained
20.9876< - - Required
> > > >Class test ge-aq-aq-gq-so: part 2
« < «
1 00.0< - - Obtained
1 00.0< - - Required
> > > >Class test for the invariant '_quaIValue
[i] >=0'« « <
true< - - Obtained
true< - - Required
«

=

4.2 Test Incident Report

=

This includes any occurrences or noteworthy
events that occur during testing. See the exam­
ple below.

This is contained in file EncounterCharacter_TesC

IncidenLday_month-year.doc
4_3 Test Summary Report
This is contained in file

EncounterCharacter_Test_Summary_Report_day_
month-year.doc
Example of a Test Log (Section 5 of the Personal Software Documentation):
EncounterCharacter_TescLog_
26..JuL1 999
Method tests:
> > > >CetCharacter Test 1 : nominal value
« « <
querty< - - Obtained
querty< - - Required
> > > >CetCharacter Test 2: Outside parameter values < < < < <
defaultName< - - Obtained
defaultName< - - Required
» » EncounterCharacter Test 3: Limit parameter values< < < < <
1 2345678901 2345< - - Obtained
123456789012345< - - Required
Expect one name for each character
querty
defaultName
12345678901 2345
» » indexOfO Test 1 : valid quality name
« « <
Actual integer
expected integer.
» » indexOfO Test 2: valid quality name
« « <
Actual integer
expected integer.

=

=

=

=

=

The test log example does not show failed tests.
These can be detailed in the log, transmitted to
a separate file, and can generate monitor text.

=

=

Example of a Test Incident Report (Section 4. 2
of the Personal Software Documention): Encounter

Character _TesLlncident_26_1uL1 999. doc

CASE STUDY: ENCOUNTER VIDEO GAME

The test was attempted with version 7.2.1 of

EncounterCharacter using version 2.3 of the YestUtilities
package. O n the first try, the test failed to run.
We think that this was due to the fact that we did
not really have version 2.3 of YestUtilities. When
we reloaded this package, the test ran without
incident.
This is a good place to mention mistakes made
during testing. These are particularly prevalent
when user actions are required, and it is im­
practical to rerun the entire test.

Example of a Test Summary Report (Section 4.3
of the Personal Software Documention): Encounter­

Character_Yest_Summary_26_JuLi 999.doc
This test was executed by John Jones at 2:00
P.M. using release 1.1.6 of Sun's virtual machine.
Subject to the anomalies in the test incident report,
the results were 100 percent pass on the built-in unit
test methods. These methods were inserted by

E. Braude in version 6.5.2. They are due to be
expanded in later versions of EncounterCharacter.
Example of Unit Test Source Code:
The following code, for the EncounterCharacter
class, includes self-test methods.
The class YestExecution is used to execute the
unit test. It contains a static method printReportYoFile()
whose parameters, in Javadoc notation, are as
follows.
* @param - FileWriter - Destination of report
* output.
* @param - String
A description of the test.
* @param - int - The expected correct result.
* @param - int - The actual result.
* @return - void
* @exception - None
There are no preconditions. The postcondi­
tions are that a file has been written to the destina­
tion indicated by the FileWriter input parameter. It
contains the test description input, the expected
result, and the actual result, each clearly indicated.
The test code is shown in Listing 26.11.
-

Listing 26.11: Control for testing EncounterCharacter
/** To t est this class
* @param argsP d estination of method test log, class test log
* r esp e ctiv ely
* /public static void main (String [1 argsP)
{

/ / Default fil es on which to write test output & run tests
String m ethodOutputFil eNameM = "methodOutput. txt";
String classOutputFil eNameM= "classOutput. txt";
i f(argsP ! = null && argsP . l e ngth == 2)

/ / use defaults if input

improp er

{

m e thodOutputFil eNam e M = argsP [01 ;
classOutputFil eNam eM = argsP [11 ;

}
/ / 1 . EXECUTE TESTS WHICH DO NOT REQUIRE HUMAN INTERVENTION
/ / T e st m e thods individually, then test class
try
t estEncount erCharact erMethods(methodOutputFileNameM);
{

661

662

CHAPTER 26

UNIT TESTING

t estEncount erCharact erClass(classOutputFil eNam eM) ;
} catch(IOExc eption eP)
Syst em. out. println( eP) ;

{
}

// 2. EXECUTE TESTS WHICH DO REQUIRE HUMAN INTERVENTION
// Display t est cas es
Fram e [] imag eTests
{
// Missing imag e
new t estCharact erImag e (
new Encount erCharact er("GuyWithNoImag e", null) ) ,
// Imag e is pr esent
new t estCharact erImag e (
new Encount erCharact er("El ena", "el ena. gif") )
=

};
for(inti = O; i< imag e T e sts. l e ngth; i++) {// Display each t est window
imag eTests[i] . s e tSiz e (400, 250) ; // Ad equat e siz e for charact er
imag e T ests[i] . s etVisibl e(tru e) ;
imag e T ests[i] . show() ;
}

try {

// L e t us er examin e windows
Thr ead. curr entThread() . sl e ep(30*1 000) ;
} catch(Exc eption exc) {
}

for(int i = O; i < imag eTests. l e ngth; i++)

// Shut th e windows

imag e T ests[i] . dispos e() ;
Syst em. exit(O) ;
}
/** T e sts this class by e x ecuting its m ethods in combination
* @param
d estinationP
Location to writ e r e sults
* @ exc eption IOExc eption If th er e's a probl em op ening or acc essing
* d e stinat ionP
*/

Class testing is covered systematically in
Chapter 27. It consists largely of testing

combinations of methods. The code testing

EncounterCharacter is given in the case study there.

26.6 SUMMARY

Unit testing is conducted by software developers either in conjunction with or immediately after implementing
a unit of code. Units are typically the methods and classes of the software. Both white box and black box
methods are utilized.

EXERCISES

The first step in unit testing is identifying units and determining what they are intended to do. This
comes from one of several sources: the SRS, the SOD, or else a motivation too m inor to specify in the
SOD. For methods arising from design, we may not possess explicitly stated requirements against which to
perform tests.
A systematic approach is required to effectively implement unit testing. In this way, as many errors as
possible at as serious a level as possible can be discovered within a practical time period and using a practical
amount of labor. The first step is organizing the testing-typically methods are tested first, followed by
classes and packages.
The extent of testing should be considered and defined in advance. Test cases are selected from one or
more categories of tests, both from normal expected operation and those judged most likely to fail. Stopping
criteria are established in advance; these are concrete conditions at which point this particular testing process
will be considered done.
Depending on the problem space of the software, there is often a set of test data that is specific to the
application. If applicable, obtaining and using this data must be planned.
Unit testing is typically conducted by developers, as they are the most familiar with the structure and
organization of the code under test. However, unit testing is sometimes conducted by a separate organization
such as QA because of their objectivity. This requires extra time for the new organization to learn the
software design so they can successfully executed the tests.
As with other phases of development, metrics are collected during unit testing. Metrics collected
include number of test cases, number of tests per test type, and percentage of failed tests.
There are several different types of white box and black box testing methodologies employed during
unit testing. White box methods include statement coverage, branch coverage, and path coverage. Black box
methods include equivalence partitioning and boundary value analysis.
When testing the methods of a class, a strategy is required to ensure proper test coverage. Humphrey
recommends using a checklist that includes items such as using normal parameters, parameters at their boundaries,
illegal values, handling of error conditions, path coverage, loop termination, timing, and hardware dependencies.
After the individual methods of a class are tested, the class as a whole is tested. All of the class methods
are tested in combination. This is because the methods of a class are frequently interrelated as they may alter
the values of common class attributes. Focus is placed on sequences likely to be commonly used and
sequences that appear most likely to contain defects. If an object of a class transitions through several states,
state-based testing is employed.
An effective method for performing unit testing, and to build quality into an implementation, is to
specify the tests that an implementation must pass before writing the code. After writing a test, one adds to the
implementation until the test succeeds. This is called test-driven development (TOO). TOO is often associated
with agile development, but it is useful for any development process.

26.7 EXERCISES
1. In your own words, describe the difference between white box and black box testing. Why is each

important and necessary?
2. Why do you think unit testing is usually conducted by the developer who implemented the unit?
3. a.

What is equivalence partitioning? Why is it important to partition the test space into
equivalence classes? Please use your own words in responding.

b. For the following function, describe five different test cases and for each describe the type of
test case it represents. The application is based on Myers' triangle problem [5]:

663

664

CHAPTER 26

UNIT TESTING

II x I y a nd z are the lengths o f the sid es o f a triangl e . This funct ion
classifies the

Iitriangle and returns e i t h er " scalen e"
I I i s o s c e les "

(two s ides

Ilequal) or "

equil at er a l "

(all sid es un equal),

(all sid es equal). If x, y and z don't

form a tr iangle

II(Le. either (a)
str ing is returned

x,

y or z

is < = zero, or (b) (x+y) < z) th e null

IIAssumption: x, y and z are i n as c end i n g o rder (i. e. x<= y< =z) so you
do not need
IIto test for this
char * tr iangle (int x, int y, int z)

{

}
4. Explain why testing every line of code for correctness (i.e.,

100 percent statement coverage) is

generally insufficient for ensuring that a program is bug-free. Give an example of a defect that can
go undetected by tests that have 100 percent statement coverage.
5. Why is path coverage a stronger form of testing than statement coverage? Give an example of a

defect that would be detected by path coverage but not by statement coverage.

6. Draw a program control graph for the method adjustQuality() of Listing 26.4 in this chapter. What
is its cyclomatic complexity? Explain your response.
7. Write the code for a class Account with attribute balance, accessor methods, and method add(). Assume

that Account has states Sound, Empty, and Arrears, and that these are implemented using the State
design pattern. Write a complete set of unit tests for Account, including state-oriented tests.
8. In test-first development, why is it important to execute a unit test to ensure that it fails before the

code it is testing is actually written?
9. You intend to implement a Rectangle class using test-first development. Suppose the class is defined

during design with the following characteristics:
•

Constructor with parameters length and width

•

Methods getLengthO and getWidthO to retrieve length and width

•

Method to calculate area of rectangle

Write a unit test class to test the as yet unwritten class Rectangle. Next, write the code to implement
the class.

BIBLIOGRAPHY

TEAM EXERCISE
unit Tests

Perform full unit tests on two significant methods of your application. State how long individuals and
the whole team spent on developing each part of these tests, and how the process you used could have
been improved.
Evaluation criteria:

( 1) Degree of clarity of the plan
(2) Extent to which the plan and test include all relevant aspects of the unit tests
(3) Realism of the self-evaluation data and improvement plan

BIBLIOGRAPHY
1. Rapps,Sandra and Elaine. J. Weyuker, "Selecting Software Test Data Using Data Flow Information," IEEE Transactions on Software

Engineering, Vol. 11,no. 4,1985,pp. 367-375.
2. McCabe,T. J., "A Complexity Measure," IEEE Transactions on Software Engineering, SE-2, no. 4 (1976), pp. 308-320.
3. Humphrey, Watts S., "Managing the Software Process (SET Series in Software Engineering)," Addison-Wesley, 1989.
4. Junit, org. www.junit.org [accessed 12/14/09].
5. Myers, Glenford J., "The Art of Software Testing," John Wiley & Sons, 1979.

665

Module and Integration
Testing

�

Testing

Maintenance
The Software
Development
Lifecycle

Planning

How do you test a class?
How are stubs and drivers used for

\

Requianalrements
ysis

Implementation
�DeSign /

testing?
What are attribute-oriented tests for
a class? Class invariant-oriented
tests? State-based tests?
What is integration?
What is big bang integration?
Incremental? Bottom-up? Top
down? Continuous?
How do daily builds facilitate
continuous integration?

Figure

What is interface testing?

27.1 The context and learning goals for this chapter

This chapter discusses testing beyond unit testing-to the module level and to the integration of
modules. We begin by discussing class testing. Class testing is considered by some to be beyond unit testing
and by others not so.
Integration is the process of assembling parts to form a whole. As a physical illustration of this concept,
consider Figure 27.2, which illustrates the integration of a suspension bridge. The order of integration and the

STUBS AND DRIVERS

Assembling the parts into a whole

Figure 27.2 The meaning of "integration" -an analogy from bridge-building, steps 1 through 6

manner in which the parts are tested together is critical for the construction of the bridge. For example,
assembling it in the wrong order will lead to longer construction times, or worse, a defective bridge. Such
issues are equally important for the integration of software systems.
Like all engineering artifacts, software systems must be built from parts. Each part is developed and unit­
tested separately. The whole is then assembled. Integration is the process of assembling these parts and testing
the result to ensure that they work together correctly. A part of a software system to be integrated can consist
of several lines of code, a whole method, a class, or an entire subsystem.
Agile methodologies use continuous integration and daily builds as much as possible. We discuss these
in this chapter.
An example of a class test is provided in one case study section. In another, an integration plan is
described. Both of these apply to the video game example used in this book.
27. 1 STUBS AND DRIVERS

Consider the coordination issues associated with integrating the parts of an application shown in Figure 27.3.
Several of the parts depend on each other yet must be put together in some order. We use stubs and drivers for
this purpose.
Simple stubs were introduced in Chapter 26. We examine them in more depth here for integration
testing, and we also introduce drivers. The left-hand column of Figure 27.4 starts the process by showing the
eventual, desired configuration of three items of an application that must be integrated. (The items can be
classes or packages of classes.)
If our goal is bottom-up integration (described in detail in Section 27.3.3) then we first create the Item 3
alone in step BU-A and test it thoroughly alone. However, a good set of tests tries to reproduce the manner in
which the item will be used. For that reason, we create a stub (step BU-b), which is substantial enough to
exercise [tern 1 but is otherwise as modest as possible.
If our goal is top-down integration (described in detail in Section 27.3.4) then we first create stubs in
steps TD-a and TD-b. These are substitutes for the items that are substantial enough for [tern 1 to be tested
(step TD-C) but otherwise require as little effort as possible.

667

668

CHAPTER 27

MODULE AND INTEGRATION TESTING

Home Office Use

Computes parts of a tax return
associated with the use of part
of the home for business
purposes

uses

uses
Creates an entire tax return for many kin ds
of person al and busin ess situations

Computes the depreciation on
various types of equipmen t

Figure 27.3 Stubs and drivers-motivation from a tax return example

Eventual

Bottom-up

Top-down

configuration

development

development

or integration

or integration

�
I
I �1
uses

lte

uses

uses

uses

�
@

��
Figure 27.4 Using stubs and drivers for integration and testing

These remarks apply just as much to the development of items in the first place as to their integration
and testing.
27.2 TESTING A CLASS

After testing the individual methods of a class, we can move on to testing the class as a whole. This amounts to
executing its methods in combination or subjecting objects of the class to events such as mouse action. Recall
that the methods of a class are frequently interrelated because they may alter the values of common variables.
For example, in an Account class, the methods depositO and withdrawO would both alter the balance variable. If

TESTING A CLASS

1. Exercise methods in combination
2-5, typically
test most common sequences first
include sequences likely to cause defects
2. Focus tests on each attribute
• initialize, then execute method sequences that affect it
•

•

•

3 . Verify that class invariants are unchanged
•

•

•

4.

verify invariant true with initial values
execute a method sequence
verify invariant still true

Verify that objects transition among expected states
•

•

•

plan the state/transition event
set up the object in the initial state by setting variables
execute event and check that transition occurred

Figure 27.5 Performing class tests-various focus

depositO were coded in terms of float, for example, but withdrawO in terms of double, the tester may not notice
anything wrong in testing each individually. For this reason, it may not be sufficient to know that each
method has been individually unit-tested.
There are several complementary ways of testing classes, as shown in Figure 27.5. Each is discussed in
this section, and several are illustrated in the case study.
27.2. 1 Example of a Class Test

Each method combination test consists of a sequence of function calls. For the class EncounterCharacter, for
example, the methods in Table 27.1 would be tested in sequences.
We concentrate our testing resources on the following:
1. Sequences likely to be commonly used
2. Sequences that appear most likely to harbor defects
Table 27.1 Example of a class test-labeling methods for use in combination
Abbreviation

Method prototype

aq

adjustQuality(String qualityP, float qualityvaluep)

d

deleteFromEncounterCharacters(EncounterCharacter encounterCharacterP)

ge

EncounterCharacter getEncounterCharacter(String nameP)

gq

float getQualityvalue(String qualityp)

gs

float getSumOfQualitiesO

gt

float getTOleranceO

io

int indexOf(String qualityP) throws Exception

ii

InsertintoEncounterCharacters(EncounterCharacter encounterCharacterp)

m

int maxNumCharslnNameO

sq

setQuality(String qualityP, float valuep)

669

670

CHAPTER 27

MODULE AND INTEGRATION TESTING

The following sequences are common in playing the game.

ge-aq-gs II get character - adjust qualities - get sum of qualities
ge-sq-aq-gq II get character - set a quality - adjust qualities - get the quality
There are, in fact, infinitely many sequences of methods, because every method can be repeated any
number of times. A procedure must be employed to make the number feasible. For example, a triage approach
can be useful in identifying common sequences. A given sequence of methods can be categorized as either
most likely or least likely to expose a defect. Otherwise, the sequence is consigned to the "neither" category.
All of the "most likely" tests are then executed, together with as many of the "neither" category as possible.
The "least likely" are executed if there is time.
The process of adjusting quality values in the Encounter video game is relatively complicated. The
following is an example of a sequence apparently more likely than many to harbor defects.

ge-sq-aq-sq-aq-gq II get character - set a quality - adjust qualities - set a quality - adjust qualities - get quality
We will assume that the methods have been tested individually, and we'll concentrate on sequences of
methods that affect the others. Figure 27.6 shows how the methods in the example chosen relate to each
other through their effect on variables. Steps 1 and 2 affect the value of the concentration variable. Step 3 affects
the value of strength. In Step 4, the stamina variable is an input to the adjustQuality(J method, which uses this
value (and the current value of concentration) to change the value of concentration. Thus, each method in the
sequence sq-aq-sq-aq affects the outcome of a later method. The interaction among seemingly simple methods
can be quite complex!
The case study of Chapter 26 shows these tests in action. The sections that follow discuss ways to tame
this complexity of choices.
27. 2.2 Attribute-Oriented Tests

Attribute-oriented tests focus on variable changes, and create method sequences that effect them. A simple
example for an Account class is to have the balance grow and shrink to zero. To do this, we could execute
the sequence setBalance( 50 ) ; addToBalance( 70 ) ; deductFromBalance( j 20) ; getBalanceC). We validate the predicted
balance. The example in Figure 27.6 can be designed as an attribute test, focusing on the variable

concentration.

1. � c = getEncounterCharacter( "PlayerCharacter")
2. §lL c.setQuality( "concentration"30 )

3. M..:. c.adjustQuality( "concentration"1 0 )
4. §lL c.setQuality( "stamina"40 )

5. M..:. c.adjustQuality( "concentration"1 0 )
6. 99:. c.getQuality( "concentration")
Figure 27.6 Selecting method sequences for unit testing

--retrieve data to validate

TESTING A CLASS

27.2.3 Testing Class Invariants

As described in Chapter 22, class invariants are constraints among the attributes of the class that must remain
true after the execution of every method. A class invariant test consists of executing a sequence of methods
and validating that the invariant remains true. For example, suppose that a rule of the bank is that overdrafts
are capped at $1,000, including the assets in the customer's savings, and total assets per regular account are
capped at $10,000,000. The invariant of the Account class would be something like the following.
-1 0 0 0 <= checkBalanc e + savingsBalance <= 100 00000

We would initially set the variables to amounts that honor this invariant, such as checkBalance -3000
and savingsBalance
2500. Then we would execute a sequence of methods such as depost(300); withdraw(500);
deposit(50) and check that the invariant is still true.
Languages such as Eiffel and Java are equipped with functions that test the validity of assertions. An
assertion is a statement that can be true or false: for example, "x
y." Assertions are often invariants.
=

=

= =

27.2.4 State-Based Tests

As we have seen, the instances of a class can often be usefully thought of as transitioning among states in
response to events. We should therefore test such classes in terms of their state. For example, let us test the
class EncounterGame. Figure 27.7 illustrates the first steps in the testing of the application's state transitions.
The complete state-transition test is shown in Figure 27.8.
The numbered steps denote a typical event sequence for causing a meaningful sequence of events. One
test would thus consist of stimulating the system so that it transitions through this sequence. The tester would
also introduce events that do not apply for particular states to ensure that indeed they do not affect the
application.
To design and execute state-oriented testing requires Significant time, especially because extensive user
inputs are required. Tools are available that record user interactions with the system and that can reproduce

�

Verify that the game is

initially in Preparing state
(by checking on the class
Player

member gameStatel).

dismisses
qualities menu

Figure 27.7 State-transition test sequences, 1 of 2
Source: Association for computing Machinery, http:www.acm.org/-perlman/question.cgl?form=PUTQ

671

672

CHAPTER 27

MODULE AND INTEGRATION TESTING

� ,------ �

Verify that the gam e is

Dismiss the quality

initially in Preparing state

menu, and verify that
the gam e is in Waiting
state.

(by checking on the class
Player

member gameStatel).

dismisses

�

qualities
menu

Move the player

character to an
adjacent area, and
verify that the

Move to

game is still in

adjacent
area

Waiting state.

Figure 27.8 State-transition test sequences, 2 of 2

these actions. In addition, assertion checkers can be embedded in the code to verify that the system is in the
state it is supposed to be.
27.3 INTEGRATION

This section discusses and compares various types of integration, and is summarized in Figure 27.9. It starts by
comparing big bang integration with the incremental style that is generally recommended (when it's
possible). The extreme form of incremental integration is continuous integration. The last classification
discussed is between top-down and bottom-up styles. Projects often mix these integration and testing styl es,
depending on the nature of the project.

Big bang integration

Test

Incremental Integration

modules

Integrate
modules

individually
Continuous?

top-down
Integrate
modules
sandwich-fashion

Non­
continuous?

Integrate
modules
bottom-up

Figure 27.9 Module and integration testing

INTEGRATION

luni� �unitl !unit! .....

..... ! Unit I I Unit I I Unit I

Figure 27.1 0 Big bang integration

27.3.1 Big Bang Integration

Big bang integration consists of creating modules in parallel and then assembling them in one operation. A
form of this is illustrated in Figure 27.10. Although big bang testing reduces or eliminates the need for test
drivers and stubs, this benefit is usually far outweighed by the complexity and cost of fault isolation. Since
many modules are integrated at once, it is frequently difficult to locate the source of defects.
As an example, consider a system that monitors the health of at-risk patients as they go about their daily
lives. As illustrated in Figure 27.11, the application can be thought of as decomposed into a module that

Individual Health

Figure 27.1 1 Big bang integration of a health monitoring system

673

674

CHAPTER 27

MODULE AND INTEGRATION TESTING

��

MOdule1

ses

�

�
uses

]5",.31
�

�

uses

uses

MOdule2

Figure 27.12 Module self-dependency-consider its effect on integration

handles the collection of data from patients, one that analyzes data for speCific diseases, one that handles
emergency notifications such as calls to the police, and so on. It makes a great deal of sense to develop these
modules separately. For example, why not develop the diabetic analysis in an organization specializing in that
field, and have emergency notification developed by a company with experience in writing such software
reliably? Some modules may be effectively written by skilled teams working anywhere, geographically
speaking. Although continual integration, described below, is preferable in general, it may not be practical in
a case like this. Each high-level module and its subsidiaries may have to be developed separately, and then
integrated in big bang fashion.
The integration and testing of modules illustrates the wisdom of designing so that dependencies are
noncyclic. In other words, we try to avoid architectures in which a module depends on itself. Figure 27. t 2
illustrates such an architecture. We can't fully test any pair of modules alone. Our only choice is to use stubs or
to test all of them together, which multiplies the potential for hard-to-find and hard-to-fix defects.
27.3. 2 Incremental Integration

Nowadays, software integration typically proceeds in an incremental manner in which software modules are
developed and assembled into progressively larger parts of the system. This is known as incremental integration
[t J. Gradually building the system means complexity increases incrementally, making it easier to isolate
integration problems. Incremental integration commences when the first two parts of an application are
developed, and continues until all its parts have been integrated into a complete system, at which time system
testing commences. Stubs and drivers are employed during this process.
Throughout the integration process, software "builds" may be created that form the emerging system, as
illustrated in Figure 27. t 3. Before adding new modules, integration tests are executed against each build,
ensuring that the build works correctly. Figure 27.2 implies that modules are developed and integrated in
some order, but does not suggest how the order is determined. We usually determine the integration order by
basing it on the design of the system. Two common methods are bottom-up and top-down, and each must
account for dependencies between the modules making up the design.
27.3.3 Bottom-Up Integration

Suppose that an application consists of the modules and dependencies as shown in Figure 27. t 4.
In bottom-up integration, modules that are most depended on are developed and integrated first. Then
the modules that depend on them are integrated next, and so on. In Figure 27. t 4, this implies that Module 3 is
developed first, since it is at the "bottom" of the dependency tree. Modules t and 2 are integrated next with

INTEGRATION

t

t
i II i
Unit

Unit

Unit

Figure 27.13 Incremental integration with builds

~ �
uses

Module1

I

�

uses

uses

�
Module 3

MOdUI

I
�

uses

Figure 27.14 Example of module dependencies

Module 3 since they depend on it. Modules 4 and 5 are integrated last. Integrating in this manner is illustrated
in figure 27.1 5. An advantage to this approach is that it reduces the need for stubs since dependent modules
are available when needed for integration.
Let's consider how we might perform bottom-up integration testing on the Encounter video game.
figure 27.16 shows the relationship among the objects of the Encounter architecture.
We have three modules (packages) to integrate, and need to determine which modules depend on
which. The direction of the aggregations suggests an appropriate order, as shown in Figure 27.17. Figure
27.1 8 shows the resulting "using" relationship between the packages.

675

676

CHAPTER 27

MODULE AND INTEGRATION TESTING

Third or fourth

Third or fourth
��-��uses

�

uses
First or second

I

uses

/�
�

/ First or second

Figure 27.15 Bottom-up integration

EncounterGame

I

EncounterGame
«facade»

getTheEncounterGame()

EncounterCharacters

getStateO

I

(> setStateO

--<> handleEventO

,-

EncounterCast

EncounterEnvironment

«facade»

getTheEncounterCastO

-

getThePlayerCharacterO
getTheForeignCharacterO

I

=0

-

EncounterEnvironment
«facade»

setLocationO

I

Area

I

Figure 27.16 Module relationship in Encounter

X depends on Y so create and test Y first
Figure 27.17 Dependence and integration order

INTEGRATION

uses"
uses

uses

Figure 27.18 Module dependencies in Encounter

Figure 27.19 Bottom-up integration testing in Encounter

Next, we apply the principle of bottom-up integration to derive an integration order. This tells us to first
test the integration of EncounterEnvironment with EncounterCharacters, and then to integrate EncounterGame. This is
illustrated in Figure 27.19.

27.3.4 TOp-DOWn Integration
Top-down integration is the opposite of bottom-up: Modules at the top of the dependency tree are developed
first. with integration proceeding down the tree. This type of integration requires a considerable use of stubs
since dependent modules are not yet ready for integration. The advantage of top-down integration is that
modules at the top of the dependency tree are typically higher level functionality of an application, such as
user interfaces, and are tested early in the integration cycle. This provides an early feeling for the application,
allowing time for important modifications.
Figure 27.20 shows the top-down integration order of Encounter. This tells us to first test the integration
of EncounterGame with EncounterEnvironment, and then to integrate EncounterCharacters.

677

678

CHAPTER 27

MODULE AND INTEGRATION TESTING

uses

uses

�ec0rV

EncounterCharacters

Figure 27.20 Top-down integration testing in Encounter

Top-down implementation, integration, and testing has a long history. In the very early days of
computing, programmers reveled in the exciting things they could do with software. Programs tended to
explicitly transfer control rapidly from one place in memory to another so that they became very difficult to
debug and extend. In a famous letter to the editor of the Communications of the ACM [2], Dijkstra suggested the
beginnings of what he and others developed into structured programming. This called for a hierarchy of functions,
with high-level functions calling lower level ones. This remains an important part of what software engineers
do. Top-down integration calls for the development of the highest level functions, calling stubbed subsidiary
functions.
Returning to the analogy with bridge construction of Figure 27.2, in top-down thinking-and
integration-we view and test first in the large ("suspension bridge") and only then begin to fill in the
rest in increasing level of detail. Continuing the analogy, we'd test a model of the suspension bridge for wind
and simulated load reaction, making gross assumptions about the parts of the bridge (the analog of stubs).
Only then would we test the parts.
27.3.5 Sandwich Integration

Sandwich Integration is a process by which one integrates from the bottom and top more or less at the same
time, introducing stubs for the intervening classes as one does this. Suppose, for example, that we want to
integrate the class ForeignCharacter, which is at the lowest level in Encounter, and EncounterGame, which is at the
highest, without having to worry about the intervening components for now. To have ForeignCharacter and
EncounterGame coexist, we can introduce stubs for the intervening classes. For example, in Figure 27.21, we first
have ForeignCharacter work with a stub for EncounterCharacters, then one for EncounterEnvironment, then EncounterGame.
We don't count the introduction of stubs as true integration, so the only step that's truly integration in this
example is the last. It integrates from the top and bottom simultaneously.
27.3.6 continuous Integration

Continuous integration is a type of incremental integration in which small amounts of code are added to the
baseline (the currently state of the application) on a very frequent basis. Intervals are often as frequent as daily
(see Section 27.4), and the newly integrated code does not necessarily correspond to a completed method or

DAILY BUILDS

uses

8

uses

�

ForeignCharacter

I

Figure 27.21 Sandwich integration testing in Encounter, in order a, b, c

class but can be smaller. As long as the code is unit-tested and does not introduce errors in the baseline, it can
be integrated into the baseline. Continuous integration is one of the twelve practices of Extreme Program­
ming (XP), as we described in Chapter 5. However, it can be utilized even if a non-agile process is being
followed.
27 .4 DAILY BUILDS

During incremental integration we build the software and regression-test it at regular intervals. Regression
testing is designed to ensure that recently added code does not compromise preexisting functionality.
Depending on the phase of the project, builds can be created weekly or even as often as daily. Daily builds are
often used at the tail end of projects when last-minute additions and changes are required. They are also used
during maintenance. Figure 27.22 shows an example schedule of overnight regression testing for an
application approaching release.
Figure 27.23 illustrates the daily code integration process. This kind of daily integration and regression
test schedule was reported by Cusumano and Selby [3] as being utilized by Microsoft, for example.
Referring to Figure 27.23, a daily code freeze time of, typically, 6 PM is established, after which no new
code is accepted for that day. The software system is then built and run, and regression tests are executed on

biweekly

weekly builds

daily

III � II � II �lllllllilJ llilJ wit,
week

23

24

25

26

27

28

29

30

31

.

release
Key:

, overnight regression test
=

Figure 27.22 Example frequency of overnight regression tests

679

680

CHAPTER 27

MODULE AND INTEGRATION TESTING

::s �
Run

egreS iOn
tests

development

6 pm

7 am

development
time
Confirm baseline or
revert to previous baseline

Freeze addition s
to baseline

Figure 27.23 Daily builds

the new build between 6 PM and 7 AM . If a problem is found with the new build, it is assumed the defec t lies in
the code that was checked in during the previous day. This makes the job of problem isolation and resolution
easier than if a longer time interval had elapsed between builds.
27.5 I NTE RFACE TESTI N G

Interface tests validate the interface o f each module from the viewpoint o f their usage by a client. These can be
conducted, to the extent possible, prior to the integration of a module (with necessary stubs); and then after
the integration of the module (with, typically, a reduced set of stubs). The Facade design pattern can be used
to facilitate interface testing. A facade obj ect is created for each class or package, prov i ding an implemen ta­
tion of its public interface. Each method in the facade checks its input parameters to ensure they are passed
correctly and returns a predeterm ined response. Thus, the caller can test its interface with a module without
knowledge of whether it is using the facade or the real i mplementation. This makes problem d iscovery and
isolation easier. Let's return to the video store as an example. Figure 27.24 shows the module decomposition
for this application.

DVDs

I

I
VSCustomers

DVDAccess
"facade»

�

DVD Rentals

'-

DVDCustomerAccess
"facade»

Figure 27.24 Video store module interfaces

I VideoStore I

I

I

I

I

r I
Yo , 1

DVDsRented

DVD Renta1

INTERFACE TESTING

Now we will perform an interface test on the DVDs module. Its usage by clients (i.e., other parts of the
application) can be exercised by means of the facade object only. Thus, the interface tests consist of testing
the facade class DVDAccess. It exposes methods such as the following:
v o i d s t o c k DVD ( S t r i n g aDVD T i t l e ) ;
R e n t a l l t e m g e t DVD ( i n t aDVD I D ) ;
R e n t a l l t e m g e t DVD ( S t r i n g aDVDT i t l e ) ;
S t r i n g d e s c r i b e DVD ( i n t aDVD I D ) ;
S t r i n g d e s c r i b e DVD ( S t r i n g aDVDT i t l e ) ;

Note that the method getDVD() returns a RentalItem object. The RentalItem class is a public framework
class, and so is accessible to all objects. The getDVD() method cannot return a D VD object because the D VD
class is hidden from clients of the DVDs package. The interface test executes interface methods with test
cases. An example is the following:

DVD gwt w = n e w DVD ( " G o n e w i t h t h e W i n d " ) ;
// G e t a c c e s s t o t h e f a c a d e o b j e c t
DVDA c c e s s dVD s = DVDA c c e s s . g e t Th e DVDAc c e s s ( ) ;
// N o w r un t h e t e s t s
dVD s . s t o c k DVD ( gwt w ) ;
R e n t a l l t e m r e n t a l l t e m = g e t DVD ( " G o n e W i t h t h e W i n d " ) ;
/ / R e p o r t d i s c r e p a n c i e s b e t w e e n s t r i n g s ( a s s ume a " c o mp a r e ( )

, ,

t e st

ut i l it y )
c o mp a r e ( r e n t a l l t e m . g e t T i t l e ( ) , gw t w . g e t T i t l e ( )

) ;

// e t c .

For the DVDRentals package, which does not use Facade, the interface is the collection of methods of
member classes. For example, the class DVDRentais exposes methods such as the following from the
DVDRentai class.
DVDR e n t a l c r e a t e DVDR e n t a l ( R e n t a l C u s t o m e r aDVD C u s t o m e r , R e n t a l l t e m
aDVD )
DVDR e n t a l [ l g e t DVDR e n t a l s ( R e n t a l C u s t o m e r aDVD C u s t o m e r )
R e n t a l C u s t o m e r g e t DVDR e n t a l C u s t o m e r ( i n t aDVDR e n t a l I D )
v o i d r e m o v e DVDR e n t a l ( R e n t a l C u s t o m e r aDVD C u s t o m e r , R e n t a l l t e m aDVD )
v o i d r e mo v e DVDR e n t a l ( i n t aDVDR e n t a l I D )
f l o a t g e t F i n e ( R e n t a l C u s t o m e r aDVD C u s t o m e r , R e n t a l l t e m aDVD )
f l o a t g e t F i n e ( i n t aDVDR e n t a l I D )

The interface test is summarized in Figure 27.25.

681

682

CHAPTER 27

MODULE AND INTEGRATION TESTING

DVDS

!

An Interface Test:

DVD gwtw = new DVD( "Gone With the Wind" ) ;

I

DV DAccess
"facade»

I

II Get access t o t h e fa�ade object
DVDAccess dVDs =
DVDAccess. getTheDVDAccessO ;

void stockDVD(StringaDVDTitle ) ;
Rentalltem getDVD( intaDVDID ) ;
Rentalltem getDVD( Stri ngaDVDTitle ) ;
String describeDVD( intaDVDID ) ;
Stri ng describeDVD( StringaDVDTitie ) ;

II Now r u n the tests
dVDs.stockDVD( gwtw ) ;
Rentalltem rentalltem =
getDVD( "Gone With the Wind" ) ;

II Report discrepancies between strings
II

(assume a "compareO" test util ity)

compare( rentalltem . getTitl eO . gwtw. getTitleO ) ;

I I etc.
Figure 27. 25 I nterface tests o f DVDs package

27.6 MODULE I NTEGRATION

Once interface tests are completed, we can feel confident about the interface between modules. We are then
ready to test their interaction more completely with integration tests . An integration test focuses on the
additional functionality gained by assembling modules.
Now let's integrate fully functional versions of the D VDs and VSCustomers packages . To perform
integration tests, we i denti fy the added functionality that this integration provi des-in this case, the
additi onal functi onali ty that the DVDs and VSCustomers packages provide. In parti cular, the methods of
DVDRental , whi ch were using stubbed facade methods in DVDAccess and DVDCustomerAccess, now use
fully functional versi ons. The methods of D VDRental can now be fully tested . The same applies to all
classes in DVDRentals . Listing 27.1 is an example of a method in DVDRental that is part of this
integrati on test.

Listing 27.1: The getDVDRentalO method, which becomes more operable after some integration
R e n t a l g e t DVD R e n t a l ( R e n t a l l t e m aDVD , R e n t a l C u s t o m e r aDVD R e n t a l
C u s t ome r )

{
/ / C h e c k t h a t aDVD i s i n t h e i nv e n t o r y
DVDA c c e s s t h e DVDA c c e s s = DVDA c c e s s . g e t Th e DVDA c c e s s ( ) ;
if (

! t h e DVDA c c e s s . i s l n l nv e n t o r y ( aDVD )

)

r e t u r n nu l l ; / / o r s o m e o t h e r e r r o r i n d i c a t o r

CASE STUDY: CLASS TEST FOR ENCOUNTER

/ / Check that aDVDRentalCustomer is an actual customer
DVDCustomerAccess theDVDCustomerAccess

=

DVDCustomerAccess.getTheDVDCustomerAccess() ;
if( !theDVDCustomerAccess.verify( aDVDRentalCustomer)
return null; / / or some other error indicator
/ / Check that aDVD is rented to aDVDRentalCustomer

/ / Retr ieve and return the rental
}

27.7 CASE STUDY: CLASS TEST FOR ENCOUNTER
Listing 27. 2, which follows, is a test for the EncounterCharacter class and completes the Encounter case study in
Chapter 26.

Listing 27.2: Tests for EncQunterCharacterclass
public static void testEncounterCharacterClass ( String destinationP )
throws IOException
/* Prepare for the test */
PrintWriter outM

=

new PrintWriter (new F ileOutputStr earn (dest inat ionP) ) ;

System.out.println("\nEncounterCharacter class test results on "
+

destinationP + "\n" ) ;

/*
* The following methods will be tested in sequences:
*
* a. adjustQuality( String qualityP, float qualityValueP
*d.deleteFromEncounterCharacters( EncounterCharacterencounterCharacterP)
* ge. EncounterCharacter getEncounterCharacter( String nameP )
* gq. float getQualityValue ( String qualityP )
* gt. float getTolerance ()
* io. int indexOf( String qualityP
*ii. insertlntoEncounterCharacters(EncounterCharacter encounterCharacterP )
* m. int maxNumCharslnName()
* sq. setQuality( String qualityP, float qualityValueP )
* so. float sumOfQualities()
*
*

The following sequences occur commonly:

683

684

CHAPTER 27

MODULE AND INTEGRATION TESTING

*

ge-aq-so

*

ge-sq-a-gq

*
*

The following sequences have a high potential for defects:

*

ge-aq-aq-gq-s

*
*1
1* Test Cl: ge-aq-so *I
EncounterCharacter eCIM= new
EncounterCharacter ( "CharForTestCl");
eCIM.adjustQuality(QUAL_STRENGTH, 40.0f);

II method "ge"
II aq

TestExecution.printReportToFile( outM,
"Class test ge-aq-so", eC 1M.sumOfQualities(), 100.Of);

II so

1* Test C2: ge-aq-aq-gq-so *I
EncounterCharacter eC2M= new
EncounterCharacter( "CharForTestC2");
eC2M.adjustQuality(QUAL_STRENGTH, 40.0f);

Ilge
II aq

eC2M.adjustQuality(QUAL_STAMINA, 20.9876f);
II aq
TestExecution.printReportToFile( outM, "Class test ge-aq-aq-gq-so: part 1",
eC2M.getQualityValue( QUAL_STAMINA), 20.9876f);

II gq

TestExecution.printReportToFile( outM, "Class test ge-aq-aq-gq-so: part 2",
eC2M.sumOfQualities(), 100.Of);

II so

1* INVARIANT-ORIENTED TESTS
* Check for the invariant "qualValueI [il >=0"
* -- after executing the sequences of methods executed above
*1
boolean truthM= true;
for( int i= 0; i < qualityTypeS.length; ++i)
{

1* Set truthM false if any entry in eCIM.qualValueI not >= 0 *I
truthM= truthM&& ( eCIM.qualValueI[il »= O.Of);

TestExecution.printReportToFile(outM, "Class test for the
invariant 'qualValueI[il >=0''', truthM, true);
1* Conclude *I
outM.close();
System.out.print In( "\nClass tests of EncounterChar class
concluded.");
} II end of testEncounterCharacterClass

1** Tests all the methods of this class one at a time

CASE STUDY: C LASS TEST FOR ENCOUNTER

* @param

destinationP

Location to write results.

* @exception

IOException

If there's a problem opening or accessing destinationP

*/

public static void testEncounterCharacterMethods ( String destinationP )
throws IOException

/* Prepare for the test */
FileWriter outM =newFileWriter( new File( destinationP ) );
System.out.print In("EncounterCharacter method test results on "
+ dest inationP + "\n" );

/* Tests for getEncounterCharacter() */
EncounterCharacter eCNorM =newEncounterCharacter( "qwerty" );

/
/normal

TestExecution.reportToFile( outM,
"GetCharacter Test l: nominal value",eCNorM.getName(),"qwerty" );
/
/null

EncounterCharacter eCNullM = new EncounterCharacter(null);

TestExecution.reportToFile( outM,"GetCharacter Test 2: null parameter",
eCNullM.getName(),GameCharacter. DEFAULT_NAME);

String tooLongM = "1234567890123456789012345678901234567890";
EncounterCharacter eCTooLongM =new EncounterCharacter(tooLongM);

/
/too long

TestExecution.reportToFile( outM,"GetCharacter Test 3: Limit parameter values,"
+ "max name len =" + eCTooLongM . maxNumCharsInName(),

eCTooLongM.getName(),
tooLongM.substring(O,eCTooLongM.maxNumCharslnName()) );
EncounterCharacter eCZeroM =new EncounterCharacter( "" );

/
/zero-len

TestExecution.reportToFile( outM,"GetCharacter Test 4: zero-length",
eCZeroM .getName(),GameCharacter. DEFAULT_NAME);
/
/bad chars

EncounterCharacter eCPuncM =new EncounterCharacter( "a+b" );

TestExecution.reportToFile( outM,"GetCharacter Test 5: bad char ' +' "
eCPuncM .getName(),GameCharacter. DEFAULT_NAME);

/* Tests for indexOf() for every valid quality name. */

for( int i =0; i < qualityTypeS.length; ++i )

try { TestExecution.reportToFile( outM,
"indexOf() Test 1." + i + ": valid name: " + qualityTypeS[iJ,
indexOf(qualityTypeS[iJ),i );

} catch( Exception eP )
{TestExecution.reportToFi1e(outM,"indexOf()Test1:validname:compare",
"indexOf ('" + qualityTypeS [iJ

+ "')", "with

/* Tests for indexOf () for an invalid quality name. * /

try { TestExecution. reportToFile ( outM,
, 'indexOf () Test 2: invalid name: zorch",
indexOf(''zorch"), --1 );

expected " + i );

685

686

CHAPTER 27

MODULE AND INTEGRATION TESTING

catch( Exception eP )

TestExecution.reportToFile ( outM,
, , indexOf () Test 2: valid name: compare " ,
,
, , indexOf (\' , zorch\' ') "
, 'with expected -1"

1 * Tests for setQuality ()

II Set up for test

);

*1

EncounterCharacter hank = new EncounterCharacter ( , 'Hank"

);

II Nominal value

hank.setQuality (QUAL_STRENGTH , 10.3f ) ;
TestExecution.reportToFile (outM, " setQuality () Test1:nominalvalue" ,
hank.getQualityValue ( QUAL_STRENGTH ) , 10.3f ) ;

IlOut of range value

hank.setQuality ( QUAL_PATIENCE, -6.2f ) ;
TestExecution.reportToFile (outM, " setQuality () Test2:nominalvalue" ,
hank.getQualityValue (QUAL_PATIENCE) , O.Of ) ;

II Value below close-to-zero threshold.

hank. setQuality (QUAL_STAMINA, getTolerance () * 0.9f) ;

TestExecution.reportToFile (outM, " setQuality () Test3:valueclosetozero" ,
hank.getQualityValue (QUAL_STAMINA) , O.Of ) ;

II Tests for adjustQuality () .
II Set up for test and verify: Values should be 20 each.

EncounterCharacter harvey = new EncounterCharacter (''Harvey"

TestExecution.reportToFile ( outM, "
verify that values add to 100"

adjustQuality () test 0:

, harvey. sumOfQualities () ,

100.Of ) ;

II strength 30 rest 70/4 each

II Nominal adjustment

harvey.adjustQuality (QUAL_STRENGTH , 30.0f ) ;
TestExecution.reportToFile (outM, "

adjustQuality () test 1:
,
values sum to 100 after adjusting' ,
harvey.sumOfQualities () , 100.0f ) ;

TestExecution.reportToFile ( outM, , 'adjustQuality () test 2:
,
values adjusted as commanded' ,
harvey.getQualityValue (QUAL_STRENGTH ) , 30.0f ) ;

II Adjustment resulting in a zero value

harvey.adjustQuality ( QUAL_STAMINA, 99.0f ) ;

TestExecution.reportTo File (outM, "

adjustQuality () test 3:
,
verify low value reverts to zero' ,
harvey.getQualityValue ( QUAL_STRENGTH ) , O.Of ) ;

);

CASE STUDY: CLASS TEST FOR ENCOUNTE R

// Conclude
outM.close () ;
System.out.println ( "
class concluded."

\nMethod tests of EncounterCharacter
);

/ * * Class to test repainting of characters. Creates a window, which will contain *
* several copies of the character image.
*/
private static class testCharacterImage extends Frame
/* * Instance attribute that remembers which character image to
display. * /
private EncounterCharacter character I;
/ * * Basic constructor -- create a window for testing some character's image.
* @param

characterP

Character whose image is to be tested.

* / testCharacterImage (EncounterCharacter characterP)
{

super (characterP.getName () ) ;

//Do all normal Frame initialization.

characterI=characterP;

//Remember which character we're testing.

/ * * Repaint the display areaof the frame.
* @param

drawP

Graphics context for drawing the character.

*/

public void paint (Graphics drawP)
{

Dimension frameSizeM = getSize () ;

// Size of the window area.

int widthUnitM = frameSizeM.width /5;

// Convenient divisions of window.

int heightUnitM = frameSizeM.height /5;
characterI.showCharacter (this, drawP,

//Drawn small, facing right.

new Point (widthUnitM, heightUnitM) , heightUnitM, false) ;
characterI.showCharacter (this, drawP,

//Drawn large, facing left.

new Point (widthUnitM* 4, heightUnitM * 3) , heightUnitM * 2, true) ;
characterI. showCharacter (this, drawP,

//Drawn large, facing right.

new Point (widthUnitM* 2, heightUnitM * 2) , heightUnitM * 2, false) ;
characterI.showCharacter (this, drawP,

//Drawn small, facing left.

new Point (widthUnitM * 3, heightUnitM* 4) , heightUnitM, true) ;
}

}

// End of testCharacterImage inner class

687

688

CHAPTER 27

MODULE AND INTEGRATION TESTING

27.8 CASE STUDY: ENCOUNTER INTEGRATION PLAN
APPEND IX FOR ENCOUNTER SCMP:
INTEGRATION PLAN

The integration testing associated with this
integration plan assumes that the individual
classes have been tested (as above).

Note to the Student:
We need to describe the order in which the
application is to be integrated. The SCMP is
an appropriate location for this description,

2. Construction of Integration Baselines

since it describes configurations of the itera­
tions and builds. This could be placed in the

Referring to the various integration techniques

SPMP, but it contains design and implemen­

discussed above, which one is this? It is largely

tation detail, which are not really project

bottom-up if you take the uses relationship for

management items. It could be placed in the

the hierarchy. The encoun/erGame package is then

SOD, but the integration plan is not a design

at the top. If the integration process were to be

but a way to get to the implementation of the

continuous, a description of a daily build pro­

design. A document on implementation issues

cess would be provided, perhaps along with

alone is a possibility. Another possibility is the

some sense of the order of the integration. This

SCMP, since it is concerned with configura­

is normally associated with an agile process.

tions as the product comes together. The
Encounter case study selected this option.

History of versions of this document:

11/1/98 E. Braude: Initial Draft
4/4/99 E. Braude: Revised
8/23/99 R. Bostwick: Documents reviewed and

The three successive builds for release 1 of
Encounter are shown in Figure 27.26. The first
build consists of the GameCharacters framework pack­
age and the Encoun/erCharacters package. The second
build uses the first build. It consists of the EncounterEn­
vironment package, its corresponding framework, and
the first build. The third build refers to builds 1 and 2.
It
consists
of
the
EncounterGame
package,
its corresponding framework, build I, and build 2.

recommendations made

8/24/1999

E.

Braude:

Recommendations

integrated

8/26/1999 E. Braude: Reviewed, comments
expanded

1. Introduction
During the integration process, the software for
Encounter is constructed in stages or builds. This
appendix describes the c onfigura ti on of the first
three builds. Integration testing is based on these
builds. The last build is the basis for system
testing.

2.1 Integration Build 1
Build 1 is illustrated in Figure 27.27. Build 1 imple­
ments the GameCharacters framework package and the
EncounterCharacters package.

Interface testing (see Section 27. 5) is performed
on this module by identifying all of the methods
that its classes make public. (Methods not
needed by other modules should be made
private to avoid unneeded tests of this kind.)
The design is such that these methods are all
part of the Encoun/erCas/ class.

CASE STUDY: ENCOUNTE R INTEGRATION PLAN

Build 3
EncounterGame

EncounterGame

Build 1
EncounterCharacters

---

EncounterCast

Build 2
EncounterEnvironment

EncounterEnvironment

Figure 27.26 I ntegration plan

Integration Plan

GameCharacters

I

1
EncounlerCharacters

«framework package»

I

I EncounterCast

GameCharacter

I

Encounter Characters

EncounterCharacter

f)

EncounterCast
" facade"

EncounterEnwonment

d EncounterEnviromnent

y

I

:::::J Encounte�ame I \

�

"singleton"

Figure 27.27 B u ild 1 for the E ncounter game

ri

I
I

PlayerCharacter

I

J
"I

ForeignCharacter

I

689

690

CHAPTER 27

MODULE AND INTEGRATION TESTING

Integration Plan

GameEnvironment

I

I

!

I GameAreaConnection
t

I

6

7S

I

I�

I

3
I '---1

EncounterGame

Enco,nteoGame

l

EncounterCharacters

I

Enco,nteoCast
Enco,nte,Env;ronment

�

GameArea

GameLayout

�I

I

EncounlerEnvironment

GameCharacter

rW
I

I

I Area
EncounterEnvironment

r<:::

I

«facade»

I EncounterEnvironment

EncounterCast
«facade»

Figure 27.28 Build 2 for the construction of Encounter

2.2 Integration Build 2
Build 2 is shown in Figure 27. 28. Build 2 consists of
the EncounterEnvironment package and the GameEnvir­
onment framework package, together with the first
build. The GameEnvironment and the EncounferEnviron­
ment packages use the build 1 GameCharacter and
EncounterCast classes, respectively. Courtyard, dun­
geon, and living room are examples of areas. Some
of these areas are connected. For example, there is a
connection between the dressing room and the
courtyard.

At the conclusion of build 2, the framework!
application decomposition is shown in Figure 27.29.
The EncounterGame package and its RolePlayingGame
framework package are not present because they are
part of build 3.

2.3 Integration Build 3
The final build, build 3, is illustrated in Figure 27.30.
Build 3 consists of the EncounterGame package, its
RolePlaying Game framework package, build I, and
build 2.

CASE STUDY: ENCOUNTE R INTEGRATION PLAN

Characters

GameEnvironment

«framework package»

EncounterCharacters

«framework package»

I
EncounterLayout I

Figure 27.29 Status of E n cou nter after build 2

,--------------------1

: RolePlayingGame :

>--------------------�------------------------------------------------------------------I
I

:

RPGMouseEventListener

i

notifyOfEventO

RPGame

k> � handleEventO

I<'
�>--------.
.::.J
-,..
�

--;>

GameState

handleEventO

l -------F------------------------------------r-----I
�--�
I
I
I
I
_______________________________________________

_______________________

________

EncounterGame

I

I

I

I

« singleton»

Engagement

Wal·t·Ing

Engaglng
·

handleEventO
I
r�--<
�>L--':":'::==�=-.J
�

handleEventO

I

I
I

I �--------�--------,

i
I
I

EngagementDisplay

I

Reporting

Preparing

handleEventO

handleEventO

L ____________________________________--,-------------------4

: EncounterGame

!

L __________________ �

I

Key: Domain class
Figure 27.30 B u ild 3 for Encounter (i ncl udes build 1 a nd build 2, not shown)

I

691

692

CHAPTER 27

MODULE AND INTEGRATION TESTING

27.9 SUMMARY
Integration refers to the process of assembling the parts of an application and testing their interactions to
ensure that they work together correctly. The parts that are integrated can be as small as a few lines of code or
as large as a subsystem.
Two overall strategies for integrating the parts are incremental and big bang. In incremental integration, the
system is built step by step in relatively small increments. As soon as a part of the application is developed it is
integrated into the baseline. In big bang integration, the parts of the system are developed first and then
are integrated together in one step. This approach can lead to many problems and is usually avoided if at
all possible.
A commonly used technique is to build and test the entire code base on a regular basis. Early in projects the
interval can be weekly, but at the tail-end it can be daily. Conducting daily builds ensures that any problems that
are uncovered can be isolated to recently added code, simplifying defect isolation and resolution.
The Facade design pattern can be used to facilitate interface testing between modules. A facade stub
object is created that implements the public interface of a class or package. Other modules test their interface
with that module, and the facade object checks that it is being called correctly and returns a predetermined
response. Once the interface is tested, the facade is replaced with the real module and the modules are tested
further.

27.10 EXERCISES
1. [n your own words, describe incremental integration. Name and explain two benefits of
incremental integration.
2. [n your own words, explain how a project schedule is affected by the method of integration used on
the project.
2A. Consider the health monitoring application described in Figure 27.11. Describe with examples
how you would integrate it bottom-up and how you would test the integration process.
3. In your own words, describe how bottom-up integration works. List and explain two advantages
and disadvantages of bottom-up integration.
3A. The case study in Section 27.8 does not describe a continuous integration process-but
suppose that the document did prescribe one instead. What would that document say?

4. In your own words, describe how top-down integration works. List and explain two advantages and
disadvantages of top-down integration.
5. Consider a point-of-sale system that is under development. Assume that the hardware platform and

device drivers that control it are brand new. The rest of the software is being ported from an
existing system. What appropriate method of integration might you recommend be used, and
why?

6. In your own words, explain how daily builds facilitate the isolation of defects in a build.
7. Figure 27.31 shows the architecture outline of an application that simulates the movement of
customers in a bank. Provide a plan for building and integrating this application.

BIBLIOGRAPHY

BankSim

I

I

BankCustomers

I

BankCustomer

BankSim

«facade»

I

PendingEvents

executeNextEventO

I

Number

I

BankSim

BankLayout

«facade»
getNumberO

I

BankLayout

«facade»

I Teller I
I Queue I

BankEvent

I

BankEvent

«facade»
executeO

Figure 27.31 A rchitecture of bank simulation exercise

TEAM EXERC ISE
Integration

Obtain project specifications from two other teams in the class. Specify informally a new application
that contains significant elements of these applications. Specify an integration plan to build this new
application.
Evaluation criteria:
(1) Degree of clarity of the plan
(2) Degree to which the plan contains an appropriate order

BIBLIOGRAPHY
1.
2.
3.

Pezze, Mauro, and Michal Young, "Software Testing and Analysis, Process, Principles and Techniques," John Wiley & Sons, 2008.

Dijkstra, Edsger, "Go To Statement Considered Harmful," Communications of the ACM Vol. 11, no. 3, 1968, pp. 147-148.

Cusumano, M., and R.W. Selby, "How Microsoft Builds Software," Communications of the ACM, Vol. 40, no. 6, 1997, pp. 53--61.

693

Testing at the system Level

�

Testing

Maintenance
The Software
Development
Lifecycle

Planning
\

Requianalrements
ysis

Implementation
�DeSign /

How do functional and nonfunctional
testing differ?
How do you conduct performance tests?
What is load / stress event testing?
Reliability and availability testing?

Recoverability testing?
How do you test usability?
How do you validate security?
How do you test when requirements are
sparse or even nonexistent?
What is acceptance testing?
How does one test in agile processes?
What are compatibility, installation, and
serviceability testing?
How do alpha and beta releases relate to
testing?
When is testing automated?

Figure 28.1 The context a nd lear n i ng goals for th is chapte r

TESTING AT T HE SYSTEM LEVEL

•

Performance ...

Test speed of application
•

Load/Stress ...

Test against heavy event traffic
•

Reliability and Availability ..

Determine percentage up-time
•

Recoverability ...

Test ease with which application recovers from crash
•

Usability ...

Determine degree of user satisfaction.
•

Security ...

Determine susceptibility to intended and unintended breaches
•

Compatibility ...

Application compatible with other systems as required
•

Installability ...

Test ease of installation
•

Serviceability ...

Test ease of keeping up-to-date at customer site
Figure 28.2 P rincipal system tests

Sys tem testing follows integration testing. It consists of black box tests that validate the entire system
against its requirements. Once all other system tests are successfully completed, the application is deemed
ready for the customer's acceptance testing (Section 28. 4. 2). These are related to the requirements and to
metrics in that each test measures one or more metrics.
System tests are most often conducted by an independent group such as Quality Assurance. During
system testing, compliance with both the functional and nonfunctional requirements is validated. Recall from
Chapter 10 that functional requirements specify services that an application must provide (e.g. , "The
application shall compute the value of the user's stock portfolio."). Nonfunctional requirements, on the other
hand, describe a quality or behavior an application must possess. Examples of nonfunctional requirements
include performance, usability, and compatibility. Figure 28. 2 summarizes various types of nonfunctional
systems tests. Since system tests ensure that the requirements have been met, they must systematically
validate each requirement specified in the SRS, including each of the use cases.
Whenever possible, system tests are performed on the application running in its required environment.
This is not terribly complicated for an application that is intended to run on a PC, such as a calendar program,
although even for simple platforms we still have to be concerned with complicating issues such as the versions
of the operating system. However, many applications cannot be fully tested in their eventual environments.
This certainly applies to space-based applications, for example, with sometimes disastrous consequences. The
Mars Climate Orbiter spacecraft is a case in point. It veered off course, resulting in a loss of hundreds of
millions of dollars. According to Cable Network News, the investigating board's chairman reported that

the root cause of the loss of the spacecraft was a failed translation of English units into metric
units and a segment of ground-based, navigation-related mission software.
Testing for this and other requirements had to take place on a ground-based test bed.
In analogy to the two principal forms of requirements.Junctional tests test the functional requirements of
the system, and nonfunctional tests the qualities and behavior of the system. The acceptance tests, validating that

695

696

C HAPTE R 28

TESTING AT T HE SYSTEM LEVEL

the requirements have been fulfilled, make up the main functional test set. The main nonfunctional tests arc
included in the summary of Figure 28.2, and are discussed in the rest of this chapter.
This chapter provides a number of metrics associated with these tests. It also discusses smoke testing
(Section 28.7.2), a kind of rough regression test, and testing in the presence of lightweight (incomplete or
even nonexistent) requirements.

28.1 FUNCTIONAL TESTING
Functional system tests focus on how customers will use the product in real life. Use cases are a primary source
of functional requirements. As an example of testing a use case, recall the following Encounter use case, Engage

Foreign Character, from the customer requirements.
1. Encounter displays the foreign character in the same area as the player's.

2. Encounter exchanges quality values between the two characters.
3. Encounter displays the results of the engagement.
4. The user hits the "OK" button.

5. Encounter displays player's character in a random area.
To test this, we may begin playing the game until an engagement takes place and is observed, as in Figure 28.3.
Elena status

..,.

<Ii

......

'"�," .. "'"" " '--_
Current value:

Figure 28.3 System testing of Encounter v ideo game-Engage Foreign Character use case

_-

FUNCTIONAL TESTING

As part of testing this use case, we see that in Step 2 quality values are exchanged. We turn to the
detailed requirements for quality values and validate each. The following is an example, taken from the
Encounter SRS.
3.2.EC1. 2 QUALITIES OF ENCOUNTER CHARACTERS
Every game character has the same set of qualities. Each quality shall be a nonnegative floating­
point number with at least one decimal of precision. These are all initialized equally so that the
sum of their values is 100. The value of a quality cannot be both greater than 0 and less than
0. 5. For the first release, these qualities will be concentration, intelligence, patience, stamina, and
strength.

This can be decomposed as follows:
3. 2. EC1.2. 1 Every game character has the same set of qualities. Each quality shall be a
nonnegative floating-point number with at least one decimal of precision.
3.2. EC1.2. 2 These are all initialized equally so that the sum of their values is 100.
3. 2. EC1.2. 3 The value of a quality cannot be both greater than 0 and less than 0.5.
3.2.EC1.2. 4 For the first release, these qualities will be concentration, intelligence, patience, stamina, and
strength .

•

•

3.2.EC 1.2.1 is validated by going through each quality on the set qualities window and ensuring that each has
a decimal value, as shown in Figure 28. 4 .
We validate 3.2.EC1. 2 by checking on Elena's qualities as the game begins.

Tota l l ife points: 60.0

Figure 28.4 System testi ng of E ncou nter v ideo game-testi ng with GUI for setting q ualities

697

698

C HAPTER 28

�

TESTING AT T HE SYSTEM LEVEL

Elena quality update

;

� Elena status

"g.

Current life points: 25.16364

Total life points: 25.563635

Current value:
Concentration
Intelligence
Patience

0.0

� Before last encounter'
1.3454546

Figure 28.5 System testi ng of E nco unter video game-testing v ia GUI for setting a nd view i ng q ualities

•

•

Validating 3. 2. EC.l . 3 can be done by reducing Elena's points on a quality to less than 0.5. The result of
setting stamina to 0.4 and showing that Encounter actually sets this internally to 0 is seen in Figure 28.5.
We validate requirement 3. 2. EC. l.2. 4 by ensuring that all promised qualities are present and that there are
no additional qualities. We continue testing in this manner for the rest of the use cases and functional
requirements.
Metrics for functional testing are usually based on the requirements, and include the following:

•

Number/percent of detailed requirements partially, and not fully realized

•

Number/percent of detailed requirements not realized at all

•

Number of high-level requirements not implemented, as perceived by the customer

•

Number of detailed requirements not implemented, as perceived by the customer

28.2 NONFUNCTIONAL TESTING
This section describes several common types of nonfunctional testing: performance, load/stress, reliability
and availability, recoverability, usability, security, compatibility, installation, and serviceability testing.

28.2.1 Performance Testing
Performance testing validates that a system meets its specified performance requirements by observing the
throughput, or speed of the system. Throughput refers to the number of transactions that can be processed in a
given amount of time. The meaning of a transaction depends on the type of application that is being tested. For our
video store application, speed could be measured by the number of video rentals that can be processed per minute.

NONFUNCTIONAL TESTING

For a real-time communications system, speed might be measured by the number of data packets that can be
processed and forwarded per second. Good requirements will have avoided vague statements about performance
such as "customer responses should be acceptably fast." Such vagueness causes problems because the stakeholders
can harbor very different interpretations of "fast." For the video store application, a well-written performance
requirement is 'The application shall be able to successfully handle a load of 1000 rental requests per minute."
Test environments such as Eclipse's Test and Performance Tools Platform (see Section 28.6) identify the
packages, classes, and methods with high execution times, as well as those invoked frequently.
Metrics for performance testing are usually based on performance requirements, and include the following;
•

Number/percent of speed requirements not satisfied

•

Number of memory use requirements not satisfied

•

Number of speed requirements not satisfied, as perceived by the customer

•

Number of memory use requirements not satisfied, as perceived by the customer

28.2.2 Load/Stress Eve nt Testing
The purpose of load/stress testing is to subject a system to increasing loads and to stress it in various other ways to
determine its breaking point. Another way of stating this is "under what load does the system start to break?"
Examples of the types of loads used are maximum number of users supported, maximum number of transactions per
second, and maximum data transfer rate. Once the points of failure are determined we can understand whether the
system meets its load-related requirements. Knowing these limits also allows us to examine the system design to
understand those parts of the architecture that are susceptible to stress, and use this for future planning.
A good requirements document specifies the performance of the application under precisely stressed
circumstances. As an example, suppose we have the following performance requirement.
The site shall handle customer visits with a maximum oj 10 seconds wait time under the Jollowing conditions. Visits
occur in a Poisson (probability) distribution with an average oj 100 per minute. Each order is an average oj 2
books, distributed normally with a standard deviation oj 1.

An example of a load/stress test based on this requirement is the following.
Visit the site Jor 10 minutes with an average oj 100 customers per minute. Each orders an average of 2 books, with a
standard deviation oj 1.

Recall that the Poisson distribution simulates arrival times at a queue; the standard deviation measures the
extent to which data varies from the mean. For example, a variance of zero in the orders of the above
requirement would mean that exactly 100 customers call every minute. Once we validate the system can
handle this load, we increase the number of customer visits per minute to determine the point at which the
application exhibits a problem.
In many cases, loads and stress limits are not explicitly specified in a requirements document. In this case,
the project manager, QA or management decides on the targets to be attained based on the following factors.
•

User and customer expectations

•

Technical limits

•

Costs of improvement

699

700

C HAPTE R 28

TESTING AT T HE SYSTEM LEVEL

•

Legal advice

•

Market conditions

•

Experience with past products

•

Comparisons with competitors' products

Tools such as Eclipse's Test and Performance Tools Platform (TPTP-see Section 28.6) provide the
number of objects created at runtime and the amount of memory they consume. Various graphical devices are
provided that show a "thermometer" reading of memory consumption (min to max) by mousing over a sequence
diagram of function invocations. Testers seek maximum and near-maximum readings. The sequence diagram
can be generated from the test execution. TPTP shows how many objects referenced a given object at runtime.
Metrics for load/stress testing include the following:

•

Number/percent of load/stress requirements not satisfied

•

Number/percent of load/stress standards (industry or company) not satisfied
These can be decomposed by types of loads and stresses.

28.2.3 Reliabi lity and Availabi lity Testing
It is an implicit requirement for every application that it be available for use! Sometimes it is acknowledged
that the system will have defects or that it will not be able to survive defects in its environment (e.g., the
operating system) and will crash at times. Reliability and availability assess and measure the extent of this.
Reliability and availability are typically measured by the mean time between failures (MTBF). To obtain
MTBF, a definition of "failure" is first specified-for example, a crash of the application that requires its reload.
Several different levels of failure may actually be defined and used. To compute the MTBF, a tester starts the
application and notes the time. He or she then executes the application using, ideally, random scenarios until
the system fails. The elapsed time is computed. This process is performed repeatedly; the MTBF is the average
of these times.
Obtaining a very reliable value of MTBF involves hiring people to use the application according to some
controlled rules and procedures. Gathering these data for many hours requires significant compensation for
testers. Naturally, one tries to gather the data while users are using the application for another purpose.
However, the other purpose-or purposes-cannot be permitted to bias the results. A related technique is to
have a large body of users exercise the application in advance of its official release (see Section 28.4.3
concerning alpha and beta releases). To obtain an MTBF, it is necessary then to estimate the number of users
and the time they spend using the application. As many know, the gathering of this kind of data continues
even after a product is shipped, as in the pop-up message "Please send us notification of this failure .

28.2.4 Recovera bility Testing
Many otherwise excellent applications crash from time to time: The reasons may be beyond the control of
developers, such as power outages. A good SRS specifies what should take place when an application crashes. A
common requirement is that, when restarted, the application returns to its state at the time of the crash. This is a
recoverability requirement. Another common requirement is for a designated log file to contain an explanation of the
crash's cause (rather like an airplane's black box). As an example of a recovery technique, consider the "backstop"
technique employed by Tom VanCourt on the Encounter video game. The code is shown in Listing 28.1.

NONFUNCTIONAL TESTING

Listing 28.1 Recoverability in Encounter video game
publicstaticvoidmain( String[] argv)
{
try {
/ / Create the main application window.
final GameMain gameFrameM = new GameMain();
gameFrameM.addWindowListener ( new WindowAdapter() {
publicvoidwindowClosed( WindowEvent e )
{System.exit(O);

}

publicvoidwindowClosing( WindowEvent e

}

{gameFrameM.dispose() ;

}

);

/ / Set frame to a workable size. The size given here is only
/ / approximate I since the frame can be resized and the layout
/ / manager can adapt the content over a wide range of sizes.
/ / Add in approximate amounts for window frames I etc.
gameFrameM.resize( GAME_AREA_WIDTH + 25 I

GAME_AREA_HEIGHT + THUMBNAIL_HEIGHT + 25

gameFrameM.createGameUI();

);

/ / Set up the user interface.

gameFrameM.show();

/ / Display the window.

gameFrameM.validate();

/ / Display the window contents.

gameFrameM.toFront();

/ / Start in front of other windows.

} catch ( Throwable thrownException) {

/ / Backstop exception handler: Catch any exceptions not already

/ / handled elsewhere and try to get debug information from them.
/ / RuntimeException obj ects I in particular I can be thrown by
/ / any method without having been declared in a I throws

I

clause.

System.err.println( thrownException.getMessage() );
thrownException.printStackTrace( System.err );

}

}

The effect of this code is to trap exceptions not handled elsewhere and report them before the
application stops. One can test for this at the system level by entering illegal values such as 1010 for strength
value of a quality. Metrics for load/stress testing include the following:
•

Number/percent of recoverability requirements not satisfied

•

Number/percent of recoverability standards (industry or company) not satisfied

•

Mean time to repair (i.e., to regain a given running status)

701

702

CHAPTE R 28

TESTING AT T HE SYSTEM LEVEL

•

Frequency of auto-recovery compared with the desired auto-recovery frequency

•

Mean recovery time

•

Mean restart time

28.2.5 Usa bility Testing
Usability testing validates an application's acceptability to its users. The primary goal of usability testing is to
ensure that the application satisfies its stated usability requirements. These should be provided in the SRS in
quantified terms, together with the manner in which the desired quantities are to be measured. Kit [1] lists the
overall criteria in Figure 28.6 as essential for usability testing.
For example, we might require that a random sample of 30 users of our home finance application rate the
application on a scale of 0 to 10, as shown in Table 28.1. An inspection of the accessibility results shows that
our application scores about 12 percent lower than the industry average-some cause for concern. Our
variance is lower than that found in industry, however, which means that the sampled users agreed more on

•

Accessibility

How easily can users enter, navigate, and exit?
For example, measure by average time taken to .
•

•

Responsiveness

How ready is the application to allow the user to accomplish specified goals?
How often is CUI display accurate (percentage)?
How quickly are user actions acknowledged?
How often is the application ready for user action?
•

•

•

•

Efficiency

Degree to which the number of required steps for selected functionality is minimal
"Minimal" calculated theoretically
For example, measure by minimal time/average time
•

•

•

Comprehensibility

How easy is the product to understand and use with documentation and help?
For example, measure time taken for standard queries
•

Figure 28.6 Key attributes sought in usability testing
Source: Kit, Edward, Software Testing in the Real World: Improving the Process, Addison-Wesley, 1995.

Table 28.1 An example of usability scores
Score

Variance

Industry
average
score

Accessibility

8.1

2.1

8.2

3.5

Responsiveness

9.3

3.2

5.0

3.0

Efficiency

5.6

2.0

7.2

1 .1

Comprehensibility

2.3

0.5

6.0

0.3

Quality

Industry
average
variance

NONFUNCTIONAL TESTING

this score than users typically agree on the usability of a Ul. This tells us that a smaller percentage probably
actually dislike using our application than is usual.
The appropriate sample size depends on the desired probability of an erroneous conclusion. [f we want a
smaller probability of error, we need a larger sample. Usability data can be collected in a controlled or
uncontrolled environment. [n a controlled environment, subjects are observed and data like the following are
obtained:
•

Average time for the user to complete designated functions

•

The rate of user errors in designated interactions

•

Average time taken to learn new functions

•

Average time taken to complete designated tasks (e. g., create a letter in a word processor)

•

The results are compared with required, company, and industry norms. Users are very sensitive to
applications with which their experience deviates much from what they are used to.

[n designing usability questionnaires, the challenge is to obtain data that enable engineers to remedy the
most serious shortcomings without exceeding the limits of users' time and patience filling out questionnaires.
Usability data can be expensive to collect because users often expect compensation for the time and trouble of
providing detailed feedback. For example, a client of one of the authors develops software for a device used by
physicians. The company provides a free dinner and significant monetary compensation in return for viewing
and commenting on screen shots and demonstrations.
Turning now to uncontrolled environments, Figures 28.7 and 28.8 show the beginnings of the Purdue
Usability Testing Questionnaire [2], which provides useful data from which to assess the value of and
potential improvements in a set of GUls.

28.2.6 Security Testing
Security testing consists of identifying security defects and measuring the extent of an application's security.
Recall that some principal aspects of security are those listed in Figure 28.9. We can base security testing on
these. The testing can be performed by using or simulating interception of traffic (called "sniffers"), using
software that attempts to break systems, such as scripts that repeatedly try password break-ins, and by using
people of varied skill levels to try deliberately breaching the designated security aspects. At the high end of
this spectrum of skills are people with experience "hacking." A high level of security clearance is required for
them. Using hackers can present major problems when an external consulting company is the only alternative
and especially when the experienced people have been involved in unauthorized activities in the past.
The Open Source Security Testing Methodology Manual (OSSTMM) is an open standard methodology for
performing security tests [3]. OSSTMM focuses on the technical details of which items need to be tested,
what to do during a security test, and when different types of security tests should be performed. A checklist
for confidentiality testing in information security, partly adapted from OSSTMM, includes the following
actions. Some are part of non-security testing as well, as one continues to recognize that many security
breaches simply exploit a defect in the software.
•

Validate confidential database locations
•

Screen all databases for confidential content

703

Purdue Usability Testing Questionnaire

Email to:

0
C'
C-

bad 0
bad 0
bad C

3. Is the control matched to user skill? III

4 . .Are the coding compatible with familiar convenbons? III

5. Is the wording familiar? III

Source: Purdue Usability Testing Questionnaire, http://www.acm.org/�perlman/Question.cgi?form=PUTQ.

Figure 28.7 P u rdue usab ility q uestio nna i re fragment. 1 of 2

0

bad C

1111

2 . .Are the results of control entry compatible with user expectations? III

't

0

Il

bad C'

RETURN TO REFFRRlNO PAOE

Email to: ,'-_____---'

1 Is the control of cursor compatible with movement? III

1. COMPAl'IBILITY

I

To mail in your results. click on: Mail Data

O

C

n

0

n

3

Add a comment about an item by clicking on its III icon. or add comment fields for all items by clicking on Comment All.

Make sure these fields are filled in: System:

For items that are not applicable. use: NA

Try to respond to all the items.

System:

•

•

•

•

•

Please rate the usability of the system.

C

()

0

()

0

4

0

0

0

0

C

0

0

0

()

C

5116

C

0

0

0

()

7

good

good

good

good

good

0

0

0

C

0

J�A

s-i ea: Un, HX. Choong. Y.-Y.• and Selvendy. O. (1997) A PropoJed Index of Usabili,,: A Mcthodfor CompDrl1'lg tIN IWative Usabili" of D!ferent Software S)MaI.5. Be...__
., u....... Tee.....,.. 16:415. '2fi1-m. � Reproduced by permission. (The ratings ofimporlQ11CC 8fe nol included in this online version, but could be incorporated into the
comments.) _ quoctioa.<o

r­
m
<
m
r-

s:

�
�
m

m

-I
:::c

�

G)

Z

�

m

-I

::c
N
00

�
m

o
:::c
»

"-I
o
�

6
Co
Co
0

Co
Co
Co

Co
Co
Co
Co

Co
Co
Co
Co

0
Co
Co
Co

b ad Co
bad Co
bad Co
bad 0

Co

bad Co
bad Co

7 Is the c o ding c onsistent acro s s display s , menu optlons ? I:l

NA

Co
0
0

bad 0
b ad 0
bad 0
bad Co

1 6 . Are the us er actlons re qUlfe d c onsistent? C"

1 7 Is the wording c onsistent acro s s displays? C"

1 8 . Is the data display c onsistent with entry re qUlfements? C"

1 9 Is the data display c onsistent with us er c onventlons? C"

2 0 . Are symb ols for grapluc data standard? C"

0
Co
Co
0

Co
0
Co
Co

0
Co
0
Co

bad 0
b ad 0
bad Co

2 1 Is the optlon wording c onsistent with c ommand language ? C"

2 2 . Is the wording c onsistent with us er gwdanc e ? C"

Source: Purdue Usability Testing Questionnaire, http://www . acm.org/-perlman/question.cgi?form=PUTQ.

Figure 28.8 Pu rdue usab ility questio n na i re fragment, 2 of 2

0

0

0

0

0

0

0

0

0

bad 0

1 5 . Is the display onentatlon c onsistent? - - p anrung vs . s crolling. 1:1

Co

0

0

Co

Co

0

Co

Co

=:J

Co go o d Co

Co g o o d 0

o go o d Co

o go o d Co

o go o d Co
0

0
0

Co go o d Co
Co

o g o o d Co

o go o d 0

o go o d Co
Co
0

o go o d 0
0

0

0

0

0
0

Co

b ad Co

1 4 Is the lab elling its elf c onsis tent? 1:1

0

0

Co
0

Co

bad 0

1 3 . Is the lab el lo c atlon c onsis tent? C"

1:1

Co go o d 0
0

Co

Co
0

1 2 . Is the lab el format c onsis tent?

0

Co go o d Co

Co
Co
Co
C

c onsis
1 1 Is the format withm data field s

tent? 1:1

o go o d 0
0

Co
0

1 O . Is the fe e db ack c onSlS tent? C"

9 Is the display format c onsistent? C"

Co

o g o o d Co

Co go o d 0

Co go o d Co

n go o d Co

7

Co

8 . Is the curs or plac ement c onsis tent?

1:1

C

Co

b ad Co

6 . Is the as stgnment of c olour c o d e s c onventlonal? I:l

4

5

3

2

1

2 . C ONSIS TENCY

'-I
0
U1

Gl

Z

r
-I
m
(I)
-I

(5
Z
»

z
"
C
Z
(")
-I

Z
0

706

CHAPTE R 28

•

TESTING AT T HE SYSTEM LEVEL

Confidentiality
•

•

Sniffers validate that data passed not visible to unauthorized parties
Hire professional hackers?

•

Nonrepudiation

•

Integrity

•

Authentication

•

Authorization

•

•

•

•

Experiments to validate
Alter data and validate consequences
Hire professional hackers?
Hire professional hackers?

Figure 28. 9 Testing for security

•

Validate cookies
•

Content, types, expiration, and encryption

•

Check for buffer overflow protection

•

Check for memory leaks

•

Test for illicit site navigation

•

Validate sign-ins
•

•

Include default IDs and passwords

Check protection against illegal and out-of-bounds input (not necessarily input that allows breaches)
Metrics for security testing include the following.

•

Number/percent of specific security requirements not satisfied

•

Number/percent of security standards (industry or company) not satisfied

•

Confidentiality: Average time required to gain disallowed access to information
•

at a specified level of security

•

by testers of a specified degree of training and experience

•

Nonrepudiation: Average time required to repudiate agreements

•

Integrity: Average time required to alter data in transit, undetected

•

Authentication: Average time required to verify identity

•

Authorization: Average time required to gain disallowed access to a location

28.2.7 Com patibility Testing
Many applications are designed to work with other applications. For example, a word processor that allows
the insertion of a spreadsheet must be compatible with the spreadsheet application. Another example is an
application that obtains data from people with mobile devices of various brands. Compatibility testing is

NONFUNCT IONAL TESTING

similar to integration testing in that it tests the interactions between parts of an application. The difference is
that the interfaces are typically developed by different organizations, and developers normally can't change
the applications with which they must be compatible.
An important subfield of compatibility testing is assuring that the application operates with designated
past versions of software on which it depends. This includes versions of the operating system. An example is
an online learning environment, which must work with various versions of Windows as well as with UNIX.
Compatibility with future versions can be planned for to some extent, and it is sometimes possible to simulate
upcoming changes. Testing must include combinations of versions.
Metrics for compatibility testing include the following:
•

Number/percent of specific compatibility requirements not satisfied

•

Number/percent of compatibility standards (industry or company) not satisfied

28.2.8 Installation and I nsta l l a bi lity Testing
An installation test validates that an application can indeed be installed. An installability test is a more general
concept in that it tests via installation test cases whether an application can be installed on a variety of
configurations. Installation tests whether an application can be successfully installed on its target systems.
These are binary can/can't tests. Many types of errors can occur during installation, especially due to the
differences in hardware and software platforms. Applications are often required to execute on multiple
hardware and software platforms. Multiple platforms typically require separate tests. For example, if our video
store application were required to execute on Windows and Macs with Internet requirements, we would
devise tests that ensure the satisfaction of the requirements on each of these platforms. Although we try to
develop applications that are platform independent, this has limitations. For example, we may need to test
with separate bar code readers for Windows and Mac platforms. Installation tests would be identical for the
most part but would contain Windows-specific and Mac-specific parts.
Once we have tested that an application can be installed correctly, we run a second tier, consisting of
installability tests that measure the level of difficulty of installing the application. As computer users we are all
too familiar with how easy or how hard it is to install an application. Installability tests this process and the
aspects of the application that make this easy or difficult.
Metrics for installation and installabilty testing include the following:
•

•

Number/percent of specific installability requirements not satisfied
Time required to install on designated platform by customers with designated amount of experience or
education

•

Time required to confirm installation integrity via a standard test sequence

•

Number of defects found during installation, with "defects" carefully defined

28.2.9 Servicea bility Testing
Servicing an application is the process of repairing or enhancing it. This could include visiting the site and
sending a full or partial replacement over the Internet.
An application's serviceability refers to the ease or difficulty with which it can be kept operational in the
face of changes to its environment. For example, an expert system application relies on its knowledge base,
typically in the form of a set of rules, which may be straightforward to modify. Another example is the ease

707

708

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

with which an appl ication that runs on one version of an operating system can be made to run on its successor.
Serviceabi l ity tests execute scenarios such as swapping databases . Serviceability is related to maintain­
abi l i ty-the ease or difficulty with which an applicatio n can be maintained. The di fference is that servicing is
a planned, expected, and predictable process.
Metrics for serviceab ility testi ng i nclude the following:
•

Number/percent of specific serviceabi lity requirements not satis fied

•

Number/percent of serviceability standards (industry or company) not satisfied

•

Time required to service speci fied actions on design ated pl atforms

28.3 TESTING WITH LIGHTWEIGHT REQUIREMENTS
This section discusses testing in the context of requirements that range from bei ng not written down at all
(Section 28.3.1) to bei ng only partially expressed i n writing via the user stories o f agile processes (Secti on

28.3.5).
28.3.1 Testing in the Absence of Requirements
Most of the software engineeri n g l i terature em phasizes the importance of requirements and the execution
of testing against those requirements. Higher CMM levels are bestowed only o n those orga n i zati ons that
write down requirements thoroughly ( see Chapter 6 ) . However, many real-worl d appl icati ons have
i ncomplete or even n onexistent requirements documents . Our concern i n th is chapter is how to test such
applicati o n s .
Even when requirements d o exist i n written form , they generally c a n n o t provi de a very g o o d feeling for
the application compared with running code. This is l ike the di fference between drawing detailed plans for a
house and living in the house after it is built-they are simply not the same. I n fact, if we want to determine
whether a house that is already built satis fies needs , it is more useful to ask the occupants than to i nspect the
architect's drawings. Figure 28.10 summarizes the reasons for testi ng with little or no reference to a
requirements document.
Suppose that you h ave been asked to test an applicatio n for which there is no requirements
document. Where do you begi n? I n the next secti o n s , we'll describe a starting poi nt: a behavioral model of the
application .

•

•

•

•

Provides a "feel" for the applicatio n
Even complete, written requirements d o not accomplish this effectively
The Requirements document omits implicit ones
The Requirements may be i ncomplete
be inconsistent with the code
be missing
never have been written down at all
You can't access the requirements because the product is from a third party
Vendor software that you must test before using

Figure 28.10 Reasons t o test without basing the tests on written requirements

TESTING WITH LIGHTWEIGHT REQUIREMENTS

28. 3.2 Models for Software Testing
To test an application in the absence of well-written requirements , the tester needs a sense of how the
applicati o n i s meant to behave and how it actually behaves. This i s called behavioral modeling. Most o f us have
already had a behavioral modeli ng experience in deal ing with an un fami liar application. Although we may
read the manual or follow a tutori al, we often simply "play around" with the applicati o n . This section concerns
disciplined ways to "play around" with the goal of finding as many defects, as serious as possible, in as little
time as possible. This is not the bl ack-and-white process of requirements-based testi ng, and it is sometimes
called an "art." Good artists , however, are extremely well-disciplined, and good testers are too .
One approach to forming the concepts of an as-built (already constructed) application is to use the
software design models that we covered in Chapter 1 5. These are the use case models, class models, data flow models,
and state models. These are valuable for creating designs of applications yet unbuilt, but they are less so for
modeling already-built applications. Table 28.2 indicates when these design models could apply to
behavioral model ing of already-built appl ications.
This suggests that a di fferen t or modified model shoul d be sought, as discussed next.
Table 28.2 Applicability of various design models to black box testing of as-built applications
Design Model

Applicability to As-Built Black Box Testing

Use Case Model

Apply use cases to identify the main, unbranching behavior

Class Model

Typically not especially useful for black-box testing

Data Flow Model

Possible if the tester recognizes prinCipal functions

state Model

Possible if the tester recognizes states that the application
transitions through

28. 3 . 3 constructing Directed Graphs for Black Box Testing
We will use the concept of directed graphs in what follows. A directed graph is a figure consisting of nodes,
together with arrows between certain nodes, called edges, illustrated i n figure 28.11. The meaning of nodes
and edges depends on the context i n which they are applied.

node

Figure 28.11 Directed graphs

709

710

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

Actions
Launch text document processing
Enter text
Hit file / save
Enter a file name and press save

An action

Edge indicates sequence
(only one in this case)

Figure 28.12 Initial directed graph for OpenOffice

One approach to modeling as-built applications is to start from what appears best to be a begi nning
point of the applicatio n , and then keep track of the paths from there i n directed graph form. Each node
represents an actio n performed by the user or the application (sometimes a sequence of such actions instead).
Each edge leads to the next possible actio n . Edges are l abeled when necessary to distin guish options. This use
of nodes and edges is neither data flow nor state/transition. It can be thought of as a control flow in that each
node represents a point at which the applicatio n is in contro l .
A s an example , let's perform this for the word processor of the open source office suite OpenOffice. Besides
selVing as a means for black box testing, a directed graph is a means of getting to know the application. Figure 28. 1 2
shows the beginning o f a directed graph for executing OpenOffice's "Writer," its word processor.
Since there is no branching in the example of Figure 28. 1 2, there is no need to l abel the edges to
understand the sequence of actions. In Figure 28 . 1 3 , on the other hand, there is such a need. Branch points are
labeled as n odes like any other (which makes these diagrams different from others we have studied in this book ) .
Figure 28 . 1 3 shows a continuation of the graphing process . T h e numbering selVes o n l y to l abel t h e nodes and
does not denote an order. The labels o n edges are used to assist in differentiating among branching options.

save

�
��

heading
bold
Actions

1.

headings

Launch text document processing.

2.

Enter text

3.

Hit file I save as

4.

Enter a file name and press save

5.

Convert 3 line to headings at levels 1,
2, and 3

6.

Bold some text

7.

File exists?

8.

Hit save I "already exists" pops up I yes

Figure 28.13 Example of a directed graph for OpenOffice

[Predicate
F

node]

T

8

TESTING WITH LIGHTWEIGHT REQUIREMENTS

�.- - -- ��
��

I

Paths:

I

=----7
> �.
__

.

. save

-

-

.
· .

.

-�-...

�

� -- ---�,
'\

eadingS

bold " ."
"

Actions
1.

Launch text document processing.

2.

Enter text

3.

Hit file / save as

4.

Enter a file name and press save

5.

Convert 3 line to headings at levels 1,

""' __.

save

'

5 .-/

save

"
'

"
.

node]

2, and 3

6.

Bold some text

7.

File exists?

8.

Hit save / "already exists" pops up / yes

/

�
'\!!.J ------

[Predicate

"
B
4

/

i
V.f
T'�
_

_

F

-

/

/

Figure 28.14 Using a directed graph for testing-Openoffice example

•

•

•

The most expected paths with no error or anomaly conditions
The most expected paths with error or anomaly conditions
The paths most likely to yield defects

Figure 28.15 Selecting paths in directed graphs for testing

28. 3.4 using Directed Graphs in Testing
Tests are designed via sequences that traverse multiple nodes. A reasonable goal is to create enough of these
to cover all nodes . (Attempting to cover all path combinations exposes more de fects but usually leads to a
combinatorial explosion in the number of possibil ities . ) Figure 28 . 1 4 shows three paths that cover all n odes .
The number of sequences made of these paths can be extremely l arge . The tester can be selective among
these as i n Figure 28 . 1 5, however.

28. 3 . 5 Testing for Agile Processes
As mentioned in previ ous chapters , conti nual testing is an integral part of agile processes, especially via
util ities such as JUnit and NUnit. Although such tests focus on a method under constructio n , a growing,
cumulative set of unit tests can effectively test large parts of an application as it grows.
A suite of JUn it tests, grown method by method and class by class (as in Chapter 27) , may be partly
usable for functional testi ng (i . e. , to check that the requirements have been satisfied) . However, i nvariably
there will be requirements for which they are not appropriate, such as those that require user interactio n .
The following kinds o f testi ng are carried out for agile projects in the same way a s for n on-agile ones:
•

•

Nonfunctional testi ng (performance, load/stress, event, recoverability, usability, security, compatibility,
installation, serviceability)
Acceptance testi ng (a central part of the agile approach)

711

712

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

28.3.6 Qualities of a Good Tester
We have described various techni ques for the black box testing of as-built applicatio n s . A good tester,
however, goes well beyond them in his or her efforts in trying to ferret out defects that coul d be encountered
when many people use the application for a signi ficant time, perhaps i n unantici pated ways. He or she should
be an independent thinker and should not be part of the team that designed or implemented the application
under test. This is because even the most independent person involved in design or implementation develops
a vision of the applicatio n that, even when excellent, is l i kely to overlook or misunderstand issues . The
following are some of the qual ities of a good tester:

•

Willingness to learn goals of appl icati o n

•

Willi ngness to put self i n user shoes

•

Determi ned

•

Dogged

•

Fearless

•

Imaginative

•

"Outside the box" thinker

•

Curious

•

Meticulous

Let's translate these qualities i n to the testing of Open Office. To find as many defects as possible within a
fixed amount of time, the tester woul d need sufficient determi nation to go beyond the obvious ways of using
the applicatio n . This is because the common procedures will probably have been exercised many times and
thus have been debugged. The tester would need doggedness to stay with his or her i ntuition concerning
lurking bugs even when it yields few i nitial bug finds. In the normal use of an application, users tend to be
relatively gentle. For exam ple, they avoid hitting a control-X button while a file is bei ng saved, or pressing
many keys in rapid successi o n , i ncludi ng function keys. A tester, on the other hand, needs the fearlessness to
stress the application i n such a manner.
There is another sense in which testers need to be dogged: getting acti on on the defects that they find.
Kaner [5] notes that finding and obtaining action on discovered defects is signi ficantly more i mportant than
simply finding them. His point i s that the time spent discovering a defect is wasted i f the defect is never
repaired. It is certainly the task of QA to ensure that qual ity is present, and th is includes ensuri ng appropri ate
action on defects .
Testers need enough imagination to th i nk of many di fferent ways of using the applicatio n . They need to
"think outside the box" because defects are usually found in execution paths that are not obvi ous. For example,
in testing the Open Office word processor, a good tester would pursue sequences very di fferent from the run ­
of- the-mill open file/edit/save sequence. A more demanding sequence is open file/add jQ lines/set some lines to various

heading levels/save in location 1Iset some lines to various bullets/save in location 2/retrieve.
Good testers are curious . They are required to wonder about the limits of the application, repeatedly aski ng
?" An example is "What i f I were to load a non-OpenOffice document, and then . . ?"
"What i f I were to .
Testers need to be meticulous i n that they must keep careful records of the steps fol lowed to discover a
defect, and gather detailed i n formation to include in bug reports .
.

.

TESTING SHORTLY BEFORE RELEASE

28.4 TESTING SHORTLY BEFORE RELEASE
Every project has a history of testi ng lasting almost as long as the proj ect i tself. However, the period j ust prior
to releasing the appl ication has special testi ng characteristics, which are described i n this secti o n .

28.4 . 1 Soak Testing
It is common to conduct soak testing near the end of the system testi ng phase . Duri n g soak testing the
appl icati on is executed in an environment that simulates as closely as possible the way a typical customer will
use the system under normal load. The soak test is conducted for an extended period o f time-for exam ple,
two weeks . Test scri pts are used so that the testing can continue for the entire duration without interrupti o n .
The purpose is to uncover problems such as mem ory leaks a n d timing-related i ssues that o n l y man ifest
themselves after the system is run for a substantial period of time. The goal of soak testing is to reduce, as
much as possible, i n i tial customer complai nts about probl ems-not necessarily serious but annoying ones­
encountered when they exercise the appl ication in a manner not exercised before . Ideally, soak tests are run
by commi tted customers, otherwise by QA.

28.4.2 Acceptance Testing
In princi ple, the customer contracts with the developer to bui ld an appl icatio n . At some point, the developer
clai ms to have fulnlled his or her part o f the contract, the customer val idates this, and then pays for the
appl icatio n i f sati sned. The customer performs th is val i dati on by means o f acceptance tests. I n princi ple, these are
most important for all concerned. Acceptance tests can be executed by the customer, or by the development
organization-i n some sort of clearly demonstrable manner-on behal f o f the customer. Acceptance tests are
typ ically driven by the SRS . A subset of the system tests is selected that val i date major functional
requirements and selected nonfunctional requirements .
It is a real i ty of software development that del ivered appl ications contain defects . If a contract were to
state that software will not be paid for if a defect is found, very few companies would risk developing software.
Defects there fore have to be factored i n to contracts . There are several ways to deal with thi s , mostly legal in
nature , that relieve the development organ ization of a degree of responsibil ity.
Recall that so ftware can meet all i ts requirements yet not meet the needs o f the customer. Contracts
attempt to navigate the gap between customers, who want appl ications that are satisfactory to them (written
or not) , and devel opers, who need to work with well-denned ends. Acceptance testi ng is planned and
conducte d accordi ngly. Metrics for acceptance testi ng are a subset o f those covered so far i n this chapter, by
mutual agreement between the customer and developer, made in advance .

28.4 . 3 Alpha and Beta Releases
Th is section concerns applicati ons intended for use by a large number of people. A software product version is
released when i t is officially turned over to customers . Th is usually takes place di rectly after acceptance tests .
Qual ined releases may take place prior to the final release. [n many cases, internal prospective users, as well as
customers, are wi lling to participate in the system testi ng process . This process is controlled by alpha releases
and beta releases, as di fferenti ated by Figure 28 . 1 6.
Alpha releases are given to i n-house users or to a highly selective and trusted group o f external users for
early prerelease use . The purpose of alpha releases is to provi de the development organization feedback
and de fect i n formati o n from a group l arger than the testers, wi thout a ffecti ng the reputation of the
unreleased product. Following the dissem i n ati o n of alpha releases, beta releases are given out. These are

713

714

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

In-house and highly trusted users
•

•

•

•

Multip lies testin g
Previews customer reaction
Benefits third-party developers
Forestalls competi tion

Selected customers
Beta

•

Multiplies testing activity
Obtains customer reaction

Figure 28.16 Alpha a n d beta releases

given to part of the customer community with the understanding that they report defects found. Alpha and
beta releases are also used to convi nce potential customers that there really is a product beh i n d the
vendor's promises.
A pri ncipal motivatio n to be alpha testers and beta testers is to gai n advance knowledge o f the product .
Developers can gain i n formati on about the appl icatio n ( typically its APls) so that they can begi n to develop
applications that use it. Users can begin to form decisions about purchasing the applicatio n or gain
experience using it.
Metrics for alpha and beta testin g i nclude the metrics mentioned so far i n this chapter, i n pri nci ple.
Alpha and beta testing are generally not focused on particular attributes . Their products are bug reports,
which are generally categorized. Metrics i nclude most of those already mentioned in this chapter, as well as
those with a simpler categorizati on such as the following:
•

Number of major defects detected with i n the fi rst x days/weeks/months

•

Number of non-major defects detected with i n the fi rst x days/weeks/mo nths

28.5 CASE STUDY: ENCOUNTER SOFTWARE TEST DOCUMENTATION1

Note to the Stude nt:
Th is document describes the overall testing
o f Encoun ter The document uses the IEEE
Stan dard 829- 1 998 S o ftware Test Docum e n ­
tation ( STD) headings (introduction, test plan,

great deal si nce it im proves their abi l i ty to
make appl icati ons more rel iable.

History of versions o f this document:

test design, test cases, test procedures, test item trans­
mittal report, test log, test incident report, test sum­
mary) and re fers to the vari ous particular tests
( i n tegrati on tests , system tests, acceptance
tests, etc . ) . Th ese , i n turn , are described us i n g
t h e s a m e I E E E S T D headi ngs . Those i nvolved
in testing apprec i ate the documentation a

1 1 / 1 /98 E. Braude: I n i tial Draft
4/4/99 E. Braude : Revised
8/23/99 R. Bostwick: D ocuments reviewed and
recommendations made
I

Reproduced with permission.

CASE STUDY: ENCOUNTER SOFTWARE TEST DOCUMENTATION

8/24/1999

E.

Braude:

Recommendations

integrated
Status: to be completed

game. IEEE standard 829-1998 for Software Testing
Documentation is used at every level of testing.
The test philosophy for the Encounter video
game is summarized in Figures 28.17 and 28.18.

1 . Introduction
This document con tains the STD for Encounter and
its role-playing game ( RPG) framework . The catego­
ries of testing addressed in this document include unit,
integration , sys tem, acceptance, and installation test­
ing. This document describes the testing required to
val idate the first three builds of the Encounter video

Although the SOD is not explicitly a require­
ments document, it effectively imposes require­
ments on the implemen tation. Sometimes these
requirements are spelled out in a separate doc­
ument. The case study in this book does not
contain such a separate document.

Test Type

Approach

Correspo nding document sections

Unit

White and black box; method and
class tests; test agai nst detailed
requirements and design.

SRS secti o n ( s ): 3.2 Classes/Objects
SOD sectio n ( s): 6. Detailed design

Integration

System

Gray box; mostly package-level;
oriented to builds (I, 2, and 3);
test against architecture and
high-level requirements .

Black box; all packages; whole
system ( Build 3); test against
nonfuncti onal requirements, ar­
chitecture and high-level
requirements.

SRS sectio n ( s ): 2. Overall description, 3 1
Extemal interfaces, vali date represen tative re­
quirements in 3.2 Classes/Objects
SOD secti on( s): 3. Decomposition description, 4 .
Dependency description, 5 Interface description.
SRS secti o n ( s ): 2. Overall description, 3.1
Extemal interfaces, validate representative re­
quireme nts in 3.2 Classes/Objects, 3 3 Per­
formance requirements, 3.4 Design constraints, 3.5
Software system attributes, 3.6 Other requirements
SOD section(s): 3 Decomposition description, 4.
Dependency description, 5 Interface description;
validate represen tative requirements in 6.
Detailed design.

Figure 28.17 Approaches to system test and their documentation, 1 of 2

Acceptance

Black box; all packages; whole system ( Build 3); test
agai nst hi gh-level requirements and detailed
requirements.

SRS sectio n ( s): 2. Overall
description, 3.2 Classes/
Objects

Installation

Black box; all packages; whole system ( Builds for
customer specific configuratio ns); test against high­
level requirements and detailed requirements .

SRS secti o n ( s ): 2. Overall
description, 3.2 Classes/
Objects

Figure 28.18 Approaches to system test and their documentation, 2 of 2

715

716

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

2. Encounter Video Game Test
Documentation
The STD for Encounter and the RPG framework covers
test planning, specification, and reporting. There are
separate test plans for unit, integration, system, accep­
tance, and installation testing. Each test plan references
its test design, test case, and test procedure speci fica­
tions.The test reporting documentation consists of the
test log, incident report, and summary report.
2.1 Unit Test STD

Refer to the separate unit test document.

2.2.1.1.3 Test Items

The classes and methods i n
the GameCharacters a n d EncounterCharacters packages
are tested through the EncounterCast singleto n .

2.2.1.1.4 Features to B e Tested

The features
tested by the test design speci fication Bui ld 1 _TO are
based on the requirements within the SRS and SOD ,
as listed in Figure 28.20.

2.2.1.1.5 Features Not to Be Tested

See the case study in Chapter 27

2.2 Integration Test STD

The STD for integration testing consists of the
separate STDs for build 1 , build 2, and build 3, as
described next. Re fer to Appendix A in the SCMP for
an explanatio n of the constructio n of the build
integration baselines. Tests will be i dentified accord­
ing to the conventions shown in Figure 28 . 1 9.

2.2.1 Build 1 sro

I nevi tably, infinitely many poi nts simply can't
be tested for, but iden ti fying particular issues
that will not be tested for sometimes helps to
clari fy the testi ng process .

The testing of the features associated with the

EncounterEnvironment and EncounterGame packages and
their frameworks i s deferred until the build 1 and
build 2 integration testi ng.
2.2.1.1.6 Approach

2.2.1.1 Build 1 Test Plan
2.2.1.1.1 Test Plan Identifier

package and the EncounterCharacters package . It de­
scribes how to verify that the player and fore ign
characters can be retrieved, modified, and displayed
through the singleton EncounterCast obj ect.

Buil d 1 _TP

2.2.1.1.2 Introduction

This test plan covers the
integration test for the GameCharacters framework

The approach to the verifica­
tion of build 1 consists of veri fying that the characters
of the game can be retrieved and displayed through
the singleton E ncounterCast object. The method and
i nterface tests verify that the required ( public) inter­
face methods of the Encounter Characters package are
available from the EncounterCast singleto n .

Test Document Identifier
Test Document

Document Identifier

Buil d 1 Test Plan
Build 1 Test Design Speci fication
Build 1 Test Case Speci fications
Build 1 Test Procedure Speci fications
Build 1 Test Logs
Build 1 Test I ncident Report
Build 1 Test Summary Report

BuildLTP
BuildLTD
Build 1 _TCltoBuild 1 _TC . . .
BuildLTPltoBuil d 1 _TP ..
Buil d 1 _LOG 1 to Build 1 _LOG .
Build 1 _l n Rep 1 to BuilcMJnRep . . .
Bui l d 1 _SumRep 1 to BuildiSumRep .

Figure 28.19 Test document file identification

.

CASE STUDY: ENCOUNTER SOFTWARE TEST DOCUMENTATION

Document

Section

Requirement Title

qual i ty values

Encounter characters
3,2,FC

characters
Player characters

SOD for RPG tr"lmp'w()'rl<

SOD for E ncounter

5.0

I nterface description

3 . 1 .2

E ncounterCharacters package

4,2

Interprocess dependencies
to the EncounterCharacters package

Figure 28.20 Features to be tested in build 1

2.2.1.1.7 Item Pass/Fail Criteria

Pass/fail crite­
ria are based upon satisfyi ng the corresponding
requirements i n the SRS and SOD .

2.2.1.1.8 suspension Criteria and Resumption

Requirements

(NIA)

Deliverables The documents
listed in Figure 28.19 are to be delivered to the
con fi guratio n management group at the completion
of the build 1 integration test.

2.2.1.1.11 Environment

Needs Depending
upon equipment availability , either an IBM PC,
Sun SPARC workstation, or an Apple iMAC hard­
ware configuratio n can be used. The Eclipse Inte­
grated Development Environment ( IDE) should be
used for the build 1 testing.

2.2.1.1.9 Test

2.2.1.1.10 Testing Tasks

The testing tasks con ­

sist o f the followin g steps:
1. Load bui l d 1 and the package Build_I.
2. Execute buil d 1 test procedures from the mainO
method of Build_1Test i n package Build_I.
3. Write test report documentation in accordance
with Section 2.2. 1 . 1 . 9 .
4 . Store a l l test documentation a n d data i n accord­
ance with Section 2.2. 1 .1.9 under con fi guration
management.

2.2.1.1.12 Responsibilities

Sally Silver and Jose
Hernandes from the SQA group are responsible for
managing, preparing, and executing the buil d 1 i nte­
gration test. In addition, the E ncounter development
group addresses technical questions and responds to
test i ncident reports . Configuration control stores all
test documentation and data.
2.2.1.1.13 Staffing and Training Needs

The
SPMP speci fies the overall staffing and training needs
for integration testing.

2.2.1.1.14 Schedule

The schedule for integra­
tion testing is i ncluded in the SPMP section 5.5
version 5 and higher. ( Sectio n 1 9 .6 discusses the

717

718

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

updating of the SPMP to reflect the architecture
selected. )

2.2.1.2.3 Approach Refinements
2.2.1.3.2 Test Items The functionality to be
tested is conta i ned i n the specifications for the
followin g public methods of EncounterCast.

The case studies in this book do not i nclude
the updated SPMP.

EncounterCast getTheEncounterCast()
GameCharacter getThePlayerCharacter()

2.2.1.1.15 Risks and Contingencies

If the SQA
team is unable to execute tests, or the number of defects
causes an unacceptable number of system failures, then
Alfred Murray of the Encounter development team will
be assigned to the build 1 integration test.

void setPlayerCharacterOuality(Stdng quality,float value)

2.2.1.1.16 Approvals

float getPlayerCharacterOuality()

GameCharacter getTheForeignCharacter()

void setForeignCharacterOuality(String quality, float
value)

The completion of this test
requires the approval of the SQA Manager, the Encoun­
ter Development Manager, and the CCB Representative .

float getForeignCharacterOuality()

2.2.1.2 Build 1 Test Design

These are tested in accordance with Fig­
ure 28.21.

2.2.1.2.1 Test Design Specification

2.2.1.3.3 Input Specifications: see Figure 28.21

Identifier

2.2.1.3.4 Output Specifications: see

2.2.1.2.2 Features to Be Tested

The test for
build 1 will get the EncounterCast object and the player
and foreign characters, change the values of various
qualities, get these values, and then veri fy their
correctness.

Figure 28.21
2.2.1.3.5 Environmental Needs

This testing i s
performed with t h e GameCharacters a n d EncounterChar­
acters packages alone.

�

Player
input
value

Foreign
input
value

BioI

N/A

N/A

N/A

Get player
character

Verify by name

BI.2

N/A

N/A

N/A

Get foreign
character

Verify by name

81.3

Concentration

30

40

N/A

Verify output values
input values

BI.4

Stamina

30

40

N/A

Verify output values
input values

Other

Action

Integration
Test #

.....

BI.5
Figure 28.21 Integration test inputs, outputs, and actions

==

==

CASE STUDY: ENCOUNTER SOFTWARE TEST DOCUMENTATION

2.2.1.3.6 Special

Procedural

2.2.1.4.4 Procedure

Steps Populate the file
Buildl_tesCdata with i nput data and expected out­
put values for the qual ities in the following format.

Requirements:

None
2.2.1.3.7 Interface Dependencies: None

<qual ity name> <in put><expected output>
<qual ity name> <i nput><expected output>

This section describes the relationships among
the various in terfaces. This becomes signifi­
cant for future buil ds, but is not an issue for
build 1

There is no additional begi nning or endi ng text.
2.2.1.5 Build 1 Test Item Transmittal

Report

2.2.1.4 Build 1 Test Procedures

... ..

.

2.2.1.6.3 Activity and Event Entries

2.2.1.4.1 Test Procedure Specification

Identifier

The "defect reference" is the number used by
the defect tracking system for this defect .

This identifies the class/method from which
the test is executed.

2.2.1.7 Build 1 Test Incident Report

Integration_Tests/Build t_Test i n package Tests

2.2.1.7.1 Test Incident Report

Identifier

2.2.1.4.2 Purpose

Build t_test3

To set up a test of buil d 1 with
a minimum of other parts of the appl icati o n .

2.2.1.7.2 Summary

2.2.1.4.3 Special Requirements

2.2.1.7.3 Incident Description

The test har­
ness i n Integration Tests/Buildl_Test, consisting of
a cl ass with a single method, main(], is to be con ­
structed, and tests t, 2,3, .. . are to be executed and
the resul ts compared.

Ed Blake was dis­
tracted duri ng the execution of test 3 by an al arm i n
the buildi ng, a n d could n o t record the results . It was
decided not to interrupt or repeat the test sequence,
and to con duct test 3 as part of the testing for bui ld 2.

Defect reference

Result
Build 1 Test Log

Test #

Passed

N/A

:2

Failed

1823

3

Data lost - To be repeated

N/A

4

Lost of preci sion in returned value

2872

5

Figure 28.22 Build 1 test log (summary)

see Figure 28.22.

719

720

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

2.2.1.7.4 Impact

It was decided that the incident(s)
reported above were not serious enough to require a
repetition of th is test.

displayed through the EncounterEnvironment object,
and that the con nections among them are consistent
with the SRS.

2.2.1.8 Build 1 Test Summary Report

Identifier

2.2.2.2 Build 2 Test Design These tests first will
verify that the correct EncounterEnvironment object can
be obtai ned, and then will show that the Area objects
and Area Connection objects can be retrieved as required.

2.2.1.8.2 Summary

2.2.2.3 Build 2 Test Case

2.2.1.8.1 Test Summary Report

The build 1 test passed with
the exception of the defects noted. This will be
handled by the regul ar defect repair process .

2.2.1.8.3 variances

The functional ity to
be tested is contai ned in the foll owi ng public func­
tions of EncounterEnvironment.

See build 1 test incident report.

GameArea getTheDressingRoom()
GameArea getTheDungeon()

2.2.1.8.4 Comprehensive Assessment

EncounterEnvironment getTheEncounterEnvironment()

Additional rem arks supplying details can be
placed here.

2.2.2.4 Build 2 Test Procedures: To be

supplied

2.2.1.8.5 Summary of Results

2.2.2 Build 2 STD
2.3 System Test STD

This format is similar to the format in the build
1 STD
2.2.2.1 Build 2 Test Plan

These tests will veri fy
that the areas of the game can be retrieved and

2.3.1 System Test Plan
These tests are performed against the architecture, as
described i n Figure 28.23.
The tests verify that the effects of game actions
i n EncounterGame correctly mani fest themselves as
EncounterGame

EncounterCharacters

I

EncounterCast
((facade"

EncounterGame
"facade»

I

EncounterEnvironment

I

I

I

I

I

l

EncounterEnvironment
((facade»

Figure 28.23 Architecture and modularization for Encounter video game

I
I

CASE STUDY: ENCOUNTER SOFTWARE TEST DOCUMENTATION

movements of
environment .

Encounter characters within the

The integration tests verify that the require·
ments of Encounter as stated in the SRS, have
been satisfied.

2.3.2 System Test Design
These system tests are designed to verify the
archi tecture by executi ng and verifying se­
quences of i nterface methods.

The acceptance tests are stored in the Accept­

anceTest package , and include the use cases.
The Initialize use case is shown in Figure 28.24
and is executed by the main() method of the class
Initial ize in the AcceptanceTest package .
The Encounter Foreign Character use case is shown
in Figure 28.25 and is executed by the main() method
o f the cl ass AcceptanceTest.Initialize.

2.3.3 System Test Cases
System Test 1
1 . Move pl ayer character into dungeon.

2. Move foreign character into courtyard.
2.4.2 Acceptance Test Design

3. Move foreign character into dungeon.

The use cases indicated in Section 2.4.1 are to be
executed in sequence several times, in accordance
with the test cases in Section 2.4.3.

4. Execute an encounter in the dungeon.
System Test 2

2.4.3 Acceptance Test Cases
2.3.4 System Test Procedures

2.4.3.1 Test Cases for Initialize Use Case

2.4 Acceptance Test STD

The tests are instances of the Initial ize use
case, also known as "scenarios."

2.4.1 Acceptance Test Plan

[EncounterGame

I

User

I

J

main player

:Player

dressing

character:

quality

room:

Player Character

window

Area

1b. «create,)

,
:
,,

1a*. (Ccreate»

,,,

!

y

2. «create),

�

I
3a. enter quality value

I

.

3b. setQualityO

II

4. select eXit for character
5. moveO
•

Numbering keyed to use case

Figure 28.24 Sequence diagram for Initialize use case in Encounter

I

,,
,,

l

721

722

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

I

:Encounter
game

I

:Encounter
Cast

I

freddie:
Foreign
Character

engagement:
Engagement

1.1 displayForeignCharO

: Player's
main
character

1.2 displayO
1.3 «create»
2. executeO

I

2.1 setPlryerQualityO
2.2 setQualityO

:Engagement
Display

I

2.3 setForeignQualityO
2.4 setQualityO
I

3.1 «create»
3.2 displayResultO

I

U

Figure 28.25 Sequence diagram for Encounter Foreign Character use case in Encounter

2.4.3.1.1 Initialize Acceptance Test 1

2.4.3.1.4 Initialize Acceptance Test 4 .

1 . Start up game .

2.4.3.2 Test Cases for Encounter Foreign

2 . Supply main character with the fol lowing qual­
ity values, in the order shown:
Strength: 30, then Concentration: 2 0 .

Character Use Case

3 . Move t h e main character to t h e courtyard.
2.4.3.1.2 Initialize Acceptance Test 2

2.4.3.2.1 Encounter Foreign Character Accep­

tance Test 1

1 . Set the main character's "patience" value to 3 0 .
2 . Set t h e foreign character's "patience" value to 2 0 .

1 . Start up game.

3. Move t h e main character to t h e drawing room.

2. Supply main character with the fol lowing qual­
ity values, i n the order shown:
Strength : 30, Concentration: 20, and
Patience: 30.

5. Verify that an engagement has taken place .

3 . Move the main character to the courtyard.

6. Observe the engagement window showing the

2.4.3.1.3 Initialize Acceptance Test 3

1 . S tart up game.
2. Supply main character with the following qual­
ity values, in the order shown:
Strength: 30 and Concentration: 20
3. Move the main character to the dungeon.

4. Cause the foreign ch aracter to enter the drawing
room.

results.
(The player's patience value should be 40, and
the foreign character's 1 0 .)
2.4.3.2.2 Encounter Foreign Character Accep­

tance Test 2

1 . Set the main character's "strength" value to 3 0 .

CASE STUDY: ECLIPSE

2 . Set the foreign character's "strength" value to 2 0 .
3 . Move t h e main character to t h e dungeon.

The i nstallation tests shall consist of the accep­
tance tests conducted on all of the above platforms.

4 . Cause the foreign character to enter the dungeon.

5. Verify that an engagement has taken place.
6. Observe the engagement window showi ng the
results.
(The player's strength value should be 40, and
the foreign character's to.)
2.4.3.2.3 Encounter Foreign Character Accep­

tance Test 3
2.4.4 Acceptance Test Procedures

Acceptance tests shall be carried out with two desig­
nated representatives of the customer present. These
representatives shal l carry out all testing with the
assistance of the vendor. Whenever possible, events
shoul d occur as a result of the random processes of the
game i nstead of being stimulated. An example of this is
the arrival of the foreign character in an area. A log of
all tests shall be maintained by the customer repre ­
sentatives and signed by all parties; any signatory can
enter dissenting statements in the log.
2.5 Installation Test STD

These are tests verifying that the application
executes correctly in its required hardware and
operating system environments.

The i nstallation tests for Encounter consist of
executi ng the system tests on the following hardware
configurations.
1. I BM-compatibl e PC with at l east 32 megabytes
of RAM and 1 00 megabytes of disk space.
2. SUN SPARC model mmm with at least 3 2
megabytes o f RAM and 100 megabytes o f disk
space .
3 . Apple iMAC model 1 2 3 4 or l ater with 3 2 mega­
bytes of RAM and 1 00 megabytes of disk space .

28.6

CASE STUDY: ECLIPSE

We continue to use Ecl i pse for a case study, as in past
chapters. There are many systems for automating
tests; and to appreciate the kind of capabilities that
they provide, we focus on the Ecl ipse Test and
Performance Tools Platform (TPTP) . The fol lowing
is quoted and adapted from the online documenta­
tion for TPTP [6] .
TPTP i s a suite of "test, trace and monitoring
tools." It addresses the "test and performance l i fe
cycle, from early testing to production application
monitoring, i ncluding test editing and execution,
monitoring, tracing and pro fi l i ng, and log analysis
capabilities." TPTP addresses many of the issues
discusses in this chapter, including the collection
of metrics.
The TPTP pro filing tool can be used to profile a
Web appl ication, including memory use and execu­
tion time (the two main performance metrics). The
size of the heap as the execution progresses is an
example. The profiling process allows the user to
select parameters as well as output formats such as
graphs.
TPTP can be used to record traffic at a Web
application . I n particular, it enables loops within
which a test engineer can embed a test, test parame­
ters varying from pass to pass. TPTP has bUilt-in
facil ities for making logs of the test results-for
example, a graphical output showing requests that
take the longest time.
Several "agents" can be set to monitor various
aspects of the execution . These can be thought of as
processes acting in parallel with the execution of the
application under scrutiny. Besides heap and stack
usage data , TPTP can be used to view the usage of
obj ects from various classes. It can account for all of
the objects of a class that come into being during
execution, allowing a trace i nto the execution . This
can be displayed in the form of parts of a sequence
diagram. For example, i t may happen that so many
instances of the String class exist at runtime that the
application's performance is compromised.

723

724

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

The key to many analyses is the i dentification
of unusual parts, such as a use of memory by a process
that exceeds by far those used by others.
TPTP provi des a means for programmers to
insert "fragments of Java code that can be invoked at
speci fied points in the Java class . . " This is called
instrumentation. It includes monitoring for "method
entry, method exit, catch/finally blocks, and class
loading. " With static instrumentation, probes are
inserted before execution. These have to be
removed-often by hand-before the application
can be deployed. This can introduce errors via
probes inadvertently left in the code . With dynamic
instrumentation, modified classes can be substituted
for unmodified ones at runtime . This avoi ds the
manual clean-up process, but the application must
be executed in a special mode to use it. Listing 28.2 is
example output from a class Order that has been
statically instrumented with method entry and exit
probes [7].

Method invocations can be compared, as in
Figure 28.26. In this example, displ ay parameters
have been chosen so as to avoid displaying methods
invoked a negligible number of times [7].
Method execution times can be displayed as i n
Figure 28.27.
TPTP includes the ability to generate test cases
and test procedures from higher-level descripti ons,
as well as the ability to record CU I interactions. In
other words, the application is executed and the user
interacts with CU Is. When the appl ication is exe­
cuted again in playback mode, the user's same CUI
actions are automatically performed.
Tests are often organized in hierarchies. For
example, to test a word processor, we would test
"child" tests for file handling capabilities, editing
capabilities, display capabilities, and others. The file
h andling tests break down into subsidi ary tests, and so
on. Managing tests within such hierarchies is a signi f­
icant challenge, and tools l ike TPTP facilitate this.

Listing 28.2: TPTP output trace of entry and exit of Order class
Entered: Order.main
Start
Entered: Order.<init>
Exited: Order.<init>
Entered: Order.placeOrder
Entered: Order.getSupplierList
Exited: Order.getSupplierList
Entered: Order.connectWithSupplier
Exited: Order.connectWithSupplier
Entered: Order.sendOrder
Entered: Order.constructOrderForm
Entered: Order.checkProductAvailability
Exited: Order.checkProductAvailability
Exited: Order.constructOrderForm
Exception: Order.sendOrder ! Too many items requested.
Exited:Order.sendOrder
Exited:Order.placeOrder
Finish
Exited:Order.main

CASE STUDY: ECLIPSE

� Method Invocations
Method Invocations
17,000
18,000
15,000
14,000
13,000
'" 12,000
<:
0

11.000

� 10,000
0

.E

'0
Q;
.c

E
"
Z

g.OOO
9,000
7.000
4.000
5,000
4.000
3.000
2.000
1,000

Methods

Figure 28.26 A comparison of method invocations in Eclipse
Source: Eclipse Test and Performance Tools Platform Project, reproduced with permission,
http://www.eclipse.orgltptp/platformldocuments/probekitlprobekit.html.

Method Execution Time (in seconds)

Figure 28.27 Graphical comparison of method execution time in Eclipse
Source: Eclipse Test and Performance Tools Platform Project, reproduced with permission,
http://www.eclipse.orgltptp/platform/documents/probekitlprobekit.html.

725

726

CHAPTER 28

28.7

TESTING AT THE SYSTEM LEVEL

CASE STUDY: OPENOFFICE

Note to the Student:
QA for open source projects is characterized
by user involvement, as exempli fied in this
case study .

The OpenO ffice testing mission statement is at
http ://qa.openoffice . org/: 'To provi de an easy way
for volunteers to find, update and better define issues,
and to define test processes to val idate a build of the
Office Suite ."

2 8 .7 . 1 Open Contribution to Quality
Assurance
Much of this section is quoted or adapted from
http ://qa. openoffice . org/helping.htm l .
The latter "describes ways in which anybody can
help make OpenOffice.org better, even nondevelopers.
Our current focus is on confirming issues that are marked
with the flags 'unconfirmed' and 'defect.' Our goal is to
respond to new issues posted by users as soon as possible
as well as clear out the backlog of unconfirmed issues that
currently resides in the IssueZilla database .
H owever, we recognize that there is a lot more
to Quality Assurance ( QA) than just reviewing and
isolating issues. In the future, O penOffice .org (000)
QA will involve testing documentation and develop­
ing test software . If you are super enthusiastic, feel free
to start working on some basic demonstrations of test
cases, regression tests, QA speci fication documenta­
tion, or any other i dea you think would be valuable to
improving the qual ity of 000.

need review, it is positive progress that is essenti al to
keep this project moving forward."

2 8 . 7 . 2 Smoke Tests
Smoke tests are superficial tests checking that
ch anges to the basel ine have not resulted in
catastrophic errors. A smoke test is a reduced
regression test. " Install ation tests" here are not
full installation tests.

The following is quoted and edited from the
site given at [ 8 ] .
"Smoke Tests ( also called Shakedown tests)
validate a buil d of 000. These are not fully - fle dged
test cases, but we may use them to create test cases in
the future . Your i deas are welcome ." These consist of
the fol lowing, quoted from the reference.
Installation Tests . Install 000 in both stand­
alone and networked environments
File type Test . Test that 000 can open and
correctly display speci fied file types. Can open/
execute a Java applet (samples available) .
File Actions. Test that 000 can create and
save di fferent types of files. Can send mail using
an external mail program.
Insert Actions. Test that 000 can insert spec­

ified actions into a text document.
Edit Actions. Test that 000 edit actions func­

tion as specified with a text document. Test that
cut and paste integrate with external edi tors
and 000.
View Action s . Test that

It is indicative of the scale of OpenO ffice that
settl ing 1 00 issues a day (over 36,000 per year)
is consi dered "insigni ficant ."

000 view actions

function as specified.
Format Action s . Test that 000 format actions

function as specified.
Tools/Options. Test that 000 tools/options

Every little bit of contribution counts and is in­
valuable. For example, if we have 1 00 interested volun­
teers, and they all work on one issue per day, we would be
able to cover 1 00 issues per day. As insignificant as that
may seem when compared to the number of issues that

function correctly .
Print. Test that 000 prints a text document to
a default printer.
Help . Test 000 help contents and functions.

CASE STUDY: OPENOFFICE

2 8 . 7 . 3 OpenOffice QA Priorities
The procedure described here is designed to
ensure that the most i mportant issues are
worked on first. Its somewhat mechanical
form is necessary i n an open-source enviro n ­
m e n t si nce n o si ngle manager is making c o n ­
ti nual decisions.

Table 2 8 . 3 reRects the OpenOffice QA priorit­
ies (taken , with m i nor editing, from the source given
in [ 9 ] .
QA contributor procedures are given at the
source in [ 1 0] .

2 8 . 7 . 4 Automated Product Source Code QA
Th is section describes a test harness for exe­
cuting Open O ffice tests .

The following is quoted and adapted from [ 1 1 ] .
'The qadevOOo project provides a test harness to
execute test cases written i n different programming
languages, like OC+ + , java, Python, or Basic. These
test cases are responsible for vali dating the functionality
and reliability of specified APls. The test harness
(written in java) is responsible for setting up, running,
and controlling the test processes and threads ."
'The test harness a n d a nearly complete set of java
and Basic test cases for the OpenOffice .org API are at
[ 1 1 ] as well as the desired value set for the test runs and a
set of test documents used by the test cases."

2 8 . 7 . 5 Automated GUI Testing
"The automated CU I testing provides a test frame­
work with test scripts and an applicati o n (TestTool) to
test almost the whole office application automati ­
cally. The TestTool scripts are written i n BAS I C with
some additional functions especially for the o ffice.
The TestTool communicates via TCP/IP with the
o ffice applicatio n . " [ 8 ]

Table 28.3 Example of priorities in Open Office
Rank

Task

IssueZilia (IZ) Search Tips

1.

New issues posted for the current month or today.

Look at the " Untouched " issues linked at
http://qa.openoffice.org/issuelinks. html
Also try searching IZ with Issue Type set to
"Defect" and Status set to "Unconfirmed,"
where the field(s) is set to "[Issue Creation)" . . .

2.

Follow up on unconfirmed defect issues with the "oooqa"
keyword . Ideally, start with the oldest "oooqa" issues and
work your way to the m ost current. If the issue is older
than 3 weeks and the issue does not follow the guidelines
listed in the "How you can help? " page, leave a com m ent
to the user indicating you are closing the issue for now,
but if they can provide more information to help
reproduce the issue, they can reopen the issue at their
convenience.

Try searching IZ with only the following fields
set: Keywords set to "oooqa" . . . Limit the
search to a particular time frame . . . .

3.

Close out issues reported against versions of 000 that
are no longer current.

Try searching IZ with Issue type set to "Defect,"
Status set to "Unconfirmed," and the
Component and Version fields set to your choice.

Do a quick check to see whether the issue is verifable. If
the issue cannot be verified, send a message to the user
to see whether upgrading to the latest version of
OpenOffice.org resolves the issue. If upgrading to the
latest version resolves the problem, close the issue. If
the upgrade does not resolve the problem follow the
000 QA "How you can help?" guidelines.

727

728

CHAPTER 28

TESTING AT THE SYSTEM LEVEL

2 8 . 8 SUMMARY
Once integration testing is completed, the application as a whole is tested. This is known as system testing.
System tests are black box tests that validate that the application meets its stated requirements . Both
functional and nonfunctional requirements are tested.
Applications are frequently distributed in-house for testing (alpha testing) and to participating
customers to try out with a clear understanding of its status as undergoing final testing. The latter is called
beta testing.
Acceptance tests are executed by the customer after system tests are successfully completed. Their
purpose is to demonstrate to the customer that the application runs satisfactorily on its target hardware and in
its intended software environment, such as the operating system. Acceptance tests are usually a subset of the
system tests .
Many real-world applications have incomplete or even nonexistent requirements documents . Testing in
the absence of well-written requirements requires the tester to obtain a sense of how the application behaves
and how it is meant to behave . This is called behavioral modeling. An approach to testing in this situation is to
start from what appears best to be a beginning point o f the application, and then keep track of the functional
paths from there. Directed graphs are used to document these paths. Tests are devised to execute a set of
paths that attain a kind of coverage.
In order to be e ffective at finding defects, a good so ftware tester must be determined, dogged, fearless,
imaginative, curious, meticulous, and must think "outside the box." The tester's goal is to discover defects that
can manifest when an application is used for a significant time by users, perhaps in unanticipated ways .

2 8 . 9 EXERCISES
Answer the fol lowing exercises in your own words .
1 . Why are black box tests (rather than white box tests) used in system testing?
2. What is the purpose of acceptance testing and why is it necessary? Cive an example of an
application and a defect that coul d go undetected in system testing yet be caught by acceptance
testing.
3 . A company is developing an application, and thinks it has discovered a novel way to speed up its
testing cycle. It decides to dispense with system testing, and instead deliver the application to
customers just after integration testing is completed. The company will therefore rely on its
customers to discover problems in the application. What are the advantages and disadvantages of
this approach? Be specific and explain your answer .
4. What is the purpose of soak testing? Cive an example of a defect this type of testing is likely to
uncover.
5. Load and stress testing is often conducted on individual units during unit and integration testing. In

this testing, units are subj ected to high levels of stress to ensure that they do not exhibit any
problems . Why is it necessary to conduct system-level stress tests even if all of the unit stress tests
are successful ?
6. Describe the various l evels of testing to which you would subject the application described in
Exercise 7 in Chapter 2 7 . Indicate which of the classes and packages (shown in the figure) would be

BIBLIOGRAPHY

i nvolved i n each . (Many more classes will be i nvolved i n bUilding the complete appl icati on, but
you are not required to show these . )
7 . For each o f the black box tester qualities l isted i n Section 2 8 . 3 . 6 , give a n example o f how that
quality could be counterproductive i f taken to an extreme .

BIBLIOGRAPHY
1 . Kit, Edward, Software Testing in the Real World, Improving the Process, Addison-Wesley, 1 99 5 .
2 . Purdue Usability Testing Questionnaire, http)loldwww.acm.org/perlman/question . cgi.form = PUTQ [accessed 1 2/ 1 510 9 ] .
3 . Herzog, Peter, OSSTMM - O p e n Source Security Testing Methodology Manual http)lwww. isecom . orgiprojects/osstm m . shtml
[accessed 1 2/ 1 5/0 9 ] .
4.

Srinivasan Desikan, a n d Gopalaswamy Ramesh. Software Testi ng, Principles and Practices, Pearson Education, 2006.

5 . Kaner, Cern, Jack Falk, and Hung Quoc Nguyen, Testing Computer Software, John Wiley & Sons, 1 999.

6 . Eclipse Test & P erformance Tools Platform Project. http )lwww.eclipse.org/tptp/ [accessed 1 1 / 1 1 /2009] .
7.

Eclipse Test & Performance Tools Platform Project. http )lwww . eclipse. org/tptp/platform/documents/probekitiprobekit.html
[accessed 1 1 / 1 1 /2009] .

8.

OpenOffice Project. "Shakedown Test Suite." http)lqa. openoffice.org/testcase/i ndex.html [accessed 1 1 / 1 1 /2009 ] .

9 . OpenOffice Project, "000 QA Issue Review Priorities." http)lqa. openoffice. org/priorities . h tml [accessed 1 1 / 1 1 /2009] .
1 0 . OpenOffice Project. " A Quick Start Guide to contributing to this project." http)lqa. openoffice. org/wwwstaging/tasks/quickstart.
html [accessed 1 1 / 1 1 /2009 ] .
1 1 . OpenOffice Project. "Automated product source code QA. " http)lqa. openoffice.org/qadevOOo_dodindex.html [accessed 1 2/ 1 5/09] .

729

Softwa re Mai ntena nce

Planning
� Maintenance
Testing

The Software
Development
Lifecycle

What are the differences between
corrective, adaptive, perfective, and
preventative maintenance?
What are some management challenges in

Requirements
analysis

/

Implementation

�

\

What are the units of software
maintenance?

DeSign

maintenance? Process challenges?
What are the main technical issues?
What is the maintenance process?
How do patches work?
What standards are there for software
maintenance?
What is reverse engineering?
Reengineering?
What maintenance metrics are available?

Figure 29.1 The context and learning goals for this chapter

Software systems continue to evolve after their initial release . The maintenance of a software system
consists of those activities performed upon it after it is released. The IEEE glossary [ 1 ] defines so ftware
maintenance as follows:

TYPES OF SOFTWARE MAINTENANCE

The process of modifying a software system or component after delivery to correct faults, improve performance or other
attributes, or adapt to a changed environment.
Maintenance is an activity of truly significant proportions, consuming an estimated 40 to 90 percent of
the tota l l i fe cycle costs of applications (see, for example [ 2 ] and [ 3 ] ) . Perhaps the most famous maintenance
effort i nvolved the year 2000 (Y2K) problem, for which massive work was performed modifying applications
to handle the years of the new millennium . This was mai ntenance because it ensured that applications already
delivered conti nued to provi de their intended functionality .
A s software systems evolve over t i m e , they require conti nuous maintenance in order to remain useful .
Lehman ( [ 4 ] and [5]) claims the existence of several l aws of software evolution borne out by extensive
experience. The first, continuing change, states that if a program is not continually adapted to ongoing needs, it
becomes less and less useful over time . According to the second law, increasing complexity, as a program is
changed over time, its com plexity increases unless work is done speci fically to alleviate thi s . An example is a
maintenance action that increases coupling between modules. Lehman's two laws are related. As so ftware
evolves, it is modified by engineers who may be competent to make each change but m ay not completely
understand the overall design and implementation . This is not surprising, given the sheer magnitude and
complexity of many applications. As a result, the application's structure and mai ntai nability decli n e . It is for
these and other reasons that software maintenance of several varieties is necessary.
The addition of new features and functionality to an application is really a kind of development­
typically of the application's next release . Nevertheless, the process is sometimes included in the "mainte ­
nance" rubric, especially when the new features are very much in the spirit of the appl ication's curren t
functionality and when they are small b y comparison. This type of mai ntenance is explained i n t h i s chapter.
I n many ways, agile proj ects can be viewed as being i n "maintenance" mode from the begi n ning. This is
because agility rel ies on addi ng to a code base-a process that has much i n common with mai ntenance .

2 9 . 1 TYPES OF SOFTWARE MAINTE NANCE
This sectio n i ntroduces the unit of maintenance. It also names and describes various types of mai ntenance
activities.

29 . 1 . 1 Maintenance Requests
Maintenance organizations manage their work by i dentifying tasks . Ideally, these should be of comparable
magnitude ( i m agine the inappropriateness of a list of chores that i ncludes "buy bananas" and also "build
house") . Each such unit of mai ntenance is called a Maintenance Request (MR) i n IEEE terminology . We try to size
MRs to be of a regul ar magnitude , but the amount of code needed for each can vary and the impact can vary as
wel l . A physically small code change may have a maj or effect on an appl icati on. One way to keep MRs at
comparable effort is to decompose them into child MRs .
An MR is either a repair or an enhancement. I t is a repair when it concerns a defect relative to t h e existi ng
requirements. An enhancement M R is one of two types. The first introduces a feature not called for i n the
requirements at delivery time; the second type of enhancement changes the design or implementation, while
keeping the functionality unch anged. This is known as refactori ng, as introduced i n Chapter 24. Refactori ng
usually improves the design i n order to reduce complexity and i ncrease efficiency, and it is a response to
Lehman's second law of i ncreas ing complexity. Figure 2 9 . 2 summarizes these distinctions.
A common categorization of M Rs is defined by Lieintz, Swanson, et al . [ 6 ] , [7], who refine these two
types of mai ntenance i nto two subcategories, as summarized in Figure 2 9 . 3 and explained in the rest of this
secti o n .

731

732

CHAPTER 29

•

Repair
•

•

SOFTWARE MAINTENANCE

Fixing defects
(rel ative to existi ng requirements)

Enhancement
•

•

New requirements
Change design or implementation
(no functional change )

Figure 29.2 Types o f maintenance

Repair

Enhance

I
I

Corrective
- defect identification and removal
Adaptive
- changes resulting from operating
system, hardware, or DBMS changes
Perfective
- changes resulting from user requests
Preventive
- changes made to the software to
m ake i t more maintainable

Figure 29.3 Types and subtypes of maintenance
Source: Lientz, Bennett P., E. Burton Swanson, and Gerry E. Tompkins, "Characteristics of Applications Software Maintenance," Communications of the ACM
(CACM), no. 2 1 , 1 978, p. 466-471 .

Main tenance Request 78

Problem : When the player changes the value of a quality, the computations are specified to keep the total
invariant, but they do not.
Example: I f the qualities are

strength
strength

=

=

1 0, patience

=

1 1, patience

0 . 8 , and endurance
0 and endurance

=

=

=

0 . 8 ( sum

=

11.6), and the player adjusts strength to 1 1 , the result is

O.

These d o not sum to 1 1 .6.
Figure 29.4 Example of corrective maintenance request

2 9 . 1 . 2 Corrective Maintenance
Corrective maintenance is concerned with the repair of defects relative to existi ng requirements. These
defects are typically discovered by customers as they use a software product. Each defect must be analyzed,
prioritized, and repaired, and fixes i ncorporated i nto new software revisions. As an exam ple defect, consider
the MR for the Encounter case study shown i n Figure 29.4 .
MR 78 requires the maintainer to determine the cause of the defect. One possibility is an error in the
code , such as in the method adjustQuali ty ( ) , which is responsible for adjusting qual ity values when one of
them is changed by the user. Another possibility here is that existi ng requirements for Encounter characters
are defective . Actually, the l atter is the case, because the requirements mandate the following:

TYPES OF SOFTWARE MAINTENANCE

•

The user shall be permitted to set any quality to any value less than or equal to the current sum of the
qualities.

•

The remaining qualities retain their mutual proportions.

•

No quality shall have a value both greater than zero and less than 0 . 5.

•

The sum of the qualities remains invariant.
As can be seen in the example in MR 78, these cannot all be satisfied. Since the defect is in the

requirements, it is the customer's prerogative to make or permit the change. One way to do this is to relax the
last requirement to the following.

I sum of qualities

-

0.5 * (N

-

1) I <

=

(sum of qualities)

'

=

> sum of qualities

where N is the number of qualities and x' is the value of x after the adjustment process
This modification keeps the effect of discouraging the player from changing quality values too much or
too many times because points may be lost whenever this is done.

29.1.3 Adaptive Maintenance
Adaptive maintenance is concerned with adapting the software to changes in the operating environment such
as a new operating system release or a new version of hardware. As software systems evolve, it is inevitable
that changes in their external environment will take place. An example is if we were to port our Encounter
video game case study to an iPhone. It may seem awkward to classify adaptive maintenance as a kind of repair,
but this is appropriate if one views an application as a living entity. In order to remain legitimate, the
application must adapt to reasonable changes in its environment .

29.1.4 Perfective Maintenance
Perfective maintenance is the development and implementation of user requests such as new feature
enhancements. Recall Lehman's first law-that systems must continually adapt to ongoing needs or become
less and less useful.
As an example of a perfective maintenance request, suppose that the marketing department has decided
that to make the Encounter video game more attractive and marketable, players require more tangible reward
for their skill. They want the entire look of the game to be enhanced whenever the player achieves a new
level. The art department will supply the corresponding graphics, and the maintenance organization is tasked
with a modification to accommodate this additional requirement, as stated in Figure 29. 5. A solution to this
MR is discussed later in this chapter.
Maintenance Request 162

Modify Encounter so that the game begins with areas and connections in a coordinated style. When the
player achieves level 2 status, all areas and connections are displayed in an enhanced coordinated style,
which is special to level 2. The art department will provide the required images.
Figure 29.5 Example of a perfective maintenance request

733

734

CHAPTER 29

SOFTWARE MAINTENANCE

29.1.5 Preventive Maintenance
Preventive maintenance consists of changing a software application in order to make it easier to maintain.
The need for preventive maintenance can be deduced from Lehman's second law. As a program evolves over
time, changes made through corrective, adaptive, and perfective maintenance requests cause the system to
become increasingly complex unless action is taken to prevent it. Preventive maintenance involves
proactively refactoring the system to reduce its complexity. It is always a good idea to perform preventive
maintenance on an ongoing basis.
An example of preventive maintenance is to recognize and anticipate industry trends. Suppose, for
example, that we sell a Windows-based word processor and that we recognize that word processors are likely
to migrate, in part, to the Web. A preventative maintenance action would be to alter the word processor's
architecture so that selected parts are more readily moveable to the Web.
Metrics can be used to identify areas that need improvement. For example, by examining defect metrics
it may be determined that a certain software module has a high number of defects reported against it . After
further investigation it may be determined that many of the defects are a result of changes made while prior
defects were repaired. This might lead to a conclusion that the design of that module is too complex, and thus
not easily modified. As a result, maintenance work may be performed to redesign the module to make it
simpler and more maintainable, without changing its functionality. Subsequently, we would expect fewer
defects to be filed against the refactored module .

29.2 ISSUES OF SOFTWARE MAINTENANCE
Software maintenance presents a unique set of challenges. Bennett [8] has categorized them as manage­
ment (what to do and who will do it), process (what procedures to follow), and technical (design and
implementation).

29.2.1 Management Challenges
Senior management tends to focus on delivering new products, which are a source of revenue (or cost
saving if internal) and provide a quantifiable return on investment. Funds spent on maintenance, however,
are usually not simple to justify. The cost of maintenance is high, and unless the maintenance organization
can charge for their services, the return on investment is much less clear than for delivering new products.
As a result, maintenance teams can often be understaffed and underfunded, making an already difficult job
even harder.
Sooner or later, the need for organized maintenance is recognized by management and resources are
allocated to it. Sometimes an individual or a group or is assigned to repair tasks and a separate group to
enhancements, incorporated in new updates or releases. As software moves from shrink-wrapped delivery and
big-bang integration to online delivery, continuous integration and security updates, the trend has been
toward more frequent version updates rather than major releases. The management of more frequent updates
is more demanding than that for major releases simply because the act of release is more frequent. This is
analogous to the difference between managing a daily newspaper and a monthly magazine.
The management of maintenance involves the assessment of benefits, the calculation of cost, and the
allocation of resources, mainly people. Table 29. 1 shows examples of costs. MRs are prioritized based on
analyses like this. However, maintenance requests are often worked on in groups since maintainers save time
by concentrating on related MRs.

ISSUES OF SOFTWARE MAINTENANCE

Table 29.1 Example of an estimate for implementing a maintenance request
Activity

Estimate
(person-days)

Activity

Estimate
(person-days)

1. Understand the problem and
identify the functions that must be
modified or added.

2-5

6. Compile and integrate into
baseline.

2-3

2. Design the changes.

1-4

7. Test functionality of

2-4

changes.
3. perform impact analysis.

1-4

8. Perform regression testing.

4. Implement changes in source
code.

1-4

9. Release new baseline and report

5. Change SRS, SDD, STP, and
configuration status.

2-6

2-4
1

results.
TOTAL

14-35

29.2.2 Process Challenges
Process issues-the procedures to be carried out-can also be a challenge. Extensive coordination is required
to handle the inAow of MRs. Typically, numerous maintenance requests Aow continually through the
organization. Some economy of scale can be achieved, reducing the cost of each change, but a stream of
maintenance changes places a significant burden on the process. Programmers, testers, and writers have to be
coordinated. To take an example, should the SRS be updated as soon as the customer indicates a Aaw in a
requirement, only after thorough testing, or only when grouped with other maintenance actions? Each of
these options leaves the documentation and source code in an inconsistent state for periods of time. Without
careful management, these supposedly short-lived inconsistencies can multiply and the documentation gets
out of control. The result is that it becomes difficult to know exactly what the application does.
If a single, focused change were the only one we had to handle, then our process problems would be
minor . However, source code changes in response to an MR typically cause a ripple effect in the design,
documentation, and test plans. An impact analysis (described in Section 20) determines the extent of the
ripple effect, and a cost analysis determines the cost of implementation. As an example of a cost analysis, let's
imagine that the Navy has informed us (a military contractor) that the algorithm for reconciling three
independent sources of shipboard navigation data is Aawed. An estimate is needed of the cost of making this
repair. Our calculations could be performed as shown in Table 29. 1, which shows that the cost of making this
change at $400-$800 per day of loaded labor (i.e., including benefits, etc.) is $5,600-$28,000.

29.2.3 Technical Issues
Maintenance can be thought of as a repetition of the development process but with a major additional
constraint: that existing required functionality of an existing code base is preserved. This impels us to
either add onto the existing design or to redesign the application. Maintenance actions that are repairs
usually result in staying with the current design. An exception to this is where the existing design itself is
a source of the problem. Adding to an existing design has the advantage of not perturbing what
already works but the potential disadvantage of creating an unacceptable overall design. Redesign has
the opposite advantages and disadvantages. The redesign-or-not decision differs from project to project
and MR to MR.

735

736

CHAPTER 29

SOFTWARE MAINTENANCE

As an example, suppose that we want to enhance the Encounter video game with the presence of several
monsters rather than just one. We would probably keep the current overall design and add to it because the
overall game remains the same in spirit and because the current architecture is capable of absorbing the
additional capability. On the other hand, if we are required to turn Encounter into a real-time 3D game in
which our character engages in various ways with the monster using weapons and they are able to pursue each
other within areas and from area to area, we would reexamine-and probably alter-the existing architecture.
This is because the combat aspects would dominate the existing state aspects.
Testing is a significant technical issue. Simply focusing tests on changed or added parts takes time enough
because special test plans must often be devised for this purpose. But focused testing is not enough. The
possibility of ripple effects requires that we execute extensive regression testing to ensure that changes have not
compromised the application's preexisting functionality . This is a major factor in the high cost of maintenance.

29.3 MAINTENANCE PROCESS
A maintenance process defines the flow of MRs through an organization. Figure 29.6 illustrates a typical
maintenance process in a large project, where the thicker lines indicate the nominal path. The additional
(thin-lined) paths show other ways in which MRs can be generated and retired.
In the process shown in Figure 29.6, customers provide comments on enhancements and defects
through the help desk. These are written up as MRs. Organizations have a limited number of resources to
work on MRs, meaning that some of the proposed enhancements and reported defects are either delayed
or never implemented. Maintenance engineers must therefore prioritize MRs. A triage process is often
employed [9] that includes the review of all proposed maintenance requests and the prioritization of their
importance to the business and to customers. Triage starts with an of ficial organizational unit, which may be

Marketing

nominal
path

Customer

�

Proposed

Maintenance
manager

MRs
Help desk

I
Approved

i��
��
Maintenance
engineer

MRs
Change control board

Current source

& documentation

....------------+1 Modified source
& documentation

Figure 29.6 A typical maintenance process for a large project
Source: Graphics reproduced with permission from Corel.

MAINTENANCE PROCESS

a single person or a committee, deciding which MRs will be implemented and assigning them a relative
priority. This unit is often referred to as a Change Control Board ( CCB) [10]. It consists of stakeholders,
selected from various organizations such as development, user documentation, marketing, quality assurance
(QA), and customer support. Each organization brings its own perspective, and collectively they decide on
MR priority.
The group conducts an impact analysis, which assesses the scope of the changes to the product's artifacts
that are necessary in order to implement the MR. Each group represented by the CCB provides input into the
impact analysis. Maintenance engineers prepare an estimate of how long it will take to implement the MR,
and its impact on the system, including code and system specifications. The user documentation group
determines which user manuals, if any, are affected and require updates. QA determines how much testing is
required to validate that the MR is implemented correctly, and also to validate that problems aren't
inadvertently introduced into other parts of the system. In the case of repair MRs, customer support
may need to determine the impact on customers of the MR and whether there are any possible workarounds
that can be employed in lieu of repairing the defect. Using all this information as input, the CCB estimates the
number of resources required, the cost, and the risk of implementing the MR. It then decides whether to
accept or reject it; and if accepted, assigns it a relative priority. MRs approved by the CCB are then retired by
technical maintenance staff. New software versions and documentation are generated and available for
customers. For efficiency reasons, multiple MRs are often grouped together and released as part
of a single
.
maintenance release.

The number of artifacts affected by the implementation of an MR is variable. Figure 29.7 illustrates two
extremes. At one extreme, the defect is in a requirement that requires changes in the SRS, the architecture,
and so on, all the way through to the code that makes the system operable in its intended environment. At the
other extreme, a defect could be present in the code for a method and the MR could affect that method
implementation but nothing else.
The minimal-impact case occurs, for example, when the programmer has failed to follow a standard in
naming a local variable, or when an unused variable is removed. In the worst case, however, every part of the
process is affected. Even for a defect in the code only, the impact can range from minor to major. A seemingly
Maximal impact

Maintenance:

Minimal impact

Impact of
Defect MR

code

Key: Shading denotes
impacted phase

Figure 29.7 The impact of a maintenance request-two extremes

code

737

738

CHAPTER 29

SOFTWARE MAINTENANCE

Add: "change appearance when
player achieves new levels"
Accommodate ability to change
global appearance: use Abstract
Factory design pattern

Add interface methods
for Layout package

-;:..-

Add classes and methods
as per detailed design
Modify gameplay
control code

Figure 29.8 The impact of a maintenance request-an example

simple change such as an increase in the size of a compile-time C++ array could have major ripple effects
throughout the application.
Maintenance Request 162, described in Figure 29.5, affects every aspect of the process, as shown in
Figure 29.8. Recall that this new requirement-the concept of multiple game levels-is a significant addition.
It leads to changes in every phase in the process.
When an application is designed with traceability in mind, the documentation of maintenance actions
can be manageable. Otherwise, the consequences can be extremely expensive.

29.3.1 Root-Cause Analysis
After a defect MR is repaired, a process sometimes known as root-cause analysis is sometimes conducted. This is
an iterative, problem-solving process aimed at determining the underlying reason that a defect has occurred.
Once the root cause is understood, process or other improvements can be implemented to prevent similar
defects from recurring in the future. Root-cause analysis is performed via the change control board or its
designee as part of the maintenance process. For each defect, the team asks a series of questions to narrow
down the root cause of the problem .
As an example, suppose that after an initial investigation it is determined that the reason for a particular
defect is due to a requirement being missed by the test plan. The root-cause analysis process is then invoked
to determine the underlying reason that the requirement was missed, and once determined, to ensure that
other requirements are not omitted in the future. The following series of questions illustrate the iterative
nature of root-cause analysis [9]. [11].
1. The requirement is not tested for in the test plan.
2. Why? It appears that the requirement was changed after the SRS and test plans were completed.
3. Why? The customer communicated with the product marketing group their desire for the change, but
this was communicated only to development. The rest of the team was unaware and therefore didn't
update the SRS and test plan .

MAINTENANCE PROCESS

4. Why? Product marketing thought this was an isolated change that wouldn't affect product testing, so
they communicated it only to development.
5. Why? Product marketing didn't understand that all changes to features must be communicated to the
entire team.
Once this root cause is understood, the product marketing department can implement appropriate
changes to its process that prevent this type of problem from recurring.
As root causes are determined, metrics are recorded to keep track of them. To provide consistency and
make it easier to track and analyze, it is helpful to define a list of root causes from which the team can choose .
Rakitin [9] suggests the following list.

I. Function was missing from SRS

2. Function was incorrectly specified in SRS
3. Design problem-design was inadequate or inappropriate

4. Design problem-design review didn't catch it
5. Code problem-code was inadequate

6. Code problem-code review didn't catch it
7. Inadequate unit testing
8. Inadequate system testing
9. Installation/environment/version compatibility issue

A metrics analysis is periodically performed to identify the most common root causes. The results are
used to create a plan of action to eliminate these types of defects from recurring. For example, if it is found
that many defects are caused by Code problem--code review didn't catch it, a review of and improvement to the code
review process can be implemented.

29.3.2 Patch Releases
Patches are used in two ways. The first way concerns getting new or replacement software versions or parts to
users. The second addresses delays in implementing an MR.
In the first way, patches are permanent replacements of parts of the application. They often take the
form of a set of files, sent via the Internet, that replace object code already written. In this case, the challenges
are for the customer's organization to ensure that patches are appropriately installed. Many customers
conduct their own system tests of patches-that is, in their own environment.
The second way concerns the handling of defect MRs that require significant time to remedy . It also
concerns defects that hamper a customer's use of the system and so must be remedied quickly. A rapid fix is
not always possible. To take an extreme example, in a military application with which one of the authors
was once involved, nine months could elapse between the identification of an MR and its complete
implementation and documentation! In these cases patches are modifications or additions to the object code
that either fix or work around a defect. Figure 29.9 shows a way in which these patches can be organized
within the development organization. It demonstrates the nominal, "official" path taken for a patch-on the

739

740

CHAPTER 29

SOFTWARE MAINTENANCE

1. Get maintenance request

L.r

L

optional
,

'"

2. Approve changes

------I

Docu"
ment

3. PI," ,h'"ge'

l
impact I

Assess

patch
I

"I

I
I

Vl
I

lmPlement

..
Release

I I

Execute
with

�

Test changeS

..

...

patch

4. Change code and documentation

4

1

Coordinate

I

Update documentation

I

,- ....1 Remove patch 1
,
Document

patch removal

Figure 29.9 Patches in maintenance-workarounds

Advantages
•

May be a complete solution to the problem

•

Keeps customers satisfled

•

Enables continued operation and testing

Disadvantages
•

May duplicate work

•

Temporaries sometimes never replaced

•

Complicates flnal flx (where applicable)

patch and flnal flx both implemented

without presence of the defect
•

Avoids masking other defects

•

Enables test of flx

proper flx deferred forever
•
•

must remove

Complicates documentation process
When tools used for insertion, may com"
promise code base

Figure 29.10 Advantages and disadvantages of maintenance patches

left-as well as an informal process for getting the patch into the application on a temporary basis-on the
right of Figure 29.9.
The advantages and disadvantages of patches include those listed in Figure 29.10.
The comment about "masking" refers to the fact that allowing defects to remain can make it difflcult to
detect other defects whose effects are hidden by the effects of the nonrepaired defect.

29.3.3 Software Trouble Reports, Maintenance Requests, and Correction Reports
It is simplest when a single test leads to an MR that is worked on as a single action, but the process is often not
so simple. Maintenance requests emerge from reports of trouble experienced with the application (often
called software trouble reports ). There may be several pieces of evidence for a single MR or, conversely, several
MRs that grow out of a single trouble report. Each part of the work on an MR that is worth documenting is
recorded in a so-called correction report. To deal with the proliferation of correction reports, we may need to
identify a child MR of the MR under consideration. This organization is shown in Figure 29.11.

IEEE MAINTENANCE STANDARDS

Maintenance
Software Trouble Report
STR 902834

1

Correction

I

Request

1293

I

1

1

Correction

Correction

Report

Report

Report

1293.1

1293.2

1293.3

Maintenance

Maintenance

Maintenance

Request

Request

Request

1293.1

1293.2

1293.3

Figure 29.11 Software trouble reports, maintenance requests, and correction reports

29.4 IEEE MAINTENANCE STANDARDS
The IEEE has published standard Std 1 2 1 9- 1 998 [ 12], which describes an iterative process for managing and
executing software maintenance activities. It is geared to large projects, but it is instructive to examine this
standard as a specific and detailed example of a maintenance process for projects of all sizes. Its table of
contents showing the pertinent sections is listed in Figure 29.12.

Problem identification

2

4

Input

1.3

Control

1. 5

Quality factors

4.2.1

Coding and testing

1.6

Metrics

4.2.3

Risk analysis and review

4.2.4

Test-readiness review

1. 2
1 .4

Process

4.1

Input

Output

4.2

Process

Analysis

2.1

Input

2.2

Process

4.3-4.6
Feasibility analysis

2.2.2

Detailed analysis

5

System test
5.1-5.6

factors, metrics

6

Acceptance test

6.1-6.6
Input, process, control,
output, quality factors, metrics

Input, process, control, output,
quality factors, metrics

Control, output, quality

Design

3.1-3.6

Control, output, quality
factors, metrics

2.2.1
2.3-2.6
3

Implementation

1.1

Input, process, control, output,
quality factors, metrics

7

Delivery

7.1-7.6

Input, process, control, output,
quality factors, metrics

Figure 29.12 IEEE 840-1994 "Software Maintenance" table of contents
Source: IEEE std 840-1994. Reproduced with permission.

741

742

CHAPTER 29

SOFTWARE MAINTENANCE

The standard defines seven phases that an MR flows through, each corresponding to a section in
Figure 29.12, as follows:
1. Problem/modification identification, classification, and prioritization
2. Analysis
3. Design

4. Implementation
5. Regression/system testing

6. Acceptance testing
7. Delivery
Note that these phases are similar to the phases of the development process. Each of the phases has six
attributes that describe the actions and data associated with them:
1. Input
2. Process
3. Control

4. Output
5. Quality factors

6. Metrics
Figure 29. t 3 summarizes the relationship between the phases and attributes. The following sections
describe how a maintenance request flows through each phase .

Phase

1. Problem identification
2. Analysis
3. Design
4. Implementation
5. System test
6. Acceptance test

Attributes

a. Input life cycle
artifacts for this step
b. Process required for
this step
c. How the process is
controlled
d. Output life cycle
artifacts
e. Process quality

7. Delivery

factors involved
f. Metrics for this step

Figure 29.13 Six attributes of each maintenance request phase
Source: IEEE, reproduced with permission.

IEEE MAINTENANCE STANDARDS

Ta ble 29.2 IEEE 1219-1998-Maintenance phase 1: problem identification
a.lnput

b. Process

c. Control
d. Output
e. Selected quality factors

f. Selected metrics

•

The Maintenance Request (MR)

·

Assign change number

·

Classify by type and severity, etc.

·

Accept or reject change

·

Make preliminary cost estimate

·

Prioritize

·

Identify MR uniquely

·

Enter MR into repository

•

Validated MR

·

Clarity of the MR

·

Correctness of the MR (e.g., type)

·

Number of omissions in the MR

·

Number of MR submissions to date

·

Number of duplicate MRs

·

Time expected to confirm the problem

Source: IEEE std 1219-1998. Reproduced with permission.

This section describes and explains Steps 1-4 in Figure 29.13. Steps 5-7 are similar to the regular testing
and delivery process. Testing in particular emphasizes regression testing to ensure that existing functionality
has not been compromised.

29.4.1 MaintenanCe Problem Identification
In this initial phase, MRs are identified, classified, and assigned an initial priority ranking. Table 29.2
summarizes the process for the identification phase of maintenance requests.
"Problem Identification" in the Encounter case study, for example, was performed by the marketing
department. They solicited and examined user complaints about the complicated way in which Encounter
game characters exchange quality values as a result of engagements.

29.4.2 Maintenance Problem Analysis
Table 29. 3 summarizes the analysis phase for maintenance requests.
Maintenance problems range from the simple to the deeply challenging. For example, suppose that we
want to provide the Encounter game player with additional image options for the main player. This appears to
be a straightforward request; however, the extent of maintenance requests like this is often underestimated.
The analysis process is designed to uncover the real work in carrying out modifications and additions. For
example, we might determine that the increased number of image options requires a complete reworking of
the way in which the images are displayed and chosen.
As an example, let's analyze Maintenance Request # 162 for the case study (see Figure 29.5) to
estimate the resources required to design and implement it. We will use the Abstract Factory design
pattern for the design of this MR, as described in Chapter 17. Modifications to the object model to
accommodate these, and the new classes are required. Once these modifications are made, it appears that

743

744

CHAPTER 29

SOFlWARE MAINTENANCE

Table 29.3 IEEE 1219-1998-Maintenance phase 2: problem analysis
a.lnput

b. Process

·

Original project documentation

·

Validated MR from the identification phase

·

Study feasibility of the MR

·

Investigate impact of the MR

·

Perform detailed analysis of the work required

·

Refine the MR description

·

Conduct technical review

·

verify ...

c. control

... test strategy appropriate
... documentation updated

d. Output

·

Identify safety and security issues

·

Feasibility report

·

Detailed analysis report, including impact

·

Updated requirements

·

Preliminary modification list

·

Implementation plan

·

Test strategy

e. Selected quality factors

·

Comprehensibility of the analysis

·

Number of requirements that must be changed

f. Selected metrics

·

Effort (required to analyze the MR)

·

Elapsed time

Source: IEEE std 1219-1998. Reproduced with permission.

we will need only to replace all Area and AreaConnection references in the client code (the code using the
new configuration) such as
=
=

new Area(); and
new Connection();

with calls of the form
LevelNBuilder. getArea(); and
=LevelNBuilder.getConnection() ;

=

and so on
IEEE metrics that quantify these modifications are as follows .
•

Number of requirements changes for MR #162: between 140 and 450 as follows.
Since we have organized the requirements by class, we count
o

o

The number of new classes that must be described: 60 to 90 (there are 20 to 30 levels, let's say, and for
each of these, Abstract Factory requires a factory class, a subclass of Area, and a subclass of Area­
Connection)
plus
The number of new methods: (2 to 5) per class * (60 to 90) classes

=

120 to 450

IEEE MAINTENANCE STANDARDS

•

Estimate of effort for MR #162 : 2.4 to 9 person-months as follows:
The effort can be estimated in terms of the number of person-days per requirement, based on these data
for the project so far. For example, if the original project has 300 detailed requirements and was completed
with 6 person-months, we can use 0.02 person-months per requirement, so that MR #162 should be taken
care of with (120 * 0.02) to (450 * 0.02) 2.4 to 9 person-months. The highly repetitive nature of the
classes suggests a lower number in this range, perhaps three person-months.
=

•

Elapsed time estimate for MR #162
The elapsed time estimate can be computed from historical data in a similar manner to the Effort
computation.
To improve on these metrics, apply the following.

a. Use linear regression, in which a set of past data is used to derive a straight-line approximation, and this
straight line is used to approximate the result. For example, instead of using simply "300 detailed
requirements were completed with 6 person-months 0.02 person-months per requirement," we can use a
graph of several different past projects and fit a straight-line relationship to these, as shown in Figure 29.14.
This gives a more reliable result: a range of 2.5 to 9.3 person-months. It should be noted that regression
methods are also available that fit curved lines.
=

b. Account for factors such as the nature of the application and the composition of staffing. For example, if
the data are available, one can create graphs that use only projects of the same type, or projects whose staff
had equivalent experience levels.
c. Include variances with the measures described. (It is useful to know averages, but we are also interested in
the extent to which measurements have differed from the averages in the past.)

9
300 detailed
'"
.<::

requirements

C

completed with 6

E
C: 6

person-months

0

0

0

0

�

<Il
a.

'0
Q;

0

0

0

.0

E 3

:J
Z

0

200

300

400

Number of detailed requirements

Figure 29.14 Using linear regression to estimate the effort for implementing an MR

745

746

CHAPTER 29

SOFTWARE MAINTENANCE

Table 29.4 IEEE 1219-1998-Maintenance phase 3: design
a. lnput

·

original project documentation

·

Analysis from the previous phase

·

Create test cases

·

Revise ...

b. Process

c. control

.. implementation plan

Verity design

·

Inspect design and test cases

·

Revised ...
·

.

. modification list

·

.

. detailed analysis

·
·

·

f. Selected metrics

. . requirements

·

·

d. Output

e. selected quality factors

·

. . implementation plan

Updated ...
. design baseline

·

.

·

. . test plans

Flexibility (of the design)

·

Traceability

·

Reusability

·

Comprehensibility

·

Effort in person-hours

·

Elapsed time

·

Number of applications of the change

Source: IEEE std 1219-1998. Reproduced with permission.

29.4.3 Designing for a Maintenance Request

Table 29.4 describes the design phase for MRs.
A design handling MR #162, for example, follows the Abstract Factory design pattern, which consists of
modifying the original EncounterEnvironment package. The original documentation for this package is shown in
Figure 29.15.
Instead of creating Area and EncounterAreaConnection objects directly, the modified application will
do so through methods getAreaO and getAreaConnectionO. These are methods of a new class, Environ­
mentFactory. Client code of the EncounterEnvironment package need have no knowledge of the type of Area
and AreaConnection objects being built, because all creation requests are channeled through the particular
EnvironmentFactory object aggregated by EncounterEnvironment. In other words, there will be no need to
write separate control code for the various levels. At runtime, the client code selects an object of the
appropriate EnvironmentFactory subclass. For illustration purposes, the object model in Figure 29.16 shows
Area and AreaConnection classes for three game-playing levels only (not for the larger number planned).
A plan is required for migrating from the old design to the new. Figure 29.17 shows such a plan. It
integrates the parts in a way that allows their testing, one at a time. We also try to keep existing parts
operational while introducing new parts in order to allow the switch only when we have confidence in the
new parts.

IEEE MAINTENANCE STANDARDS

I

1 GameEnvironment

J

GameCharacter

GameAreaJ

�T

GameAreaConnection

I

I

1

1
I

�

l EncounterAreaConnection J

J

EncounterEnvironment

EncounterEnvironment

Figure 29.1 5 EncounterEnv;ronment package (before modification)

+

l..n

>1

EncounterEnvironment

I

I I

Level1Area

t
1
1

1

I

'

I

II

J I

£nvironmentFacf0r::i.
getArea()
getConnection()

�

Level2Area

Level1 AreaConnection

1',
«create»

I

�

L;,
£ncounterAreaConnection

1

Level3Area

+
1
1

J

�

I

\

\

Level2AreaConnection

l'

1

:

I

I

\

I

J \ , I Level3AreaConnection I

\ ,..
\

I

\1

Level1Factory

Level2Factory

Level3Factory

getAreaO

getAreaO

getAreaO

getAreaConnectionO

getAreaConnectionO

getAreaConnectionO

Figure 29.16 Abstract Factory applied to Encounter video game

This plan begins with the existing design, then adds and tests parts that do not disrupt the existing
implementation such as types of areas and connections. Before the last step, the redesign is ready to execute
the Abstract Factory implementation, each of the parts having been thoroughly tested. In the final step, the
new creation process is finally "turned on" and tested.
29.4.4 Implementing a Maintenance Request

Table 29.5 shows steps and documentation for the implementation of maintenance requests.

747

EnvironmentFactOlY

Figure 29.17 Migration plan for level-based graphics

EncounterEnvironment

Phase 3: Introduce The.Builder Class and Subclasses

I

EncounterEnvironment

EnvironmentFactory

buildAreaQ and buildAreaConnectionQ

z
o
m

-I
m
Z

»

I

�------�' Area

Level3AreaConnection

;lJ
m

�

o

EncounterAreaConnection

!:J.

.1 EncounterAreaConnection 1

(/)

;lJ
N
'"

�
m

�
»
Z

Final Phase: Activate

1

»

o
:::r:

EncounterEnvironment

Start: Existing Model

EncounterEnvironment

Phase 2: I ntroduce Subclasses of Area and ... Connection

.....
....
co

SOFTWARE EVOLUTION

Table 29.S IEEE 1219-1998-Maintenance phase 4: integration

a.lnput

b. Process

·

Original source code

·

Original project documentation

·

Detailed design from previous phase

·

Make code changes and additions

·

perform unit tests

·

Review readiness for system testing

·

Inspect code

·

verify ...

c. Control

d. Output

·

.

.

.

CM control of new code

.

.

.

Traceability of new code

Updated . ..
·

e. Selected quality factors

f. Selected metrics

. . software
.

unit test reports

·

.

·

. . user documents

·

Flexibility

·

Traceability

·

Comprehensibility

·

Maintainability

·

Reliability

·

Lines of code

·

Error rate

Source: IEEE std 1219-1998. Reproduced with permission.

The response to maintenance requests can involve a Significant amount of development, and this
may actually introduce new defects. The error rate is the number of defects created by this maintenance effort
per unit of effort (e.g., person-month). The measurement methodology for these new defects has to be
precisely defined-for example, "the number of defects of medium severity found within three months of
deployment." Suppose, for example, that the handling of MR # t 62 described above consumes twenty person­
days and produces ten defects; then the error rate for this MR would be 10/20 0.5 defects per person-day.
The remaining maintenance steps are system testing, acceptance testing, and updating the project
documentation. The procedures followed for these are similar to those for regular development.
=

29.5 SOFTWARE EVOLUTION

Systems that have been maintained for a significant amount of time are referred to as legacy systems. This term is
often used, more particularly, for systems that most people would like to replace but would be expensive to
replace. As previously noted, software systems that are subjected to repeated maintenance activities become
larger and more complex, and maintaining them can be a challenge. Some of these challenges are as follows:
•

Software complexity due to continuous maintenance-e.g., increased coupling

•

Inefficiencies due to older technology

749

750

CHAPTER 29

SOFTWARE MAINTENANCE

•

Lack of accurate documentation

•

Original developers who fully understand the systems are no longer available

As the complexity of legacy systems increase, so does the cost of maintaining them. Organizations are
faced with the challenge of how to reduce costs by making systems more maintainable. A good approach,
especially for systems with little or no documentation or with outdated documentation, is to start with reverse
engineering. This is a technique in which a system is analyzed to identify its components and their inter­
relationships. From this information its design and specifications are recreated. That is, we start with a low
level of abstraction (source code) and create a higher level of abstraction (design and documentation).
Another common technique is reengineering, where the system is restructured in order to improve its design and
maintainability. The reengineering process often starts with reverse engineering.
29.5.1 Reverse Engineering

Software products under maintenance have a wide variety of possible histories; many existing applications
are poorly or inconsistently documented, and not very well understood. This leads to inefficiencies as
maintenance engineers attempt to implement MRs on systems they don't fully understand. Reverse
engineering brings such a system to a consistent, documented, understood state. Two components of
reverse engineering are redocumentation and design recovery [t 3]. Redocumentation is typically the first step in
reverse engineering in which documentation describing the system is generated from existing source code.
Several commercial tools are available to assist in this purpose, which can, for example, reformat the source
code to make it more readable or extract comments to form documents.
Once the necessary documentation is available, the next step is design recovery. This is the process of
analyzing the available documentation and knowledge about a system in order to understand its design. Once
successfully completed, improvements to the design and the system can be implemented. Tools are available
to generate UML class diagrams from source code, for example. This usually produces a very complicated
diagram. The diagram can be used to build the key parts of the UML by hand or by erasures. Suppose, for
example, that we were to lose track of the UML for the Encounter video game. We could first generate the
UML for all of the code. After that we could start with a key class such as EncounterEnvironment, identify all
classes that it relates to, select some among those to retain, and then repeat the process with those or start
with other known classes.
29.5.2 Reengineering

The short-term goal of maintenance is to fix a problem or install a feature as soon as possible. The long-term
goal is to position the changing system so that it continues to work efficiently and with reasonable cost per
MR into the future. Due to increasing complexity and the escalation in cost per MR, we periodically take a
fresh look at the entire architecture and design of the system. Making changes to the architecture from the
top down is the main task of reengineering. As defined by Chikofsky and Cross [t 3], reengineering is the
"examination and alteration of a subject system to reconstitute it in a new form and the subsequent
implementation of the new form." Sometimes the reengineered system supports new requirements that the
older system was unable to implement. The overall goal of reengineering is to create a system that is less
complex, and ultimately, easier to maintain and less costly.
As an example of reengineering, suppose that the video store application is required to track the non-video
items that customers purchase at the store (candy, paraphernalia, etc.). In the absence of reengineering, we
might add variables to the Customer class so that when Customer objects are stored, these additional data are stored
at the same time. In all likelihood, this approach will eventually produce a hard-to-maintain application.

MAINTENANCE METRICS

IDvDsl

I

DVDAccess
« facade »

�

rDVDRentals

J

I

�

VSCustomers

I

I

DV D Renta1

�

DVDCustomerAccess
« facade »

r-

-

D

1

D

Figure 29. 1 8 Original video store architecture

DVDRentals
DVDRentalAccess
« facade »

VSCustomers

VSCustomerAccess
« facade »

videoStore
«to be completed»

Key: reengineered parts:

I XX I

Figure 29. 1 9 Reengineered video store architecture

Now let's consider a reengineering approach. Recall the existing video store architecture, as shown in
Figure 29.18.
Tracking non·video purchases does not properly fit into any of the modules shown , and consequently a

non VideoItems package is introduced. Since the business of the store now consists of more than rentals, a separate
management module is strongly indicated. We will label this module videoStore. In addition, it now becomes
appropriate to introduce a facade object for the D VDRentais package. This results in the reengineered
architecture shown in Figure 29.19.

29.6 MAINTENANCE METRICS
Since maintenance consumes a large fraction of life cycle costs, it is particularly important to quantify its costs
and benefits. Not all organizations have the same goals in pursuing maintenance. Organizations first
determine the maintenance goals for the application, then select or create metrics that measure their degree

751

752

CHAPTER 29

SOFlWARE MAINTENANCE

Table 29.6 Maintenance metric selection by goal
Goal

Question

Maximize
customer
satisfaction

How many problems are

Selected Corresponding Metrics (The n umbered metrics a re
from the I EEE)
·

Fault density =
[Number of faults found in the applicationj/KSLoC

affecting the customer?

" Faults" are defects found during testing or operation .
KSLOC

=

thousands

of

lines of

noncommented

source

statements
·

Mean time to failure = The average time it takes to obtain a
failure. of the application measured from startup.

·

Break/fix ratio = [Number of defects introduced by maintenance
actions]/[Number of defects repaired]

How long does it take

·

Fault closure = Average time required to correct a defect, from
start of correction work.

to fix a problem?
·

Fault open duration = Average time from defect detection to
validated correction.

Where are the bottlenecks?

·

Staff utilization per task type = Average person-months to (a)
detect each defect and (b) repair each defect.

·

Optimize effort
and schedule

Where are resources

Computer utilization = Average time/CPU time per defect.

Effort and time spent, per defect and per severity category

being used?

.

.

.

planning

.

.

.

reproducing customer finding

.

.

.

reporting error

.

. . repairing

.

. .

. . . enhancing

M inimize defects

Number of entries and exits per module

where are defects

·

most likely to be found?

·

Cyclomatic complexity

·

Ratio of commented lines/KLoC
(KLoC = thousands of lines of source code, including comments)

of success in attaining those goals. Table 29.6, based on a table by Stark and Kern [14], illustrates this by
showing how three different goals indicate the use of different metrics.
'The definition of "failure" for the application under test depends on what the customer perceives as
failure, and ranges from application crashes to specific types of problems. For a financial application, for
example, any calculation resulting in a discrepancy of a dollar or more could be defined as a failure. In any
case, the definitions should be explicit.
Let's consider how metrics can be used to manage a maintenance activity. The fraction of commented lines in
the source code helps to predict the relative magnitude of a maintenance effort. For example, suppose that the
application being maintained consists of three modules (Accounts Received, Timesheet, and Sick Day Recorder)
each with the size and commenting data shown by the respective black and white dots in Figure 29.20.
Compared with the Accounts received and Timesheet modules, the Sick Day Recorder module is liable to
produce the biggest maintenance challenge because it is larger and has a larger proportion of uncommented
lines of code. The Accounts Receivable module is likely to be the least expensive to maintain because it is the
smallest and has a higher than average proportion of comments. The proportion of comment lines can be
obtained using a utility program or by counting from a random sample of pages of code.

MAI NTE NANCE M ETRICS

o

t

0

Percentage of

•

comment lines
(higher value = lower

0

maintenance effort)

•
Size

I

•
•

(lower value = lower

0

maintenance effort)

I
Module:

Accounts
received

Timesheet

Sick day
recorder

LOWEST

HIGHEST

EFFORT

EFFORT

Figure 29. 20 Predicting relative maintenance efforts

To manage a maintenance effort, graphs like the one in Figure 29.21 are useful. These show new, open,
and closed MRs.
According to the chart in Figure 29.21, a large number of requests for repair and enhancement arrived in
the first two years, resulting in a peak backlog during the second year. This backlog was eventually worked off.
The profile in Figure 29.21 is a typical one, whether the comparable time scales are years, months, or weeks.
Typically, the maintenance manager tries to account separately for faults and enhancements so that the
true cost of the application, as required, can be tracked.
To manage an organization's effectiveness in handling the maintenance workload, a graph such as the one
in Figure 29.22 can be used. The graph shows the average number of weeks that a maintenance request (whether
800
700
600

D # M R 's received

---l - # M R ' s com pleted

__

-

• # M R ' s cancelled
D # MR's

500

n

400
300
200
1 00
0
2000

2001

Figure 29.21 Measuring maintenance productivity

2002

2003

753

754

CHAPTER 29

SOFTWARE MAINTENANCE

t

For example, in April, the

open

average enhancement MR

# weeks

had been open for 8 weeks.

10

?
5

.

/ -8 /

o

"Fixing" M R s

• Enhancement M R s

l /�/t-�"
i I I
b
.

/.

! /

•

6

,

. _
__

_ �.

6

6

i

Figure 29.22 Assessing maintenance operations

a repair or an enhancement) has been waiting for resolution, measured from the time it was first reported. It shows
a convergence to an average delay of about one week for repairs, and roughly four weeks for enhancements.
29.7 CASE STUDY

The following is an excerpt from the OpenOffice
documentation that illustrates a means of handling
defects and enhancements.

there is time). Here is a general rule of thumb for
priorities:
P I -OpenOffice cannot be used for testing or
development.

ISSUE HANDLING AS A QA TEC HNIQUE IN
OPENOFFICE

P2-0penOffice crashes or basic features do
not work.

The IssueZi/la (IZ) tool is an accessible list of Open­
Office "issues." These include defects and en­
hancements. OpenOffice publishes guidelines and
protocols for dealing with issues. The following is
quoted from openoffice.org. Priorities range from P I
(very urgent) to P5 (will be considered when

P 3-Bugs that usually involve a feature not
working as expected.
P4-Bugs that do not affect basic features and
usually have workarounds.
P5-Very minor annoying bugs.

ISSUEZl llA STATISTICS

Note to the Student:
Bugzilla allows graphical forms of data, which supplement tables such as that shown below. The core of
bug tracking is a history of new, existing, and closed issues over time.
Table 29.7 is an example of the statistics available using IssueZilla [ 1 5] during an example time period. It
tracks the number of defects in each state (e.g., reopened) within each major part (e.g., spreadsheet) of OpenOffice.

1

database access

database access Result

unconfirmed
new

database access
-1

6

-1
-1

reopened
started

database access

0

database access

chart Result

unconfirmed
new

Chart

0

138

141

137

75

27

29
73

29

6

31

72

35

30

5

50

53

54
4

3

1

46

3

3

47

3

4

47

started

1 94
0

1 92

Chart

0

0

82

13

98

78

14

99

74

Chart

-4

15

191

new

Api

1
101

0

unconfirmed

Api

2

0

reopened

started

Api

api Result

reopened

Api

133

74

25

29

5

50

3

1

46

0

1 94

85

14

94

3

2

31
22

2
31
23
61

1 17

2
31
17
58

108
153

142

151

96

20
96

22

5
30

5
30

1 14

59

2

46

2

44

3

43

1

43

43
0

40

38
2
3

2

40

46

3

40

86

23

28

5

46

3

1

42

1 78
0

1 74
0

171
0

1 75
0

186
0

191
0

67
61

97
13
13

1
99

59

11

100

64

15

95

1

71

21

93

1

70

23

97

Changes 08/02/04 07/26/04 07/19/04 07/1 2/04 07/05/04 06/28/04 06/21 /04 06/1 4/04 06/07/04 06/01 /04

Chart

state

project

Defects

Ta ble 29.7 Examples of statistics available using IssueZilla

.....
U1
U1

c
o
-<

�

m

�
Vl

756

CHAPTER 29

SO FTWARE MAINTENANCE

Table 29.1 shows defect status at a summary level. It is a useful form for project leadership when
assessing the maturity of recent MRs. Other forms of the data show defects and features ("issues") grouped
according to modules. This enables a developer to work on several related issues at more or less the same time,
and it enables a leader to assess the health of a module and the work of teams.

29.8 SUMMARY

Software systems continue to evolve after their initial development and release. Software maintenance
consists of those activities that are performed on the system after its release, such as repair of defects,
implementation of enhancements, and adaptation to changes in the environment.
The challenges of software maintenance fall into three main areas: management, process, and technical.
Management must understand the complexity and value of maintenance and provide adequate support.
Implementing an efficient maintenance process helps reduce the complexity. Technical challenges include
the design of regression tests to ensure that implemented maintenance requests do not have unintended side
effects on other parts of the system.
A typical maintenance process starts with customers providing comments on enhancements
and defects through the help desk. These are written up as Maintenance Requests (MRs). MRs are
regularly reviewed and prioritized, often by a change control board (CCB). The CCB is composed of
stakeholder groups such as development, user documentation, marketing, quality assurance, and
customer support.
An impact analysis is performed on incoming MRs that assesses the scope of the changes to product
artifacts that are required in order to implement the MR. Each group represented by the CCB provides
input.
Root-cause analysis is a process conducted after completing the repair of a defect MR. Its purpose is to
determine the underlying reason that a defect has occurred. This information is then used to implement
process improvements so that similar defects are prevented from occurring in the future.
IEEE Std 12 1 9-1998 describes an iterative process for managing and executing software maintenance
activities. The standard defines seven phases that an MR flows through, similar to the phases that occur during
new product development: MR identification and prioritization, analysis, design, implementation, testing,
and delivery. Each phase has six attributes associated with it that describe the activities and data for that
phase: input, process, control, output, quality factors, and metrics.
As software systems evolve, they become more complex and less understood. Frequently, much of the
original documentation is lost or outdated, and many if not all of the original developers are no longer
available. Reverse engineering is a process that reconstructs system documentation, such as enhanced, more
readable code, or class diagrams, from existing source code. An understanding of software architecture and
design is then constructed from the new documentation.
Periodically, organizations take a fresh look at the whole design of a system, with the goal of reducing
its complexity, increasing its effiCiency, and making it more cost effective to maintain. Changing to the
software architecture and design to meet these goals is referred to as reengineering. This is especially needed
for older systems whose design has deteriorated over time.
It is common for organizations to define specific maintenance goals and then select or create metrics
that measure the organization's degree of success in attaining those goals. For example, if a goal is to minimize
defects, metrics would be collected to measure the complexity of the code, with a goal of refactoring those
areas that have the highest complexity.

EXERCISES

29.9 EXERCISES
1 . Define the term "software maintenance" in one sentence.

2. Describe in your own words four types of software maintenance. Is there an example of a
maintenance request that might overlap two of the categories?
3. Give examples of corrective, adaptive, perfective, and preventive changes for the Encounter case
study.
4. Suppose that a proposal is made to change the length of an array in an application to accommodate
requirements that were not previously satisfied. What activity is required before actual changes in
the code can be made?
5. Describe a practical scenario in which the rather lengthy maintenance flow illustrated in Figure

29.6 might need to be circumvented?
6. A proposal has been made to implement the following requirement for the Encounter case study,
which was initially designated optional.
PlayerG:haracter Requirement [desirable] ("Player character image") The player shall have the
option to choose the image representing her main character from at least 4 GIF files
a. What type of maintenance request (MR) is this?
b. Provide an impact analysis for this MR.
7. Which of the following would require reengineering. Explain.
a. Convert a simulation of the operations of a bank into an automated bank security system .
b. Add to a simulation of the operations of a bank so that it handles the movements of security
personnel.
c. Modify an online tutoring system so that it can to provide multiple-choice quizzes at any time to
permit students to assess their understanding of what they are currently reading.
8. There are many commercial reverse engineering tools that automatically generate docu­
mentation from source code. Using Internet research, identify two such tools and describe
the types of documentation they generate. Explain how the documentation clarifies the source
code.

TEAM EXERCISE
Maintenance

(a) Obtain project specifications from two other teams in the class. Propose at least one of each of the
following types of modifications: corrective, adaptive, perfective, and preventive.
(b) Another team will have proposed four such modifications to your project. Develop an impact
assessment on your project of each of these modifications.

757

758

CHAPTER 29

SOFTWARE MAINTENANCE

(c) Negotiate with the team proposing modifications to your project to make them reasonable in terms
of the resources required, then implement these modifications.
(d) Implement, test, and measure your modifications.

Evaluation criteria:

(1) Degree to which the proposed modifications are of the types specified
(2) Completeness of your impact assessments
(3) Degree to which the modifications have been tested

BIBLIOGRAPHY
l. "IEEE Standard Glossary of Software Engineering Terminology," IEEE Std 610.12-1990, December 1990.

2. Foster, J., Cost Factors in Software Maintenance, PhD. thesis, University of Durham, NC, Computer Science Dept, 1994, as noted
in [9].
3. Pigoski, Thomas M., Practical Software Maintenance, Best Practices for Managing Your Software Investment, John Wiley & Sons, 1996.

4. Lehman, M., "Programs, Life Cycles, and the Laws of Software Evolution," Proceedings IEEE, No. 19, 1980, pp. 1060--1076.
5. Lehman, M., "Program Evolution Information Processing Management," Proceedings IEEE, No. 20, 1984, pp. 19-36.
6. Lientz, Bennett P., and E. Burton Swanson, "Software Maintenance Management," Addison-Wesley, 1980.
7. Lientz, Bennett P., E. Burton Swanson, and Gerry E. Tompkins, "Characteristics of Applications Software Maintenance,"
Communications of the ACM (CACM), No. 21, 1978, pp. 466-471.

8. Bennett, K.,"Software Maintenance, A Tutorial," Software Engineering, IEEE Computer Society, November 1999, as noted in [Dorfman
and Thayer, 1999].
9. Rakitin, Steven R., "Software Verification and Validation for Practitioners and Managers," Artech House Publishers, 2001,.

10. McConnell, Steve, "Rapid Development, Taming Wild Software Schedules," Microsoft Press, 1996.

II. Arthur, Lowell J., Improving Software Quality, An Insider's Guide to TQM, John Wiley & Sons, 1993.

12. "IEEE Standard for Software Maintenance," IEEE Std 1219-1998, 1998.

13. Chikofsky, Elliott.]" and James H. Cross ll, "Reverse Engineering and Design Recovery, A Taxonomy," IEEE Software, Vol. 7, no. I,
1990, pp. 13-17.
14. Stark, George E., and Louise C. Kern, "A Software Metric Set for Program Maintenance Management," Journal of Systems and Software,
No. 24, 1994, pp. 239-249.

15. OpenOffice. http'//qa.openoffice.org/iz_statistic.html laccessed November 18, 2009].

Glossary

Acceptance testing

The process of testing an application on behalf of the customer to enable the customer

to validate that the requirements have been met.
Actor

A particular role adopted by the user of an application while participating in a use case.

Agile development processes

Highly iterative processes that emphasize working code and frequent

interaction with the customer.
Alpha release

A preliminary version of an application given to highly trusted customers and/or internal

users to obtain feedback.
A widely recognized U.S. nonprofit standards and

American National Standards Institute (ANSI)

accreditation organization.
Application Programming Interface (API)

A set of classes and member function prototypes provided for

the benefit of programmers. The function information consists of its name, parameter types, return types,
and exceptions thrown.
Architecture, Software

An overall design of an application, including its decomposition into parts.

Any kind of data, source code, or information produced or used by a participant in the

Artifact

development process.
Association for Computing Machinery (ACM)

An organization of professionals involved in the computing

enterprise, emphasizing software.
A variable of a class as a whole (not a variable local to a method). Also called a field.

Attribute
B-Ianguage
Baseline

A formal, mathematical language for specifying and, in part, implementing an application.

A known and documented version, form, configuration, or implementation of an artifact.

Subsequent changed versions are compared with it.
Beta release

A preliminary version of an application, given to selected customers to help detect defects, and

to obtain feedback.
Black box method

A testing method, applied to implemented code, which takes into account input and

output only (i.e., not the internal manner in which the code operates).
Build

A partial implementation of an application.

Business process reengineering (BPR)

A systematic design of a business process, such as purchase order

handling, from beginning to end, including human and non-human aspects, typically performed from scratch.
Capability assessment

A process by which the capability of an organization, group, or person to produce

software, is measured in a quantitative and objective manner.
Capability Maturity Model (CMM and CMM-I)

A systematic manner of assessing the overall capability of

an organization to develop software; developed by the Software Engineering Institute in Pittsburgh, PA.
CMM-I is a successor to CMM.

760

GLOSSARY

Change control board (CCB)

A committee that decides whether or not a proposed enhancement or repair

to an application should be implemented.
Code inspection
Coding

A process by which a team inspects a program to find defects.

Another term for programming.
Commercially available software product. In this context, such software

Commercial off-the-shelf (COTS)

is used to work with code built from scratch to create an application.
Common object request broker architecture (CORBA)

A standard under which applications can invoke

functions residing on remote platforms, regardless of the language in which they are written.
Computer aided design/Computer aided manufacturing (CAD/CAM)

Graphic-intensive software which

assists in the design and manufacturing of electronic, construction, or mechanical products.
Computer-aided software engineering (CASE)

The software engineering process, when assisted by a

coordinated set of software tools. These tools are tailored to the various phases of software development.
Configuration item (CI)

An artifact whose versions are specifically tracked from the beginning to the end of

a project.
The process of maintaining and managing the various versions of various

Configuration management (CM)
artifacts of a software project.
Constraint

A specified limitation.

Constructive Cost Model (COCOMO)

Barry Boehm's formulas for computing the probable labor

requirements, in person-months, to build an application, and the probable elapsed time, based on the
estimated lines of code.
A process of deciding once and for all whether or not to proceed with a

Critical design review (CDR)

proposed design. The process includes, or may consist entirely of, a meeting.
Data base management system (DBMS)
Data flow diagram (DFD)

A system for organizing and accessing data.

A diagram showing how data flows into, within, and out of an application. The

data flows among the application's user, the data stores, and internal processing elements of the application.
Defect

A deviation from what is explicitly or implicitly required.

Design pattern

A pattern of commonly occurring classes, relationships among them, and accompanying

algorithms.
Detailed requirements

(also "Developer requirements") A form of requirements primarily suitable for

developers to work from, but also forming part of the requirements for customers.
Eclipse

An open source software development environment.

Encounter
Event

The video game case study used in this book.

An occurrence affecting an object, initiated externally to the object.

Extreme Programming (XP)
Formal methods

A widely used, early agile process pioneered by Kent Beck.

Rigorous methods for specifying requirements, design, or implementation; mathematical

and logical in nature.
Framework

A collection of general classes that forms the basis for several applications. The classes of each

application aggregate or inherit from the framework's classes.
Function-oriented organization

A managerial organization built around job functions such as program­

ming and marketing.
Function point (FP)

A measure of an application's complexity.

GLOSSARY

Functional requirement

A requirement expressing a function which an application must perform. This

contrasts with non-functional requirements such as processing speed.
Graphical user interface (GUI)

A graphic display, often interactive, by means of which a user interacts with

an application.
Help desk

A facility for providing help to users of an application.

High-level requirements
Incremental process

Requirements stated in a summary form.

An iterative software development process in which each iteration consists of small changes.
The process of performing verification and validation by a

Independent verification and validation (IV&V)

third party (i.e., not by the organization performing the development or by the customer).
Institute of Electrical, and Electronics Engineers (IEEE)

An organization of professionals, dedicated to

engineering involving electronics, electricity, and software.
The fusing of application modules to form an application.

Integration

Integration testing

The process of testing for the successful fusing of modules.

Interactive development environment (IDE)

A software application that helps developers to create, edit,

compile, and execute code.
Interface

An interface for a software system is a specification of a set of functions which the system

provides. This includes the names of the functions, their parameter types, return types, and exceptions.
International Standards Organization (ISO)

A widely recognized international body that sets standards

such as quality standards.
Invariant

A relationship among variables which, within a specified context, does not change (the values of

the individual variables may change, however).
A specification which is specifically not required of an application.

Inverse requirement
Iteration

The process of adding requirements, design, implementation, and testing to a partially built

application.
Iterative development

A process that repetitively uses the requirements/designlimplementation/test

sequence of phases.
Legacy application
Legacy systems
Maintenance

An application that has been delivered and used.

Existing computer systems that continue to have value.

The process of repairing and enhancing an application that has been delivered.

Maintenance request (MR)
Matrix organization

A request to modify or add to an existing application.

A way to organize employees in which each manager formally supervises a group with

similar skill types (he is their line manager). Employees may work on one or more projects involving
personnel with different kinds of skill sets. Projects are managed by project managers.
Mean time between failures (MTBF)

The quantity (Time an application is in use)/(number of occasions the

application failed during that time); a definition of "failure" is made and used consistently.
Mean time to failure (MTTF)
Meta-process
Metric

The average time elapsing between starting an application and its first failure.

A process concerning processes.

A means of measuring (assigning a number to) a software engineering artifact. For example, lines of

code is a metric for source code.
Model

A view of an application's design from a particular perspective, such as the relationships between its

classes, or its event-driven behavior.

761

762

GLOSSARY

Non-comment lines of source code (NCSLOC)
Non-functional requirement

A line of source code which is not a comment.

A requirement placed upon an application that does not involve any specific

functionality. A constraint on memory is an example.
Object-oriented (00)

An organization of designs and code into classes and instances ("objects"). Every

object in a given class is provided with a set of functions specified for that class; each object has a copy of a
set of variables specified for the class.
A non-profit organization of companies, which establishes standards

Object Management Group (OMG)
for distributed object computing.

OpenOffice

An open source office productivity software suite.

Open Source Project

A project to produce a free software application in which the source code is available

free and which qualifies individuals to contribute.
A way of thinking, such as the object-oriented paradigm.

Paradigm

Personal software documentation (PSD)
status of his or her code.
SM
(PSP)
Personal Software Process

Documentation that an individual maintains about the current

A process, developed by Watts Humphrey at the Software Engineer­

ing Institute, for improving and measuring the software engineering capability of individual software
engineers.
Phase

See Software development phase.

Physical configuration audit (PCA)

A systematic review of a project's physical artifacts on hand, including

the documents, source code, files, tapes, and disks.
Preliminary design review (PDR)

A meeting at which an early draft of a design, of all or part of the project,

is presented and critiqued by engineers and managers.
Process

A "software process" is a sequence of activities or phases in which development activities are

performed.
Project management

The process of fulfilling the responsibility for the successful completion of a project.

Project-oriented organization

A way to organize employees in which each reports to the manager of a

project.
Prototype

An application that illustrates or demonstrates some aspect(s) of an application that is under

construction.
A program written in such a manner that a mathematical and logical proof can be

Provably correct program

produced which proves that the program satisfies its requirements.
An English-like language which is formal enough to describe an algorithm.

Pseudocode

Quality assurance (QA)

.

The process of ensuring that a specified level of quality is being attained in the

execution of a project; may also be used to refer to the organization performing this function, rather than
the function itself.
Rapid application development (RAD)

The process of quickly developing an application, or part thereof,

typically sacrificing proper documentation, design, or extensibility.
Reengineering

Given an existing application, this is a process of redesigning all or part of it and then

modifying the existing application to fit the new design.
Refactoring

A process of changing the design and/or code of an application to improve it (e.g., to make it

easier to modify) while retaining its functionality.

GLOSSARY

Validating that the addition of code to an application under development, or its

Regression testing

alteration, has not diminished the capability it possessed before the changes were made.
The wants and needs of the customer for a software application; often in the form of a

Requirements

written document.
The process of obtaining a complete, typically written, statement of what

Requirements analysis

functionality, appearance, performance, and behavior are required of an application.
The process of deducing the contents of a software development phase from the

Reverse engineering

artifacts of a subsequent phase (for example, deducing the design from the code).
Risk retirement

The process of dealing with a perceived threat to the successful execution of a project (a

risk), either by finding a way to avoid the risk, or by taking action to eliminate its impact.
A list of activities which result in attaining a speCified goal.

Roadmap
Robustness

The quality of an application in which it responds reasonably to improper input.

Role-playing game (RPG)

A game, often a video game, in which the players assume roles and interact with

each other in those roles.
Scrum
Security

An agile process based on iterations known as sprints, developed by Ken Schwaber and others.
The property of an application that inhibits malicious exploits on it.

Sequence diagram

A diagram involving objects of an application, showing a sequence of function calls

between the objects. Sequence diagrams usually elaborate upon use cases.
Software cost estimation

The process of estimating the cost to produce an application based on partial

information (e.g., the requirements document alone).
Software configuration management plan (SCMP)

A document that specifies how the code and documents

of a project, and all of their versions, are to be managed.
Software design document (SOD)

A document describing the design of a software application.

Software development folder (SDF)

A document specifying the current status of the code on which an

individual software engineer is working. This includes all details about the unit testing which the engineer
has performed to date.
Software development phase

An identifiable and related set of activities that is part of the software

development process, such as requirements analysis.
Software engineering

The discipline for creating software applications.

Software Engineering Institute (SEI)

An institute initially founded to improve the quality of U. S. defense

software. Its work is used by many non-defense organizations as well.
Software maintenance

See Maintenance.

Software project management plan (SPMP)

A plan stating who will develop what parts of an application,

and in what order they will do so.
Software quality

The degree to which an application satisfies its explicit and implicit requirements.

Sometimes defined as the degree to which an application exceeds requirements.
Software Quality Assurance Plan (SQAP)

A document describing the manner in which quality is to be

attained in a software project.
Software requirements specification (SRS)
Software test documentation (STD)
application.

A document stating what an application must accomplish.

A document that specifies all aspects of the testing process for an

763

764

GLOSSARY

Software test plan (STP)

Documentation stating what parts of an application will be tested, and the

schedule of when testing is to be performed.
Software Verification and Validation Plan (SVVP)

A document describing the manner in which a software

project is to be verified and validated.
An early iterative process, developed by Barry Boehm, in which several of the iterations have

Spiral Model

identified purposes.
A person, group, or organization with a stake in the outcome of an application being developed.

Stakeholder

An object's status; formally defined as set of values of the object's variables. For example, an Automobile

State

object can be defined as in "early" state if its mileage value is less than 10,000 and in "late" state if greater than
150,000.

System engineering

The process of analyzing and designing an entire system, including the hardware and

software.
The process of testing an entire application (as opposed to testing its parts).
SM
Team Software Process
(TSP) A process, developed by Watts Humphrey at the Software Engineering
System testing

Institute, for assessing and improving the performance of teams developing software.
Testable

An artifact (e.g., a requirement) for which it is possible to write a specific test validating that the

product is consistent with the artifact.
Test-driven development (TOO)

A software development process in which each successive part is

developed by first creating a set of tests that validate it, then implementing the code that passes these
tests.
A requirement is traceable if the design and code fragments that implement it can be readily

Traceable

identified; a requirement is not traceable if it is unclear which parts of the design accommodate it, or which
parts of the code implement it.
The capacity of a software development process to enable developers to track each require­

Traceability

ment to the code that implements it and to track each part of the code base back to the corresponding
elements of design and requirement.
(in a state diagram) The process under which an object changes from being in one state to being

Transition

in another.
TSPi

A version of the Team Software Process® tailored to the restrictions of university student teams.

Unified modeling language (UML)
Unified Process (UP)

A graphical notation for expressing object-oriented designs.

A software development process based on named iterations, developed by Booch,

Jacobson, and Rumbaugh and made popular by Rational (and then the IBM) Corporation.
Unified Software Development Process (USDP)

A development process created by Booch, Jacobson, and

Rumbaugh, often considered most appropriate for large software projects.
Unit testing
Use case

The process of testing a relatively small part of an application such as a method.

A sequence of actions, some taken by an application and some by the user, which are common in

using an application; the user assumes a particular role in this interaction, called an "actor" relative to the
use case.
User story

An intended major usage of the application, told from the user's perspective, from beginning to

end.
Validation

The process of ensuring that a software application or artifact of the development process

performs its intended functions in the manner specified for it.

GLOSSARY

Verification

The process of ensuring that a software application is being built in the manner planned.
A software development process in which requirements are first collected, a design is

Waterfall process

developed, the design implemented in code, and then the code tested. This is performed in a single
sequence, with a small amount of overlap between the successive phases.
White box process

A method, typically testing, applied to implemented code, which takes into account the

manner in which the code is intended to operate.
Xtreme Programming
Z-specifications

See Extreme Programming.

A mathematical notation for expressing requirements precisely and formally.

765

Index
Agi le processes, 49-51,63-78

A
Abstract classes, 365

code comments in, 304

Abstract Factory:

crystal, 72-74

appl ied to Encounter, 747

detailed design and, 490

design pattern, 38 8-390

development cycle in, 68

design purpose of, 403-408

extreme programm ing, 69-71
history of, 64-65

for word processing, 409
Abstractions, 4 8 2

crashes of, 30, 700
Eclipse, 5, 1 4-16 , 51,134-136,
196-205, 268-2 72 , 466-468,
503-505 , 559, 700,723-724
Encounter, 14, 15, 1 03-117,
129-134, 187- 1 96 , 2 2 5-2 2 8 ,
250-2 5 1 , 264-2 6 8 , 2 80,

manifesto of, 64-65

2 83-2 84, 2 8 7-2 8 8 ,3 1 5-32 8 ,

methods for, 66-68

344-347,456-459,462-466,

Abstract layers, 398-399
Acceptance testing, 35-36, 713, 7 1 5

with non-agile processes, 74-75

494-503, 556-559 , 575-5 81,

Accepted projects, 16

principles of, 65-66

652-662 , 683-687, 6 8 9-691,

Accessibi lity, 332-333, 702

process qual ity in, 8 2-83

ACM/IEE-CS Joint Task Force, 12-13

refactoring, 601, 6 1 7-618

Actions, 376

scrum, 71-72

interactions with/with in, 2 49-2 50

Activity diagrams:

testing for, 71 1

Interpreter example, 419-42 2

for algori thms, 484-48 5
in uni fied language modeling, 374376

uni t tests in, 304

696-6 9 8 , 716-723
event-driven, 4 2 8

Observer example, 4 2 5-426

Agi le programming cycle, 305

with other appl ications, 706-707

Agi le projects:

packaged, 247

Actors, 250, 2 51

esti mation with, 180-1 8 2

Singleton example, 402-403

Adapter, 412-417

user stories i n , 2 5 0

size esti mate, 190

Adaptive maintenance, 733

Agi le requirements analysis, 2 4 2

State example, 4 29-431

Adequate preparation, 89

Agi le schedule, 69

states of, 2 6 2

Adjusted function points, 175--176

Algori thm(s):
backward chaining, 374-376

video store, 34-36,67, 9 5 , 159,
160, 177, 232-233, 239-241,

Agendas, 56, 165
Aggregate class candidates, 2 8 9
Aggregation:

in detailed design, 4 8 2-4 85

249,2 56,257, 2 8 2-2 8 4, 2 8 9,

expression of, 484-48 5

333,34 1 , 353, 35 8 , 369-370,

and inheri tance, 433

Alpha releases, 713-714

in layered architectures, 451
in UML, 366

Alternative architectures, 439-453,

in uni fied language modeling,

American National Standards

366-368

5 2 8-530
Institute (ANSI ) , 10

453-454, 510-516, 519-521,
544,5 47, 566-5 75,618, 6 2 2 ,
623, 631, 638, 640-64 1 ,643,
6 8 0,698-699, 707, 750-751
Approvals, of change requests, 125

Agile All i ance, 49, 64

Analysis, of configuration i tems, 124

Approximations, 171

Agile-driven approach, 76-77,540
Agile Manifesto, 49-50, 64-66

Anomalous input, 587
Anonymous CVS , 1 35

Architectural layers, 449-450,

Agi le methods:
and CMMI, 103

ANSI (American National Standards
Institute), 1 0

Architecture(s), 350, 438-475

Arbitrary defaul ts, 550
469-473

cycle of activities in, 618

Application framework library, 473

choosing between, 439, 5 2 8-530

for detailed requirements, 303-305
for high-level requirements, 252254

Application layer, 452
Applicati ons, 178
Abstract Factory example, 407-408
Adapter example of, 414-416

comparison of, 526
data Aow, 439-443
design document for, 459-466

for requirements, 239-240
with tests and testing, 6 2 2
Agile organizations, 144

as-built, 709
for ATMs, 2 60-261

design quali ty/metrics in, 5 2 5-53 1
in detailed design, 477-478
of Ecl ipse, 466-468

768

INDEX

for Encounter, 456-459, 496,
5 2 7-5 31, 720

Automated tel ler machine (ATM)
applications, 2 60-261, 444-445,

C U I - driven, 5 2 8-529

4 8 9-490

Business purpose, 2 54-2 56
Business requirements, 2 3 2
Business rules, 5 4 8

IEEE standards for, 455
independent components

Availabil ity, 2 3 5 , 2 5 9 , 700
Avoidance strategy, 1 59-160

Business use cases, 3 5 4

architecture, 44 3-447

Axis( -es) ( bulls-eye diagram ) ,

C

layered, 449-450
multiple, within applications,
452-4 5 3
for OpenOffice, 468-47 3
and proj ect plan, 455-456

1 57- 1 5 8

Capabi l i ty maturity model ( CMM ) ,
1 0, 708
Capabil ity maturity model integration

B
Backlog, 7 1

( CMMI):

Backward chaining algorithm ,
3 74-376
Backward traceabil ity, 299

and agile methods, 1 0 3
and cost estimation, 1 71
process qual i ty levels in, 1 00- 1 0 3

trade-offs with, 45 3-454
verification of, 5 3 0-5 3 1

Basel ines, for software configuration
management, 1 2 2-12 3
Basel ine defenses coverage, 5 2 4

for videogames, 412

Baseline safety, 1 2 1 , 122

virtual machine, 447-44 8

Basis paths, 6 3 5-6 3 6 , 6 3 9-640

repository, 448-449
service-oriented, 450-452
tools for, 454-455

Architecture design, 3 5

Batch sequential data Aow, 442-4 4 3

Architectures:

Beans, 4 5 5 , 4 8 5-4 86

blackboard, 449
client-server, 443

Behavioral design patterns, 390,
3 9 3-396, 417-4 3 1

event systems, 446-447

with Observer, 4 2 2-4 2 8

high-level , 467

parsing expressions i n , 4 1 7-42 2

mainframe, 4 4 3

with state design model , 42 8-4 3 1
Behavioral model ing, 708-709

pipe and filter, 44 1 -442

and organization-level qual ity, 100
Case models, 3 5 6
Case studies, see Eclipse; Encounter;
OpenOffice
CASE (computer-aided software
engineering) tools, 154,
454-45 5
Catching (exceptions) , 5 5 0
Causal analysis, 9 1
C code, 5 5 1
Changes:
branching of, 126

term inal , 443

Behavioral requirements, 2 3 3
Beta releases, 7 1 3-714

in class features, 608
i n configuration, 2 1 9
implementation of, 1 2 5

tiered, 443, 4 5 3

Beta testing, 3 5

merging of, 1 2 6

Big bang integration, 673-674
Big style output, 404

release of, 1 2 5

and detai led design, 476-477

Blackboard architectures, 449

in requirements, 2 1 9, 241

and maintenance requests, 7 3 7-73 8

Black box testing, 62 3-6 2 4 , 6 3 1 -6 3 2 ,
709
Boehm, Barry, 24, 44-46, 177-179.

and serviceabil ity, 707-708

subsidiary, 452

Ariane project, 3
Artifacts, 7, 3 5 8

Artifact readiness, 8 9
As-built applications, 709
Assessment(s) :
for agile projects, 180-1 8 2
continuous vs. staged, 1 00
of development capabilities, to
Associ ations, 3 6 3-364
Assumptions, 268
Asynchronous messages, 3 71
ATM appl ications, see Automated
tell er machine applications
Attributes, 3 6 3
in class models, 3 6 2

See also Constructive cost model

requests for, 125
responding to, 65
in source code, 7 3 5
veri fication o f , 1 2 5
Change control, 1 24-12 5

( COCOMO)
Booch, Crady, 46
Bottom-up approximation, 171

Change control board ( CC B ) , 1 2 4 ,
737

Bottom - up integration, 667, 674-677
Boundary classes, 49 1
Boundary value analysis, 6 3 2 ,

Change reporting form, 1 1 5
Charter (Ecl ipse open source) ,
1 96-2 0 3

641-642
Branch coverage, 6 3 2 , 6 3 4 , 6 3 5
Branch ing, 1 2 6 , 2 5 1 -2 5 2
Bridge bui l ding, 477-478

documentation o f , 5 5 5
Attributes-oriented tests, 670
Audits:
qual ity assurance, 92-9 3
for software configuration
management, 1 27
Authentication, 2 5 9 , 597, 706
Authors, 88
Authorization, 259, 597, 706

Budgets and budget allocation, 192 ,
1 9 3 , 628
Buffer overAow prevention, 5 5 1
Bugzilla, 96, 2 70-2 7 1 , 306, 754
Builds, 126, 674, 679-680, 6 8 9-69 1
Build or buy decision, 1 55
"Bulls-eye" diagram , 1 57-158
Business logi c , 357
Business management, 6

Automated CUI testing, 727

Business process layer, 452

Checkl ists, 8 9
document basel ining, 1 17
Checkout/checkin, 1 2 5
Choke points, 5 21-5 2 2
Cis ( configuration items) , 1 20, 12 2 ,
1 24 , 3 0 8
CIA ( Confidentiality, Integrity, and
Authentication), 259
Class(es ) , 3 5 3-354
abstract, 365
boundary, 49 1
col lection of, 408-412
control, 49 1
core, of Eclipse, 504

INDEX

Class(es), (continued)
in detailed design, 477-479,
48 2-485

for software architecture

Complete traceability, 299

alternatives, 439-453

Complexity, 592 , 593, 73 1

for State, 4 2 9

Components, 4 1 0 , 443

in U M L , 378
Class tests, 669-670

Component models, 357
Component reuse, 485-486

entity, 49 1

"Clean" code, 648
Client role, 399-400

CompOSition, 366-367
Compound objects, 47 1

within a framework, 358-359
and implementation, 540-54 1

Client-server archi tectures, 443
Close-ended questions, 249

Comprehensibility, 702
Comprehensive documentation, 65

as modularization, 6 1 6

CMM (capability maturity model),

Comprehensiveness:

module and integration testing of,
668-672

1 0, 708
CMMI, see Capability maturity model

metrics for, 334-335
in requirements analysis, 333-334
Computer-aided software engineering

development of, 408 , 4 1 0
for Encounter foreign character,
488

organization by, 2 9 1 , 3 1 4,
625-626

integration
CMMI -SW, 1 00

( CASE) tools, 1 54 , 454-455

organization of detailed
requirements by, 284-290

Coaching, 1 52
Cockburn, Al istair, 39, 72-73

Concept of operations, 247-248

reusabi l ity of, 594-595

COCOMO, see Constructive cost

Concurrence, 37 1

reuse o f, 354
in uni fied language m odel ing,
362-363
Class diagram:
for Observer, 4 2 7
from source code, 750
in UML, 368

model
Code. See also Source code

Concrete layers, 398-399
Concurrent version system ( CYS),
1 28- 1 29, 1 35

desk-checked, 597

Conditions, 2 63, 373

documentation of, 593
and method composition, 607

Confidential i ty, 259, 597, 706
Confidential i ty, Integrity, and

from OpenOffice, 56 1 -565
with open-source projects, 5 1

Authentication ( ClA), 259
Configuration, 34, 1 2 2, 1 27. See also

Classical approaches, 63

Code base, 6 1 2-6 1 3, 6 1 7

Classi fication(s):
combination of, 28 1

Code comments, 303, 304
Code generation, 540. See also

Software configuration
management (SCM)
Configuration audits, 1 27

of defects, 93-95
of defect severity, 534-535

Implementation
Code inspections, 7, 1 2 , 87, 597-599

Configuration changes, 2 1 9

of detailed requirements, 3 1 4

Code l istings, 566-575

i n large-scale projects, 308
of methods, 493

Code ownershi p , collective, 7 1

Configuration identi fication, 1 2 2
Configuration items ( CIs), 1 20 , 1 2 2 ,

Code reviews, 599

object- oriented, 280-28 1

Code walkthroughs, 599

Configuration control, 1 24

1 24 , 308
Configuration status reporting, 1 2 7

Coding standards, 7 1 , 552-554

Conquest strategy, 1 59- 1 60

Cohesion, 35 1 -353, 5 1 0

Consistency, 336-337

Classi fication methods, 2 9 1

CollabNet TeamForge, 55

Constants, 593

Class inheritance, 5 1 2

Collaboration:

Constraints, 232 , 234, 236, 2 68 , 327

of severity, 95
Classification attributes, 3 1 5

Class invariants, 540-54 1
Class invariants testing, 67 1
Class models, 355, 356
for Abstract Factory, 405-407
for Adapter, 4 1 3
attributes in, 362
for batch sequential data flow,

with customer, 65
tools for, 58
Collective code ownershi p , 7 1
Colors, 2 95-296
Comments:

Construction phase, 48
Constructive cost model
( CO COMO):
CO COMO I , 1 77- 1 79

extractable, 485

COCOMO I I , 1 79- 1 80
cost drivers, 1 8 1

and implementation, 554-555

formulas of, 1 78

442-443
for black box testing, 709

Committed plan item , 204
Common code, 592 , 593

for job duration, 492
Continual interaction, 66

for chaining rules, 376

Communication:

Continuing change, 73 1

from data flow architecture, 442

e-mail, 58

Continuous assessment, 1 00

of dependencies, 379
Facade, 4 1 0-4 1 1
of Interpreter, 4 1 9

as external interface requirement,
237

Continuous integration, 7 1 ,
678-679

and object m odels, 368
of Observer, 424-425
o f parallel communicating
processor architecture, 446
for Singleton, 40 1 -402

in extreme programming, 69
in teams, 1 44- 1 46
verbal, 57-58
Communication plan, 57
Compatab i l i ty, testing for, 706-707
Completeness, 308

Contract negotiation, 65
Contradicted requirements, 337
Control classes, 49 1
Control flow, 369 , 633
Controls, 295
Conventions, 553-554

769

770

INDEX

"Convert procedural design to
obj ects," 604-605
COREA I nterface Definition
Language (ID L), 483
Correct code, 54 1

Databases, 448-449
Data col lection, 703
Data flow architectures, 439-443

D e legation design pattern form,
43 1 -433

Data flow diagrams ( D FDs), 260-262,
522

management), 1 2 7
Delphi process, 526

Del ivery (software configuration

Correction reports, 740-74 1

batch sequential , 442-443

Corrective maintenance, 732-733
Cost(s):
of defect repair, 2 4-25, 82

detai led, 489-490
for detailed deSign, 486-490

in class models, 379
for Encounter, 464-465

and processing units, 439-440

and integration order, 676
of modul es, 675

inspection, 9 2

Data flow models, 355-356

maintenance, 734-735

for black box testing, 709

project, 49 1 -492

in unified language modeling,
376-377

as project variable, 1 57
of prototype development, 40--4 1

Data stores, 260, 376

testi ng, 34 1 -342
Cost drivers, 1 80, 1 8 1

Data tier, 453

Cost estimation, 1 69- 1 8 2
agil e proj ects, 1 8 0- 1 8 2

"Dealing with generali zation"
refactorings, 6 1 3-6 1 5

effort/duration, 1 77- 1 80
with function points, 1 7 1 - 1 77

Decision making:
buildlbuy, 1 55

methods, 1 70

Data values, 548-549

triage, 1 56- 1 57

D ependency( - i es), 268

i n schedules, 1 85
UML representation of, 367
Dependency Inversion Principle
( D l P), 48 1
DeSign, 8 . See also Design patterns;
D etailed design
constrai n ts on, 236, 327
conversion of, 6 1 2-6 1 3
defects in, 2 1 6-2 1 7
for maintenance requests,
746-747

Declaration of variables, 547

model for Encounter, 5 5 7

Decompositions, 353
Deep inheritance, 52 1 -5 2 2

phase, 2 3 7
recursive, 3 5 2

Crashes, 30, 700
Creational design patterns, 390, 39 1 ,
393, 400-408

D e faul t values, 548-549
Defects, 23-2 5

o f screens, 292-293

black box testing for, 6 2 4

simplicity of, 70
technical, 237

with families of objects, 403-408

classification o f , 93-95

and testing, 632

Singleton, 400-403
Critical paths, 1 8 5

cost to repair, 2 4-25, 8 2
count, 2 1 7

Crystal methodologies, 72-74

defined, 62 1 -6 2 2

with unified development process,
490-49 1
with unified language model ing,

without function poin ts, 1 70- 1 7 1
Coupl i ng, 35 1 -353, 5 1 0
Courage, 70

CSS processes, 53-54

in design, 2 1 6-2 1 7

Customers, 7, 1 1

detection of, 2 4 , 8 9 , 2 1 6-2 1 7
goals with, 23-24

collaboration with, 65
and developers, 70

injection of, 2 1 6-2 1 7

377-380
without design patterns, 386-388
DeSign classes, 359, 540, 54 1
D esign dependency, 394
Design documents, 459-466
Design model i ntegration, 354-357
Design patterns, 353, 383-437,
6 1 8-6 1 9

and high - l evel requirements,
246-247

location of, 279
i n open-source proj ects,

needs vs. wants of, 247
on-site, 7 1

5 1 -52
per KLOC, 2 1 4

and requirements, 23

in proposed architectures, 525

application of, 386-390

as source of requirements, 23 1

in pseudocode, 536
and quality, 2 2

behavioral, 4 1 7-43 1
characteristics of, 396-400

Customer documents, 7

and quality assurance, 8 5

creational, 400-408

Customer interviews, 3 1 1 -3 1 2
Customer problems metrics, 30
Customer satisfaction metrics, 30

repair of, 24-25, 8 9

and design purpose, 384-386
and flexibil ity, 5 1 2
forms of, 43 1 -434

vision of, 247-248

CVS (concurren t version system),
1 28- 1 29, 1 35
Cyclical development, 39
Cyclomatic complexity, 636, 638
D
Daily buil ds, module and integration
testing of, 6 79-680
Dashboard, 2 1 8-2 1 9
Data, location of, 609-6 1 2

resolution of, 2 1 7
root causes of, 738-739
severity classification of, 94,
534-535
types of, 95
Defect density, 2 9-30
Defect management, 93-96
Defect metrics, 2 1 6-2 1 7
Defect recording log, 558
Defensive programming, 548-5 5 2
De fined CMMI leve l , 1 0 1 , 1 02
D elay, sources of, 5 1 8

structural , 408-4 1 7
by type, 390-396
Design phase , 33, 35
D esign principles, 350-360,
479-48 1
design model integration,
354-357
frameworks, 357-359
goals, 35 1 -354
IEEE standards, 359

INDEX

inspections process for, 344-347

Document creation, 2 2 0

of Abstract Factory, 403-408

organizati on o f, 280-29 1

Domain classes, 285-290, 358-359,

of Adapter, 4 1 2-4 1 3

prioriti zati o n o f, 30 1 -302

and design patterns, 384-38 6
of Facade, 408-410

and proj ect management, 300
securi ty, 296

o f Interpreter, 4 1 7-4 1 8
o f Observer, 42 2-42 4

tests for, 302-303

Domain-specific test input, 627

traceab il ity o f, 297-300

Drafting, 2 2 1

o f S i n gleton, 400-401
of State , 428-429

for user interfaces, 2 9 1 -296
Web- based tools for, 305-308

D resdner Klei nwort Wasserste i n

writing of, 3 1 4-315

Drivers, module and i n tegrati o n

Design purpose:

Design qual ity and metrics, 458,
508-537

479, 5 4 1
for Encoun ter, 287, 496
intent of, 540

(DrKW) , 5 1 -52

Devel opers:

tes ting w i t h , 667-668

i n archi tecture selection, 5 2 5-53 1

as alpha/beta testers, 7 1 4

of detailed designs, 53 1 -536

and customers, 70

CO COMO I formula for, 178

for flexibility, 5 1 2-5 1 3

as stakehol ders, 247

estimation o f, 1 77- 1 80

Durati on:

of j obs, 17 1

for reliability, 521-523
for reusabi l i ty, 5 1 3-5 1 6

and testing, 628
Devel oper requirements, 2 79

Dynamic instrume ntati on, 724

for robustness, 511-5 1 2

Developer's gUide (Ope n O fAce ) ,

Dynamic vi ewpo int, 396, 397-398

for securi ty, 523-5 2 5
fo r space efficiency, 5 1 9-52 1

560-56 1
Development:

for sufAciency, 5 1 0-5 1 1

Boeh m's spi ral model for, 44-46

for time efficiency, 5 1 6-5 1 9

test-driven, 66, 70

for understan dab i l i ty/cohesion/
coupl ing, 510
Design recovery, 750
Design speci fications, 586

Devel opme nt manager, 1 5 2
Development media, 236
Development processes, trade - o ffs i n ,
74-75

Desirabl e requirements, 289

Development team s, 7

Desk- checked code, 597

Devic e - based con trols, 295

Detai led design(s ) , 35, 350, 476-507
and agi l e processes, 490
architecture in, 477-478

DFDs, sec Data flow diagrams
DIP (Dependency Inversion
Principle), 48 1

E
Eclipse (case study ) :
con figuration management for,
1 34-136
detai led design of, 503-505
high- level architecture o f, 467
high- level requirements for,
2 68-272
implementation of, 559
i n tegrated devel opment
environment, 1 4, 1 6
open source project, 1 5- 1 6

classes/functions/al gori thms i n ,
48 2-48 5

Directed graphs, 709-7 1 1

platform architecture of, 468

Di sasters, so ftware, 3-5

platform subproj ect, 2 69-2 72

component reuse i n , 485-48 6

D i saster recovery, 121, 122

project management for,

design qual i ty/metrics of, 531-536
of Eclipse, 503-505

Distinct paths, 635-636
Distributed teams , 146-15 1

Release 3_0 of, 203-2 05

o f Encounter video game , 494-503

Documentati o n , 1 4 1 , 592

so ftware architecture o f, 466-468

inspection of, 534-536

as - needed, 65-66

agai nst in terfaces, 48 1 -482
metrics for, 533-534

of attributes, 5 5 5

object- oriented, 479-48 1

comprehensive, 65

reusabi l i ty example for, 5 1 4--5 1 6

o f configuration items in need of

road map for, 478-479
security of, 5 2 4-5 2 5

for Ecl ipse project management,

sequence and data fl o w diagrams
for, 486-490
in unified development process,
490-491
updates of project with, 49 1 -493
use cases i n , 477-478
Detailed requirements, 232-233,
2 78-330
agi l e methods for, 303-305
defined, 2 79-280
e ffects on project o f, 308-309
for E ncounter video game, 3 1 5-328
error conditions, 2 96-2 97

of code, 593

change, 1 2 4
196
for Encounter tests/testi ng,
7 1 6-723

1 96-205

tech nology proj ect charter,
196-203
Test and Performance Tool s
Platform , 7 0 0 , 723-724
Edges, 709-710
E ffiCie n cy, 354, 702
i n development, 73
of implementation, 595
i n so ftware deSign, 35 1
E ffort:

for high-level requirements,
2 48-249

COCOMO II formula for, 1 80

of method, 544

esti mati o n o f, 1 77-180

in duration formula, 178

o f qual ity, 83-8 4

EI (external inputs) , 1 72

of requirements, 238-239
for software architecture design,
459-466

EIN (external inquiri es ) , 172, 173

o f tests and testing, 626, 6 2 7
Document base l i n i n g checkl ist,
117

Elaboration phase , 47, 48
ELF (external l ogical files), 173
E-mail communication, 58
Embedded appl ications, 1 78
Encapsulation, 552

771

772

INDEX

E ncounter (case study ) , 1 4, 1 5
bui l ds for, 689-69 1
candi date classes for, 287-288
class test for, 683-687

Essential requirements, 289
Estimabil i ty, 253

Estimation, 1 4 1 . See also Cost
esti mation

code l isting from, 575-58 1
con figuration management pla n

organ i zation by, 28 1 -2 8 2 , 2 9 1
testing of, 7 1 7
Feature creep, 305
Feedback, 37, 70, 648

of MR efforts, 745

File i dentification, 7 1 6

of MR implementation , 735

Filters, 44 1 -442

precision of, 1 69- 1 70
of size, 492-493

Flexibility, 35 1 , 353

detailed design of, 494-503
detailed requirements in, 280,

of story points, 1 8 2

for, 1 29- 1 34

283-284, 3 1 5-328

design quality/metrics for, 5 1 2-5 1 3
of implementation , 592-594

o f time-to- complete, 492-493
EthiCS, 1 2- 1 4

Focused inspectors, 8 9

implementation model for,
556-559
inheritance relationships in, 288

Evaluation , o f con figuration i tems,
1 24

Forward traceabil i ty, 299

integration plan for, 689

Event(s) , 372-374

Framework(s), 485-48 6

project management plan for,

Event- driven applications, 428
Event systems architectures, 446-447

decomposition of, in Encounter,
462-464

quality assurance for, 1 03- 1 1 7
requirements inspection for,
344-347

Exception (s), 543, 549-55 1

for role-playing game, 494-495

software architecture design for,

Expert systems, 374, 376

1 8 7- 1 96

456-459
software design document for,
462-466
SRS for h i gh-level requirements,
2 64-268

Exception handling mechanism, 548
Execution time, 725
Explicit numbers, 546-547
Expressions, 4 1 7-42 2
Expressive nami ng, 544-546

Follow-up meetings, 9 1
Four "P's," 6

for software design, 357-359
Framework classes, 359
Framework layer, 472-473
Functions:
i n detailed design , 48 2-485
hierarchy of, 678

Extensions, 250

n ames of, 593-594

External agencies, 260

system testing for, 696-698

External hardware/software, 523

precise specification of, 483-48 4
public, 527

test documentation for, 7 1 6-723

External inputs (EI) , 1 72
External inquiries (EIN ) , 1 72 , 1 73

i n sequence diagram, 369, 370
verification of, 532-533

External i nterfaces, 1 88 , 234, 237
External logical files ( ELF) , 1 73
External outputs ( E O ) , 1 72- 1 73

Functional groups, 1 43
Functionality, 1 57, 449-450 , 48 1 -48 2
Functional managers, 1 43, 1 44

External quality, 2 1 4, 2 1 5
External release, 40
Extractable comments, 485
"Extract hierarchy," 606

Functional requirements, 233, 300
Functional speCifications, 2 79

Extreme programming (XP) method,
69-7 1

Function -oriented organizations, 1 43

unit testing for, 652-659
use case scenarios for, 250-2 5 1
verification a n d validation plan for,
2 25-2 28
EncounterCharacter, 500-502
class unit testing for, 659-662
code l istings for, 575-58 1 ,
652-659
source code for, 559
unit test for, 659-66 2
End users, 7
"Enforce Intentions" principle,

F

55 1 -552
E rihancement, 73 1 -732

Facade, 408-4 1 2

Functional tests, 695, 696
Function hierarchy, 2 8 2
Function parameters, 546
Function pOi n ts method:
adjusted, 1 75
calculation of, 1 72- 1 75

design pattern , 527
design purpose of, 4 1 0

computation with, 1 74
conversion to code, 1 75- 1 76

Entity classes, 49 1

for Encounter, 4 1 2

estimation with, 1 7 1 - 1 77

Environment(s) :

objects in, 449, 680-68 1

E nterprise beans, 485-48 6

a n d i mplementation, 555-556
network-dominated, 45 1
for programming, 555-556
and system tests, 695
EO (external outputs) , 1 72- 1 73
E quivalence classes, 640
Equivalence partitioning, 632 ,
638-64 1
Error conditions, 234, 2 96-297
Error handling, 1 09- 1 1 0, 234,
237-238
Error rates, 2 20, 749

refactoring by, 6 1 6

estimation without, 1 70- 1 7 1
Future requirements, 334

Face-to-face meetings, 58

Fuzzy descriptors, 4 92-493

Faga n , Michael , 8 7
Failed test, 650-65 1
Failure, of application, 752
Failure speci fication, 700
Families, object, 403-408
Fan-in measures, 509
Fan-out measures, 509
Fault i nj ection , 628
Feasibility studies, 40, 44
Feature(s) :

Fuzzy methods, 526, 530
G
Gage, Debbie, 3-4
Gaming Consolidated Industries
(GCI) , 1 06- 1 09
Garla n , D., 439
Generic computation , 593
Geographically distributed
development (GOD ) , 1 46- 1 5 1

INDEX

Geographically distributed teams, 5 8
Global vari ables, 5 4 5 , 546, 5 9 2 , 5 9 3

user i n terface spec i ficati o n s ,
2 54-2 5 8

and classes, 540-54 1
code l i s t i ngs for, 566-575

H i gh - level task chart, 1 92

coding stan dards for, 552-554

o f con figura t i o n man agem ent, 1 2 2
w i th de fec ts , 2 3-24

H i s tory of req u i rements, 3 0 8
Hum phrey, W . , 1 5 4 , 6 4 3

a n d comme nts , 554-5 55
defe n s ive programming,

fo r im provement, 2 2 3

Hybrid open-source/proprietary

Goal s :

for so ftware con figurati o n

processes, 54

o f Encounter, 556-559, 565
EncounterCharacter code l is t i ngs

manageme n t , 1 2 1
for so ftware design, 3 5 1 -3 5 4
o f so ftware engi neering, 1
Grammars , 4 1 7-4 1 8
Graphics, l eve l - based, 748
Graph ical user i n terface (GU I ) :
automated tes t i n g o f , 727

I D E , see I n tegrated deve lopment
environment; I n teractive
developme n t enviro n m e n t
I D L ( I n terface D e fi n ition Lan guage ) ,
483

common terms for, 295

I EEE quality documen ts , 85-87

and customer, 2 3 7

IEEE stan dards :

for Encoun ter, 4 3 0
orga n ization b y , 2 8 3-2 8 4 , 29 1

547-552
o f Ecli pse, 559

master copies of code a n d
documen tati o n , 1 27

for, 5 75-5 8 1
of m a i n tenance request, 747-749
methods for, 54 1 -544
object-ori e n ted, 6 2 5-62 6
o f OpenOffice , 5 59-565
prac tices, 544-547
progra m m i n g la nguage for, 540
a n d programming tools/
e nviro nments , 5 5 5-556

prel i m i n ary, 2 55-2 56
for prototypes, 40-4 1

severi ty c l ass i ficati o n , 5 3 4

Implementation class, 5 4 1

so ftware archi tecture , 4 5 5

I m plementati o n l anguages, 1 55- 1 56

req u i rements test for, 3 4 1

so ftware audits, 1 2 7

Implementation phase, 3 3 , 3 5

a n d states, 3 74

so ftware c o n fi guration

Implementation qual i ty, 5 8 4-597

system tes t i n g with, 697-698
transitions of, 2 5 6-2 5 8
Graphic beans, 4 8 5-486

ma nagement plan, 1 2 8
so ftware design docume nt, 3 5 9 ,
455-456, 49 1

and code i n spec t i o n s , 597-599
and degree o f security, 596-597
a n d e ffi c iency, 595

Graphs, directed, 709-7 1 1

so ftware m a i n tenance, 74 1 -749,

and flex i b i l i ty, 592-594
metrics for, 585, 592 , 594-597

G U I - driven archi tecture , 5 2 8-529

752
so ftware proj ect management plan,

G U I , see Graph ical user i n terface
GUI tra n s i t i o n s , 2 5 6-2 5 8

1 8 6 , 1 8 7- 1 96

and pair progra m m i ng, 599
and rel i ab i l i ty, 596

so ftware qual ity assurance plans,
2 7-2 8 , 8 5-87, 1 0 3 - 1 04

and reusab i l i ty, 594-595

H
Habitab i l i ty, of conventions, 73

so ftware requireme n t

a n d scalab i l i ty, 596

H acke rs , 70 3

spec i ficati o n s , 2 3 9-240, 2 8 0 ,

Hardware, as external i n terface

282, 289

req u i rement, 2 3 7
Health I n surance Portabi l i ty a n d
Accou ntab i l i ty A c t ( H I PAA) ,
2 5 9-260
" H i de delegates" re facto ring, 609

so ftware test documentati o n , 659,
714
so ftware veri fication and validation
p l a n , 2 2 3-2 24
Standard Diction ary o f Measures of

H i e rarchy, 2 8 2

the So ftware Aspects of

H i gh cohes i o n , 3 5 2

Dependab i l i ty, 526

H i gh - level archi tec ture, 467
H igh - level requirements, 2 3 2-2 3 3 ,
2 4 2 , 2 45-2 76
agile methods for, 2 5 2-2 54
and customer wants, 2 46-2 47
d iagrams for, 260-2 64
for Ecli pse, 2 6 8-272
i nterview and documentation
process for, 2 4 8-249
main fu nctions and use cases,
249-2 5 2
f o r O p e n O ffice, 2 7 3-274
overview for, 249
securi ty requirements, 2 5 8-260
and stakeho l der v i s i o n , 2 47-2 48

Standard Dictionary o f Measures to

and robustness, 5 8 7-592
a n d sufficie ncy, 5 8 6-5 8 7
Imprec i s i o n , o f req u i rements, 3 1 5
Im provem e n t :
across projects , 2 2 2-2 2 3
o f i nspection process, 9 1
meta-process for, 98
w i th metrics, 2 1 9-2 2 3
w i th i n project, 2 1 9-222
I nception phase, 33, 3 4 , 47, 48
I n -code comme nts, 303

Produce Re liable So ftware,

I n consi stency, 3 0 8 , 3 3 6

3 4 3-344

I ncreme ntal development, 3 9-40

Stan dard Glossary o f So ftware

I ncremental i n tegra t i o n , 674, 675

Engi neeri ng Term i n o logy,

I ncubator projects, 1 6

62 1 -622

I n depe n d e n t components

I F P U G ( I n ternational Function Poi n t
U sers Gro u p ) , 1 72- 1 7 3
I LF ( i nternal logical fi l e s ) , 1 72 , 1 7 3
I l legal data, 5 4 8-549
"Illegal" i n put, 297
Impact analysis, 737
Implementa ti o n , 8 , 5 3 9-5 8 3
agile/nonagile approaches to, 540
o f changes, 1 2 5

architec ture , 44 3-447
I n depende n t veri fication and
validati o n , 2 2 4
I n dividual class candidates ,
2 8 9-290
I n d ividuals a n d i n teractio n s ,
processes and t o o l s vs . , 64-65
I n formation hidi ng, 3 5 1 , 3 5 4 , 546
I n frastructure layer, 47 1

773

774

I NDEX

Inheritance, 480, 6 1 2
in Adapter, 4 1 6-4 1 7
and aggregation, 433
in uni fied language model ing,
364-366
Initial CMMl level , 1 00- 1 0 1
Initialization of variables, 545, 547
Input(s), 587, 6 2 7
Inspection(s), 1 2
code checklist for, 597-598
detailed, 1 08
of detailed designs, 532, 534-536
for detailed requirements, 344-347

International Standards Organization
( I S O ), 1 0, 8 2

Legal data, 548-549
Legitimate traffic analysis, 5 2 5

Interpretation, 42 1 , 447-448

Lehman, M . , 73 1

Interpreter, 4 1 7-42 2

Levels, 397

Interventions, quality assurance, 9 3

Libraries, 358 , 470-473

Interviews:
with customers, 3 1 1 -3 1 2

Library classes, 4 1 7

for high - l evel requirements,
2 48-249
with stakeholders, 248
" Introduce module" refactorings,
6 1 6-6 1 7

Life cycle:
of agile methods, 6 1 8
of Encounter V&V, 2 26-2 2 7
Life cycle models, 3 2
Lightweight requirements, testing
with , 708-7 1 2

process for, 90-92

Introductory team software process
(TSPi ) , 1 52- 1 54

for process quality, 8 7-92
and quali ty, 8 1

Invariants, 483-484, 540-54 1 , 543,
671

conversion of function points to,
1 75- 1 76

time/cost requirements for, 92

I S O (International Standards

effort/duration estimation from ,

and V&V, 2 6

Organization), 1 0, 8 2

Inspection meetings, 9 1 , 1 1 6- 1 1 7

Issuezilla ( lZ ) , 274, 727, 754-755

Inspectors, 88-8 9

Iterations:

Installation and instabi l i ty, testing for,
707
Installation test, 7 1 5
Institute of Electrical and Electronics
Engineers (IEE E ) , 1 0. See also
IEEE standards
Instrumentation, 724
Integrated development environment
(IDE ) , 1 5
Integrated tools, 1 54
Integration. See also Module and
integration testing

of agi le processes, 50
in Boehm's spiral model, 45
of unified process model, 46-47
Iterative development:
models for, 9
in software process, 39-40
IZ, see Issuezilla
J
Jacobson, Ivar, 46
Java API, 363, 365-367, 4 1 6 ,
426-428, 468 , 48 2 , 48 5 , 553

continuous, 7 1

Java Beans, 455

defined, 667

Java development tools (JOT),

planning for, 565

2 0 2-203
Javadoc, 306 , 307

testing for, 672-679, 7 1 5 , 7 1 8
Integration baselines, 688-69 1

JOT (Java development tools),

Integrity, 2 5 9 , 597, 706

202-203

Intellectual distance, 1 2

Joch, Alan, 5 1 -52

Intent, 54 1 -543

J Unit, 648-6 5 2
J Unit tests, 6 2 7 , 7 1 1

Interaction, continual, 66
Interactive development environment
(IDE) , 448 , 455

"Just-in-time" planning, 70

Interface, user, see User Interface ( UI)
Interface Definition Language ( lOL),

K
Keyboard actions, 374

483
Interface functions, 48 1
Interface Segregation Principle, 48 1

KitchenViewer, 384-390

Interfacing flexibi l i ty, structural
design patterns with, 4 1 2-4 1 7
Internal logical files ( lLF), 1 72 , 1 73
Internal processing, 5 5 1
Internal quali ty metrics, 2 1 4-2 1 5
Internal release, 40
International Function Point Users
Croup ( IFPUC) , 1 72- 1 73

KLO C , see Line(s) of code
Known issues, 54 1 , 543

Linear regression, 745
Line(s) of code ( KLOC), 2 9-30 , 1 78

1 77- 1 80
Lines coded per man-month (MM),
214
Lines-of-code estimations:
with function points, 1 7 1 - 1 77
without function points, 1 70- 1 7 1
Liskov Substitution Principle,
480-48 1
List and cut process, 2 8 7
Load testing, 699-700
Locally modified status, 1 29
Logging subsystems, 549
Login, secure, 524
Loops, 545, 547
Low coupling, 352
M
McCormick, John, 3-4
Magnitude, estimation of, 1 79
Mainframe architectures, 443
Main functions, high- level
requirements for, 249-2 5 2
Main menus, 294
Main success scenario, 2 5 0
Maintainability index, 53-54
Maintainability requirements, 235
Maintenance, 8. See also Software
maintenance
Maintenance efforts, 753
Maintenance metrics, 75 1 -753
Maintenance phase, 33, 36
Maintenance problem analysis,

L
Language issues, 1 55- 1 56 , 236 , 286
Large-scale projects, 308
Launch issues, 1 53
Layered architectures, 449-450,
469-473
Legacy systems, 749-750

743-746
Maintenance processes, 736-740
Maintenance requests (MRs),
73 1 -732
Major number, 1 35
Managed CMMl level, 1 0 1 , 1 02

I NDEX

Management, of maintenance

for internal quali ty , 2 1 4-2 1 5

Mutation testing, 6 2 8

for load/stress testing, 70 1 -702

Mutual fund application, 4 2 7

Management plan, 1 8 5- 1 8 7

for monitoring quality, 8 5

M V C (Mode l - View Controller),

Managerial processes:
for Encounter video gam e , 1 89- 1 95
for quali ty assurance, 1 04- 1 06

for prioritization, 338
for process, 96-99
in project management, 2 1 3-2 23

The Mythical Man-Month (Fred Brooks) ,

Manifesto for Agil e Software

qual ity, 2 9-30, 584-600

requests, 734-735

428
1 45

Development, see Agil e

for requirements analysis, 332-348

Manifesto
Martin, Robert, 479

for serviceab i lity testing, 708
for software maintenance, 75 1 -753

Matrix organizations, 1 43- 1 44

for traceabi l i ty, 343

expressive, 544-546

Mean time between fai lures (MTBF ) ,

tracki ng of, 628

of functions, 5 93-594
of variables, 593-594, 602

596, 700

for unambiguity, 336

N
Naming:
consistency with, 592

Mean time to failure (MTTF ) , 30

Metrics analysis, 734 , 739

Naming conventions, 553

Mediator design pattern, 394-395
Meetings:
agendas for, 1 65

Metrics coll ection, 8 9-90

Narrow interfaces, 4 t o, 443

Metric h istory, 1 1 3

NASA, 279

Middle tier, 453

Native- l ang projects, 1 6

conducting, 1 64

Migration plan, 748

NATO Study Group on Computer

face-to- face, 58

Milestone completion, 2 1 9

follow-up, 9 1

Minor number, 1 35

Near-shore team distribution, 1 48

inspection, 9 1 , 1 1 6- 1 1 7

Missing requirements, 340

Needs a patch (status ) , 1 29

m inutes for, 57

Misuse cases, 339

Needs merge (status) , 1 29

planning of, 1 64
project planning, 208-2 t o

Model (appl ication ) , 247

Science , 2

Modeling tools, 454--455

Negotiation, contract, 65
Network assembly, 4 1 9-423

Menus, system , 2 9 4

Model -View Controller (MVC ) ,

Network-dominated environment,

Merging ( o f changes) , 1 26

428
Moderators, 88

Nodes, 260, 376

Modularity, 35 1
Modules (modularization ) , 463, 464,

Non-agile approach ( es) , 75-76
with agil e processes, 74-75

Metaphor, 7 1
Meta-processes, 96, 98
Methods:
for agile processes, 66-68 . See also
Agile methods
classi fication of, 493

6 2 5-626, 676, 677, 720
Module and integration testing,
666-693

45 1

to detailed design, 490
for detailed requirements, 304
to implementation, 540

code standards for, 553-554

of classes, 668-672

Nonambi guity, triage for, 335-336

composition of, 606-607

class test, for Encounter, 683-687

Nonfunctional requirements,

for distributed development,

of daily builds, 679-680

1 49- 1 5 1
documentation of, 544

integration, module , 672-679,
68 2-683

for estimation, 1 70

of interfaces, 680-68 2

execution time of ( Ecl ipse ) , 725

of module integration, 68 2-683

fuzzy, 5 2 6 , 530

with stubbs and drivers, 667-668

for implementation, 54 1 -544
purely functional, 543

Module dependencies, 675
Module interfaces, 680

testing of, 642-647
Method invocations (Eclipse ) , 725

Module sel f-dependency, 674
Mouse actions, 256, 374, 495

Metrics, 2 1 -2 2 , 2 8-3 1

MRs (maintenance requests) ,
73 1 -732

for alphalbeta testing, 7 1 4
benefits of, 28-29
for comprehensiveness, 334-335

MTBF (mean time between failures) ,
596, 700

233-238 , 299-300
traCing and testing of, 300
veri fication of, 533
Nonfunctional testing, 695-696,
698-708
compatibi l i ty , 706-707
installation and instabi l i ty, 707
with l i ghtweight requirements,
708-7 1 2
load/stress event, 699-700
performance, 698-699
recoverab i l i ty, 700-702
rel iabi l i ty and availabil ity, 700
security, 703, 706

for consistency, 337
for detailed design, 533-534

MTTF (mean time to failure ) , 30

serviceabi l i ty, 707-708

Mul tiple platforms, tests for, 707

usab i l i ty , 702-705

on detailed requirements, 3 1 5
for high-level requirements, 3 1 3
for implementation quali ty, 5 8 5 ,
5 9 2 , 5 94-599
for install ation and instabi l i ty
testing, 707

Multiple software architectures,
4 52-453
Multiple subsidiary architectures,
453
Multiplicative cost drivers, 1 80
Multiplicity, 363, 364

Nonrepudiation, 2 5 9 , 597, 706
Nontrivial algorithms, 484
Non-unit tests, 6 2 6-627
Numbers ( explicit) , 5 46-547
Numbering system , for requirements,
333

775

776

INDEX

o
Objects, 369
Object diagrams, 368, 369
Obj ectives;
o f team so ftware process, 1 5 1 - 1 5 2
in UP model , 48
Object Managem ent Croup (OMC) ,
3 6 1 -3 6 2
Obj ect models , 3 6 8
Object-oriented (00) programming;
classes in, 54 1
classification i n , 2 8 0-2 8 1
detailed design, 479-48 1
functional requirements
orga n i zation of, 2 8 5-2 8 6
i mplementations and testing i n ,
6 2 5-62 6
i nteractive development
environments , 455
non-OO programming vs . , 2 8 1
and 00 style , 2 8 2
tools for, 5 5 5-556
Observer, 4 2 2-42 8
O C P ( O p e n - Closed Pri n c i p l e ) , 4 8 0
O ffshoring, 1 46- 1 48
OMC ( Obj ect Management Croup) ,
3 6 1 -362
O n - s i te customers , 7 1
00 program m i ng, see Objectoriented programming
Open - Closed Pri nciple (OCP), 480
Open-ended questions, 249
Open O ffice (case study ) ;
architecture o f , 469
code from, 56 1 -565
communication screenshot, 1 7
directed graph for, 7 1 0-7 1 1
high-level requirements for,
2 73-2 74
implementation of, 559-565
i nfrastructure l ayer of, 47 1
office productivity suite, 1 4 , 1 6 , 1 8
project management for, 205-208
software archi tecture for, 46 8-473
software maintenance of, 75 3-756
student project, 1 6- 1 8
system abstraction l ayer of, 470
word processing program i n , 1 7
OpenOffice. org (000), 726
Open- source processes, 5 1 -55
Open Source Security Testi n g
Methodology Manual
( O S STMM ) , 70 3 , 706
Operating systems , past versions of,
707, 708
Operating system layer ( O S L ) , 470

Opti m i z i ng CMMl leve l , 1 0 1 , 1 02
Optional requirements, 2 8 9

People management, 6-7, 1 2
Perfective maintenance, 7 3 3

Organic applications, 1 78

Performance, testing for, 69 8-699

CMMI model for, 1 00

Performance requirements, 2 3 5
Personal So ftware D ocumentation
( PS D ) , 557

of detailed requirements, 2 8 0-2 9 1

Personal So ftware ProcessSM ( PS P ) ,

Organ i zati o n , 1 4 1 . See also Project
m anagement organization

for Encounter video gam e , 1 8 8- 1 8 9

1 0, 1 02- 1 0 3

method, for detailed requirem ents,
314

Person-hours, 1 7 1
Phases, 9

with staged processes, 1 00
and traceabi l ity, 3 42-3 4 3
Organizational leve l , process qual i ty
at, 1 00- 1 0 3

of maintenance requests, 74 1
and metrics, 2 2
i n schedules, 1 8 3
in software process, 3 2

Organizational risks , 1 59

of software process, 3 3-36

Organ ized chaos, 7 1

of uni fied process mode l , 46-47

"Organizing data" re fac tori ng,
6 1 0-6 1 2

in vi deo store exam ple, 3 6
i n waterfall process m o d e l , 3 7

Orthogonal use cases, 2 5 2
O S L ( operati ng system l ayer ) , 470

P i p e a n d filter archi tectures,
44 1 -442

OSS processes, 5 3-54
OSSTMM ( Open Source Security

Plans;
detail of, 74

Testing Methodol ogy M anual ) ,
70 3 , 706
Outputs , 404, 42 1 -4 2 3
Output trace, 724

following, 65
for software configurati on
management, 1 2 7
Planni ng, 8

Overtime h ours, 2 1 9

for i n spection process, 9 1

Overwrite safety, 1 2 1 , 1 2 2

"just - i n -time," 70
for metrics, 2 1 7

P

process of, for XP, 70
for process qua l i ty, 8 3-87

Package s , 3 5 5 , 3 6 3
Packaged applicatio n s , 2 4 7
P a i r programming, 6 5 , 7 1 , 1 6 2 , 599
Parallel communicating processor
architectures, 444-446

for qua l i ty, 2 7-2 8
Planning manager, 1 5 2
Planning phase, 3 3 , 3 4
Platform ( s ) , 4 4 0 , 444

Parallel operati ons, 5 1 7, 5 1 9

as constra i n t , 2 3 6

Parameters, 546

Ecl i pse a s , 1 5 , 202

Parameterizing, 5 1 3-5 1 4
Parameter space , 6 3 8 , 640
Parameter values, 552

Plug- i n development environment
(PDE), 203
Plug- i n versi o n numberi ng, 1 3 6

Pars i n g expressi ons, 4 1 7-42 2

PMC ( project management

Partitions, 6 3 8

comm i ttee ) , 1 9 8- 1 99

Parti tioning, 645
Password stren gth , 525

Policies, 5 8
Polymorphi s m , 3 8 6 , 4 8 0

Patch l atency, 525

Portab i l i ty requirements, 2 3 5

Patch releases, 73 9-740
Path coverage , 6 3 2 , 6 3 4-6 3 8
Pattern application rol e , 399
Payoff calculation, 4 3-44
PDE (plug- i n development
environment), 203
Peer organizational structure ,
1 46
Peer process, for i nspections,
88
Peer teams, 1 62

Postconditions, 48 3-4 8 4 , 5 4 2 , 5 4 3
Postmortem activity, 2 2 1
Postmortem data and ana lysi s , 3 1 3 ,
315
Post-uni t testi ng, 624-62 5
P owerPoi n tTM , 3 1 2
Precision, estimate, 1 69- 1 70
Precondi tions, 48 3-4 8 4 , 5 4 2 , 5 4 3 ,
587
Presentation tier, 4 5 3
Preventive mai ntenance, 7 3 4

INDEX

Prioritizatio n :
o f detailed requirements, 3 0 1 -3 0 2
metric for, 3 3 8
and quality assurance, 727
i n requirements analysis, 3 3 7-3 3 8
Priority ( o f defect ) , 9 3 , 9 5
Privacy, 2 5 9
Problem reporting, 1 09- 1 1 0,
1 1 4- 1 1 5
Procedures, quality assurance, 8 5
Process(es ) , 6 , 9- 1 1 , 3 2-6 1
agile, 49-5 1

Programming conventions, 5 4 3 ,
556-557, 5 6 5
Programm i n g l a n guage, for
implementation principles, 540
Proj ects, 6
costs associated with, 49 1 -492

Project teams, 1 42
Proj ect variables, 1 57- 1 5 8
Promotion, 602
Proofs of concept, 40-44
Property-based security metrics,
5 2 4-52 5

documentation of, 7
effect of detailed requirements o n ,
308-309
l arge - scale, 3 0 8
roles a n d responsibilities i n , 1 8 9
in software engi neering, 8-9

and feasibility studies, 44

Project dashboard, 2 I 8-2 I 9

iterativeli ncremental processes,

Project management, 6, 1 40- 1 6 1 ,

3 9-40

Project status document, 306

1 68-2 1 2

maintenance, 73 6-740

and detailed requirements, 300

open- source, 5 1 -55

for Eclipse open source project,

Prototypes ( p rototyping) , 3 3
development costs o f , 4 I -42
payoff calculation for, 4 3-44
release o f, 40
i n software process, 40-44
PSD ( Personal Software
Documentatio n ) , 557
Pseudocode, 484-4 8 5 , 5 3 5-5 3 6

P S P , see Personal Software ProcessSM
Public functions, 5 2 7

p arallel communicating, 444-446
phases of, 3 3- 3 6
and prototypi ng, 40-44

for Encounter proj ect, 1 8 7- I 96
management plan for, 1 8 5- 1 8 7

Purdue Usability Testing
Questionnaire, 704-705
Purely functional methods, 5 4 3
Purpose:

1 96-205

and spiral mode l , 44-46

for Open Office project, 2 05-208

unified process methodology,

quality i n , 2 1 3-2 1 5 , 2 2 3-2 2 4

46-49
waterfall process model , 3 7-3 8
Processes and tools, i ndividuals and

risk management i n , 1 5 8- 1 62

i nteractions vs . , 64-65
Process improvement, 96-99
Process metrics, 29
gatheri ng, 99
quality in, 96-99
Process models, 3 2
Process quality, 80- 1 1 9

application, 2 5 4-2 56

design, see Design purpose

scheduling for, 1 8 2- 1 8 5
tools and techniques for, 1 5 3- 1 5 8
Proj ect management committee
( PMC) , 1 98- 1 99
Project management estimati o n ,
1 69- 1 8 2
agi le proj ects, 1 8 0- 1 8 2
cost estimatio n , 1 69- 1 70
effort/durati o n , 1 77- 1 80

Q

QA, see Qual i ty assurance
Qualifier number, 1 3 5
Qualities, 2 3 4

Qual i ty, 1 1 , 2 1 -2 8 , 3 0-3 1 . See also
Metrics
for agile projects requirements
analysis, 3 3 2

i n agile processes, 8 2-8 3

with function points, 1 7 1 - 1 77

attributes of, 2 3 4-2 3 6

CMMI , 1 00- 1 0 3
defect management, 9 3-96

methods for, 1 70
without function points, 1 70- 1 7 1

defined, 2 2-2 3
of implementation, 5 8 4-597. See

Encounter videp gam e , 1 0 3 - 1 1 2
inspections, 8 7c..9 2
at organizational leve l , 1 00-- 1 0 3
planning for, 8 3-87
principles of, 8 1 -8 2
a n d process i mprovement, 96-99
and process metrics, 96-99
reviews/audits, 9 2-9 3

Project management metrics,
2 1 3-2 2 2
identification o f , 2 1 6-2 1 7
i mprovement with , 2 1 9-22 3
monitor/review for, 2 1 7-2 1 9

planning for, 2 7-28
in project management, 2 1 4-2 1 5 ,
2 2 3-2 2 4

planning for, 2 1 7

as proj ect variable , 1 57

Project management organizati o n ,
1 42- 1 5 3

Process speed, 595

agile, 1 44

Product, 6-8

function- oriented, 1 4 3

Product artifacts, 7

geographically distributed
development, 1 46- 1 5 1

Productivity, of maintenance, 7 5 3
Productivity measurements, 7
Product metrics, 2 9
ProfeSSionalism, 1 5 1 - 1 5 2
Profiling process, 72 3
Program control graph, 6 3 2 , 6 3 7
Programming:
extreme, 69-7 1
and implementati o n , 5 5 5-556
pair, 65, 7 1 , 1 62

also Implementation quality

internal, 2 1 4-2 1 5

matrix, 1 4 3- 1 44
project-oriented, 1 42
team size, 1 44- 1 46
team software process, 1 5 1 - 1 5 3
Project managers , 1 40- 1 42 , 3 00
Project mi lestones, 2 1 6
Project- oriented organizational
structure , 1 42
Project planning meetings, 208-2 1 0

in requirements analysis, 3 3 2
a n d software defects, 2 3-25

i n software process, 8 0- 1 1 9 . See also
Process quality

veri fication and validation for,
2 5-2 7
Qual i ty assurance ( QA ) , 3 5 , 8 2
audits for, 92-9 3
with Encounter, 1 0 3 - 1 1 2
and engineers, 6 2 8
i nterventions for, 9 3
with OpenOffice, 754-756
priorities for, 727
for requirements analysis, 3 3 2-348
requirements of, 84

777

778

INDEX

reviews for, 92-9 3
standards for, 8 5

Repository architectures, 44 8-449
Reproducibility , 1 2 3

techniques for, 8 5

Request for proposal ( RF P ) , 2 4 1 -242
Requirements, 2 3 0-240, 2 4 3-244
agile methods for, 2 3 9-240
apportioning of, 2 6 8

Quality metrics, 2 1 9
Qual ity/process manager, 1 52
Quantitatively managed CMMl leve l ,
1 0 1 , 1 02
Questionnaires, 70 3-705
R

changes i n , 2 1 9 , 2 4 1
contradicted, 3 3 7
data flow diagrams for specification
of, 262

testab i l i ty, 3 40-3 4 2
traceab i l i ty , 342-343
unambiguity, 3 3 5-3 3 6
understan dabi l i ty, 3 3 5
Requirements analysis phase, 3 3 , 3 5
Requirements document, 2 3 2-2 3 3 ,
2 9 8-299, 699

RequisitePro TM, 3 0 7-308
Research, 2 2 1

desirable, 2 8 9

Reset, of system, 549
Resources, for testing, 628

Ramona, Berta, 3-4

detailed, 2 3 2-2 3 3 , 278-3 3 0

Responding to change, 65

Range of error, 1 69

documentation of, 2 3 8-2 3 9

Responsibility( -ies) :

Ranking, of requirements, 3 0 1
Rational unified process ( R U P ) , 46, 49
Readers, 88
Recorders , 88

essenti a l , 2 8 9
functional , 2 3 3
future, 3 3 4

Responsiveness, 702

generation of, 2 3

Retesting, 62 2-62 3

Recoverability , testi n g for, 700-702

high - l evel , 2 3 2-2 3 3 , 246

Retirement by avoidance, 1 60

Recurri ng design purpose, 3 8 4-3 8 6
Recursion design pattern form ,

history of, 308
implemented, 586

Retirement by conquest, 1 60
Return , 5 4 3

imprecision o f, 3 1 5

Reusab i l i ty , 3 5 1 , 3 5 3- 3 5 4

Radiation overdose, 3-4

4 3 3-4 3 4

for documentation, 2 1 5
for qual ity, 8 3

Recursive des ign, 3 5 2

missing, 3 4 0

of components, 3 5 7-3 5 8

Redesign, 7 3 5-73 6
Redocumentati o n , 750

n o n functional, 2 3 3-2 3 8
numberi n g system for, 3 3 3

design quality/metrics for, 5 1 3-5 1 6
i n detailed design, 4 8 5-4 8 6

Reeengineering, 750-75 1

i n open- source projects, 5 1 -5 2

detailed design example to be rated

Refactoring(s), 6 8 , 70, 305, 60 1 -620

optional , 2 8 9

for, 5 1 4-5 1 6

big, 604-606

f o r quality assurance, 8 4

composing methods as, 606-607

ranki ng o f , 3 0 1

data organization as, 60 8-6 1 2

and schedules, 1 8 2

features placement as, 607-608

sources o f, 2 3 1 -2 3 2

general ization as, 6 1 2-6 1 5
modularization as, 6 1 6-6 1 7

sufficiency i n , 50 8-509
and system tests, 695

i n projects, 6 1 7-6 1 9

and testing, 6 3 2

improvement for, 2 2 1

renaming as, 60 1 -6 0 3
Refactoring patterns, 6 1 8-6 1 9

testing i n absence o f , 708
tests with, 3 4 1 -3 4 2

for metrics, 2 1 7-2 1 9
quality assurance, 92-93

Refactoring wizard, 603

traceability matrix for, 2 9 9

Reworking, 9 1

Regression testing, 6 2 2-62 3 , 679

traceab i l i ty o f , 2 3 9

RFP ( request for proposal ) ,
2 4 1 -242

Release(s ) , 7 1 3-7 1 4
of changes, 1 2 5
maj or, 7 3 4
of patches, 73 9-740
small , 70

wri tte n , 70 8
Requirements analysis, 8 , 2 3 0-2 3 1 ,

2 4 1 -244, 3 3 1 -3 4 8 . see also High ­

level requirements
accessibility, 3 3 2-3 3 3

types of, 40
Release del iverables, 205

comprehensiveness, 3 3 3-3 3 4
consistency, 3 3 6-3 3 7

Release m anagement, 1 27
Release m i lestones, 205
Rel i abil i ty , 3 5 4
design quality/metrics for, 5 2 1 -5 2 3
i n implementati o n , 596
i n so ftware des ign, 3 5 1
testi ng for, 700
Reliability requirements, 2 3 4
Remote teams, 1 47
Repair, 73 1 -7 3 2

detailed, 278-3 3 0 , 3 44-3 4 7
f o r detailed requirements, 2 7 8- 3 3 0
metrics for, 3 4 3-344

Reporting, 1 2 3 , 1 27
Repository ( term ) , 1 25

i n E ncounter, 4 8 6
i n implementati o n , 5 94-595
Reverse engineering, 750
Reverse- engineering tools, 5 5 5-556
ReverSi o n , 1 2 1 , 1 2 2
Reviews, 599

Risks, identification of, 1 59
Risk analysis, 1 94, 2 1 9
Risk management, 1 4 1 , 1 5 8- 1 62
Robustness, 3 5 1 , 3 5 3
design quality/metrics for,
5 1 1 -5 1 2

prioritizatio n , 3 3 7-3 3 8
and proj ect updates, 2 4 1 -2 4 3
and qual i ty for agi l e projects, 3 3 2
quali ty i n , 3 3 2
security, 3 3 8-3 3 9
sel f-completeness, 3 3 9-340
stakeholders i n process of,
3 3 7-3 3 8

i n implementati o n , 5 8 7-592
and rel i ability, 596
Roles, 8 8-8 9 , 397
Rol e - playing game framework,
494-495
Root-cause analysis, 73 8-7 3 9
Rough metric s , 5 8 5
Royce , W. W . , 3 7
RTL (runtime l ibrary ) , 470
Rumbaugh , James, 46
Runtime l ibrary ( RTL) , 470

status o f, 305-306

RU P (rational unified process ) , 46, 49

INDEX

Software engineering, 1 - 1 9

S
Safety, in project outcome, 73

for Facade, 41 1
of figure drawing application , 3 8 0

de fined, 2-3

SAL ( system abstraction layer),
469-470
Sandwich i ntegratio n , 6 7 8 , 679

functions i n , 3 6 9
for Interpreter, 4 1 9, 420
for mouse events, 495

Eclipse open source project, 1 5- 1 6
Encounter video game project, 1 5
ethics i n , 1 2- 1 4

Satisfaction questi onnaire, 3 4 1

of parallel communicatin g

OpenOffice project, 1 6- 1 8

SBL ( scripting and basic library ) , 47 1 ,
472
Scalabil i ty, 596

processor architecture , 444
i n unified language modeli ng,
3 6 8-3 7 1

people, 6-7
principles, 1 0- 1 2
process, 9- 1 0
product, 7-8

Scal ing cost drivers , 1 8 0

Sequential use cases, 2 5 2

Scenarios, 250, 3 5 5

Serviceability testing, 707-708

project, 8-9

Schedules, 1 4 1

Service interface l ayer, 4 5 2

unsuccessful projects, 3-5
Software Engineering Code o f Ethics

a fter architecture selection, 456

Service number, 1 3 5

after high - l evel requirements, 243

Service- oriented architectures

dependence i n , 1 8 5

Software Engineering Institute (SEI ) ,

as proj ect variable , 1 57

(SOAs ) , 450-45 2
Setup role , 399, 400

and requirements, 1 8 2

Severity, 9 3-95

S oftware evolutio n , 749-75 1

showing phases i n , 1 8 3

Shaw, M. G . , 4 3 9

Software maintenance, 7 3 0-75 8

work breakdown structure i n , 1 8 4

Simplicity, design, 70

Schemas, 4 1 7-4 1 8

SCM, see Software con figuration
management
SCMP (software con figuration
man agement plan ) , 1 8 6

and Professional Practice, 1 2 , 1 3
1 00- 1 02

IEEE standard for, 740-749

Simulations, 44

issues o f, 7 3 4-736

Si ngle Responsibility PrinCiple,

metrics for, 75 1 -75 3

479-48 0
Single- source documentati o n , 1 8 6 ,
307

of OpenOffice, 75 3-75 6
processes of, 73 6-740
and software evoluti on, 749-75 1
types of, 73 1 -7 3 4

Screen -based controls, 2 9 5

S ingleto n , 400-403

Screen design, 2 92-2 9 3

Size estimation, 492-493

Scripting and basic library ( S B L ) , 47 1 ,
472

Small releases, 70

Software process models, 9

Small style output, 404

Software program managers network

Scrum method, 7 1 -7 2 , 249

Smoke tests, 726

SDD, see Software deSign documentl
documentation

Sni ffers, 70 3

Secondary storage, 5 1 9-5 20

architecture s ) , 450-45 2
Soak testing, 7 1 3

Secure logi n , 5 2 4

SOAs (service- oriented

Security, 2 3 5
design quality/metrics for, 5 2 3-5 2 5

Software architecture , see Architecture

for detailed requirements, 2 9 6

Software configuration management

detailed requirements of, 296

(s)
( S CM ) , 8 4 , 1 20- 1 3 9

So ftware process, see Process(es)

(SPMN ) , 2 1 8

Software proj ect management, see
Project management
Software proj ect m anagement plan
(SPMP) , 3 4 , 1 8 5- 1 8 7, 2 4 2-24 3
Software quality assurance plan
(SQAP) , 2 7-2 8 , 8 3-85 , 1 0 3 - 1 1 7
Software requirements specification
( S RS ) , 35, 8 4 , 2 3 1

high- level requirements, 2 5 8-260

audits, 1 2 7

for Encounter, 2 64-26 8

o f implementation , 596-597

basel ines for, 1 2 2- 1 2 3

organization o f , 2 3 8-2 3 9

i n requirements analysis, 3 3 8-3 3 9

change control i n , 1 24- 1 2 5

preliminary, 3 0 2

testi ng for, 70 3 , 706

configuration identificati o n , 1 2 2

robustness for, 5 1 1 -5 1 2

SEI (Software Engineeri ng I nstitute ) ,
1 00- 1 02

for Eclipse open source project,
1 3 4- 1 3 6

SEI specifications, 1 0 1 - 1 02

goals of, 1 2 1 , 1 2 2

Self-completeness, 3 3 4 , 3 3 9-340

plans for, 1 2 7

Self-dependency, 674

release management/del ivery, 1 27

usability requirements i n , 702
S oftware system attributes , 3 2 7-3 2 8
Software Test Documentation (STD ) ,
7 1 4-72 3

Software testi ng, see Tests ( testing)

Semi - detached appl ications, 1 78

status reporting, 1 27

Software trouble reports, 740-74 1

"Separate domain from presen tation,"

systems for, 1 2 8- 1 2 9

Software veri fication and validation

604-606
Sequence diagrams, 3 5 5 , 5 1 8
for Abstract Factory, 407, 408
for Adapter, 4 1 3-4 1 4
detailed, 4 8 7-48 8
for detailed design, 4 8 6-490
for Encounter, 4 8 7-4 8 8 , 49 8-499,
72 1 , 722

version control, 1 2 5- 1 2 7
Software configuration management
plan ( S CM P ) , 1 8 6

So ftware design, see Design
Software design documentl
documentation ( S D D ) , 3 5 ,
8 3-84
So ftware disasters, 3-5

plan ( SVVP) , 28, 8 4
f o r Encounter QA, 1 09
for quality, 2 2 3-2 2 4
S ources :
of defects, 9 3 , 9 5
for OpenOffice project, 207-208
of requirements, 2 3 1 -2 3 2
o f testi ng units, 6 3 1

779

780

INDEX

Source code, 4 8 5
changes i n , 7 3 5
class diagram from , 750
for EncounterCharacter, 559
Space efficiency, 5 1 9-52 1 , 595

Statement coverage, 6 3 2-6 3 3 , 648
State models, 3 55-3 5 7, 709

for OpenOffice, 726-727
shortly before release, 7 1 3-7 1 4

State - transition diagrams, 2 6 2-264,
372, 464, 5 3 1 . See also State

T

diagrams

Tab l e - driven approach, 529-5 3 0

Specialized inspectors, 89

State -transition table, 5 2 9

Speci fication ( s ) :

State - transition test sequences,

Tab l e - driven state transitions, 529
Target values, 3 3 2

of classes/functions/algorithms,
4 8 2-48 5

Static i nstrumentatio n , 724

of failure , 700

Static viewpoint, 3 9 6 , 3 9 7- 3 9 8

o f functions, 48 3-4 8 4

Status reportin g (software

TDD , see Test- driven development

user interface high - l evel

con figurati o n management), 1 2 7
STD (Software Test D ocumentation ) ,

Teams:
communication withi n , 1 44- 1 46

requirements, 2 5 4-258
Specific requirements, 2 79 , 2 8 1

6 7 1 -672

7 1 4-72 3

Tasks :
all ocation of, 1 49
order of, 1 8 5

development, 7

Specified roles, for inspections, 8 8-89
Speed, 595, 698-699

STL (Standard Template Library ) ,
470, 486

distribute d , 1 46- 1 5 1
near-shore distributio n , 1 4 8

Spiral process mode l , 44-46

Stopping criteria, 6 2 7
Storage needs, 5 1 9-5 2 0

peer, 1 62
project, 1 42

Storage use, 5 9 5
Story points, 1 8 0 , 1 8 2

remote, 1 47
size of, 1 44- 1 46

"Straw man" vers i o n , 1 6 3

student, 5 6

SPMN (software program managers
network), 2 1 8

SPMP, see Software proj ect
m anagement plan

Spreadsheets, using, 3 06-3 0 7

Stress events, testin g for, 699-700

testers o n , 7 1 2

Sprints, 7 1 -72

Structural design patterns, 3 90-3 9 3 ,

uneven contributions i n , 1 62- 1 6 3

S QAP, see Software quality assurance
plan
SQL (structured query language ) , 448
SQL i njecti o n , 3 3 9
SRS, see Software requirements

40 8-4 1 7
with collection o f classes, 408-4 1 2
with interfacing Aexibility ,
4 1 2-4 1 7
Structured programming, 678

Team leaders , 5 6 , 1 40- 1 4 1 , 1 5 2
Team ski l l s , 5 7
Team Software Process

SM

:

and CMM I , 1 02- 1 0 3
organization i n , 1 5 1 - 1 5 3

Structured query l a n guage ( SQL) , 448

Team Software ProcessSM (Watts

Stubs, 642-644, 667-668
Stubbing, 4 1 0

Humphrey) , 1 5 1 - 1 5 2
'Tease apart i nheritance," 604

Staged assessment, 1 00

Subpackages, 497

Stakeholders, 6, 2 3 1

Subsidiary architectures, 452

Technical issues, with mai ntenance
requests, 7 3 5-73 6

Substates, 3 72

Technical processes, plans for, 1 8 6

Sufficiency, 3 5 1

Tech nical risks, 1 59

specification
Staffing plans, 1 90 , 1 9 1
Staff turn over, 2 1 9

and high - level requirements, 2 4 7248
i nterviews with , 248
i n requirements analysis process,
3 3 7-3 3 8
Standards, quality-assurance, 8 5
Standard Template Library (STL) ,

design qual i ty/metrics for, 5 1 0-5 1 1
in implementatio n , 5 8 6-5 8 7
Supporting process p l a n s , 1 8 6- 1 8 7
Support manager, 1 5 2
Sustainable pace, 7 1
SVVP, see Software veri fication and

Telescopi ng, 4 8 9
Tentative version, 1 6 3
Terminal architectures, 443

Tests ( testi n g ) , 8 , 6 2 1 -6 2 9 . See also
Module and integration testi ng;

of applicati o n , 2 6 2

SVX l ibrary, 473

System tests; Unit tests
agile methods with , 6 2 2
black box/white b o x , 6 2 3-624

classification of, 2 8 4
of graphical user interfaces, 2 5 6 ,

Synchronous messages, 3 7 1
Systems, for software configuration

for commun ication plan, 59
cost of, 3 4 1 -3 4 2

management, 1 2 8- 1 29
System abstractio n l ayer ( SAL) ,
469-470
System menus, 294
System reset, 549

f o r detailed requirements, 3 0 2 - 3 0 3

470, 4 8 6
States, 3 72

3 74
organization by, 29 1
State -based tests, 67 1 -672
Statecharts , 372
State design mode l , 4 2 8-4 3 1 ,
5 2 8-5 3 0
State design pattern, 446-447
State diagrams:
bottlenecks i n , 5 2 2-5 2 3
in unified language modeling,
3 7 1 -3 74

val idation plan

System tests ( system testi ng),
694-72 9
for Eclipse, 72 3-72 5
for Encounter video gam e , 7 1 4-7 2 3
functional, 696-698
nonfunctional, 698-70 8

documentation of, 6 2 6
f o r Encounter QA, 1 09
of functional/nonfunctional
requirements, 300
for graphical user interfaces, 3 4 1
models for, 709
obj ect- oriented implementations,
6 2 5-62 6
phase, 3 3 , 3 5-36
planning for, 626-6 2 8

I N DEX

Top-down approximatio n , 1 7 1

design example with , 377-380

for quality, 85

Top-down integration, 667, 677-678

design models, 52 1

regression, 6 2 2-6 2 3
w i t h requirements, 34 1 -342

TPTP, see Test and Performance Tools

i nheritance i n , 364-368

unit vs. post-unit, 6 2 4-625

Platform
Traces, 298

multiplicity i n , 363
notation , 2 8 7-288 , 363

for veri fication and vali dation, 26

Traceability, 2 4 1

Tests (testing) (continued)

i n waterfall process model , 38
Testability, i n requirements analysis,
340-342
Test and Performance Tools Platform

sequence diagrams in, 368-37 1

of detailed requirements, 2 9 7-300

state diagrams i n , 37 1 -374

metric for, 343

tools, 48 2

with 00 style, 298

use case diagram ( Encounter) ,

and organizatio n , 342-343

(TPTP) , 700, 723-72 4
Test cases, 63 1
creation of, 64 1

U n ified processes ( U Ps) , 46-49

i n requirements analysis, 342-343

U n i fied software development

Test case execution rate, 2 1 4

Traceability matrix, 299

Test documents/documentation, 7,

Tracking defects, 95-97

7 1 4-723

25 1

of requirements, 239
table for, 30 1

organi zation of, 642-647

from OpenOffice, 562

and baselines, 1 23

Trade-offs, 74-75, 453-454

process ( U S D P ) , 46, 283
U nit tests (unit testing) , 299, 303,
304 , 6 2 4-62 7 , 630-63 1 , 7 1 1 ,
7 1 5. See also Unit-testi ng
methods

Test document identifier, 7 1 6

Training plans, 1 90

Test-driven development (TD D ) , 66,

Transitions, 2 6 2-263, 373

checklists for, 643, 644

Transition phase, 48

defined, 630

Triage:

for EncounterCharacter class,

70, 305
and quality, 8 1 -8 2

and defect severity, 534-535

and unit testi ng, 647-652

659-662

Testers, 7 1 2

for defect severi ty, 9 4

Testing progress, 2 1 6

f o r maintenance requests, 736-737

for E ncounter video game, 652-659
post-unit vs. , 6 2 4-625

Test log, 7 1 9

for non ambiguity, 335-336

sources o f units for, 63 1

Test scripts, 7 1 3
Test suites, 628 , 646-647
Three-tier architectures, 453

for project management, 1 56- 1 57
SM
TSP, see Team Software Process
TSPi ( i ntroductory team software

Thrown exceptions, 550

process) , 1 52- 1 54

Tiered architectures, 443

Type claSSi fications, 95

suites of, 648
and test-driven development,
647-652
testing of methods for, 642-647
Unit-testing methods, 63 1 -642
boundary value analysis, 64 1 -642

Time:

branch coverage, 634

for inspections, 9 2

U

for remedies, 739-740

UCB (universal content broker) , 472

equivalence partitioni ng, 638-64 1

i n sequence diagram , 370
Time comm itment, 57

U I , see User Interface

path coverage, 634-638

Time delays, 5 1 7, 5 1 8

UML, see U n i fied modeling language

U niversal content broker ( U C B ) , 472

Time distributio n , 49

Unadjusted function point

U niversal network objects (UNO ) ,

Time efficiency, design quality/
metrics for, 5 1 6-5 1 9
Time limits, 90
Time recordin g log, 558
Time-to-complete estimatio n ,
492-493
Timing diagrams, 5 1 7, 5 1 9
Tools, 1 4 1
computer-aided engineering,
454-455
constraints o n , 236
for distributed development,
1 49- 1 5 1
object-oriented, 555-556
for project management, 1 53- 1 58
reverse-engineering, 555
for software architecture, 454-455
Web-based, 305-308
Tool l ibraries (TO O LS ) , 47 1

Umbrella activities, 32-33

computation, 1 74

statement coverage, 632-633

47 1 -472

for first Encounter functions, 1 74

U nknown status, 1 29

for video store example, 1 76- 1 77

UNO (universal network objects) ,

U nambiguity :
metric for, 336
in requirements analysis, 335-336
Understandabil ity, 35 1 , 592

47 1 -472
U nsuccessful projects, 3-5
U Ps (uni fied processes) , 46-49
Updates:

design quality/metrics for, 5 1 0

with detailed deSign, 49 1 -493

i n requirements analysis, 335

and requirements analysis,

Uneven contributions, in teams,
1 62- 1 63
U n i fied development process,
detailed design i n , 490-49 1
U n i fied model ing language (UML) ,
352, 36 1 -38 2
activity diagrams i n , 374-376
aggregatio n i n , 366-368
classes i n , 362-363
data flow models in, 376-377

2 4 1 -2 43
to requirements document,
2 98-299
Up-to - date status, 1 29
Usability testi ng, 702-705. See also
Reusability
Usability Testing Questionnaire
( Purdue ) , 704-705
U S D P (uni fied software development
process) , 46, 283

781

782

INDEX

Use case ( s ) , 249, 3 5 4
and architecture, 5 3 0-5 3 1

User story( - i e s ) , 65-66
i n agi l e projects, 2 5 0

in detailed design, 477-478

with high-level requirements,
2 5 2-2 5 3
implementation o f , 540
and requirements, 240

diagrams, 2 5 0
o f Encounter foreign character, 4 8 8
high - l evel requirements for,
249-2 5 2

splitting of, 2 5 4

organization b y , 2 8 2-2 8 3 , 2 9 1 , 3 1 4
in sequence di agrams, 3 70
Use case mode l , 3 54-3 5 5 , 709
Users:
characteristics of, 267
and customer, 247

V&V, see Veri fication a n d val i dation

Validati o n , 2 5-26
for quality, 2 5-27

W

i n testin g phase, 35

Walkthroughs , 599

veri fication vs . , 2 6-27

Waterfall process model, 9- 1 0,

"Values" ( o f extreme programming) ,

1 99
nature of, 254, 2 5 5

69-70
Variables, 5 9 2
avoiding global , 545

U ser experi ence theme (Eclipse

global , 5 4 5 , 546, 5 9 2 , 593

platform subproj ect) , 2 70-2 72
User I n terface ( U I ) , 1 4 3

i nitializing, 545, 547

for Abstract Factory, 405, 406

Virtual machine architectures,
447-44 8
Virtual machi n e programs, 4 2 0
Vision stage, 57, 2 3 9-240
Visual class l ibrary (VCl), 470
Visual operating system layer, 4 7 1

V

o f Eclipse technology project,

satisfaction questionnaire for, 3 4 1

Viewpoints, 3 9 7
Virtual C a s e File project, 3

naming of, 5 9 3-594, 602
proj ect, 1 57- 1 5 8

3 7-3 8 , 1 79
Watts, Humphrey, 4 9 2 , 49 3
Web-based tools:
for detailed requirements, 305-308
spreadsheets, 306-307
Web Servic e Description language,
449
White box testing, 62 3-6 2 4 ,

for Adapter clients, 4 1 3

Variab l e declaration, 547

designing agai nst, 4 8 1 -4 8 2
detailed requirements for,

VCl (visual class l ibrary ) , 470
Velocity, 68, 1 80 , 1 8 2

Wideban d Delphi process, 5 2 6
Width/length pairs, 6 3 8

Verbal communicati o n , 5 7-5 8

Windows :
l ayout of, 2 9 5

2 9 1 -296
for Encounter, 3 1 5-3 1 7,

Veri fication, 2 5-26

6 3 1 -6 3 2

o f architectures, 5 30-5 3 1
of changes, 1 2 5

types of, 2 9 3-2 94
Word processor interactio n ,

for Interpreter, 4 1 8-4 1 9

of functions, 5 3 2-5 3 3

module and integratio n testing of,

o f n o n functional requirements, 5 3 3
for quality, 2 5-27

40 3-404, 4 0 9
Workarounds, 740

465-466
flexibility with, 4 1 2-4 1 7

6 8 0-6 8 2
o f modules, 680
narrow, 4 1 0, 443
as nonfunctional requirement
category, 2 3 4
for Observer, 424
requirements for, 2 3 7-2 3 8 ,
254-2 5 8
scalabil ity o f , 2 70-2 7 1

val i dation vs. , 26-27
Veri fication and val i dation (V&V ) :
for Encounter, 2 2 5-2 2 8
i n dependent, 2 2 4
i n spections a n d , 2 6
Versi o n ( s ) :
labeling of, 1 2 7
numbering, for Eclipse, 1 3 5

for S ingleton clients, 4 0 I

past, 707, 708

for State clients, 4 2 9
steps f o r constructing, 2 3 8

updates of, 7 3 4

testi n g of, 6 8 2

Version control , in software
configuratio n management,

in UMl, 365
window types for,
2 9 3-294

1 2 5- 1 27
Video rental example code l isting,
566-575

Work breakdown structure (WBS ) ,
1 84 , 1 8 5 , 1 9 3
Work flow, of scrum , 72
Working software, 65, 66
Work plan, 1 90- 1 92
WRITER ( OpenOffic e ) , 2 7 3-274
Written requirements, 3 1 4-3 1 5 ,
708

x
XP (extreme programming) method,
69-7 1
Z
Z-specifications ( Encounter video
game proj ect) , 3 1 5

